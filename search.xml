<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ 14 Summary</title>
      <link href="/C/cpp-cpp14/"/>
      <url>/C/cpp-cpp14/</url>
      
        <content type="html"><![CDATA[<h3 id="C-14"><a href="#C-14" class="headerlink" title="C++ 14"></a>C++ 14</h3><h5 id="1-New-language-features"><a href="#1-New-language-features" class="headerlink" title="1. New language features"></a>1. New language features</h5><ul><li>function return type deduction</li><li>alternate tuype deduction on declaration</li><li>relaxed constexpr restriction</li><li>variable template</li><li>aggregate member initialization</li><li>binary literals</li><li>digit separators</li><li>generic lambdas</li><li>lambda capture expressions</li><li>the attribute [[deprecated]]</li></ul><h5 id="2-New-standard-library-features"><a href="#2-New-standard-library-features" class="headerlink" title="2. New standard library features"></a>2. New standard library features</h5><ul><li>shared mutexes and locking</li><li>reader-writer locks</li><li>heterogeneous lookup in associative containers</li><li>standard user-defined literals</li><li>tuple addressing via type</li><li>smaller library features (make_unique, integral_constant, is_permutation)</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++14 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11 Summary</title>
      <link href="/C/cpp-cpp11/"/>
      <url>/C/cpp-cpp11/</url>
      
        <content type="html"><![CDATA[<h3 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h3><h5 id="1-Core-language"><a href="#1-Core-language" class="headerlink" title="1. Core language"></a>1. Core language</h5><ul><li><p>rvalue reference and move constructors</p></li><li><p>constexpr</p></li><li><p>modification to the definition of plain old data</p></li><li><p>extern template</p></li><li><p>initializer lists</p></li><li><p>uniform initialization</p></li><li><p>type inference</p></li><li><p>range-based for loop</p></li><li><p>lambda functions and expressions</p></li><li><p>alternative function syntax</p></li><li><p>object construction improvement</p></li><li><p>explicit overrides and final</p></li><li><p>nullptr</p></li><li><p>strongly typed enumerations</p></li><li><p>right angle bracket</p></li><li><p>explicit conversion operators</p></li><li><p>template aliases</p></li><li><p>unrestricted unions</p></li><li><p>variadict templates</p></li><li><p>new string literals</p></li><li><p>user-defined literals</p></li><li><p>multi-threading memory model</p></li><li><p>thread-local storage</p></li><li><p>explicitly defaulted and deleted special member functions</p></li><li><p>type long long int</p></li><li><p>static assertions</p></li><li><p>allow sizeof to work on members of classes witout an explicit object</p></li><li><p>control and query object alignment</p></li><li><p>allow garbage collected implementations</p></li><li><p>attributes</p></li></ul><h5 id="2-C-standard-library-changes"><a href="#2-C-standard-library-changes" class="headerlink" title="2. C++ standard library changes"></a>2. C++ standard library changes</h5><ul><li>upgrades to standard library components</li><li>threading facilities</li><li>tuple types</li><li>hash types</li><li>regular expressions</li><li>general-purpose smart pointers</li><li>extensible random number facility</li><li>wrapper reference</li><li>polymorphic wrappers for function objects</li><li>type traits for metaprogramming</li><li>uniform method for computing the return type of funciton object</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 11 Summary</title>
      <link href="/C/cpp-cpp20/"/>
      <url>/C/cpp-cpp20/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++20 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 17 Summary</title>
      <link href="/C/cpp-cpp17/"/>
      <url>/C/cpp-cpp17/</url>
      
        <content type="html"><![CDATA[<h3 id="C-17-Features"><a href="#C-17-Features" class="headerlink" title="C++ 17 Features"></a>C++ 17 Features</h3><h5 id="1-Language"><a href="#1-Language" class="headerlink" title="1. Language"></a>1. Language</h5><ul><li>Making the text message for <code>static_assert</code> optional[10]</li><li>Allow <code>typename</code> (as an alternative to <code>class</code>) in a template template parameter[11]</li><li>New rules for auto deduction from braced-init-list[12][7]</li><li>Nested namespace definitions, e.g., <code>namespace</code> X::Y { … } instead of <code>namespace</code> X { <code>namespace</code> Y { … } }[7][13]</li><li>Allowing attributes for namespaces and enumerators[14][15]</li><li>New standard attributes [[fallthrough]], [[maybe_unused]] and [[nodiscard]][16]</li><li>UTF-8 (u8) character literals[14][17] (UTF-8 string literals have existed since C++11; C++17 adds the corresponding character literals for consistency, though as they are restricted to a single byte they can only store ASCII)</li><li>Hexadecimal floating-point literals[18][19]</li><li>Constant evaluation for all non-type template arguments[14][20]</li><li>Fold expressions, for variadic templates[14][21]</li><li>A compile-time static <code>if</code> with the form <code>if constexpr</code>(expression)[22]</li><li>Structured binding declarations, allowing <code>auto</code> [a, b] = getTwoReturnValues();[23]</li><li>Initializers in <code>if</code> and <code>switch</code> statements[24]</li><li>copy-initialization and direct-initialization of objects of type T from prvalue expressions of type T (ignoring top-level cv-qualifiers) shall result in no copy or move constructors from the prvalue expression. See copy elision for more information.</li><li>Some extensions on over-aligned memory allocation[25]</li><li>Class template argument deduction (CTAD), introducing constructor deduction guides, eg. allowing std::pair(5.0, <code>false</code>) instead of requiring explicit constructor arguments types std::pair&lt;double, bool&gt;(5.0, <code>false</code>) or an additional helper template function std::make_pair(5.0, <code>false</code>).[26][27]</li><li>Inline variables, which allows the definition of variables in header files without violating the one definition rule. The rules are effectively the same as inline functions</li><li>__has_include, allowing the availability of a header to be checked by preprocessor directives[28]</li><li>Value of __cplusplus changed to 201703L[29]</li><li>Exception specifications were made part of the function type[30]</li></ul><h5 id="2-Library"><a href="#2-Library" class="headerlink" title="2. Library"></a>2. Library</h5><ul><li>Most of Library Fundamentals TS I, including:[31][32]</li><li>std::string_view, a read-only non-owning reference to a character sequence or string-slice[33]</li><li>std::optional, for representing optional objects, a data type that may not always be returned by a given algorithm with support for non-return</li><li>std::any, for holding single values of any type</li><li>std::uncaught_exceptions, as a replacement of std::uncaught_exception in exception handling[34][14]</li><li>New insertion functions try_emplace and insert_or_assign for std::map and std::unordered_map key-value associative data structures[35][36]</li><li>Uniform container access: std::size, std::empty and std::data[36][37]</li><li>Definition of “contiguous iterators”[36][38]</li><li>A file system library based on boost::filesystem[39]</li><li>Parallel versions of STL algorithms[40]</li><li>Additional mathematical special functions, including elliptic integrals and Bessel functions[41]</li><li>std::variant, a tagged union container[42]</li><li>std::byte, allowing char to be replaced for data types intending to model a byte of data as a byte rather than a character[43]</li><li>Logical operator traits: std::conjunction, std::disjunction and std::negation[44]</li></ul><p><a href="https://github.com/AnthonyCalandra/modern-cpp-features" target="_blank" rel="noopener">https://github.com/AnthonyCalandra/modern-cpp-features</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++17 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manage multiple keys for different github repository</title>
      <link href="/Git/git-git-key-management/"/>
      <url>/Git/git-git-key-management/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>ssh search <code>~/.ssh/id_rsa</code> by default, if you have multiple keys or your key’s name is not the default, you should add the key into ssh-agent so that ssh can search for it.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval "$(ssh-agent -s)"</span><br></pre></td></tr></table></figure><p>you can config <code>~/.ssh/config</code> file to automatically load keys into the ssh-agent and store passphrases in your keychain.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">  AddKeysToAgent yes</span><br><span class="line">  UseKeychain yes</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>If github still ask you for password, you’re probably using the HTTPS clone URL for your repository. To solve it,</p><p>(1) Update the URL of origin remote using SSH instead of HTTPS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:username/repo.git</span><br></pre></td></tr></table></figure><p>(2) Make Git store the username and password and it will never ask for them.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><h4 id="Calculate-fingerprint-from-RSA-keys"><a href="#Calculate-fingerprint-from-RSA-keys" class="headerlink" title="Calculate fingerprint from RSA keys"></a>Calculate fingerprint from RSA keys</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -lf ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>In newer versions of OpenSSH, Base64 encoded SHA-256 is shown instead of hexadecimal MD5. To show the legacy style hash, use</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -l -E md5 -f ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二章：共识算法介绍</title>
      <link href="/Blockchain/blockchain-02-consensus-algorithms/"/>
      <url>/Blockchain/blockchain-02-consensus-algorithms/</url>
      
        <content type="html"><![CDATA[<h3 id="PoW"><a href="#PoW" class="headerlink" title="PoW"></a>PoW</h3><h3 id="PoS"><a href="#PoS" class="headerlink" title="PoS"></a>PoS</h3><h3 id="dPoS"><a href="#dPoS" class="headerlink" title="dPoS"></a>dPoS</h3><h3 id="PBFT"><a href="#PBFT" class="headerlink" title="PBFT"></a>PBFT</h3><h3 id="DAG"><a href="#DAG" class="headerlink" title="DAG"></a>DAG</h3>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一章：基本概念介绍</title>
      <link href="/Blockchain/blockchain-01-basic-concepts/"/>
      <url>/Blockchain/blockchain-01-basic-concepts/</url>
      
        <content type="html"><![CDATA[<h4 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h4><h4 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h4><h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><h4 id="挖矿、矿工、矿场、矿池"><a href="#挖矿、矿工、矿场、矿池" class="headerlink" title="挖矿、矿工、矿场、矿池"></a>挖矿、矿工、矿场、矿池</h4><h4 id="软分叉、硬分叉"><a href="#软分叉、硬分叉" class="headerlink" title="软分叉、硬分叉"></a>软分叉、硬分叉</h4><h4 id="算力-hashrate"><a href="#算力-hashrate" class="headerlink" title="算力 hashrate"></a>算力 hashrate</h4><h4 id="ICO"><a href="#ICO" class="headerlink" title="ICO"></a>ICO</h4><h4 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h4><h4 id="TPS、吞吐量"><a href="#TPS、吞吐量" class="headerlink" title="TPS、吞吐量"></a>TPS、吞吐量</h4><h4 id="点对点网络"><a href="#点对点网络" class="headerlink" title="点对点网络"></a>点对点网络</h4><h4 id="公有链、私有链、联盟链"><a href="#公有链、私有链、联盟链" class="headerlink" title="公有链、私有链、联盟链"></a>公有链、私有链、联盟链</h4><h4 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h4><h4 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h4><h4 id="DApps"><a href="#DApps" class="headerlink" title="DApps"></a>DApps</h4><h4 id="梅克尔树"><a href="#梅克尔树" class="headerlink" title="梅克尔树"></a>梅克尔树</h4><h4 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h4><h4 id="数字签名，公钥、私钥"><a href="#数字签名，公钥、私钥" class="headerlink" title="数字签名，公钥、私钥"></a>数字签名，公钥、私钥</h4><h4 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h4><h4 id="结构化网络-非结构化网络"><a href="#结构化网络-非结构化网络" class="headerlink" title="结构化网络/非结构化网络"></a>结构化网络/非结构化网络</h4><h4 id="Overlay-amp-Underlay"><a href="#Overlay-amp-Underlay" class="headerlink" title="Overlay &amp; Underlay"></a>Overlay &amp; Underlay</h4><h4 id="加密货币、虚拟货币、通证，数字证书"><a href="#加密货币、虚拟货币、通证，数字证书" class="headerlink" title="加密货币、虚拟货币、通证，数字证书"></a>加密货币、虚拟货币、通证，数字证书</h4><h4 id="主链-母链-子链-侧链"><a href="#主链-母链-子链-侧链" class="headerlink" title="主链/母链/子链/侧链"></a>主链/母链/子链/侧链</h4><p>以下是区块链领域中的一些常见术语，供有兴趣了解区块链技术的初学者参考。</p><p>1、地址(Addresses，加密数字货币地址)加密货币地址用于在网络上发送或接收交易。 地址通常表示为个数字字字符，但也可以表示为可扫描的QR码。</p><p>2、协议分类账(Agreement ledger)是由两方或多方用来协商和达成协议的分布式分类账。</p><p>3、Altcoin是“Bitcoin alternative”(比特币的替代品，或着说山寨版)的缩写。目前，大多数Altcoin都是比特币的分叉，通常比特币区块链的工作量证明(POW)算法有一些细微变化。最出名的Altcoin是莱特币。莱特币引入了原始比特币协议的变化，例如减少块生成时间，增加最大货币数量和不同的哈希算法。</p><p>4、认证分类账(Attestation Ledgers)是分类账，提供持久的协议，承诺或声明记录，提供证据(证明)这些协议，承诺或陈述是人为作出的。</p><p>5、ASIC是“专用集成电路”(Application Specific Integrated Circuit)的缩写。 通常，与GPU相比，ASIC专门用于挖矿，可能会节省大量能源。在比特币中，它们被设计为处理SHA-256散列问题以挖掘新的比特币。</p><p>6、比特币(Bitcoin)是一个众所周知的加密货币，基于POW区块链。</p><p>7、区块链(Blockchain)是一种分布式分类账，由不可更改的数字化记录的数据组成，称为数据块(更像是将数据整理成一张纸)。然后使用加密签名将每个块“链接”到下一个块。这允许块链像分类帐一样使用，可以由具有适当权限的任何人共享和访问。</p><p>8、分组密码(Block cipher)是一种对文本进行加密(以产生密文)的方法，其中密码密钥和算法一次作为一组应用于数据块，而不是一次一个bit。</p><p>9、块高度(Block height)是指块链中连接在一起的块的数量。例如，高度0即是第一块，也就是所谓的成因块。</p><p>10、块奖励(Block reward)给予已成功散列一个事务块的矿工。块奖励可以是硬币和交易费用的混合，取决于所讨论的加密货币使用的策略，以及所有的硬币是否已经被成功开采。比特币网络的当前块奖励是每个块有25个比特币。</p><p>11、中央分类帐(Central ledger)是指由中央机构维护的分类帐。</p><p>12、链式链接(Chain linking)是将两个区块链彼此连接的过程，从而允许在链之间进行交易。这将允许像比特币这样的区块链与其他侧链进行沟通，允许它们之间的资产交换。</p><p>13、密码(cipher)是用于信息加密和/或解密的算法。在通用语言中，“密码”也被用来指代加密消息，也被称为“代码”(code)。</p><p>14、确认(Confirmation)意味着区块链交易已经被网络验证。这是在POW系统(比如比特币)中所谓挖掘的过程发生的。一旦交易被确认，不能被撤销或双重消费。交易的确认越多，执行双重支出攻击就越困难。</p><p>15、共识流程(Consensus Process)是一组对等点，负责维护分布式账本的使用，以达到分类账内容的共识。</p><p>16、一个联盟区块链(Consortium blockchain)是一个共识过程由一组预先选定的节点控制的区块链;例如，可以想象一个由15个金融机构组成的联盟，每个联盟都运行一个节点，其中必须有十个成员在每个块上签字，才能使该块有效。阅读区块链的权利可能是公开的，也可能仅限于参与者。还有一些混合路由，例如块的根哈希值与API一起公开，允许公众成员进行有限数量的查询，并获得区块链状态某些部分的密码证明。这些区块链可能被认为是“半分布式的”。</p><p>17、密码分析(Cryptoanalysis)是研究获得加密信息的含义的方法，而不需要访问通常需要的秘密信息。</p><p>18、加密数字货币(Cryptocurrency)是基于数学的数字货币形式，其中使用加密技术来调节货币单位的生成并验证资金的转移。此外，加密货币独立于中央银行运作。</p><p>19、密码使用法(Cryptography)是指加密和解密信息的过程。</p><p>20、dApp是一个分散的应用程序，必须完全开放源代码，它必须自主运行，并且没有实体控制其大部分代币。</p><p>21、一个DAO(分散的自治组织)可以被认为是一个没有任何人的参与下运行的公司，在一套不可变的商业规则的控制之下。</p><p>22、DAO(是的，与一个DAO有区别)是建立在以太坊上的一个风险投资基金，它引发了一次软/硬分叉。</p><p>23、解密(Decryption)是将密文变成纯文本的过程。</p><p>24、加密(Encryption)是将明文消息(明文)转换成数据流(密文)的过程，使其看起来像一个无意义的随机的比特序列。</p><p>25、以太(Ether)是以太坊区块链的原生代币，它用于支付交易费用、矿工奖励和网络上的其他服务。</p><p>26、以太坊(Ethereum)是一个基于区块链技术的开放式软件平台，支持开发人员撰写智能合约，构建和部署分散式应用程序。</p><p>27、以太坊经典(Ethereum Classic)是现有加密数字货币的分拆，经过硬分叉后的以太坊。</p><p>28、EVM代码是以太坊区块链上的帐户可以包含代码的编程语言。每次向该帐户发送消息时，都会执行与帐户关联的EVM代码，且可以读取/写入存储并自行发送消息。</p><p>29、数字商品(Digital commodity)是一种稀缺的，可电子转让的，无形的，具有市场价值的虚拟商品。</p><p>30、数字身份(Digital identity)是由个人，组织或电子设备在网络空间中采用或声明的在线或网络身份。</p><p>31、分布式账本(Distributed ledger)是分布在多个站点，国家或机构中的一种数据库。记录一个接一个地存储在连续分类账中。分布式账本数据可以通过“许可”或“不许可”来控制谁可以查看它。</p><p>32、难度(Difficulty)，在“POW”挖掘中，验证区块链网络中的区块是非常困难的。在比特币网络中，采矿难度调整为每隔2016个块进行验。这是为了保持块验证时间在十分钟。</p><p>33、双倍支出(Double spend)指的是比特币网络中的一种情况，即有人试图同时向两个不同的收款人发送比特币交易。但是，一旦比特币交易得到确认，就几乎不可能将花费翻倍。特定交易的确认越多，双倍花费比特币就越难。</p><p>34、菲亚特货币(Fiat currency)是指政府宣布为履行财务义务而有效的任何货币(如美元或欧元)。</p><p>35、分叉(Fork)指向同一个父块的2个区块被同时生成的情况，某些部分的矿工看到其中一个区块，其他的矿工则看到另外一个区块。这导致2种区块链同时增长。通常来说，随着在一个链上的矿工得到幸运并且那条链增长的话，所有的矿工都会转到那条链上，数学上分几乎会在4个区块内完结自己。</p><p>36、气体(Gas)是一个与计算步骤大致相当的测量法(以太坊)。每笔交易都需要包括一个Gas限制和一个愿意为每个Gas支付的费用;矿工可以选择进行交易和收费。每个操作都有一个Gas支出;对于大多数操作来说，支出范围在3-10，虽然一些昂贵的操作花费高达700，但一般这种情况下，交易本身花费高达21000。</p><p>37、减半(Halving)：比特币的供应有限，这使得它们成为稀缺的数字商品。将要发行的比特币总量为2100万。每块产生的比特币数量每四年下降50%。这就是所谓的“减半”，最后的减半将在2140年完成。</p><p>38、硬分叉(Hardfork)是对区块链协议的改变，使先前无效的块/交易有效，因此要求所有用户升级其客户端。是当比特币协议规则发生改变，旧节点拒绝接受由新节点创造的区块的情况。违反规则的区块将被忽视，矿工会按照他们的规则集，在他们最后见证的区块之后创建区块。</p><p>39、Hashcash是一个用于限制垃圾邮件和拒绝服务攻击的POW系统，最近以其在比特币(和其他加密货币)中的使用而成为挖掘算法的一部分。</p><p>40、哈希率(Hashrate)是比特币矿工在给定的时间段(通常是一秒)内可执行的哈希值。</p><p>41、首次代币发行(ICO)是一种事件，指新的加密数字货币从总体基础币出售高级代币以换取前期资本。 ICO经常被用于新的加密数字货币的开发者来筹集资金。</p><p>42、分类账(Ledger)是一个仅追加记录的存储器，记录是不可变的，可能比财务记录拥有更多的一般信息。</p><p>43、莱特币(Litecoin)是基于Scrypt 工作量证明网络的点对点加密货币。有时被称为比特币黄金中的白银。</p><p>44、挖掘(Mining)是验证交易并将其添加到区块链的过程。这个使用计算硬件解决密码问题的过程也触发了加密货币的发行。</p><p>45、多重签名(multisig)地址允许多方要求多个密钥授权交易。在创建地址时同意所需的签名数量。多重签名地址对盗窃具有更大的抵抗力。</p><p>46、节点(Node)是连接到区块链网络的任何计算机。</p><p>47、完整节点(Full node)是完全实施区块链的所有规则的节点。</p><p>48、点对点(P2P)是指在高度互连的网络中至少两方之间发生的去中心化交互。 P2P参与者通过一个中介点直接处理彼此。</p><p>49、被许可的分类帐(Permissioned ledger)是行动者必须有权访问的分类帐。被许可的分类帐可能有一个或多个所有者。当添加新记录时，分类账的完整性将通过有限的共识流程进行检查。这是由信任的行动者(例如政府部门或银行)执行的，举个例子——未被许可的分类账使用的共识形成过程会使得维持一个共享记录要简单得多。</p><p>50、被许可的区块链(Permissioned blockchain)提供了高度可验证的数据集，因为共识流程创建了数字签名，各方都可以看到。</p><p>51、私钥(Private key)是一串数据，表明您可以访问特定钱包中的比特币。私钥可以被认为是一个密码;私钥绝不能透露给任何人，因为密钥允许你通过加密签名从你的比特币钱包里支付比特币。</p><p>52、权威证明(Proof of Authority)是私人区块链中的一种共识机制，它基本上为一个客户(或特定数量的客户)提供一个特定的私人密钥，使得区块链中的所有区块都成为可能。</p><p>53、权益证明(Proof of Stake)是工作量证明系统的替代方案，在这种系统中，您使用加密货币的现有股份(您持有货币的数量)来计算您可以挖掘的货币数量。该机制是当创造一个区块时，矿工需要创建一个“币权”交易，交易会按设定的比例把一些币发送给矿工本身，类似利息。</p><p>54、工作量证明(Proof of Work)是一个将挖掘能力与计算能力联系起来的系统。块必须被散列，这本身就是一个简单的计算过程，但是在散列过程中增加了一个额外的变量，使其变得更加困难。当一个块被成功散列时，散列必须花费一些时间和计算量。因此，散列块被认为是工作量的证明。</p><p>55、协议(Protocol)是描述如何传输或交换数据的正式规则集，特别是在整个网络中。</p><p>56、Ripple是建立在分布式账本上的支付网络，可以用来转账任何货币。该网络由支付节点和由当局运营的网关组成。付款是使用一系列的借条进行的，网络基于信任关系。</p><p>57、Scrypt是SHA-256工作系统的一个替代证明，旨在对CPU和GPU矿工特别友好，然而对ASIC矿工没有什么优势。</p><p>58、SHA 256是用作比特币工作证明系统基础的密码函数。</p><p>59、智能合约(Smart contract)是其条款以计算机语言记录而非法定语言的合约。智能合约可以由计算系统自动执行，例如合适的分布式账本系统。智能合约由直接在复制的网络上运行的程序组成。智能合约使用一种编程语言在区块链上对业务规则或合同进行编码，由网络中的所有参与者执行。这些程序在 Hyperledger Fabric 中称为链代码，它们被复制到网络中的每个节点，并由拥有权限的各方调用来传输资产。</p><p>60、软分叉(Softfork)是对比特币协议的一个修改，其中只有以前有效的块/事务被无效。由于旧节点会将新块识别为有效，所以软分叉是向后兼容的。这种分叉只需要大量矿工来升级执行新规则。是当比特币协议规则发生改变，旧的节点并不会意识到规则是不同的，它们将遵循改变后的规则集，继续接受由新节点创造的区块。矿工们可能会在他们完全没有理解，或者验证过的区块上进行工作。</p><p>61、流密码(Stream ciphers)是一种对文本(密文)进行加密的方法，其中密码密钥和算法一次一bit地应用于数据流中的每个二进制数字。</p><p>62、代币(Token)是可以被获取的东西的数字身份。</p><p>63、无代币分类帐(Tokenless ledger)是指不需要本地货币操作的分布式分类帐。</p><p>64、交易区块(Transaction block)是比特币网络上的交易集合，集合成一个块，然后可以将其散列并添加到区块链中。</p><p>65、交易费用(Transaction fees)是对通过比特币网络发送的一些交易征收的小额费用。交易费用授予那些成功散列包含相关交易的块的矿工。</p><p>66、像比特币这样的未经许可的分类账(Unpermissioned ledgers)没有单一的所有者——事实上，它们不能被拥有。未经许可的分类帐的目的是允许任何人向分类帐提供数据，并为拥有分类账的每个人提供相同的副本。</p><p>67、钱包(Wallet)是一个包含私钥集合的文件。</p><p>以上只是初级/中级水平上的常见区块链术语，且由于中英文差异可能会出现错误，若有所遗漏或错误请在下方评论区补充和指正。</p><p>68、区块链应用</p><p>一个区块链应用需要 3 个相互依赖的组件：面向用户的应用、智能合约和账本。顶层是面向用户的应用，用于满足网络参与者的需求。该应用让用户调用智能合约在业务网络中触发交易。智能合约 封装网络的业务逻辑：资产、所有权和传输方式。每次调用智能合约，都会在网络中创建一个交易并更新账本。账本 持有智能合约数据的当前值(如 vehicleOwner=Daisy)，并分发到整个网络。</p><p>69、零知识证明</p><p>指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。</p><p>“零知识证明”实质上是一种涉及两方或更多方的协议，即两方或更多方完成一项任务所需采取的一系列步骤。证明者向验证者证明并使其相信自己知道或拥有某一消息，但证明过程不能向验证者泄漏任何关于被证明消息的信息。</p><p>70、难度炸弹</p><p>为了确保以太坊的矿工能加入到新链条中来，开发团队引入了”难度炸弹”机制。它会使难度系数呈指数增加以至于让挖矿变得几乎不可能的。</p><p>71、挖矿</p><p>挖矿是反复总计交易，构建区块，并尝试不同的随机数，直到找到一个随机数可以符合工作证明的条件的过程。 如果一个矿工走运并产生一个有效的区块的话，会被授予的一定数量的币（区块中的交易全部费用）作为奖励。而且所有的矿工开始尝试创建新的区块，这个新区块 包含作为父块的最新的区块的散列。</p><p>72、工作量证明</p><p>一种共识机制，该机制是一方（通常称为证明人）出示计算结果，这个结果众所周知是很难计算的但却很容易验证的。通过验证这个结果，任何人都能够确认证明人执行了一定量的计算工作量来产生这个结果。</p><p>73、闪电网络</p><p>一个可扩展的微支付通道网络。交易双方若在区块链上预先设有支付通道，就可以多次、高频、双向地通过轧差方式实现瞬间确认的微支付；双方若无直接的点对点支付通道，只要网络中存在一条连通双方的、由多个支付通道构 成的支付路径，闪电网络也可以利用这条支付路径实现资金在双方之间的可靠转移。</p><p>Block Explorer（区块资源管理器）</p><p>区块资源管理器是一种用来来查看区块上的所有交易（过去和当前）在线工具。 它们提供有用的信息，如网络哈希率和交易增长率。</p><p>Block Height（区块高度）</p><p>连接在区块链上的块数</p><p>Block Reward 积分奖励</p><p>它是在采矿期间成功计算区块中的哈希的矿工的一种激励形式。 在区块链上的交易验证的过程中产生新的币，并且矿工被奖励其中的一部分。</p><p>Central Ledger 中央帐簿</p><p>由中央机构维持的分类帐。</p><p>Confirmation（确认）</p><p>去中心化的一次交易，将其添加到blockchain的成功确认</p><p>Consensus（共识）</p><p>当所有网络参与者同意交易的有效性时，达成共识，确保分布式账本是彼此的精确副本。</p><p>Cryptocurrency 加密货币</p><p>也称为令牌，加密货币是数字资产的呈现方式。</p><p>Cryptographic Hash Function（加密哈希函数）</p><p>密码哈希产生从可变大小交易输入固定大小和唯一哈希值。 SHA-256计算算法是加密散列的一个例子。</p><p>Dapp（去中心化应用程序）是一种开源的应用程序，自动运行，将其数据存储在区块链上，以密码令牌的形式激励，并以显示有价值证明的协议进行操作。</p><p>DAO（去中心化自治组织）</p><p>去中心化自治组织可以被认为是在没有任何人为干预的情况下运行的公司，并将一切形式的控制交给一套不可破坏的业务规则。</p><p>Distributed Ledger（分布式账本）</p><p>分布式账本，数据通过分布式节点网络进行存储。 分布式账本不是必须具有自己的货币，它可能会被许可和私有。</p><p>Distributed Network（分布式网络）</p><p>处理能力和数据分布在节点上而不是拥有集中式数据中心的一种网络。</p><p>Difficulty（容易程度）</p><p>这是指成功挖掘交易信息的数据块的容易程度。</p><p>Digital Signature 数字加密<br>通过公钥加密生成的数字代码，附加到电子传输的文档以验证其内容和发件人的身份</p><p>Double Spending 双重支付<br>当花费一笔钱多于一次支付限额时，就会发生双重支付</p><p>Ethereum（以太坊）<br>Ethereum是一个基于blockchain的去中心化运行智能合约的平台，旨在解决与审查，欺诈和第三方干扰相关的问题。</p><p>EVM（以太坊虚拟机）<br>Ethereum虚拟机（EVM）是一个图灵完整的虚拟机，允许任何人执行任意EVM字节码。 每个Ethereum节点都运行在EVM上，以保持整个块链的一致性。</p><p>Fork（分支）<br>分支可以创建区块链的交叉版本，在网络不同的地方兼容的运行两个区块链。</p><p>Genesis Block 创世区块</p><p>区块链的第一个区块。</p><p>Hard Fork（硬分支）<br>一种使以前无效的交易有效的分支类型，反之亦然。 这种类型的分支需要所有节点和用户升级到最新版本的协议软件。</p><p>Hash（哈希）<br>对输出数据执行散列函数的行为。 这是用于确认货币交易。</p><p>Hash Rate（哈希率）<br>采矿钻机的性能测量值以秒为单位表示。</p><p>Hybrid PoS/PoW（混合PoS / PoW）</p><p>POW（Proof of Work，工作证明）是指获得多少货币，取决于你挖矿贡献的工作量，电脑性能越好，分给你的矿就会越多。POS（Proof of Stake，股权证明）根据你持有货币的量和时间进行利息分配的制度，在POS模式下，你的“挖矿”收益正比于你的币龄，而与电脑的计算性能无关。</p><p>混合PoS / PoW可以将网络上的共享分发算法作为共享证明和工作证明。 在这种方法中，可以实现矿工和选民（持有者）之间的平衡，由内部人（持有人）和外部人（矿工）创建一个基于社区的治理体系。</p><p>Mining（挖矿）<br>挖矿是验证区块链交易的行为。 验证的必要性通常以货币的形式奖励给矿工。 在这个密码安全的繁荣期间，当正确完成计算，采矿可以是一个有利可图的业务。 通过选择最有效和最适合的硬件和采矿目标，采矿可以产生稳定的被动收入形式。</p><p>Multi-Signature 多重签名<br>多重签名地址需要一个以上的密钥来授权交易，从而增加了一层安全性。</p><p>Node（节点）<br>由区块链网络的参与者操作的分类帐的副本。</p><p>Oracles（数据库）<br>Oracle通过向智能合约提供数据，它现实世界和区块链之间的桥梁。</p><p>参考：<br><a href="http://graphics.reuters.com/TECHNOLOGY-BLOCKCHAIN/010070P11GN/index.html" target="_blank" rel="noopener">http://graphics.reuters.com/TECHNOLOGY-BLOCKCHAIN/010070P11GN/index.html</a><br><a href="https://t.cj.sina.com.cn/articles/view/6335372514/1799e1ce200100531v" target="_blank" rel="noopener">https://t.cj.sina.com.cn/articles/view/6335372514/1799e1ce200100531v</a></p><p><a href="https://yeasy.gitbooks.io/blockchain_guide/content/appendix/terms.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/blockchain_guide/content/appendix/terms.html</a></p><p>第 1 页 区块链小知识第（11）话：<br>共识机制的相关定义介绍Ⅱ•<br>第 2 页 验证池机制/ POOL•<br>第 3 页 51% 攻击/ 51% attack•<br>第 4 页 双重支付/ 双重花费/ 双花/ Double Spending•<br>第 5 页 拜占庭将军问题/ Byzantine Generals Problem / BGP•<br>第 6 页 改进型实用拜占庭容错/ Practical Byzantine Fault Tolerance / PBFT•<br>第 7 页 授权拜占庭容错算法/ Delegated Byzantine Fault Tolerance / dBFT•<br>第 8 页 联邦拜占庭协议/ Federated Byzantine Agreement /</p><p><a href="http://www.lianmenhu.com/blockchain-1266-1" target="_blank" rel="noopener">http://www.lianmenhu.com/blockchain-1266-1</a></p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第三章：区块链的安全风险</title>
      <link href="/Blockchain/blockchain-03-security-issues/"/>
      <url>/Blockchain/blockchain-03-security-issues/</url>
      
        <content type="html"><![CDATA[<h3 id="四种类型的攻击"><a href="#四种类型的攻击" class="headerlink" title="四种类型的攻击"></a>四种类型的攻击</h3><ol><li>Peer-to-peer network-based attacks</li><li>Consensus &amp; Ledger-based attacks</li><li>Smart Contract-based attacks</li><li>Wallet-based attacks</li></ol><h2 id="1-Peer-to-Peer-Network-based-Attacks"><a href="#1-Peer-to-Peer-Network-based-Attacks" class="headerlink" title="1. Peer-to-Peer Network-based Attacks"></a>1. Peer-to-Peer Network-based Attacks</h2><p><strong>Eclipse attack</strong><br>A node will depend on “x” number of nodes selected using a Peer selection strategy to have its view of the distributed ledger. But if an attacker can manage to make the node to choose all the “x” number of nodes from his malicious nodes alone, then he can eclipse the original ledger’s view and present his own manipulated ledger to the node.</p><p><img src="https://media.arubanetworks.com/blogs/Blockchain-Eclipse-Attack.jpg" alt=""><br>Source: <a href="http://cs-people.bu.edu/heilman/eclipse/" target="_blank" rel="noopener">http://cs-people.bu.edu/heilman/eclipse/</a></p><p><strong>Sybil attack</strong></p><p>While the Eclipse attack is about eclipsing a user’s view of the true ledger, the Sybil attack targets the whole network. In a Sybil attack, an attacker will flood the network with large number of nodes with pseudonymous identity and try to influence the network. These nodes, though appearing like unrelated individuals, are operated by a single operator at the back. In this case the objective is not to target one user, but a number of nodes or network as whole, and generate a fork in the ledger if possible, allowing the attacker to make double spending and other attacks.</p><h2 id="2-Consensus-Mechanism-and-Mining-based-Attacks"><a href="#2-Consensus-Mechanism-and-Mining-based-Attacks" class="headerlink" title="2. Consensus Mechanism and Mining-based Attacks"></a>2. Consensus Mechanism and Mining-based Attacks</h2><p><strong>Selfish mining attack</strong>: Many blockchains consider the longest chain to be the true latest version of the ledger. So a selfish miner can try to keep building blocks in stealth mode on top of the existing chain, and when he can build a lead of greater than two or more blocks than the current chain in the network, he can publish his private fork, which will be accepted as a new truth as it is the longest chain. He can do transactions in the public network just before publishing his longer stealth chain to reverse the transaction he just did. This effectively provides a small window for the attacker to do double spending based on this ability to build a stealth chain by building sufficient block lead (Finney attack).</p><p><strong>Mining malware</strong>: Malware uses the computing power of unsuspecting victims’ computer to mine cryptocurrencies for hackers. China reported that over a million computers were infected by this malware and helped attackers mine more than 26 million tokens of various cryptocurrencies.</p><p><strong>51% attack</strong>: This attack is possible when a miner or a group of miners controls 51% or more of the mining power of the blockchain network. Though it is very difficult to happen for large networks, the possibility of a 51% attack is higher in small networks. Once a group has majority control over transactions on a blockchain network, it can prevent specific transaction or even reverse older transactions.</p><p><strong>Timejack attack</strong>: Nodes in certain blockchain networks like Bitcoin depend on internal timing derived from median time reported by its peer nodes. For example, you depend on your friends to know the time. Let us say an attacker manages to put a lot of malicious people in your friends’ list, then he can manipulate your time. The first step to this attack can be an Eclipse attack on the target node. Once this attack is complete on a target node, then the target node will not accept blocks from the actual network as the timestamp of the blocks will not be in line with its timestamp. This provides an opportunity for the attacker to be double spending or do transactions with the targeted node as these transactions can’t be submitted to the actual blockchain network.</p><p><strong>Finney attack</strong>: If you can mine a block with one of your transactions in it and keep it in stealth, there is an opportunity for you to double spend the money. If a merchant accepts the unconfirmed transaction, you can transfer him this earlier transacted currency. Next you publish the earlier mined block, which was kept in stealth, before your new transaction is confirmed on network.</p><p><strong>Race attack</strong>: This attack is minor variation of the Finney attack. The difference is that the attacker need not pre-mine the block with his transaction, which he intends to double spend. During the attack, the attacker submits an unconfirmed transaction to a merchant (victim) and simultaneously does another transaction which he broadcasts to the network. It is easier for the attacker to launch the attack if he is directly connected to the merchant’s node. This would give the merchant an illusion that his transaction is the first, but that is never submitted to the blockchain network by the attacker.</p><h2 id="3-Smart-Contract-based-Attacks"><a href="#3-Smart-Contract-based-Attacks" class="headerlink" title="3. Smart Contract-based Attacks"></a>3. Smart Contract-based Attacks</h2><p>Smart contracts are completely automated contracts, which execute transactions in an agreed upon way between participants, with inputs from the real world and without intervention from any middlemen. So once started, a smart contract cannot be stopped. The transaction once completed and written into blockchain becomes immutable. This gives a guarantee to participants of returns based on their performance, as agreed upon while entering the contract. But think what would happen if the Smart Contract has bugs: Millions of dollars are in stake and no one can change it. We are going to look at such attacks or attack vectors relating to smart contracts.</p><p><strong>The DAO attack</strong>: The biggest exploitation in the history of cryptocurrencies is the “THE DAO” hack. Decentralized Autonomous Organization was an ambitious feature of Ethereum. A company called Slock started crowdfunding for a project called “The DAO”. The crowdfunding got an overwhelming response, collecting 12.7 million Ether, valued at $150 million then ($2 billion today). But an attacker identified a vulnerability in the code where by a recursive withdraw function could be executed without checking the settlement of the current transaction. So the attacker started the attack by contributing a small amount and requesting withdrawal with a recursive function. This allowed him to pull out almost $70 million dollars out of the crowdfund.After this the events took an interesting turn. The Ethereum Foundation threatened the attacker to stop the attack and freeze the account. The attacker responded saying that he was playing as per the agreed upon contract and an intervention through a soft or hard fork will be a breach of contract, which he can take to court (Read the Attacker’s open letter.) But he stopped the attack. Later the Ethereum Foundation went with a hard fork to recover the money, though this decision raised many concerns of autonomy of smart contracts. This hard folk resulted in two Ethereum currencies – Ethereum &amp; Ethereum classic and a lot of controversy.</p><h2 id="4-Wallet-based-Attack"><a href="#4-Wallet-based-Attack" class="headerlink" title="4. Wallet-based Attack"></a>4. Wallet-based Attack</h2><p><strong>Parity Multisig Wallet Attack</strong>: This was the case of a vulnerability with the parity client wallet hacked by an attacker resulting in holding up of 500,000 Ether ($77 million today). Wallet contracts are additional logic than can be built on user wallets for regular automated payments. To reduce the gas or transaction fees, the parity Multisig wallet functionality (Multisig wallet is like a joint account in bank with multiple owners) used a centralized Library contract. But they left some critical functions open, resulting in a vulnerability, which was exploited by the attacker. The attacker added his account as owner in the library contract, so for all wallets implemented after a particular date, the attacker became a joint owner. Then he triggered a kill function, which froze the currencies in the wallet. He basically locked $155 million as of that day, forever in cryptographically inaccessible wallets.</p><h3 id="51-攻击"><a href="#51-攻击" class="headerlink" title="51% 攻击"></a>51% 攻击</h3><h3 id="双重花费攻击（分叉攻击）"><a href="#双重花费攻击（分叉攻击）" class="headerlink" title="双重花费攻击（分叉攻击）"></a>双重花费攻击（分叉攻击）</h3><h3 id="贿赂攻击、P-Epsilon-Attack"><a href="#贿赂攻击、P-Epsilon-Attack" class="headerlink" title="贿赂攻击、P+Epsilon Attack"></a>贿赂攻击、P+Epsilon Attack</h3><h3 id="黑名单-Blocklisting"><a href="#黑名单-Blocklisting" class="headerlink" title="黑名单 Blocklisting"></a>黑名单 Blocklisting</h3><h3 id="timejacking"><a href="#timejacking" class="headerlink" title="timejacking"></a>timejacking</h3><h3 id="Sibyl-Attack"><a href="#Sibyl-Attack" class="headerlink" title="Sibyl Attack"></a>Sibyl Attack</h3><h3 id="DDos"><a href="#DDos" class="headerlink" title="DDos"></a>DDos</h3><h3 id="Replay-Attack"><a href="#Replay-Attack" class="headerlink" title="Replay Attack"></a>Replay Attack</h3><h3 id="Routing-Attacks"><a href="#Routing-Attacks" class="headerlink" title="Routing Attacks"></a>Routing Attacks</h3><h3 id="私钥丢失"><a href="#私钥丢失" class="headerlink" title="私钥丢失"></a>私钥丢失</h3><h3 id="代码漏洞：智能合约之殇"><a href="#代码漏洞：智能合约之殇" class="headerlink" title="代码漏洞：智能合约之殇"></a>代码漏洞：智能合约之殇</h3><h3 id="多重签名漏洞"><a href="#多重签名漏洞" class="headerlink" title="多重签名漏洞"></a>多重签名漏洞</h3><h3 id="隐私泄漏"><a href="#隐私泄漏" class="headerlink" title="隐私泄漏"></a>隐私泄漏</h3><h3 id="Vendor-Risk"><a href="#Vendor-Risk" class="headerlink" title="Vendor Risk"></a>Vendor Risk</h3><h3 id="政治风险：审查与监管"><a href="#政治风险：审查与监管" class="headerlink" title="政治风险：审查与监管"></a>政治风险：审查与监管</h3><p>参考：<br><a href="https://blockgeeks.com/guides/hypothetical-attacks-on-cryptocurrencies/" target="_blank" rel="noopener">https://blockgeeks.com/guides/hypothetical-attacks-on-cryptocurrencies/</a><br><a href="https://medium.com/zkcapital/beginners-guide-on-blockchain-security-attacks-part-1-network-ca4e74435723" target="_blank" rel="noopener">https://medium.com/zkcapital/beginners-guide-on-blockchain-security-attacks-part-1-network-ca4e74435723</a><br><a href="https://blogs.arubanetworks.com/solutions/10-blockchain-and-new-age-security-attacks-you-should-know/" target="_blank" rel="noopener">https://blogs.arubanetworks.com/solutions/10-blockchain-and-new-age-security-attacks-you-should-know/</a></p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第五章：P2P 网络技术</title>
      <link href="/Blockchain/blockchain-05-p2p-communication/"/>
      <url>/Blockchain/blockchain-05-p2p-communication/</url>
      
        <content type="html"><![CDATA[<h3 id="Gossip-Protocol"><a href="#Gossip-Protocol" class="headerlink" title="Gossip Protocol"></a>Gossip Protocol</h3><h3 id="DHT-Kadmlia"><a href="#DHT-Kadmlia" class="headerlink" title="DHT: Kadmlia"></a>DHT: Kadmlia</h3><h3 id="Overlay-amp-Underlay"><a href="#Overlay-amp-Underlay" class="headerlink" title="Overlay &amp; Underlay"></a>Overlay &amp; Underlay</h3><h3 id="Peer-Discovery"><a href="#Peer-Discovery" class="headerlink" title="Peer Discovery"></a>Peer Discovery</h3>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第六章：数据结构探索</title>
      <link href="/Blockchain/blockchain-06-data-structure/"/>
      <url>/Blockchain/blockchain-06-data-structure/</url>
      
        <content type="html"><![CDATA[<h4 id="Merkle-Tree"><a href="#Merkle-Tree" class="headerlink" title="Merkle Tree"></a>Merkle Tree</h4><h4 id="Block-Data-structure"><a href="#Block-Data-structure" class="headerlink" title="Block Data structure"></a>Block Data structure</h4><h4 id="UTXO"><a href="#UTXO" class="headerlink" title="UTXO"></a>UTXO</h4><h4 id="GAS"><a href="#GAS" class="headerlink" title="GAS"></a>GAS</h4>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第八章：比特币详解</title>
      <link href="/Blockchain/blockchain-08-bitcoin-explained/"/>
      <url>/Blockchain/blockchain-08-bitcoin-explained/</url>
      
        <content type="html"><![CDATA[<h4 id="比特币的交易"><a href="#比特币的交易" class="headerlink" title="比特币的交易"></a>比特币的交易</h4><ul><li>比特币的脚本</li><li>比特币脚本的应用</li><li>比特币的区块</li><li>比特币网络</li><li>限制与优化</li></ul><h4 id="如何储存和使用比特币"><a href="#如何储存和使用比特币" class="headerlink" title="如何储存和使用比特币"></a>如何储存和使用比特币</h4><ul><li>简单的本地储存</li><li>热储存与冷储存</li><li>密钥分存和密钥共享</li><li>在线钱包和交易所</li><li>支付服务</li><li>交易费</li><li>货币兑换市场</li></ul><h4 id="比特币挖矿"><a href="#比特币挖矿" class="headerlink" title="比特币挖矿"></a>比特币挖矿</h4><ul><li>比特币矿工的任务</li><li>挖矿所需硬件</li><li>能源消耗和生态环保</li><li>矿池</li><li>挖矿的激励和策略</li></ul><p>比特币区块验证 -&gt; 交易验证</p><p>提交区块时，必须先验证区块，在验证区块时，先验证区块中包含的交易。</p><p>1）CheckBlock()</p><p>（1）CheckBlockHeader() -&gt; pow<br>（2）CheckMerkleRoot<br>（3）check tx size 交易数量限制<br>（4）最大输出 OpSig</p><p>2) CheckTransaction()</p><p>（1）验证输入和输出<br>交易必须有输入（Input）和输出（Output）</p><p>（2）输出的数值合法<br>不能是负数，也不能超过比特币总量 2100 万</p><p>（3）输入不能重复</p><p>（4）coinbase tx</p><p>对于 coinbase 的 tx，其 scriptSig 的 size 范围限制 2-100<br>如果是普通 tx，则检测每笔 input 的 prevOut 是否为 Null</p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第七章：密码学原理</title>
      <link href="/Blockchain/blockchain-07-cryptography/"/>
      <url>/Blockchain/blockchain-07-cryptography/</url>
      
        <content type="html"><![CDATA[<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><ul><li>哈希计算</li><li>哈希算法的种类</li><li>区块链中的哈希算法</li></ul><h4 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h4><ul><li>公钥和私钥</li><li>RSA算法</li><li>椭圆曲线密码算法</li></ul><h4 id="编码-解码算法"><a href="#编码-解码算法" class="headerlink" title="编码/解码算法"></a>编码/解码算法</h4><ul><li>Base64 87</li><li>Base58 88</li><li>Base58Check 89</li></ul>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第四章：区块链的设计缺陷</title>
      <link href="/Blockchain/blockchain-04-tech-obstacles/"/>
      <url>/Blockchain/blockchain-04-tech-obstacles/</url>
      
        <content type="html"><![CDATA[<h3 id="复杂度-Complexity"><a href="#复杂度-Complexity" class="headerlink" title="复杂度 Complexity"></a>复杂度 Complexity</h3><h3 id="Untested-Code-amp-Untestable-Code"><a href="#Untested-Code-amp-Untestable-Code" class="headerlink" title="Untested Code &amp; Untestable Code"></a>Untested Code &amp; Untestable Code</h3><h3 id="网络规模-Network-size"><a href="#网络规模-Network-size" class="headerlink" title="网络规模 Network size"></a>网络规模 Network size</h3><h3 id="交易成本，网络速度"><a href="#交易成本，网络速度" class="headerlink" title="交易成本，网络速度"></a>交易成本，网络速度</h3><h3 id="网络拥堵：大量交易的确认延迟"><a href="#网络拥堵：大量交易的确认延迟" class="headerlink" title="网络拥堵：大量交易的确认延迟"></a>网络拥堵：大量交易的确认延迟</h3><h3 id="容量贪吃蛇：不断增长的区块数据"><a href="#容量贪吃蛇：不断增长的区块数据" class="headerlink" title="容量贪吃蛇：不断增长的区块数据"></a>容量贪吃蛇：不断增长的区块数据</h3><p>目前区块链存在的问题：</p><p>扩容困难（看比特币扩容战争就知道了）<br>交易很贵 (曾经参投ico，10个ETH转账费用用掉了0.1个ETH)<br>链与链之间缺乏连接<br>区块链近乎重新定义了整个网络架构 ，现有企业应用起来非常困难</p><h3 id="分级设计"><a href="#分级设计" class="headerlink" title="分级设计"></a>分级设计</h3><h3 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h3><h3 id="分片设计"><a href="#分片设计" class="headerlink" title="分片设计"></a>分片设计</h3><p>1、分级设计</p><p>　　在比特币扩容争议中，小区块的支持者最常使用的一个支持小区块的逻辑就是应该采用分层设计——主链承当结算层，闪电网络充当支付层，或者称为大额交易走结算层，小额支付走闪电网络。但我觉得主链和闪电网络将这种行驶相同功能，按功能的规模设计分成“分层”，并不能真正称为分层设计，这个应该称为分级设计。</p><p>　　我以前做机械设计的，设计过过滤粉尘的机器，就经常会用到分级设计。使用一个粗孔滤芯，先过滤掉一些大颗粒粉尘，然后再用细孔滤芯，过滤小颗粒粉尘。处理同一类对象但“物理大小”不一样，设计成多级。这样设计的好处在于节省运营成本。如果过滤器不分级，直接按最小颗粒来设计滤芯，那很快就要换滤芯，越细孔的滤芯成本越高。但分级成，使用两级来分担过滤任务，粗孔滤芯更便宜，让粗孔滤芯先过滤掉大粉尘，细孔滤芯压力就小，这样可以节省成本。</p><p>　　分级设计在我们生活中是非常常见的，我们家庭常用的饮用水过滤器就是分级的。比特币扩容方案选择的时候，有人提出使用闪电网络来分流主链的压力，这属于分级设计。因为这种提议，主链和闪电网络行驶的功能是完全一样的，都是发交易的支付行为。虽然有人将主链的交易行为称为“结算”，但这个叫法无法改变行为的功能。</p><p>　　因为比特币主链上发交易的成本是最高的，对个人来说，需要支付矿工费，对比特币系统来说需要所有节点来完整验证交易，需要系统的CPU、带宽、硬盘。而在闪电网络上发交易的成本是较低的，对个人来说，闪电网络里的手续费更低，速度更快，对比特币系统来说，并不需要所有节点去验证闪电网络内的交易，只需要验证进出闪电网络的交易。</p><p>　　同样的，使用offchain钱包来完整同钱包内的转账，也属于分级设计。因为offchain钱包，只是钱包公司自己完整数据的调整就可以了，这和在比特币网络上发交易是完全不一样的成本。</p><p>　　分级设计中，第一级(主链)是根本就不需要关心第二级是什么样子的，但第二级(闪电网络和offchain等)是需要关心主链的。比如闪电网络就需要监视主链，以保证不会出现支付通道的人做广播欺诈。</p><p>　　分级设计中，第二级出了问题，并不会伤害第一级主链。比如offchain钱包被盗了，跟主链毛关系都没有。但反过来则不一样。</p><p>　　分级设计其实是人对成本的考量而催生出来的，并不需要顶层设计，让市场自由博弈就能涌现出来分级解决方案。</p><p>2、分层设计</p><p>　　互联网最成功的分层设计应该是网络协议分层，就是我们熟知的七层网络结构，什么物理层、链路层、网络层……</p><p>　　分层的基本设计原则是：</p><p>　　各层是独立的，各自层做好自己的事即可。</p><p>　　层和层之间的功能是不一样的。</p><p>　　层和层之间的交流都是通过接口通信，只要接口保持不变，层内部的设计可以改变，且不会影响别的层。</p><p>　　目前各种区块链的设计，各种宣称说自己是分层设计的，往往都是不符合上述原理。</p><p>　　比特币比较接近分层设计的思想是侧链的设计原理。侧链可以完整独立设计成和主链完全不一样的功能，比如RSK目标是实现智能合约。而比特币主链实现的核心功能就是UTXO的转账和账本的更新维护。侧链和主链只是通过特定的交易来充当接口。但侧链往往需要关心主链在干吗，主链是不需要关心侧链的。这就是侧链和主链并不是相互独立的。</p><p>　　比特币(包括BTC和BCH)，尤其是BCH的OP_Return就是一个将来非常好的扩展为分层的设计。比特币主链对OP_Return里的数据只关心是否为真，并不关心具体的数据。那OP_Return就可以在里面设计出一整套新的功能，只要这里面的代码最后在BCH主链的交易里为真。而主链和OP_Return设计出来的新层是不需要相互关心的。</p><p>　　很早之前，以太坊的V神就想在OP_Return上实现他的以太坊的智能合约设想，可惜当时被Core开发组限制了。比特现金BCH的开发正在拿OP_Return大做文章。其实比特币的元币协议，就是一个很好的分层设计，只是一直没有被广泛使用起来。但现在我还没有充值理解元币协议，以后搞懂了再来讲。以太坊并不是分层设计，所有的功能都是在同一层上。以太坊所有的Dapp都是在同一套账本层里做事，并没有分层处理。</p><p>　　3、分片设计</p><p>　　分片设计目前还没有做完，无论是在比特币还是在以太坊上，都没有实现。但我可以简单讲下原理。现在比特币网络处理交易是这样的，一个节点收到一波交易，比如1万笔，节点会先将这些交易序列化，即给这些交易编个号排队，然后一笔一笔去验证。如果碰到某一笔验证无法通过，比如需要前置零确认的交易，那就先缓存起来。如果碰到有非法的交易，则直接丢弃。</p><p>　　比特币现在的这种处理交易方式就是串行的，即一个时间点，只能处理一笔交易。这样做就会有很大的瓶颈，单一电脑再牛逼，处理能力也会有上限。那能不能分成两台电脑，比如将1万笔交易，分成两波，5000笔一波，分别发给一台服务器去验证呢?不能!目前比特币还不支持这种并行验证。如何要做到并行验证呢?那就是要讲到分片设计了。比特币的UTXO的“物理实体”是这样的，一笔UTXO在电脑里存的主要数据是以下四个部分：</p><p>　　生成这笔UTXO的交易的txid;</p><p>　　生成这笔UTXO的交易的输出序列号index。因为大部分交易是一个或多个输入，多个输出，第一个输入序列号是0，第二个是1。</p><p>　　锁定脚本lockscript。</p><p>　　是金额value</p><p>　　其中txid是16进制表达，即使用0到F来表达，如果将首字符来分类，0归一类，1归一类……F归一类，就可以分为16类。如果使用首两个字符来分类，00一类，01一类……FF一类，那就可以分为256类……如果使用4个字符呢?16^4类。我们将上述的一类称为一个片，这就是分片。分片后，将一类分给一台电脑去处理，另一类分给另一台去处理……，256片就可以分成256台电脑来处理。而UTXO的txid就是交易的txid，则打包交易的区块，也可以按这种分类来打包，比如分成256片，则同一区块里，可以设成256个分区，一个分区打包一个片。也就是说，UTXO、交易、和区块都可以按同样的规则分片。</p><p>　　这样比特币全网就可以实现节点可选择处理哪一个分片，比如我运行一个节点，我只收、验证和广播特定分片的UTXO、交易和区块。这样就实现了比特币网络的并行扩展。但这种分片还是很复杂的，我上面讲的只是基本的原理，要完成设计是非常复杂的。比如一个UTXO去花费两次，是可以实现不同的txid，然后发到不同的分片，如果分片之间没有机制来通信，则可能会双花成功，但如果分片之间还要为这种攻击大量通信，则还不如不分片呢。</p><p>　　但如果实现了分片，那比特币网络则是可以实现无限扩展，什么百万TPS，都不在话下，什么1M、8M、32M根本就不是事，至少1G区块。因为一台电脑处理不了，可以搞16^n台来处理好了，一个人买不起16^n台电脑(中心化)的话，那就找16^n个人每人买一台好了。</p><p>　　以太坊的分片更复杂，我暂时讲不明白。BCH的开发正在全力开发UTXO分片，我也在努力学习这些知识，以求能贡献一点知识。</p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第九章：智能合约</title>
      <link href="/Blockchain/blockchain-09-smart-contract/"/>
      <url>/Blockchain/blockchain-09-smart-contract/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十一章：跨链与通证经济</title>
      <link href="/Blockchain/blockchain-11-cross-chain-and-token-economy/"/>
      <url>/Blockchain/blockchain-11-cross-chain-and-token-economy/</url>
      
        <content type="html"><![CDATA[<h4 id="去中心化交易所"><a href="#去中心化交易所" class="headerlink" title="去中心化交易所"></a>去中心化交易所</h4><h4 id="公证人机制（Notary-schemes）"><a href="#公证人机制（Notary-schemes）" class="headerlink" title="公证人机制（Notary schemes）"></a>公证人机制（Notary schemes）</h4><ul><li>瑞波Interledger协议</li></ul><h4 id="侧链-中继（Sidechains-relays）"><a href="#侧链-中继（Sidechains-relays）" class="headerlink" title="侧链/中继（Sidechains/relays）"></a>侧链/中继（Sidechains/relays）</h4><ul><li>侧链：BTC Relay</li><li>中继：Polkadot, Cosmos</li></ul><h4 id="哈希锁定（Hash-locking）"><a href="#哈希锁定（Hash-locking）" class="headerlink" title="哈希锁定（Hash-locking）"></a>哈希锁定（Hash-locking）</h4><ul><li>Lighting network</li></ul><h4 id="分布式私钥控制（Distributed-private-key-control）"><a href="#分布式私钥控制（Distributed-private-key-control）" class="headerlink" title="分布式私钥控制（Distributed private key control）"></a>分布式私钥控制（Distributed private key control）</h4><ul><li>WanChain</li></ul><p>参考：<br><a href="https://36kr.com/p/5117175" target="_blank" rel="noopener">https://36kr.com/p/5117175</a></p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十章：以太坊详解</title>
      <link href="/Blockchain/blockchain-10-ethereum-explained/"/>
      <url>/Blockchain/blockchain-10-ethereum-explained/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十二章：匿名货币</title>
      <link href="/Blockchain/blockchain-12-anonymous-coin/"/>
      <url>/Blockchain/blockchain-12-anonymous-coin/</url>
      
        <content type="html"><![CDATA[<h4 id="匿名的基础知识"><a href="#匿名的基础知识" class="headerlink" title="匿名的基础知识"></a>匿名的基础知识</h4><ul><li>如何对比特币去匿名化</li></ul><h4 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a>零知识证明</h4><h4 id="混币"><a href="#混币" class="headerlink" title="混币"></a>混币</h4><ul><li>分布式混币</li></ul><h4 id="零币和零钞"><a href="#零币和零钞" class="headerlink" title="零币和零钞"></a>零币和零钞</h4>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十三章：另类币</title>
      <link href="/Blockchain/blockchain-13-alt-coins/"/>
      <url>/Blockchain/blockchain-13-alt-coins/</url>
      
        <content type="html"><![CDATA[<p>另类币和加密货币生态系统<br>另类币的历史和诱因<br>几种另类币的详细介绍<br>比特币和另类币的关系<br>另类币的夭折与共同挖矿<br>不可分割的交叉链互换<br>侧链——基于比特币的另类币<br>以太坊和智能合约</p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十五章：DApp 应用开发</title>
      <link href="/Blockchain/blockchain-15-DApps/"/>
      <url>/Blockchain/blockchain-15-DApps/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十六章：区块链数据统计</title>
      <link href="/Blockchain/blockchain-16-statistic/"/>
      <url>/Blockchain/blockchain-16-statistic/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第十四章：区块链哲学</title>
      <link href="/Blockchain/blockchain-14-blockchain-philosophy/"/>
      <url>/Blockchain/blockchain-14-blockchain-philosophy/</url>
      
        <content type="html"><![CDATA[<p>去中心化系统的优势<br>更强的计算能力<br>更低的成本<br>更高的可靠性<br>自增长的能力（扩展性）</p><p>去中心化系统的劣势<br>节点间的协调 coordination<br>节点间的冗余通信<br>对网络的过度依赖<br>系统编程的较高复杂度<br>安全问题</p><p>分层设计</p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Database fundamentals</title>
      <link href="/System-Programming/core-techs-database/"/>
      <url>/System-Programming/core-techs-database/</url>
      
        <content type="html"><![CDATA[<h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><h2 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h2><ul><li>底层和上层数据库组件概况</li><li>查询优化过程概况</li><li>事务和缓冲池管理概况</li></ul><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>数据模型主要用来描述数据！上边已经说了，当我们想在计算机上存储现实事物的数据时，需要先抽象成概念模型。将概念模型转换成DBMS支持的数据模型，就可以把事物存储到计算机中！</p><p>数据模型一般由三个部分组成：</p><ul><li>数据结构（对象与对象之间的关系）</li><li>数据操作（增删改查）</li><li>完整性约束（限定数据是有一定规则的，比如：年龄不能为负数）</li></ul><p>数据模型也经历了一个发展阶段：</p><p>①：层次模型，是一种树型（层次）结构来组织数据的数据模型。<br>②：网状模型， 是用有向图结构来组织数据的数据模型<br>③：关系模型，是一种用二维表格结构表示数据及数据之间联系的数据模型。</p><p>高级术语<br>1、存储引擎 、事务、复合索引、连接池、备份、恢复<br>2、主从复制、行锁定、表锁定、慢查询、二进制日志、临时表、内容分发、同步、数据库分区、分库、分表、水平拆分、垂直拆分</p><p>数据库系统概念 事务<br>事务：原子性、一致性、隔离性、持久性：ACID特性<br>原子性与持久性的实现<br>影子副本，在副本中更新事务，db__pointer指向更新过的副本即可实现事务原子性提交<br>并发执行<br>并发：提高吞吐量和资源利用率，减少等待时间<br>冲突存在等价串行化执行顺序，则冲突可串行化<br>调度视图等价于一个串行调度，即视图可串行化<br>冲突串行化顺序可由拓扑排序获得<br>并发控制<br>基于锁协议<br>共享锁：事务获得数据项上共享锁后可读不可写<br>排它锁：事务获得数据项上排它锁后可读又可写<br>事务T申请对数据项Q加M型锁时，并发控制管理器授权加锁的条件<br>不存在数据项Q上持有与M型锁冲突的锁的事务<br>不存在等待对数据项Q加锁且先于T申请加锁的事务<br>两阶段封锁协议<br>增长阶段：只能加锁不能释放锁<br>缩减阶段：只能解锁不能加锁<br>最后加锁位置：即封锁点，根据封锁点排序（串行化顺序）避免发生死锁<br>严格两阶段封锁：任一事务失败，级联回滚<br>强两阶段封锁：事务提交之前不能释放任何锁</p><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>MySQL 索引使用的注意事项参考：</p><p>mysql 索引使用技巧及注意事项</p><p>说说反模式设计参考：</p><p>每个程序员要注意的 9 种反模式</p><p>说说分库与分表设计</p><p>分表与分库使用场景以及设计方式</p><p>分库与分表带来的分布式困境与应对之策</p><p>服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策</p><p>说说 SQL 优化之道</p><p>sql 优化的几种方法</p><p>MySQL 遇到的死锁问题<br>   参考： Mysql 并发时经典常见的死锁原因及解决方法</p><p>存储引擎的 InnoDB 与 MyISAM<br>InnoDB 支持事务，MyISAM 不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而 MyISAM 就不可以了。<br>MyISAM 适合查询以及插入为主的应用，InnoDB 适合频繁修改以及涉及到安全性较高的应用<br>InnoDB 支持外键，MyISAM 不支持<br>从 MySQL5.5.5 以后，InnoDB 是默认引擎<br>InnoDB 不支持 FULLTEXT 类型的索引<br>InnoDB 中不保存表的行数，如 select count() from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含 where 条件时 MyISAM 也需要扫描整个表<br>对于自增长的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM 表中可以和其他字段一起建立联合索引<br>清空整个表时，InnoDB 是一行一行的删除，效率非常慢。MyISAM 则会重建表<br>InnoDB 支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘%lee%’ 参考：<br>MySQL 存储引擎之 MyIsam 和 Innodb 总结性梳理</p><p>数据库索引的原理<br>  参考： <a href="http://blog.csdn.net/suifeng3051/article/details/52669644" target="_blank" rel="noopener">http://blog.csdn.net/suifeng3051/article/details/52669644</a></p><p>为什么要用 B-tree</p><p>鉴于 B-tree 具有良好的定位特性，其常被用于对检索时间要求苛刻的场合，</p><p>例如： </p><p>1、B-tree 索引是数据库中存取和查找文件(称为记录或键值)的一种方法。 </p><p>2、硬盘中的结点也是 B-tree 结构的。与内存相比，硬盘必须花成倍的时间来存取一个数据元素，这是因为硬盘的机械部件读写数据的速度远远赶不上纯电子媒体的内存。与一个结点两个分支的二元树相比，B-tree 利用多个分支（称为子树）的结点，减少获取记录时所经历的结点数，从而达到节省存取时间的目的。</p><p>聚集索引与非聚集索引的区别</p><p>参考：快速理解聚集索引和非聚集索引</p><p>limit 20000 加载很慢怎么解决</p><p>LIMIT n 等价于 LIMIT 0,n</p><p>此题总结一下就是让 limit 走索引去查询，例如：order by 索引字段，或者 limit 前面根 where 条件走索引字段等等。</p><p>参考： MYSQL 分页 limit 速度太慢优化方法</p><p>选择合适的分布式主键方案</p><p>参考：分布式系统唯一 ID 生成方案汇总</p><p>选择合适的数据存储方案<br>关系型数据库 MySQL<br>MySQL 是一个最流行的关系型数据库，在互联网产品中应用比较广泛。一般情况下，MySQL 数据库是选择的第一方案，基本上有 80% ~ 90% 的场景都是基于 MySQL 数据库的。因为，需要关系型数据库进行管理，此外，业务存在许多事务性的操作，需要保证事务的强一致性。同时，可能还存在一些复杂的 SQL 的查询。值得注意的是，前期尽量减少表的联合查询，便于后期数据量增大的情况下，做数据库的分库分表。</p><p>内存数据库 Redis<br>随着数据量的增长，MySQL 已经满足不了大型互联网类应用的需求。因此，Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。</p><p>在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。</p><p>使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。</p><p>文档数据库 MongoDB<br>MongoDB 是对传统关系型数据库的补充，它非常适合高伸缩性的场景，它是可扩展性的表结构。基于这点，可以将预期范围内，表结构可能会不断扩展的 MySQL 表结构，通过 MongoDB 来存储，这就可以保证表结构的扩展性。</p><p>此外，日志系统数据量特别大，如果用 MongoDB 数据库存储这些数据，利用分片集群支持海量数据，同时使用聚集分析和 MapReduce 的能力，是个很好的选择。</p><p>MongoDB 还适合存储大尺寸的数据，GridFS 存储方案就是基于 MongoDB 的分布式文件存储系统。</p><p>列族数据库 HBase<br>HBase 适合海量数据的存储与高性能实时查询，它是运行于 HDFS 文件系统之上，并且作为 MapReduce 分布式处理的目标数据库，以支撑离线分析型应用。在数据仓库、数据集市、商业智能等领域发挥了越来越多的作用，在数以千计的企业中支撑着大量的大数据分析场景的应用。</p><p>全文搜索引擎 ElasticSearch<br>在一般情况下，关系型数据库的模糊查询，都是通过 like 的方式进行查询。其中， like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。ElasticSearch 作为一个建立在全文搜索引擎 Apache Lucene 基础上的实时的分布式搜索和分析引擎，适用于处理实时搜索应用场景。此外，使用 ElasticSearch 全文搜索引擎，还可以支持多词条查询、匹配度与权重、自动联想、拼写纠错等高级功能。因此，可以使用 ElasticSearch 作为关系型数据库全文搜索的功能补充，将要进行全文搜索的数据缓存一份到 ElasticSearch 上，达到处理复杂的业务与提高查询速度的目的。</p><p>ElasticSearch 不仅仅适用于搜索场景，还非常适合日志处理与分析的场景。著名的 ELK 日志处理方案，由 ElasticSearch、Logstash 和 Kibana 三个组件组成，包括了日志收集、聚合、多维度查询、可视化显示等。</p><pre><code>ObjectId 规则参考：</code></pre><p>MongoDB 学习笔记~ObjectId 主键的设计</p><p>mongodb 中的_id 的 ObjectId 的生成规则</p><p>聊聊 MongoDB 使用场景参考： 什么场景应该用 MongoDB ？</p><pre><code>倒排索引</code></pre><p>   参考： 什么是倒排索引？</p><p>聊聊 ElasticSearch 使用场景<br>在一般情况下，关系型数据库的模糊查询，都是通过 like 的方式进行查询。其中， like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。ElasticSearch 作为一个建立在全文搜索引擎 Apache Lucene 基础上的实时的分布式搜索和分析引擎，适用于处理实时搜索应用场景。此外，使用 ElasticSearch 全文搜索引擎，还可以支持多词条查询、匹配度与权重、自动联想、拼写纠错等高级功能。因此，可以使用 ElasticSearch 作为关系型数据库全文搜索的功能补充，将要进行全文搜索的数据缓存一份到 ElasticSearch 上，达到处理复杂的业务与提高查询速度的目的。</p><p>缓存使用</p><p>Redis 有哪些类型<br>Redis 支持五种数据类型：</p><p>string（字符串），hash（哈希），list（列表），set（集合）及 zset(sorted set：有序集合)。</p><p>参考：  Redis 数据类型</p><p>Redis 内部结构参考：</p><p>redis 内部数据结构深入浅出</p><p>聊聊 Redis 使用场景随着数据量的增长，MySQL 已经满足不了大型互联网类应用的需求。因此，Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。</p><p>在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。</p><p>使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。</p><p>Redis 持久化机制参考： redis 的持久化和缓存机制</p><p>Redis 如何实现持久化参考： Redis 如何实现持久化</p><p>Redis 集群方案与实现参考： redis 集群主流架构方案分析</p><p>Redis 为什么是单线程的</p><p>单纯的网络 IO 来说，量大到一定程度之后，多线程的确有优势——但并不是单纯的多线程，而是每个线程自己有自己的 epoll 这样的模型，也就是多线程和 multiplexing 混合。 一般这个开头我们都会跟一个“但是”。 </p><p>但是。 还要考虑 Redis 操作的对象。它操作的对象是内存中的数据结构。如果在多线程中操作，那就需要为这些对象加锁。最终来说，多线程性能有提高，但是每个线程的效率严重下降了。而且程序的逻辑严重复杂化。 </p><p>要知道 Redis 的数据结构并不全是简单的 Key-Value，还有列表，hash，map 等等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在 hash 当中添加或者删除一个对象，等等。这些操作还可以合成MULTI/EXEC 的组。这样一个操作中可能就需要加非常多的锁，导致的结果是同步开销大大增加。这还带来一个恶果就是吞吐量虽然增大，但是响应延迟可能会增加。 </p><p>Redis 在权衡之后的选择是用单线程，突出自己功能的灵活性。在单线程基础上任何原子操作都可以几乎无代价地实现，多么复杂的数据结构都可以轻松运用，甚至可以使用 Lua 脚本这样的功能。对于多线程来说这需要高得多的代价。</p><p>并不是所有的 KV 数据库或者内存数据库都应该用单线程，比如 ZooKeeper 就是多线程的，最终还是看作者自己的意愿和取舍。单线程的威力实际上非常强大，每核心效率也非常高，在今天的虚拟化环境当中可以充分利用云化环境来提高资源利用率。多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的，所以单线程、多进程的集群不失为一个时髦的解决方案。</p><p>缓存奔溃<br>参考： Redis 持久化</p><p>缓存降级</p><p>服务降级的目的，是为了防止 Redis 服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis 出现问题，不去数据库查询，而是直接返回默认值给用户。</p><p>使用缓存的合理性问题参考： Redis 实战（一） 使用缓存合理性</p><p>消息队列</p><p>消息队列的使用场景主要解决应用耦合，异步消息，流量削锋等问题</p><p>消息队列使用的四种场景介绍</p><p>消息的重发补偿解决思路</p><p>参考： JMS 消息传送机制</p><p>消息的幂等性解决思路</p><p>参考： MQ 之如何做到消息幂等</p><p>消息的堆积解决思路</p><p>参考： Sun Java System Message Queue 3.7 UR1 管理指南</p><p>自己如何实现消息队列</p><p>参考：自己动手实现消息队列之 JMS</p><p>如何保证消息的有序</p><p>参考： 消息队列的 exclusive consumer 功能是如何保证消息有序和防止脑裂的</p><p>原文：<a href="https://blog.csdn.net/ganquanzhong/article/details/86185185" target="_blank" rel="noopener">https://blog.csdn.net/ganquanzhong/article/details/86185185</a></p>]]></content>
      
      
      <categories>
          
          <category> System Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二部分：区块链核心技术：区块链项目核心知识</title>
      <link href="/Distributed-System/blockchain-part2-industry-exp/"/>
      <url>/Distributed-System/blockchain-part2-industry-exp/</url>
      
        <content type="html"><![CDATA[<p>专业经验<br>专业经验则是指对目前最主流的区块链项目的掌握程度，比如 Bitcoin，Ethereum 等，了解账户模型，智能合约等等，而且，不仅是它们的运行原理，而且能在它们的基础上持续改进、开拓以及创新，比如对侧链，轻节点、分布式存储，扩容方案等有一定的理解等等。</p><p>为此，我也做了一个列表，主要展示对区块链的专业经验的一些要求：</p><p>目前区块链主流共识算法之间的差异（比如 PBFT 与 POW 之间区别）<br>联盟链、公链及私链之间的区别，部署方式<br>针对区块链的攻击方式：51% 算力攻击，Sybil 攻击，Eclipse 攻击，DDos 攻击<br>P2P 网络通信模式（Gossip，Totem，DHT 等）<br>Merkle Tree 数据结构<br>Bitcoin UTXO 模型，以太坊账户模型，转账流程（GAS 计算，Nonce 值等等）<br>以太坊智能合约的编写，Solidity 相关知识<br>密码学（公钥/私钥，ECDSA，RSA，哈希算法），签名，多重签名，盲签名等等<br>以太坊协议 ERC20 ERC721 ERC223 ERC875<br>比特币（P2SH 地址，交易脚本等）<br>这部分内容可以详见我的系列文章之《区块链核心技术：专业经验》。</p><h2 id="续篇"><a href="#续篇" class="headerlink" title="续篇"></a>续篇</h2><p>这篇文章是这个系列的第二篇：<strong>专业经验</strong></p><h3 id="一、共识算法"><a href="#一、共识算法" class="headerlink" title="一、共识算法"></a>一、共识算法</h3><p>我在第一部分的分布式理论中介绍了共识机制的原理和典型的非拜占庭共识算法，比如 Raft，Paxos 等。它们虽然能保证共识，但是它们对环境有较多要求，比如不能有恶意节点，无法抵御女巫攻击等。只能应用于相对封闭的网络环境。</p><p>这一篇，我们将要介绍在开放网络（公网）环境中依然能保证共识一致性的算法。比如 POW, PBFT 以及 POS 等一些耳熟能详的算法。这些算法由于能够容忍恶意节点，因此我们通常统称为 BFT 算法。</p><h4 id="POW"><a href="#POW" class="headerlink" title="POW"></a>POW</h4><p>POW 全称是 Proof of Work，工作量证明。它是目前最主要的一种 BFT 算法，大名鼎鼎的比特币、以太坊以及其他项目的挖矿原理都是基于 POW 的。</p><p>POW 的原理是利用一些数学难题的计算困难来实现不同节点（矿工）公平争夺记账权，获得记账权的节点就可以获得一定数量的比特币奖励。<br>所谓的数学难题的计算困难是指没有解法，每个参与的节点都只能依赖暴力试算。运气好的节点先试算出匹配的答案就可以获得奖励，这是一种相对公平的算法，因为即使运算能力很低的普通计算机也有机会试出答案。</p><p>数学难题的类型有很多种，比如哈希的逆运算、卷积求导、大质数分解等，在主流的数字货币中（比特币、以太坊等），最典型的 POW 就是利用哈希的逆运算难题。那就是：任何一组数据要计算出它的哈希很简单，但是要根据哈希来得知原数据是什么，则没有算法，只能靠猜。在比特币中，每个矿工都可以打包一定数量的合法交易，要决定谁打包的交易可以被比特币网络确认，就需要计算它们打包后的交易数据的哈希，如果这个哈希符合要求（与答案吻合），那么这个矿工就获得记账权，并得到比特币奖励。其它矿工继续在此基础上打包下一次交易数据，并再次争夺记账权，依此类推。</p><p>POW 的计算方式为：</p><p>numberOfPrefixZero_proofhash &lt;= numberOfPrefixZero_targetHash</p><p>可以看到，在 P0W 下，只能暴力试算，节点获得记账权的概率是随机的。而由于试算需要需要较长时间的耗时耗电运算，所以恶意节点需要推翻已经确认的结果需要花费双倍甚至多倍的算力和资源。比特币采用最长链的方式来维持一致性，只要多数节点（51%）在最长链上进行挖矿，就可以保证交易的正确性不可篡改。而且即使存在分叉也可以得到矫正。</p><p>POW 使用简单试错暴力猜答案的方式来保证公平性，是一个相对比较公平的代币分发机制，它也是迄今为止最安全的公有链共识算法，任何想要恶意攻击系统的人都不得不付出比收益高得多的成本，从经济效益上确保了公链的安全性。比特币、以太坊以及其它主流的数字货币都采用 POW 算法。</p><p>但是 POW 其也有固然的缺陷，那就是哈希算法只是简单的指令计算（SHA256 哈希算法），这个算法只消耗CPU资源，对内存要求不高，这就意味着性能更高的计算机可以在短时间内试算更多答案，从而大大提高命中的概率。而且，专业的矿机（ASIC）对指令集做了精简，使得其在运行指定的哈希算法时速度更快，导致算力迅速被集中到少部分人手中。这也就违背了 POW 算法的初衷。POW 还有一个被人诟病的重大缺陷就是对资源的浪费，大量的矿机在花费无数的电力执行一个毫无实际意义的运算，只为了争夺一次记账权，获得记账权的节点得到奖励，而其余所有付出同样时间进行计算的节点则无法获得任何回报。</p><p>比特币挖矿芯片的更新换代图：<br><img src="/image/blockchain/bitcoin_asic.png" alt=""></p><p>专业的比特币 ASIC 矿场：<br><img src="/image/blockchain/factory.jpg" alt=""></p><p>这样算力就集中在大矿主手里，普通用户使用电脑根本不可能挖到矿，这与中本聪当年设想的人人都能公平记账的愿景相违背。<br>为此，人们设计了各种反 ASIC 化的方案。一个主要的思路就是将 POW 算法改的很复杂，需要大量的内存，这样 ASIC 芯片是不可能集成大量内存进去的，从而无法制造出专门的挖矿芯片。</p><p>比较有代码的改进方案有：<br>莱特币：刚性内存哈希函数 Scrypt 取代 SHA256<br>达世币：X11，11 种哈希函数混合使用<br>以太坊：Ethash，大内存 DAG 搜索<br>但是实际上，只要利益足够大，人们总能够设计出专门 PoW 挖矿的矿机，莱特币矿机和达世币矿机先后被制造了出来，以太坊之前也顶多是使用显卡挖矿，后来也被研发出了专门进行以太坊挖矿的专业矿机。</p><p>比特币 PoW 算法的资源浪费问题<br>中本聪为了解决拜占庭共识问题，在比特币系统中引入竞争挖矿的机制。同时，为了保证最大可能的公平性，采用了基于哈希运算的PoW共识机制。矿工如果想要得到一个合法的区块，则必须向区块头中填入不同的随机值，然后计算出区块头的哈希值，使得得到的哈希值小于目标值。这样，矿工在不断寻找合适随机值的过程中完成了一定的工作量。可以发现，矿工完成的这个工作量对于现实社会毫无意义。唯一的意义就是保障了比特币的安全性。</p><p>对 PoW 算法进行改进的尝试<br>比特币的 PoW 算法是没有任何实际意义的 SHA256 运算，于是人们就试图把这些计算变成有意义的计算，比如科学计算等，而不是单纯的浪费。以下是几个比较有名的进行有效工作量证明的区块链：</p><p>质数币：Primecoin（质数币）发布于2013年7月。其最大的特点是将虚拟货币中浪费的算法资源利用起来。它的PoW可以搜索质数，从而计算孪生素数表。所以有一定的科学价值。<br>治疗币：Curecoin（治疗币）发布于2013年5月。治疗币最大的特点是将蛋白质褶皱结构的研究SHA256工作量证明算法进行了结合。因为蛋白质褶皱研究需要对蛋白质进行生化反应的模拟过程需要大量的计算资源，所以在“挖矿”的同时，还用于发现治愈疾病的新药，一举两得。<br>比原链：比原链重新设计一种不同于比特币的哈希运算 PoW 共识机制，引入了矩阵运算与卷积运算，这样就能让人工智能运算充分利用比原链的挖矿设备。在这个过程中，人工智能加入了新的硬件，其算法运行速度得到明显提高。同时，这样也能减少一定的资源浪费。在这种情况下，矿机市场巨大的经济利益能够极大地加速人工智能 ASIC 芯片的发展，加快人工智能的研究。反过来，人工智能的快速发展也产生了更多的 ASIC 矿机需求。因此，这是一种正向反馈良性发展的过程。</p><h4 id="POS"><a href="#POS" class="headerlink" title="POS"></a>POS</h4><p>POS，全称是 Proof of Stake，权益证明。我们可以把它理解为股份制，谁的股份越多，谁的话事权越大，这和我们现实世界中的股份制含义是一样的。<br>在 POS 中，我们可以选择把持币数量或者持币时间作为股份权益，持有的虚拟货币数量或时间越多，那么其所获得出块权的概率就越大。以币龄为例，一旦出块，就扣除币龄，并获得相应的奖励（利息）。</p><p>由于 POS 不需要节点牺牲资源就可以进行出块获得奖励，作恶成本很低，所以就需要设计一套惩罚机制以确保 POS 网络的安全。通常把这种机制称为 “slashing”，最常见的就是扣除 miner/validator 的保证金。</p><p>需要注意，在 Pos 的世界中不再有矿工，而是有 Validator，只有称为 Validator 才具有出块权，要成为 Validator，通常需要发送一个特定的指令（或交易），锁定部分权益（Stake），最后通过出块获得相应收益。</p><p>PoS 的实现方式通常主要可以分为两种：chain-based PoS 和 BFT-style PoS。chain-based PoS 是在每轮出块是随机选择（根据权重）一个 Validator 来进行出块，这个 Validator 出的块就是最终被确认的块，比如 Peercoin，Nxt 等。而 BFT-Style 则是由所有 Validator 对某个提交的块进行投票，来决定是否最终确认这个区块。</p><p>下面就介绍几个主流的采用 PoS 算法的虚拟货币：</p><p>1）点点币 Peer Coin<br>点点币是 2012 年 8 月发布的，它的采矿方式混合了 POW 工作量证明及 POS 权益证明方式，其中 POW 主要用于发行货币，未来难度逐渐上升，产量降低。系统安全则主要由 POS 维护。目前区块链中存在两种类型的区块，POW区块和POS区块。</p><p>Peercoin 中的 POS 是根据币龄来决定挖矿难度的，币龄越长，挖矿难度就越小，从而其获得出块权的概率就越大。<br>跟 POW 中挖矿结果的计算方式类似，先计算其欲提交的区块哈希，然后对比目标值，如果符合要求，那就获得出块。</p><p>公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proofHash &lt; coinAge x targetHash</span><br></pre></td></tr></table></figure><p>考虑到一些安全性方面的要求，点点币还设置了币龄的上限为 3 个月，以及区块间隔等。</p><p>采用币龄有两个最明显的漏洞：</p><ol><li><p>币龄攻击 save-up attack<br>由于币龄可以决定出块权，那些持有很少币（比如仅 1%）的用户，可以恶意憋个两个月不挖矿积攒币龄，然后来攻击网络。由于它们持币少，攻击成本低，可以很容易就对区块链进行分叉，形成双花。</p></li><li><p>离线 offline<br>即使是诚实节点，它们也可以利用离线的方式积攒币龄，然后在到期前再同步获得利息。这样会造成两个后果，一是在线节点减少导致网络活跃度低，从而同步速度和交易速度都受影响。此外在线节点少也更加容易发生攻击。</p></li></ol><p>2）NextCoin<br>NextCoin 是第一个纯 POS 的虚拟货币，是在 2013 年由 Bitcointalk 论坛的一个叫 BCNext 的用户发起的。Nxt 不再通过消耗大量的资源“挖矿”产生新货币，而是通过现有账户的余额去“锻造”区块，并给与成功“锻造”区块的账户交易费用奖励。NXT 的 POS 实现方式与 PPC 完全不同，合格区块判定方法为：</p><p>hit &lt; baseTarget * effectiveBalance * elapseTime</p><p>hit 是根据最新区块和用户的私钥生成的值，用户在挖一个区块时只需要计算一次即可。而右边的值跟账户余额成正比，跟流逝的时间成正比。也就意味着，用户账户余额越多，挖到矿的几率越高，随着时间的流逝越久，越容易找到新的区块。</p><p>transparent forging</p><p>NXT 把上述挖矿机制称为“透明锻造”，它可以预测哪个账户将会锻造下一个区块。具体的方法就是，遍历所有具有锻造资格（余额大于1k）的活跃账户，看谁具有最高的 hit 值。由于每一个节点都可以计算出哪个账户是下一个区块的生成者，因此可以直接将交易发送给下一个区块的锻造者，而不用像通常的那样广播至整个网络。这极大的提高了区块交易的速度。而且，如果轮到那个该进行锻造的账户不锻造的话，还会受到惩罚（锻造力清零）。</p><p>一天有 1440 分钟，NXT 每天出 1440 个块，也就是平均每分钟一个块。账户通过锻造区块来赚取交易费，它能够锻造的块取决于它拥有的 coin 数量相对于所有 active coin 的数量。当一笔 coin 转移到一个新的账户，它必须等待 1440 分钟才能成为 active coin 参与锻造。这样避免了被拥有大账户和账户多的人员垄断锻造机会。</p><p>通常来说，每笔交易的费用最少是 1 个 fee coin，一个区块可以是空的，也可以最多包含 255 笔交易。也就是说，按最少交易费（1 fee coin）来算，锻造一个区块可以获得最多 255 个 “fee coin”。</p><p><a href="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221701177-996771581.png" target="_blank" rel="noopener"></a></p><p>3）黑币 Blackcoin<br>黑币 BLK 是在 2014 年发布的。起初它采用 POW 和 PoS 混合的方式，<br>发行前 7 天采用 Scrypt 算法进行 POW 挖矿，第 8 天开始（10001 块）进入纯 POS 阶段。</p><p>在 POS 算法中，它的难度公式不再使用币龄，而是使用持币数量，公式如下：</p><p>proofhash &lt; coinAmout * targetHash</p><p>由于没有币龄，使得积攒币龄的方法不再有效，所有节点必须更多的保持在线，以进行权益累积。</p><p>虽然如此，但是 PoS 依然有一个核心的缺陷难以解决，那就是分叉。<br>由于 Pos 不消耗算力，所以一旦出现分叉，理性节点会在所有链上同时 PoS 挖矿。以至于每次分叉都会形成新的山寨币，PoS 无法很好的应对分叉。<br>相反，PoW 中通常节点只能选择一个最长链进行挖矿，否则如果选择在多个链进行挖矿的话，算力分散，得不偿失。</p><p>4）Ethereum Casper<br>由于 PoW 的高耗能缺陷，Ethereum 很早就计划迁移到 PoS 机制上，2017 年发布的 Casper Protocol 就是其 PoS 实现的一种规范。</p><p>Casper 采用 Validator 来对区块进行有效性验证和最终确认，Validator 是网络的参与者，必须抵押一定的虚拟货币资产，以便在其违背诚信原则（slashing conditions）时作为处罚。Validator 通过确认区块来获得收益。</p><p>我们来简单看一下 Casper 是如何工作的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">验证者押下一定比例的他们拥有的以太币作为保证金。</span><br><span class="line">然后，他们将开始验证区块。也就是说，当他们发现一个可以他们认为可以被加到链上的区块的时候，他们将以通过押下赌注来验证它。</span><br><span class="line">如果该区块被加到链上，然后验证者们将得到一个跟他们的赌注成比例的奖励。</span><br><span class="line">但是，如果一个验证者采用一种恶意的方式行动、试图做“无利害关系”的事，他们将立即遭到惩罚，他们所有的权益都会被砍掉。</span><br></pre></td></tr></table></figure><p>Casper 不是一个单一的项目，它包含了两个研究项目，它们是</p><ul><li>（1）Casper the Friendly Finality Gadget (FFG)<br>FFG 是 Vitalik 提出的一种混合 POW/POS 共识算法，主要目的是为了方便 Ethereum 过度到纯 PoS 而设计。<br>具体来说，Casper FFG 被设计为运行在 PoW 之上的 Smart Contract，参与方需要发送至少 1500 ETH 作为抵押才能称为 Validator，然后对 PoW 产生的每 50 个区块（称为 “Checkpoint”）进行一个 Validity 投票验证，为了防止恶意攻击，Validator 必须接受 slashing conditions，也就是说，一旦被发现不诚实行为，它所有的 Deposits 都会被扣除。</li></ul><p>FFG 可以实现一定程度的 BFT 性质要求：</p><p>（1）Accountable Safety<br>只要不到 1/3 的 Validators 不违反 slashing condition，那么就不会有两个冲突的 Checkpoints 同时被确认。</p><p>（2）Plausible Liveness<br>只要 2/3 的 Validators 遵守协议，那么就一定能够产生（finalize）一个永久有效的 checkpoint。</p><p>具体数学论证请查看 <a href="https://arxiv.org/pdf/1710.09437.pdf" target="_blank" rel="noopener">Casper FFG paper</a></p><p>FFG 已经被废弃了，那么它有什么问题？<br>首先最大的问题就是它不够分布式 decentralized，一方面，由于依然受限于 PoW 出块的效率（ 15tx/s），导致需要把最低抵押金（MIN_DEPOSIT_SIZE）设置为 1500 ETH，这对于个人来说是一个很大的数值，而且 Validators 网络被限制为大概只有 900 到 1000 个左右的参与者以便该网络能更有效的运行。</p><p>另一方面，智能合约层的签名验证有不可避免的瓶颈。假如我们把最低保证金降低到 32 ETH，整个网络有 1000 万 ETH 保证金，那么将会有 31.25 万个 Validators，每个投票周期需要收集 2/3 的票，也就是每个 PoW 矿工需要收集 20.8 万个票。这个将极大的降低系统的出块率，在极端情况下需要10几个小时才仅能提交一个块，非常不可行！</p><p>那么怎么才能有效的收集超过 10 万数量的投票呢？答案是：off-chain</p><p>使用一种称为 “BLS Signature Aggregation“ 增量签名的方法，不对公钥进行1对1验证，而是把它们看作一组，使用多重签名的方式对他们一次性验证，极大的提高验签效率。</p><ul><li>（2）Casper the Friendly GHOST: Correct-by-Construction (CBC)</li></ul><p>Casper CBC 也叫做 Vlad 版的 Casper，在 CBC 中，不再通过设计一个完整的协议来运作，而是仅指定部分协议（Partial Protocol），然后根据这些协议来推导最终的正确性，这就是 Correct by Construction 的本质含义。</p><p>用大白话来说，我们是动态地推导出该协议的。获得完整协议的其中一种方式是运行一种被 Vald 称为“理想对手（ideal adversary）”的预估安全预言机（estimate safety oracle），它运行下列两者之一：</p><ul><li>提出一个合理估计的错误的例外情况。</li><li>列出所有在未来可能发生的错误。</li></ul><p>关于 Casper CBC 更详细的分析可以参考下面几篇文章：<br><a href="https://medium.com/@barnabe/partially-explained-casper-cbc-specs-86d055fd0628" target="_blank" rel="noopener">(Partially) Explained Casper CBC specs</a><br><a href="https://medium.com/@aditya.asgaonkar/casper-cbc-simplified-2370922f9aa6" target="_blank" rel="noopener">Casper CBC, Simplified!</a><br><a href="https://medium.com/ethereums-transition-from-casper-ffg-to-beacon/from-casper-ffg-to-full-casper-chain-cbd522751a7e" target="_blank" rel="noopener">From Casper FFG to Full Casper Chain</a><br><a href="https://blockgeeks.com/guides/ethereum-casper/" target="_blank" rel="noopener">What is Ethereum Casper Protocol?</a></p><p>Casper CBC 是纯 PoS 的算法，由于篇幅限制，这里就不展开。</p><p>总结：</p><p>PoS 算法的优势：</p><p>（1）无过度的资源消耗<br>（2）出块速度更快，效率更高</p><p>劣势<br>（1）Nothing-At-Stake 无利害关系<br>也叫权益粉碎攻击，在 PoS 中，钱多的人权利也更大，利益也更大，相比作恶，其更倾向于维护系统安全，也就是说 PoS 更能抵御 51% 攻击。而反过来，钱越少责任越小，所以权益越少的节点越倾向于制造分叉，因为制造分叉并不需要 PoW 中那样的算力成本。<br>这也就意味着，你在最长链上挖矿的同时，也去创造一个只在自己的区块上挖矿的分支。尽管他们知道这种尝试会造成整个币的价值降低，但是他们的钱很少，他们并不在乎，这就是所谓的平凡人悲剧（tragedy of the commons）。</p><p>虽然不同的币会有对这种行为惩罚的机制，比如 Casper 中的 slasher 罚没。但由于作恶成本低，依然不能杜绝。</p><p>（2）Long range attack 长程攻击<br>长程攻击就是攻击者创建了一条从创世区块开始的长区块链分支，并试图替换掉当前的合法主链。该分支上可能存有和主链不同的交易和区块，所以这种攻击又被称 替换历史攻击或历史覆写攻击。</p><p>长程攻击之所以存在，由于权益证明协议有<strong>弱主观性</strong>并且能进行<strong>无代价模拟</strong>造链。这里的弱主观性是指新节点或长期离线节点加入网络并同步区块时所遇到的问题，<br>当一个新节点加入到网络中时，总需要人为地为它提供一个创世区块，这个区块是独一无二被大家共识为首区块的区块。设置好创世区块后，节点接着就会收到当前区块链上所有公开的分支。但是问题是，它无法分辨哪些分支是从属于主链的。长期离线（例如数月）的节点也会遭遇相同的问题。虽然之前节点已经同步了相当长的主链，但是在长时间的离线之后，它们也无法分辨究竟哪一个新的分支从属于主链。而保持在线状态的节点则总能及时地监控并同步主链，不存在弱主观性问题。</p><p>无代价模拟的一个重大问题是，最长链并不能成为判断主链的依据，因为节点几乎不消耗算力资源来创建一条从创世区块开始的长分支链的能力。任何加入到权益证明区块链的新节点都会接收到多条分支链，其中很大一部分长度也相同。长程攻击恰恰利用了权益证明协议区块链的这两个特点。</p><p>(3) 理性分叉<br>相比权益粉碎攻击和长程攻击这种主动制造分叉的行为，理性分叉则是被动的。按理来说诚实节点不会在非主链上挖矿，但是如果其是理性的话，那么它就会在所有分叉上进行挖矿，因为在 PoS 中，这种行为不像 PoW 那样需要消耗算力成本。如果整个网络足够理性，会出现的情况反而是每条分支都会永远存在，因为理性的矿工会同时在所有分支上挖矿。这是 POS 最大的缺陷，如果只用最长链共识的话，POS 本身是没法应对分叉的，必须通过惩罚。但是这种惩罚又是只对作恶有效，它是违反节点逐利本性的，所以非常难以实施。<br>而当多数矿工都在两条甚至多条链上一起挖矿的时候，就会很容易出现双重支付攻击。</p><p>简单来说，PoS 难以解决节点在多个分叉上进行验证（“挖矿”）的行为。</p><p>（4）冷启动问题 ( Initial Distribution Problem )<br>PoS 机制中，由于持币量会对挖矿难度产生影响。因此，当一个基于 PoS 体系代币系统启动时，就会面临早期获得代币的持有者，没有动力去花费或者转移代币给第三方。同时，持有越多的币，越容易挖到矿，这样就产生了代币初始流通性问题。</p><p>对于冷启动问题，通常的解决办法是 PoW + PoS，也就是说先通过 PoW 机制来创建货币，然后逐步转移到 PoS。这是因为先采用 PoW 的话，矿工在挖矿过程中往往需要资金来升级硬件，从而让矿工手中的币流通起来。</p><p>（5）富者愈富？<br>一种反复出现的对权益证明的批评是，它只会让富人变得更加富有。因为为了具备验证者的资格，你需要锁定一个你的（比如以太）资产中的可观的比例作为保证金；而且，除了这一点，你将获得的奖励是跟你押注的数额成比例的。钱越多越容易挖到区块，这将会造成富者越富，资源越来越集中，从而导致整个系统变得更加中心化。<br>虽然这是 PoS 现存的可能事实，不过也有很多力致力于解决这个困境，比如以太坊的 Jon Choi 在 《Ethereum Casper 101》 一文中声称不存在富者愈富问题。</p><p>此外，PoS 还面临许多其它类型的攻击，比如：币龄加和攻击 （ Coin Age Accumulation Attack ），预计算攻击 ( Precomputing Attack) 等，这里就不多介绍。</p><h4 id="dPoS"><a href="#dPoS" class="headerlink" title="dPoS"></a>dPoS</h4><p>dPoS，Delegated proof of stake，委托权益共识算法，在 2014 年 4 月由 Bitshares 的首席开发者 Dan Larimer（BM, Byte Master）提出。<br>它的原理是让每一个持有比特股的人进行投票，由此产生 101 位代表 , 我们可以将其理解为 101 个超级节点或者矿池，而这 101 个超级节点彼此的权利是完全相等的。</p><p>从某种角度来看，DPoS 有点像是议会制度，由固定数量的议员或代表们来负责整个系统的决策，这些议员对某个议题（区块）进行投票，占多数投票的议题（区块）就成为最终的决策。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的委员会来取代他们。</p><p>我们来看一下这里的受托人需要履行的职责有哪些：</p><ol><li>提供一台服务器节点，保证节点的正常运行；</li><li>节点服务器收集网络里的交易；</li><li>节点验证交易，把交易打包到区块；</li><li>节点广播区块，其他节点验证后把区块添加到自己的数据库；</li><li>带领并促进区块链项目的发展；</li></ol><p>受托人的节点服务器相当于比特币网络里的矿机，在完成本职工作的同时可以领取区块奖励和交易的手续费。</p><p>我们可以看一下 dPos 的伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> round i <span class="comment">// 分成很多个round，round无限持续</span></span><br><span class="line">   dlist_i = get N delegates sort by votes <span class="comment">// 根据投票结果选出得票率最高的N个受托人</span></span><br><span class="line">   dlist_i = shuffle(dlist_i) <span class="comment">// 随机改变顺序</span></span><br><span class="line">   loop <span class="comment">// round完了，退出循环</span></span><br><span class="line">       slot = global_time_offset / block_interval</span><br><span class="line">       pos = slot % N</span><br><span class="line">       <span class="keyword">if</span> dlist_i[pos] exists in <span class="keyword">this</span> node <span class="comment">// delegate 在这个节点</span></span><br><span class="line">           generateBlock(keypair of dlist_i[pos]) <span class="comment">// 生成 block</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           skip</span><br></pre></td></tr></table></figure><p>可以看到，在每一轮循环里，系统会重新统计得票排名。在选出最高的 N 个受托人里，系统采用先打乱顺序，然后受托人依此生产区块。一轮区块生产完毕后进入下一个周期。</p><p>DPOS 中生产区块主要分为两个步骤：首先选择一群区块生产者，然后安排区块生产。区块生产者选举的过程中，想要成为见证者的节点需要到社区去拉票，获得用户的支持，用户根据自己手中的权益去投票，同时见证者创建区块时投票者也会获得收益，具体收益由他们选出的代表决定。见证者的数量不是固定的，是有权益持有者共同决定的。在投票过程中，大家用自己手中的权益支持信任的候选人，然后根据整体投票情况确定一定数量的见证者，第一步就结束了。</p><p>选举出来的见证者的权利是完全相等的，他们共同生成新区块。以EOS为例来。在 EOS 中，每生产 126 个区块为一个周期：每次选举出 21 个出块的超级节点，每个节点生产6 个区块。每 0.5 秒产生一个区块，一次只分配一个节点进行区块生产。如果有生产者错过出块，就会跳过该块，该生产者也会被删除。每完成一个周期的生产，就会重新投票选举见证者。</p><p><a href="https://bitshares.org/technology/delegated-proof-of-stake-consensus/" target="_blank" rel="noopener">Delegated Proof-of-Stake Consensus</a></p><p>dPoS 是由 BM 设计的，因此很多开源的区块链项目也都来自于其主导，比如 BitShares、Steemit、EOS 等，此外还有 Nano（XRB），Aelf 等项目也都在用 dPoS 来设计实现。</p><p>总结：</p><p>（1）dPoS 的优势</p><p>大量降低能耗：在 DPOS 中生产区块的节点数量极少，大致几十或几百个，每次只授权一个生产者在给定时间生产区块，区块生产是井然有序的，这些节点之间的关系是合作而不是竞争，因此不需要消耗大量的算力去竞争记账权，这样就极大地降低了能源消耗。<br>加快确认速度：比如 EOS 每生成一个区块只需要 0.5 秒，一笔交易大概经过 6-10 次确认，时间不超过一分钟。对比来看，采用 PoW 算法的比特币系统中，每生成一个区块需要 10 分钟，每笔交易的确认则需要一小时，同样，POS 共识机制的交易确认时间也很长。所以 dPoS 的速度优势非常明显。</p><p>（2）劣势<br>中心化，dPoS 的代理委员会制度设计与区块链的去中心化特点是不完全契合的。毕竟，出块的权利只集中在几个节点了，一旦减小参与者规模，区块链的核心问题就从如何提高系统性能转变为如何防止委员会联合作恶或者操控网络。</p><p>当然，是否中心化这个话题涉及到区块链的设计哲学，毕竟大多数或者 geek 一类的人最早都是从接触比特币开始了解整个生态的，点对点通信的设计是这个系统最核心的要素，如果像 dPoS 这样需要借助中介（代理委员会）去实现点对点的电子转账或交易的话，诚然系统运行的效率更高了，但是在我看来已经偏离了这个技术的初衷和发展的方向。</p><h4 id="PBFT"><a href="#PBFT" class="headerlink" title="PBFT"></a>PBFT</h4><p>PBFT 全称是 Practical Byzantine Fault Tolerance，实用拜占庭容错。</p><p>该算法最早是 Miguel Castro (卡斯特罗) 和 Barbara Liskov（利斯科夫）在 1999 年发表的论文《Practical Byzantine Fault Tolerance 》中提出来的，解决了原始拜占庭容错算法效率不高的问题，算法的时间复杂度是O(n^2)，使得在实际系统应用中可以解决 BFT 问题。</p><p>这个算法在保证活性和安全性的前提下提供了(n-1)/3 的容错性，也就是说如果存在 f 个出错节点，节点数需要至少 3f+1 个。</p><p>下面介绍一下 PBFT 算法的原理</p><p>pbft 算法主要是三个核心阶段：pre-prepare, prepare 和 commit，如下图所示：</p><p><img src="https://pic4.zhimg.com/80/v2-ab3bab245c17269625d7ebc56c3848c3_hd.jpg" alt=""></p><p>PBFT 是一种状态机副本复制算法，所有的副本在一个视图（view）轮换的过程中操作，主节点通过视图编号以及节点数集合来确定，即：主节点 p = v mod |R|。v：视图编号，|R|节点个数，p：主节点编号。</p><p>首先，客户端向主节点发起请求，主节点 0 收到客户端请求，会向其它节点发送 pre-prepare 消息，其它节点就收到了pre-prepare 消息，就开始了这个核心三阶段共识过程了。</p><ul><li>Pre-prepare 阶段：节点收到 pre-prepare 消息后，会有两种选择，一种是接受，一种是不接受。什么时候才不接受主节点发来的 pre-prepare 消息呢？一种典型的情况就是如果一个节点接受到了一条 pre-pre 消息，消息里的 v 和 n 在之前收到里的消息是曾经出现过的，但是 d 和 m 却和之前的消息不一致，或者请求编号不在高低水位之间（高低水位的概念在下文会进行解释），这时候就会拒绝请求。拒绝的逻辑就是主节点不会发送两条具有相同的 v 和 n ，但 d 和 m 却不同的消息。</li><li>Prepare 阶段：节点同意请求后会向其它节点发送 prepare 消息。这里要注意一点，同一时刻不是只有一个节点在进行这个过程，可能有 n 个节点也在进行这个过程。因此节点是有可能收到其它节点发送的 prepare 消息的。在一定时间范围内，如果收到超过 2f 个不同节点的 prepare 消息，就代表 prepare 阶段已经完成。</li><li>Commit 阶段：于是进入 commit 阶段。向其它节点广播 commit 消息，同理，这个过程可能是有 n 个节点也在进行的。因此可能会收到其它节点发过来的 commit 消息，当收到 2f+1 个 commit 消息后（包括自己），代表大多数节点已经进入 commit 阶段，这一阶段已经达成共识，于是节点就会执行请求，写入数据。</li></ul><p><img src="https://images2018.cnblogs.com/blog/2625/201804/2625-20180415221647215-565887866.png" alt=""></p><p>从上图我们可以看出，PBFT 算法下，网络通信的复杂度达到了 O(n²)。这也就意味着，使用 PBFT 算法的网络节点不能太多，否则很容易导致消息数量爆炸，从而造成网络风暴，使得整个网络堵塞。</p><p>这一特性也使得采用 PBFT 算法的链通常用在联盟环境或者私有环境，比如 Hyperledger。<br>当然它也可以在更大的公网中作为辅助协议运行，比如 dPoS 中的代理委员会决策，或者 Cosmos/Tendermint 网络中的 bonded Validators。</p><p>PBFT 在 Fabric0.6 的时候被采用，但是由于一些说不清的原因，在 Fabric1.0 中并没有采用PBFT，而是使用 Kafka 对交易进行排序，作为共识节点。在 Fabric 的提案中，打算会采用 SBFT（Simple BFT），这种 BFT 算法会对 PBFT 进行简化，具体什么时候实现现在还不确定。</p><p>当然，采用 PBFT 算法的项目很多，包括早起版本的 Hyperledger Fabric，还有 Stellar、Ripple、Dispatch 等。</p><p>总结：</p><p>Practical BFT 算法本质上是 BFT 算法的一种实现，BFT 简单来说是一类系统的统称，这类系统可以容忍任何错误，而 PBFT 则通过设置一些条件限制，比如限制出错节点数，来达到 BFT 的效果，其他的类似协议还有 Delegated BFT (NEO 采用), Federated BFT（Stellar 采用）。<br>另外，前面介绍的 PoW, PoS 等算法其核心目的都是需要实现 BFT 容错，至于 PoW 是否是真正的 BFT 有部分争论，因为在比特币的 PoW 设计中，区块的最终状态是不确认的，依赖应用层对最长链的信任程度。</p><p>主流区块链分别用的是什么共识算法<br><img src="https://pic3.zhimg.com/80/v2-80ef4d4e2ac38e32015f9a0d8ed70906_hd.jpg" alt=""></p><p>自区块链技术运用以来，诞生了几十上百种共识算法，除了一些创新之外，多数是改进和优化。更多的共识算法还有比如 dBFT，PoA，PoSe，PoET，PoSV 等等，有兴趣的读者可以自行了解。</p><p>参考：<br><a href="https://medium.com/coinmonks/pbft-understanding-the-algorithm-b7a7869650ae" target="_blank" rel="noopener">https://medium.com/coinmonks/pbft-understanding-the-algorithm-b7a7869650ae</a></p><h4 id="DAG"><a href="#DAG" class="headerlink" title="DAG"></a>DAG</h4><p>DAG，Directed Acyclic Graph，有向无环图，这是一种数据结构。<br>最早是在 2013 年的 “Ghost 协议”中提出 旨在解决当时比特币的扩容问题。后来，在 NXT 社区，又有人提出了 DAG of block，将 DAG 的拓扑结构用来存储区块，解决效率问题。那时对于 DAG 的应用，还停留在类似于侧链的一个认识。</p><p>与传统的 block-based 的单链表数据结构不同，每个后继节点可以引用两个或多个前序节点。<br>另外一个区别在与 DAG 是以交易为单位进行确认，而传统的区块链（比特币、以太坊等等主流虚拟币）都是以区块为单位进行确认。</p><p><img src="/image/blockchain/DAGstructure.jpg" alt=""></p><p><img src="/image/blockchain/Blockstructure.jpg" alt=""></p><p>可以看到，传统区块链是由区块组成的一条单链，而 DAG 则是由交易组成的网络。它最大的特点就是交易是异步处理和确认的，不需要想传统区块链那样需要每隔一段时间汇集一定数量的交易到一个区块中进行同步确认。这样的好处就是无需挖矿，极大的提高确认速度，尤其对小额支付非常便捷快速，并且扩展性好。</p><p>在其网络中，节点发出交易时，把将自己发起的交易指向网络中任意两笔已存在的交易，这里的指向其实就是背书，验证之意。每个节点即是交易者也是验证者，它的角色相当于传统区块链中的矿工。由于交易之间无需同步，只要交易不发生冲突，理论上速度和数量都没有限制，参与的节点越多，交易速度越多，能承载的交易量也越多。</p><p>DAG 与链式结构的本质区别在于异步与同步通讯。链式结构的本质等同于数据库事务日志，而出块操作则为检查点操作，那么链式结构体系可以看做是定期同步检查点的数据库事务同步机制。</p><p>总结分析</p><p>DAG 的优点<br>快速确认（约 30 秒）<br>扩展性好（不像 bitcoin, ethereum 有区块大小限制）<br>没有孤块问题<br>没有交易推送延迟（没有 mempool，peer 收到就会立即 confirm）</p><p>DAG 存在的问题</p><p>1）交易时长不可控<br>DAG 通过将事务操作进行异步处理来增加网络吞吐量，通过后续交易对前继交易的引用来确认，验证时采用随机方式，而没有任何先后规则，这就导致有可能产生某些交易在极端情况下没有任何其他节点对其验证，从而永远不会被确认。这个问题在 IOTA 的实现中通过多次重试的方式来解决。但是是否存在更好的一次性确认机制能更有效地解决该问题值得探讨；</p><p>2）交易顺序不可控<br>由于交易是异步进行的，网络中没有统一的时间戳和全局排序机制，无法有效预测交易被确认的时间与周期，并且操作之间的全局顺序无法最终在多个节点间确认保持一致。<br>在这种情况下，在非等阶操作时可能存在不一致的问题（例如对同一条记录，在两个不同的节点同时执行转账（加减法）和计息（乘法）操作，两个节点得到的操作顺序有区别，导致账户余额最终结果不一致）。这也导致系统支持的操作类型非常有限，目前只支持加减。</p><p>3）检索与工程实现难度<br>为了追踪每一笔交易与之前交易的关系，整个 DAG 图谱需要被随时检索和访问。在一个较大规模的系统中其交易图谱溯源会非常复杂，同时几乎不可能被全部保存在内存中以进行实时更新。而如果将这些数据保存在磁盘上，那么实时刷新每个 Tangle 的权重会造成大量随机 I/O（也许可以通过大量部署 SSD 解决），因此从工程实现上来看优化难度较大；</p><p>4) 安全性风险</p><p>DAG 要比 PoW 脆弱得多。在 PoW 共识机制中，算力达到 51%，才能够发起攻击；而攻击 DAG，以 Tangle 为例，发起一笔交易验证两笔交易，理论上来说，只要达到 34% 的算力，就能够攻击整个 DAG 网络了。</p><p>一方面，每个人都参与处理交易，如果一个拥有高算力的节点通过发起巨量的交易，从而获得更多验证权，就很容易降低 DAG 网络的效率，甚至发起攻击；另一方面，无交易费使得发起和验证的成本为零，同时海量的节点更增加了这种攻击风险。</p><p>此外，具体的安全问题主要还包括下面两种：</p><p>一、双花问题<br>DAG 异步通讯的特性为双花攻击创造了可能。例如，攻击者在网络的两个不同的位置添加了两笔冲突的交易（双花），交易在网络中不断向前验证，直到它们出现在同一笔交易的验证路径上，网络才会发现冲突，这时这两笔交易汇聚成的共同祖先节点才能判断哪一笔交易是双花攻击。</p><p>而如果将交易路径控制的过短又会存在类似“Blowball”的问题：当极端情况下绝大多数交易都较为“懒惰”（Lazy Tip）、只参考早期交易时，交易网络会形成一个以少数早期交易为核心的中心拓扑。这对依赖于交易的不断增加而提高网络可靠性的 DAG 来说，也不是一件好事。</p><p>目前，有越来越多的DAG项目正在发展，有乐观者认为DAG才是真正的区块链3.0，也有人认为区块链才是更加完善的去中心化账本。不可否认的是，DAG的确是区块链在去中心化和拓展问题上的强劲对手。</p><p>二、影子链问题<br>由于存在双花的潜在问题，当攻击者可以构建出足够数量的交易后，就可能从真实的网络数据中分叉出一个欺诈性分支（影子链），其中包含着双花交易，然后将这个分支合并到DAG 网络中，特定情况下这个分支有可能取代原有交易数据。</p><p>DAG 的改进方案<br>目前项目主要都是通过牺牲一部分 DAG 的原生特性来保证安全性。</p><p>IOTA 项目中采用了马尔科夫链蒙特卡洛（Markov chain Monte Carlo，以下简称 MCMC）的方式来解决该问题。IOTA为交易引入了累积权重（Cumulative Weight）的概念用来记录该笔交易被引用的次数，目的是表示其交易的重要性。MCMC算法通过对累积权重进行加权随机游走，选择目前网络中已存在的交易作为新增交易的参考。即被参考越多的交易路径越容易被算法选中。游走策略在1.5.0版本中也进行了优化，可将交易拓扑的“宽度”控制在一个合理范围内，使得网络更加安全。</p><p>但在平台启动初期，由于参与节点和交易数量均有限，所以很难避免一个恶意机构通过大量节点发送出海量的恶意交易使得整个网络受到影子链的攻击。因此就需要一个权威的仲裁机构来判定交易的有效性。在 IOTA 中，这一节点为 Coordinator，它会定期对目前交易数据网络（Tangle）进行快照；包含在快照中的交易即被确认为有效交易。但 Coordinator 并不会一直存在。随着整个网络的运行和成长，IOTA会在未来某一时间取消掉 Coordinator。</p><p>Byteball 改进方案的特色在于其对于见证人（witness）和主链的设计。因为 DAG 的结构带来了很多偏序关系的交易，而要避免双花则需要对这些交易建立一个全序关系，形成一个交易主链。主链上较早的一笔交易作为有效交易。而由知名用户或机构担任的见证人通过不断的发送交易确认其他用户交易，从而形成主链。</p><p>以上方案也可能会对基于 DAG 结构的平台带来不一样的改变。以 IOTA 为例，因为引入了 Coordinator，一定程度上降低了去中心化特性。</p><p>采用 DAG 的知名项目主要有：IOTA, Byteball 和 NANO，他们被称为“DAG 三驾马车”，其他采用 DAG 并作出重大改进的项目还有 Hashgraph。</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Encrypted Article</title>
      <link href="/life/life/"/>
      <url>/life/life/</url>
      
        <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Enter password" />    <label for="pass">Enter password</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19iotUCnWutHeU2jJ6FxzqqltiUg9h0g1aXr3S/0xWpHM85DD6rQ0WUkFPN2XXjmBlQ92Ps4EE4ybaXKVwgdbV3cJK6KY+tDA1+EsNnvOlupvQz8mSjjm07BWNWsPtR9mebrAznLYLamg==</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>南昌风俗礼仪</title>
      <link href="/%E5%8D%97%E6%98%8C/nanchang-custom-and-rites/"/>
      <url>/%E5%8D%97%E6%98%8C/nanchang-custom-and-rites/</url>
      
        <content type="html"><![CDATA[<p style="text-align:center; font-size:40px">习俗</p><p>1、南昌风俗尤其自身鲜明的特色，无论是节庆时日，还是婚丧嫁娶，都体现了农业社会的特征以及农耕文化的内涵。主要包括“年节习俗”、“生活习俗”、“信仰习俗”、“游艺习俗”等四个内容。</p><br><p style="text-align:center; font-size:26px">(一) 年节习俗</p><p>2、年节习俗是随着季节、时序的变化，在人们生活中所形成的约定俗成的现象。在南昌，传统过年的习俗既有南方的一般特征，又有其鲜明的地区特色。南昌民谚“过了二十四，天天都十年”，说的是南昌人从腊月二十四就开始过年了，一直到正月十五过完元宵结束。</p><p>3、传说这是从秦始皇修筑万里长城时期开始的。当年秦始皇在全国征集了大量的民夫去修万里长城，传说临近腊月有人向秦始皇提出要让大家回家过年，得到同意后大家便纷纷启程回家。</p><p>4、由于路途的远近不同，民夫启程的时间不同。南昌籍民夫在腊月二十四日以后陆续到家，望穿秋水的家人再也等不急大年三十，就以亲人抵家团圆的那一天为“年”。南昌人称之为“团年”。至今如南昌县的黄姓（腊月二十五），熊姓（腊月二十六），胡姓（腊月二十七），万姓（腊月二十八），高姓（腊月二十九）等村落或家族仍保留这种过年的方式。</p><p>5、过年是家家户户都有一种习俗是不可少的，那就是祭灶。祭灶的风俗，实际上起源于古人对火的崇拜。周代的天子“天祀”中，就有祀灶一项。当时允许平民百姓也立一祀，“或立户（门神），或立灶（灶神）”。可见远在先秦时代，灶神就是人们崇拜的重要对象。</p><p>6、农历腊月二十三之前，家家户户都要准备好祭灶的用品。祭灶很有讲究：腊月二十三是当官的人家祭灶，二十四是平民百姓家里祭灶，二十五这天是渔民家里祭灶。古时候南昌人祭灶只有男子参加，忌女子祭灶，反映出封建社会重男轻女的一面。</p><p>7、对于拜年，南昌人也是很有讲究的。南昌流传着“初一的崽，初二的郎，初三初四女看娘”的说法。初一儿子给父母拜年，幼辈依次向尊长叩头拜年，尊长又率幼辈向左右邻居贺年。初二女婿给丈母娘拜年，初三女儿回了娘家要给邻居们分糖饼，体现邻里融洽关系。</p><p>8、过去，南昌人拜年携带的礼物也很有特点，一般亲朋走往，以厚草纸包裹“海参饼”、“牛舌头”，“绿豆糕”等糕点，辗转护送，谓之“换茶”（谐音“茶”为“财”），意喻：把对方的财运换回家。</p><p>9、南昌人把正月初五定为“财神爷”的生日，商户从年初一那天闭门休息，初四晚三更以后，便提前给“财神爷”供上一对活鲤鱼和羊头，它是“利”和“银洋”的谐音，去发财致富之含义。初五凌晨燃放爆竹，摆设香案，点着大香烛，供着三牲酒肴，老板或其代理人磕头膜拜，烧财神利市，盼望在新的一年里招财进宝。</p><p>10、在过年期间，正月初七是很重要的，南昌民谚“上七大似年”。南昌百姓认为：初一为天日，初二为地日，初三为水日，初四为火日，初五为木日，初六为金日，初七为人日。传说女娲造人就是在初七，因此每逢这天，家家户户都要热烈庆祝，往往比大年三十还热闹。</p><p>11、南昌人重视过初七，还有一层意思，就是普通百姓过完初七就算过完年了，要赶紧忙农耕。初七这一天家家户户要吃糊羹（糊羹是用七种带叶子的蔬菜和米糊做成的），民谣说：“吃了初七羹，妻子上田埂”。人们还认为吃了糊羹，象征步步高。</p><p>12、正月十五是一年之中第一个月圆日，古称“上元”，夜谓之“宵”，“元宵”便由此得名。元宵节还有张灯观赏的习俗，因此也称“灯节”。南昌人“闹”元宵这一天，从洗马池、中正街、府学前、瓦子角、铁柱万寿宫到西大街一带，到处锣鼓喧天，观花灯、蚌壳灯，舞板凳龙、舞狮子，敲得胜鼓、跑旱船、猜灯谜等等。入夜之后家家户户灯火通明，门前都要挂起彩灯，各种灯笼大显身手。</p><p>13、春节过后，公历四月五日前后，便是清明节。它是我国农历的二十四节气之一。这时候，我国的大部分地区气温转暖，万物萌发，让人感到格外清新明洁，因此叫做清明。这一天又上坟祭祖之俗。人们怀着沉重的心情纷纷前往墓地，剪除荆草，供上祭品，缅怀逝去的亲友，表达对亲人的追思和怀念。</p><p>14、五月初五为端午节。“端”和“初”同义，“五”与“午”谐音，所谓“端午”，也就是“初五”。端午节，源于纪念两千多年前战国时期楚国的爱国诗人屈原。屈原杯楚怀王流放以后，秦国攻陷楚国郢（yǐng）都，屈原忧愤交加，于公元前 278 年农历五月五日投了汨罗江，以身报国。后人敬仰和怀念他，便把他投江这一天，定位端午节，年年纪念，代代相传，绵绵不息。</p><p>15、端午这天人们盛行吃粽子（一种把糯米等包在菰叶里煮熟的食物）。粽早在春秋之前就已出现，起源于端午节祭祀龙或伍子胥的祭品，楚人为了让投江过世的屈原遗体不被鱼类所食，就以粽子投江喂鱼，另说则是直接以粽子祭祀屈原的亡魂。到了晋代，粽子成为端午节的节庆食物。粽子作为中国历史文化积淀最深厚的传统食品之一，传播亦甚远。日本、越南以及华人聚居的新加坡、马来西亚、缅甸等地也有吃粽子的习俗。</p><p>16、端午划龙舟在南昌早称习俗。从农历四月底便开始筹备，俗称：“初一划，初二歇，初三初四划到节”。过去南昌的龙舟竞赛多在南郊施家窑附近的赣江举行，这里河面辽阔，浩瀚无垠，居高临下，可俯览全景；岸上旷地高宽，可容万余人。除此，南昌端午期间还有插艾枝、拜河神等习俗，以求平安。</p><p>17、相传农历七月初七，是牛郎织女天河相会的日子。每到这一天，天下的喜鹊搭成一座鹊桥，他们才能相见。这个美丽的传说始于汉朝，“乞巧节”也由此而来。这一传说代代相传，各地区都有不同的传说故事。</p><p>18、神话传说中的织女，是天上神仙世界中的巧妇。传说她芊芊玉手，飞舞金梭，能织出彩霞般的锦绣。妇女都希望像妇女那么手巧，所以在七夕傍晚，她们扫净庭院，沐浴更衣后，家家门口都摆上香案，奉上七杯净水，供上香花瓜果，纷纷展示自己所做的绣花鞋、鸳鸯枕、石榴裙、虎头帽、香荷包等女工，包括手剪的各种窗花、鞋花，及工笔画等，满街恰似一个女工技艺博览会。</p><p>19、南昌古时有“丢针卜巧”的风俗。农历七月初七日中午，女孩子用小瓷盘装一点水放在太阳下，把针浮在水面上。如果水底出现刀剪形的影子，表明善女红；如果出现钻杵形的影子，表明笨手笨脚。实际上这是一种乞巧游戏。</p><p>20、南昌还有的地方把农历七月七日称作“女儿节”，每逢着一天，人们就要把出嫁的女儿接回家来。在南昌新建县一带，古时候七夕这天要把全村庄的雄鸡宰掉，因为没有雄鸡报晓，牛郎织女就可朝夕相守，不再离别；在南昌安义县一带，百姓白天不猎禽鸟，半夜三更起床，两眼注视天空，观赏星象，讲述有关牛郎织女的故事。</p><p>21、农历八月十五，是我国传统的中秋节。这天恰值三秋之半，故名“中秋”（三秋：七月为孟秋，八月为仲秋，九月为季秋）。关于中秋节的来历，民间流传着许多美丽动人的传说故事，其中最有影响的大概要数”嫦娥奔月“了。</p><p>22、每逢中秋之夜，人们都要设瓜果、月饼、柚子等于庭院，观赏明月和桂花、秋海棠等。也有游人于中秋之夕泛舟于抚河之上，或聚集在南昌西湖高士桥上赏月。在拜月时，男子是不能参加的，因为月宫里的嫦娥是位女子，男子是不能给女子下跪的，反映了封建社会”男尊女卑“的思想。</p><p>23、中秋节亲人团圆，也称“团圆节”。中秋这天，南昌一带百姓都用月饼招待归家的亲人，月饼也称为“团圆饼”，到了晚上，全家人一边赏月，一边品尝月饼。如亲人在异地，合家望着月亮表达对异地亲人的思念之情。宋代大词人苏轼为怀念弟弟曾于中秋写下了“但愿人长久，千里共婵娟”的名句。</p><p>24、农历九月初九为重阳节。在古代，人们将“九”定为阳数，两九相重为“重九”，两阳相重，故名“重阳”。在重阳前后，人们在绳经塔、滕王阁等城郊沙丘登高寄兴，携眷邀友挎着盛有茱萸（茱萸别名叫“辟邪翁”）的布袋，手拿三角形彩色纸旗，帽沿插着菊花，饮着菊花酒，吃着重阳糕，欣赏着秋色，寄托远离秽浊、身康体健的美好心愿。</p><br><p style="text-align:center; font-size:26px">(二) 生活习俗</p><p>25、在南昌生活习俗中最有特色的是招待客人的方式。南昌人喜欢用三个蛋一碗面招待客人，如果是受宠的外甥来了，舅舅还会在里面加一只鸡腿；如果客人进门主任给他吃了两个蛋，那就表示这家主人不欢迎他到家里做客，客人若遇到这种情况就会吃一个留一个，表示以后不再登这家人的门。</p><p>26、南昌有一道最具特色的菜“藜蒿炒腊肉”。藜蒿是生长在鄱阳湖边上的一种野草，其茎可以吃。据说这道菜最初是明代朱元璋与陈友谅大战鄱阳湖时，由朱元璋所发现的。藜蒿的季节性很强，南昌民谚：“三月藜，四月蒿，五月当柴烧”。意思就是三月是吃藜蒿的最好季节，四月成蒿杆，到了五月份藜蒿九只能当柴烧了。</p><p>27、江西人走到外地总被称为“江西老表”。传说朱元璋当年逃难到江西，深受重伤，昏迷在路旁，是一位过路人为救他，将自己身上的肉割下来熬汤给他喝。朱元璋康复后对救他的人说：有朝一日我真当上皇帝，你可以到京城来找我。老农说：你真当了皇帝又怎会想起我。朱元璋说：你就说你是我江西的一位表兄就可以了。</p><p>另：关于江西老表的由来，并没有统一公认的说发，还有几种说法如下：</p><ul><li>南怀瑾在《论语别裁》中写道：“江西人称‘老表’，是最亲切、最好的称呼。其由来是古时候战乱，江西人很多移民到湖南，许多年后，年轻的后代，还回到江西扫墓，而留在江西的后代子孙，以为是祖宗坟墓被他人误祭或盗葬，次年预先守候，两方相见，论起家族上代渊源，认出是表亲关系来，而称‘老表’。这个‘老表’就说明了宗法社会对血统、家族的重视。”</li><li>明朝建立时，湖南的长沙附近由于洪武屠湘而一片荒芜，大批江西人迁入湖南。后来在明清之际又有大批江西人迁入，甚至有些地方十户之八九来自江西。后世湖南人认为江西是他们的父母之地，江西人是他们的亲戚，于是把江西人叫做老表。此即江西填湖广的相关传说。</li></ul><p>28、朱元璋称帝后，有一年，江西大旱，农民交不起赋税，大家就提议者为老农去求皇帝减少赋税。老农去了京城，被看守城门的衙役拦住，老农对衙役说“请你禀告皇帝就说他江西的老表来了”，果然，朱元璋接见了老农并减免了江西当年的赋税。这件事传开后，外地人都爱称呼江西人为“老表”。“老表”一词反映了江西人正直、善良、诚实的性格。</p><p>29、旧时南昌常见使用的土车有几种：<br>鸡公车，又名羊角车，俗称“土车子”。</p><ul><li>车身高、轮大，左右有平板，可载货，配上车椅亦可以乘人，为羊角车；</li><li>车身矮，轮小，为鸡公车，宜载笨重或体积大的物品，如载柴草稻麦等物，堆积物挡住视线，只能倒拖着才能行走。<br>故南昌民谚：“顺推羊角，倒推鸡公”。</li></ul><p><img src="/image/nanchang/solewheel1a.jpg" alt=""></p><p>就还有一种是叫“板车”，有长长的载重板底，推杆变成拉杆，有四个木质轮子，无辐条。可以负载很大重量，适合拉运大型货物比如粮食，稻谷等。可以人拉也可以牛拉。它的样子长下面这样：</p><p><img src="/image/nanchang/banche.jpg" alt=""></p><br><p style="text-align:center; font-size:26px">(三) 信仰习俗</p><p>30、信仰习俗是一种特定的社会心理现象，是人对某种事物的特殊情感和心理体验。南昌人最信奉的是<strong>许真君</strong>，并以许真君为自己的保护神。包含南昌人在内的江西人，不管将生意做到何处，不管迁徙到何方，总不忘修建供奉许真君的万寿宫，并以它为江西商会、江西同乡会所在地。</p><p>31、南昌铁柱万寿宫，始建于西晋怀帝-永嘉六年（公元 312 年），初名旌阳祠，它坐落于漳江码头的广润门内，以许真君铁柱锁蛟，治理水患而闻名于世；西山万寿宫，始建于东晋宁康三年（公元 375 年），是南昌人信仰、祀奉这个“江西神”治水功迹之地。其前身为“许仙祠”，传说是许逊在江西根治水患后，修炼成仙“拔宅飞升”之地，“一人成道，鸡犬升天”典故出自于此。</p><p>32、每年的农历八月初一许真君生日，万寿宫举办庙会，村民们预先斋戒沐浴。“善男信女”们组织朝仙队伍，人们摆香案迎接真君。进香及游览者日达数万，盛况空前。如今，朝仙之俗犹存，西山万寿宫已成为著名的观光游览胜地。在绳经塔每年都举办类似庙会的“金秋经贸文化艺术节”等活动，深受广大市民的欢迎。</p><p>33、南昌人尚佛。始建于南朝梁天监年间（公元 502 - 519 年）的佑民寺，曾经是禅宗著名高僧马祖道一弘法师道场。寺内有一座巨大铜佛，为南昌一大宝。谚云：“南昌穷是穷，还有三万六千铜”。南昌人对该寺极为看重，夸大其辞云：“先有佑民寺，后有豫章城”。</p><br><p style="text-align:center; font-size:26px">(四) 游艺习俗</p><p>34、游艺习俗是民间各种娱乐活动的总称，它包括民间歌舞、民间戏曲与曲艺、民间竞技与游戏等文化娱乐活动。南昌最具特色的民间戏曲，是南昌采茶戏，如“四大记”：《南瓜记》、《鸣冤记》、《辜家记》、《花轿记》。南昌老小都爱看，也能哼。”哭不死的梁山伯“，”杀不死的蔡鸣凤“是对南昌采茶戏常演剧目的谑语。</p><p>35、“南昌道情”是南昌茶楼、酒馆常有的民间说唱曲艺。起源于清乾隆年间，清末传入南昌城。最初由演唱者一手敲简板，一手打渔鼓，边打边敲边唱。后来经过民间艺人加工和改进，构成了“三响”，即加入一面钹（bó），在拍打道情筒的同时，用棍棒打竹筒和钹，发出三种不同声响，丰富了伴奏效果。南昌人称“南昌道情”也俗称“一打三响”。</p><p>36、南昌清音在清朝中叶就已盛行，曲调丰富，具有浓厚的地方色彩。演唱者以女性为主，乐队伴奏多为盲人。其音乐以小曲为主，南词为辅。过去一般多为自由组合，在茶楼进行演唱，后逐步吸收了一些地方曲种之长，增加了简单的表演动作，创作出许多反映现实生活的曲目。</p><p>37、南昌民间灯彩品种繁多，舞龙灯与舞狮子比较盛行。一般对颜色很有讲究，南昌百姓素有“乌称霸，黄访友，红参师，绿学艺”之说。意指乌黑为霸，有墓冢无敌手之意，不服者可立即与之较量，亦可群起而攻之。</p><p>38、唢呐是我国民间吹打乐中的主奏乐器，在南昌是非普及。安义县湖乡素有“唢呐之乡”美称。新建县也有百支唢呐队伍活跃在民间。南昌人学吹唢呐特别有灵性，谓之“斗米胡琴担米笛，升生唢呐呜哩哇”。</p><p>39、“堵棍”是民间非常流行的一项体育娱乐活动。设备简单，随时随地均可进行。只要一根扁担或木棍，两人各持一端，以手掌或肩或腹部同时向对方顶，进则为胜，退则为败。另外，如举石锁、踢毽子等游艺活动也非常普及。</p><p>40、民间游艺式样繁多，棋类活动更是盛行，大多为民间自创。如南昌盛产西瓜，民间便自创西瓜棋，其形式是就地画简单棋盘，执石子数枚，双方对垒，施展攻防之术，颇得博弈趣味。此外还有田棋，鸡婆棋等民间棋类。</p><br><p style="text-align:center; font-size:40px">礼仪</p><p>41、礼是人类社会发展的产物，仪是反映礼的形式。传统礼仪的缘自人类在长期的社会活动中，对大自然的感悟，其内容非常广泛，经历了漫长的传承与变异。其中人生礼仪占突出地位，它是传统社会维持人际关系的重要纽带，它实际上涵盖了人一生该怎么度过的问题，主要包括诞生礼仪，成年礼仪，结婚礼仪，祝寿礼仪以及丧葬礼仪等五个方面的内容。</p><br><p style="text-align:center; font-size:26px">（一）诞生礼仪</p><p>42、“诞生礼仪”是人生的开端之礼，婴儿的诞生，预示着生命有了延续。伴随着他（她）的成长，形成各种礼仪。种种礼仪都是向婴儿祝吉，希望他（她）健康成长，成为栋梁。主要包括：求子仪式、孕期习俗、庆贺生子三个阶段的内容，其中又以庆贺生子为中心。南昌民间有种种企盼求子的习俗，其仪式多带有神秘色彩。</p><p>43、在南昌西湖区孺子路附近处有一高士桥（因南州高士徐稚得名），上有石柱栏杆十二根，每年八月十五之夜，已婚妇女在未怀孕之前，相约或独行至高石桥上，待月至中天，便用手在高桥两旁的石柱上抚摸，甚至纳入怀中。据传如此这般便可生男孩。</p><p>44、清代刘一峰曾作《高桥行》诗一首，可展现当时人们拜月求子的盛况。诗曰：“高桥月明当夜半，千呼后呼女郎伴；传言拜月过中秋，便好生儿嫁石头”。现高石桥早已拆除，仅留下一条以“高桥”为名称的街道，这古老的求子习俗也被现代文明所湮没。</p><p>45、成语“种瓜得瓜”、“瓜熟蒂落”、“瓜瓞（dié）绵绵”等都与生育有关。民间以瓜象征子，在南昌农村，流传着“偷瓜送子”、“摸秋”求子的风俗。妇女极望生子者，乃潜入别人菜园内窃瓜，园主就是目睹，亦佯作不知，得瓜不仅象征已能生育，若回家剖食之，瓜子是双数，则是“弄璋”（生男），单数则是“弄瓦”（生女）。</p><p>46、在女儿怀孕将要临产的前一个月里，外公、外婆要给即将出生的婴儿送去冬夏衣服、鞋帽、坐桶、摇床等礼物，民间称之为“催生”，目的是传授育儿经验，表达美好祝福。所送的帽子上镶有银“寿星”，并绣有“福禄寿喜”四个字；鞋子上要有绣花，鞋头绣有“虎头”。求子习俗随着社会的进步已渐渐淡化，男女平等，少生优育的观念深入人心，新的婚育文化已取而代之。</p><p>47、婴儿呱呱坠地之后，有一系列庆祝仪式。第一项礼仪便是报喜。做父亲的要办“诞生宴”，并提着一篮煮熟的、染成朱红色的鸡蛋，放着鞭炮，向岳父母和自己的宗亲报喜。岳父母家接到报喜后，要招待女婿及客人，他们走时要回送母鸡、鸡蛋、红糖、挂面、婴儿衣帽等礼品。</p><p>48、婴儿生下的第三天，要给孩子“洗三”，它不同于一般的洗澡，礼仪非常繁复。主人请接生婆以樟枝、艾叶、黄连、葱蒜等中草药煎水，给婴儿沐浴。家人和亲友往盆里放鸡蛋或金银饰物，名曰“添盆”。洗罢将婴儿脐带盘于肚上，涂抹烧过的明矾，用棉花包扎好。有的家人还用两条红带系在婴儿双腕上，以期望其健康成长。</p><p>49、婴儿出生到一个月即“满月”，要行满月礼。行满月礼仪式时，外婆家要给小孩送去几乎全部所需生活用品。南昌俗称：“娘亲舅大”，体现着母系氏族社会的痕迹。同时，亲朋聚集，馈送礼品，如长命锁，上写“状元及第”、“长命富贵”、“五子登科”等，祝贺婴儿“满月”。</p><p>50、小孩出生一百天后要请客祝福，百日又称“百岁”、“百禄”，即百日的福禄、多福。婴儿称为“百岁儿”，含有祝贺婴儿长命之意。百日这天，主家宴请亲邻，贺客为产妇和婴儿祝福，并给婴儿赠送礼物。在婴儿的成长过程中，人们视百日为一个极点和新的起点。这天还请人为婴儿剃头，脑后留一撮毛发称为“百岁毛”。</p><p>51、孩子出生满了一年整，是婴儿第一个生日，称“过周岁”。除了大宴亲友外，还要“抓周” —— 在婴儿前面放置各种物件，任其抓取，用以预测孩子将来的志向。如抓了钱，则认为这个孩子将来会赚钱；如抓了算盘则说这个孩子将来会算账；如抓了文具、纸张，则说这个孩子将来会读书。</p><p>52、满周岁之后，每年要过生日，这天小孩吃一碗面、三个蛋，意味着小孩将来能连中“三元”（乡试第一称解元，会试第一称会元，殿试第一称状元）、长命百岁。初入学的孩子在启蒙时要“拜孔子”、“喝墨水”（预示将来文章满腹）、“爬楼梯”（以期步步高升）。“开笔”（少儿开始识字习礼）俗称“破蒙”，启蒙老师向孩子讲述尊师重教、孝顺父母的道理，以适应孩子心理成长的需要。</p><br><p style="text-align:center; font-size:26px">（二）成年礼仪</p><p>53、成年礼仪又称“成丁礼”，男性称“冠礼”，女性称“笄（jī）礼”，这是一个人步入成年的仪式，其中有不少教育内容。成年礼仪被视为品德修养达到基本完备的标志。此礼过后，刚成年者的言行要遵守成年人的义务和权利，只有具备孝、悌、忠、顺的德行，才能成为合格的社会角色，为社会作出贡献。</p><p>54、男子到了二十岁（称“弱冠”），要行“冠礼”。冠的本义是指“帽子”（音为 guān），后则兼指“加冠”（音为 guàn）。行冠礼仪式主要包括：筮日（选择一个吉祥日作为行冠礼的时间）、筮宾（挑选在行冠礼时替受冠者加冠的来宾）、挽髻（将发辫梳至头顶编成发髻）、加冠（由卜选出来的冠宾替受冠者加冠）、共饮旧式6、拜见母亲、命名、见兄弟及亲属邻里成员、酬宾送客等九个环节。</p><p>55、女子到了十五岁时，要行“笄礼”。笄，是古代妇女盘头发用的发簪（zān）。及笄，即女子把头发簪起，表示已成年。在传统社会中，头发曾受到特别的关注和崇拜，因此须发完整是男子、女子孝心的一种表征。</p><p>56、随着社会的发展和变革，传统的成年礼渐渐衰弱了，但“礼”作为修身的规范，讲信修睦、律己修身、仁爱孝悌、敬老爱幼、尊师重教、自谦敬人，这些无疑是中华传统礼仪文化的精华。今天，面对传统礼仪，应分清什么是符合时代精神的，什么是封建落后的，我们要“取其精华，去其糟粕”，继承传统美德，建设现代文明。</p><br><p style="text-align:center; font-size:26px">（三）结婚礼仪</p><p>57、结婚礼仪是人一生中最重要的礼仪，是男女社会成员组成家庭的必然步骤，是人们用以规范婚姻关系的重要手段。中国婚姻由习俗而礼制、由礼制而法律，有一套完整的制度。由于婚姻关系而到家庭幸福、种姓繁衍和社会安定，因此有关婚姻的礼仪、习俗也就特别繁多。</p><p>58、封建社会的婚姻是“父母之命，媒妁（shuò）之言”的包办、买卖婚姻。以汉族传统婚礼习俗为例，自周代以来，婚姻就沿袭“六礼”之制，即纳采、问名、纳吉、纳征、请期、亲迎。几千年来，虽有变异，但嫁娶之礼基本便由这“六礼”组成。其中以亲迎形式最为丰富多彩。</p><p>59、南昌的婚姻习俗除了“父母之命，媒妁之言”外，还有许多礼节。男到 20 岁，女到 15 岁，父母已经发现有相宜对象，就开始“托媒”。一般由男家采取主动，并请媒人开始张罗。这个过程相当于“六礼”中的“纳采”（是议婚的第一步，意指男女双方采择成偶）。</p><p>60、男家先给媒人买鞋钱，即预付部分报酬，以后要陆陆续续给媒人送礼和请其吃饭。南昌民谚“媒人十八餐、餐餐用肉餐”。媒人从接受买鞋钱起，即开始履约去女家，经同意议婚，媒人便开始询问女家待嫁闺女的芳名和出生时日。这种仪式相当于“六礼”中的问名，南昌民间多将”问名“叫做”请八字帖“。</p><p>61、所谓“八字”，是指旧历中的“天干地支”所对应人的出生年、月、日、时。媒人用五行相克来推算男女双方八字是否相合。八字和好后，双方父母把交换来的“庚贴”用红纸写好，置于祖宗灵前香炉底下，如三天内全家平安，就取出帖子，请算命先生去合婚求签占卜。这个仪式又叫“卜婚”，相当于“六礼”中的“纳吉”，意指纳取吉利之礼。</p><p>62、通过占卜得到的可以合婚的吉兆后，双方都同意的姐这门亲事了，男家先向女家发“求允帖”，如女家同意，便发“回允帖”。接着男家就要向女家下聘礼，南昌俗称“过礼”，它相当于“六礼”中的“纳征”（也称纳币、纳财），意指确定黄道吉日下聘礼。男家送白银一锭，金如意一支，表示一定如意；女家回送茶叶、莲藕，代表女子从一而终。</p><p>63、订婚这天，男女双方都要办订婚酒，称“知宾酒”，目的是让亲友知道男女双方已定亲。接着，男方媒人将“龙凤帖”送到女方家，双方的婚事算是最后谈妥了。当然，按照现在的法律，《婚姻法》没有对订婚作出规定，只要男女双方自愿，依法到婚姻登记机关领取结婚证即视为婚姻成立。</p><p>64、婚期确定后，女家就要准备嫁妆，并择日发送。嫁妆主要有：盆、桶大小七个，漆红色，“七”谐音为“妻”，意为“妻生贵子“，其中马桶内放筷子（快生贵子）、枣子（早生贵子）、花生（龙凤胎）、红蛋（生男孩）。各种器具内放油：红枣、白莲子、南瓜子、绿豆子、红被子，取意”五子登科“。</p><p>65、对于整个婚礼来说，以上数礼还只算是前奏，婚礼的真正高潮是在迎新这一天，它相当于”六礼”中的“亲迎”（是新浪在傧相的陪同下到女家赢取新娘的一系列仪式）。旧时举行婚礼的头一天下午二时左右，开始上花烛贺郎，吹鼓手开始捶打。新郎要戴冠，向天地、祖宗、父母叩头，便开宴请客，喝贺郎酒。</p><p>66、新娘出嫁前一天，要向父母叩头，感谢父母养育之恩，然后束发开面。束发也叫及笄，就是将头发绾（wǎn）起，做成盘头插上花。接着开面，即用棉线把脸上的汗毛绞掉。这天晚上，女方的母亲和新娘要哭嫁，哭嫁的内容大都是母亲教女儿怎样做媳妇，怎样相夫教子；女儿主要感谢母亲多年的养育之恩。哭嫁一直哭到第二天花轿进门结束。</p><p>67、花轿到了男家，新郎掀开轿帘把自己的银簪插到新娘的头上，把新娘的簪子插到最的头上，此举叫“换簪”。这时新郎家的一群小孩拥上前去，用手中的苦楝（liàn）子迎面洒向刚扶出轿的新娘，这叫“去煞”。新娘下轿脚是不能沾地的，这时男家会在地上铺上麻袋（麻，孝顺；袋与“代”谐音），新娘踩着麻袋进入喜堂，男家代表铺着麻袋口中念道：“传袋、传袋，一代接一代”。</p><p>68、新郎、新娘进入喜堂之后，新娘要拜花轿，即向花轿的四方作揖，以感谢迎送；然后同新郎在一片喝彩声中一拜天地、二拜高堂、三拜父母、夫妻对拜和向宾客作揖。父母、宾客都要赏红包。拜毕，新郎用秤杆掀新娘的红盖头（用“秤杆”意指“称心如意”）。接着用盂盛饭加肉，让新郎新娘各举一箸（zhù， 筷子），谓之“孝顺饭”。一对新人并和交杯酒（古称“合卺(jǐn) 礼”）。</p><p>69、新人洞房花烛夜，特别热闹，即使宾客们闹得过了火，粗俗，男家也不能发火，因为“闹”是为了“发”，叫做“越闹越发”。南昌民间风俗认为，“闹房三日无大小”。除取乐、闹笑外，再就是逗新娘开口笑，因为新人之间未曾谋面，新娘难免害羞，亲朋来宾可以用各种方法逗趣，以营造一种和谐的氛围。</p><p>70、过去南昌“闹洞房”，“贺郎歌”的彩词非常有特色，这里我们来看一首：“一堆花烛喜洋洋，满堂宾客贺新郎，老者贺郎添福寿，少者贺郎寿命长，读书贺郎登金榜，作田贺郎万担粮。男扶栏杆女浆纱，满堂宾客笑哈哈。进入洞房花烛夜，一床锦被盖双虾”。</p><p>71、旧社会男尊女卑、重男轻女吗，早婚、纳妾与表亲婚、指腹婚、童养婚、转亲婚、典妻婚、冥婚等陋俗，是我国传统婚育习俗中的糟粕。随着社会的发展与进步，一些婚姻陋习已经绝迹，但有的则仍以各种变化了的形式在社会上残存着，需要我们在建设新型婚育文化的过程中予以革除。</p><br><p style="text-align:center; font-size:26px">（四）寿庆礼仪</p><p>72、寿庆礼仪是人们关爱尊长、表述亲情的重要手段。“小过生日，老做寿”。所谓“寿”，通俗地来说就是指生命存在的时间和生命延续的过程。长寿是人生的一大追求，世上所有人都希望自己的生命能够延续长久。寿庆礼仪的主要形式是“祈寿”、“祝寿”。</p><p>73、“祈寿”本事一种具有原始巫术色彩的行为方式，它通过借助某些想象的动作行为，满足人们渴望长寿的愿望，了却生命持久的心愿，如贴寿字，挂寿图等等。“祝寿”也是人们追求长寿理想、祈求延年益寿而产生的行为方式，与一般意义上的祈寿方式有所不同的是，祝寿有一个十分明确的行为主体，那就是做寿老人。</p><p>74、按南昌传统习俗，年龄进入五十岁以后才举行祝寿活动，越到老年，祝寿活动的仪式也就越是隆重。南昌有句俗语：“三十五人晓，四十无人知，五十做一做，六十摆宴席，七十大庆贺，八十无信息，九十、百岁大摆席”。南昌民间认为“九”是一个吉利数字，它代表天长地久，而“十”是一个足数，又与“死”谐音，离“世”不远，十分忌讳，做寿是避“十”做“九”，俗称“过九”。</p><p>75、祝寿时，燃放鞭炮，儿子立于门前，迎接姐妹、亲友，收下礼物，接着致祝寿贺辞，晚辈依次向二老跪拜，并诵念“添福添寿，长生不老”或“福如东海，寿比南山”等简短祝语，有的还要喝寿彩、吹喇叭。亲友也纷纷上前拜贺祝福。寿星站立拱手还礼，接着吃长寿面、唱南昌采茶戏、照全家福。</p><p>76、祝寿完毕，即开寿筵（yán）。先吃寿面，南昌人读“面”总喜欢与“命”谐音，所以不管是谁家老人做寿，都要给来客敬上一大碗长寿面，以示同寿，即便是左邻右舍，主人也要去送一碗，以表和睦之意。席终尽兴而散。做寿老人要回礼，一般为寿碗、寿筷等。上世纪 80 年代以来，有的则兴起吃生日蛋糕，有的祝寿仍沿旧俗，但礼节从简。</p><br><p style="text-align:center; font-size:26px">（五）丧葬礼仪</p><p>77、丧葬礼仪是人生历程的最后一个仪式。一个人谢世之后，子女、亲友为其举行道别和安葬仪式，以寄托自己的哀思。南昌丧葬礼仪分为葬前礼、葬礼、服丧之礼。南昌民间对死者进行吊唁，叫做“白喜事”。旧时，南昌的丧葬，有一整套封建迷信的繁缛礼节，一般有举丧、守灵、入殓、出殡、安葬、关山、接七等几个步骤。</p><p>78、随着社会进步，现代人变厚葬为厚养薄葬，丧失从简是重大的观念更新。厚葬既来自灵魂不灭观念，也来自封建时代以“孝”为核心的伦理观。当代人对丧葬与“孝”的关系有了新的认识，认为厚养薄葬乃是“孝”之正道，重点是厚养。对长辈的孝敬应在生前，而非死后大肆铺张。</p><br>注：本文来自绳经塔下话南昌丛书之《南昌风俗礼仪》<p><img src="/image/nanchang/nccustomnrites.jpeg" width="30%"></p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> 南昌 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文化 </tag>
            
            <tag> 历史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让 Host-Only 模式下的虚拟机访问外部网络</title>
      <link href="/Macbook/vbox-hostonly-access-network/"/>
      <url>/Macbook/vbox-hostonly-access-network/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" media="all" href="/materials/my.css"><p>Host-Only 顾名思义就是虚拟机只能跟宿主机通信的一种网络模式。在这种模式下，虚拟机不能直接访问外部网络，而只能跟宿主机通信，因而它是一种封闭而安全的网络模式，可以保护虚拟机系统不受任何外部网络的影响。</p><p>但是，在某些情况下，我们需要 Host-Only 模式下的虚拟机访问外部网络，那么该怎么做呢，这篇文章就来详细介绍具体方法。</p><p>本文以 Mac OS 作为宿主机（Host OS），Windows 10 作为虚拟机（也即客户机，Guest OS）为例来进行介绍如何使 Host-Only 模式下的虚拟机访问外网。</p><p>我的 Mac 系统中使用 Parallels Desktop（以下简称 PD） 虚拟机软件安装了 Windows 10 系统。当然，使用其他软件比如 VirtualBox 或 Vmware 原理相同。虚拟机中的操作系统需要联网，一般虚拟机软件都会提供几种最基本的联网模式，PD 就提供了三种：1）Shared Network 2）Bridge Network 3）Host-Only Network。</p><p>如下：</p><div class="center80">![](/image/pd_netconfig.png)</div><!-- <img class="center1" src="/image/pd_netconfig.png" width=800></img> --><div class="center70">![](/image/desknet.png)</div><p>默认情况下，PD 为虚拟机启用的是共享网络（Shared Network）模式。这种模式本质上就是 VirtualBox 中的 NAT 模式，宿主机充当虚拟机的路由器，通过虚拟网关为虚拟机分配一个内网 IP 地址来实现内网机器的对外联网。</p><p>由于宿主机充当路由，所有虚拟机发出的网络请求都会忠实的转发出去，因而虚拟机可以轻松实现上网。简而言之，共享模式下我们日常上网的绝大多数情况都能满足。但是如果我们对虚拟机的安全性要求高的话（比如运行了重要的程序，防止受病毒侵袭，或者数据泄漏等），我们可能就需要一个更加安全封闭的网络，也就是说，我们即不希望虚拟机直接访问外部网络，也不希望外部网络访问虚拟机。那么 Host-Only 就是一个必然的选择。</p><p>VirtualBox 中还有 Internal network 模式，它比 Host-Only 更严格。虽然这篇文章的主要目的是介绍如何让 Host-Only 模式下的虚拟机访问外部网络，但是先理解 Host-Only 模式的原理是我们达到目的的一个重要前提。所以这里就先简单介绍下这个模式的基本原理和用法。</p><p>不管哪种网络模式，虚拟软件都需要在宿主机上创建一个虚拟网卡，比如 Shared Network 模式下虚拟软件会自动命名把该网卡命名为 Shared Network Adaptor，而 Host-Only 模式下，虚拟软件则将该网卡命名为 Host-Only Network Adaptor。</p><p>本人 Mac 系统中使用 PD 创建上述两块虚拟网卡，Mac 中打开 Network Preferences 页面，显示如下：</p><div class="center80">![](/image/nic02.png)</div><div class="center80">![](/image/nic01.png)</div><p>PD 创建的虚拟网卡会自动为 Host OS 和 Guest OS 分配 IP 地址，如上图所示，宿主机 Mac 的 Host-Only 虚拟网卡为其分配的地址是 10.37.129.2，或者我们直接在命令行中输入 ifconfig 也可以看到该信息，如下：</p><div class="center80">![](/image/vnic.png)</div><p>我们进入 Windows 10 客户机，可以查看 Host Only 网卡为 Windows 10 所分配的 IP 地址（10.37.129.3），如下：</p><div class="center80">![](/image/win_ipconfig.png)</div><p>由上图还可以看到，Host-Only 虚拟网卡的网关是 10.37.129.1。</p><p>在启用 Host-Only 模式之后，我们需要先把宿主机与虚拟机互 Ping 以测试它们是否可以正常联通（一切正常的话，应该联通）。</p><p>Guest -&gt; Host （可以 Ping 通）</p><!-- <div class="left">![](/image/guest2host.png)</div> --><p><img src="/image/guest2host.png" width="80%"></p><p>Host -&gt; Guest （无法 Ping 通）</p><!-- <div class="left">![](/image/host2guest.png)</div> --><p><img src="/image/host2guest.png" width="80%"></p><p>原因：Windows 防火墙阻挡。</p><p>Windows 10 的防火墙阻止了外部的 Ping 命令所发出的 ICMP 请求包，所以，我们暂时关闭防火墙即可。</p><p>同理，如果虚拟机无法 Ping 通宿主机，也应该先关闭防火墙来排查故障。我们也可以仅修改防火墙的具体规则而不是把整个防火墙关闭来达到目的，如下：</p><div class="center80">![](/image/win_firewall.png)</div><p>如何在宿主机 Mac OS 的网络设置页中显示 Host-Only 虚拟网卡？</p><p>在 Paralles Desktop 启用 Host-Only 时，默认情况下，Mac 的网络设置页不会显示该虚拟网卡，我们需在通过如下设置来显示：</p><p>右键 Parallels Desktop，选择 Preference，在弹出的选项框中勾选 “Show in System Preference”，如下：</p><div class="center80">![](/image/pd_preferences.png)</div><div class="center80">![](/image/pd_pref.png)</div><p>然后，我们打开 Mac 的网络设置页，就可以看到 Host-Only 这张虚拟网卡了，如下：</p><div class="center80">![](/image/hostonly.png)</div><p>好了，前期准备我们已经完成了，现在回到重点，如何才能让虚拟机访问外网！</p><p>如果想要虚拟机上外网，有两种办法可以解决：</p><p>1、为虚拟机再设置一块网卡，连接方式为NAT，使用 NAT 来访问外网。</p><p>2、在宿主机中开启一个代理端口，然后虚拟机的浏览器中 LAN 设置使用这个代理。</p><p>第一种方案的思路很简单，就是增加一个 NAT 网卡来连接外网，这里不多介绍。（而且，由于 Mac 系统下的 Parallels Desktop 每次只能为虚拟机中的系统使用一块网卡，因此第一种方案暂不可行。）</p><p>下面，我们来看第二种方法，也就是在把宿主机作为代理机被虚拟机访问，这就需要我们在宿主机中开启一个代理端口以便虚拟机可以访问。</p><p>那么如何在宿主机中开启一个代理呢？</p><p>我们可以通过一个知名的代理软件 “Surge for Mac” 来实现。</p><p>先安装 Surge for Mac，然后按照如下方式进行设置并开启代理端口：</p><p>1）点击右下角 Enhanced Mode 进入 Setup Guide 页面</p><div class="center">![](/image/mac_surge.png)</div><p>2）选择 For Remote Machines &gt; 点击 Allow External Access</p><div class="center">![](/image/mac_surge_guide.png)</div><p>可以看到，点击 Allow External Access 之后其右边会出现 Listen on: 192.168.22.33:6152 端口开放信息。</p><p>它是实际上是一个 0.0.0.0:6152 类型的允许远程连接的端口，如下：</p><p><img class="center1" src="/image/lsof.png" width="75%"></p><p>需要注意的是：宿主机提供的代理端口必须要允许远程连接，也就是 *:80（也即 0.0.0.0:80），而不是 localhost:80 这种形式。</p><p>所以，Host-Only 模式下的虚拟机可以向这个端口发起请求，而 Surge 会帮我们把这个请求代理出去，从而实现虚拟机上网。</p><p>通常，我们上网需要用到浏览器，那么我们只需在虚拟系统中的浏览器中进行代理设置即可，目标代理地址就填写作为 Host-Only 模式下虚拟机可以访问的宿主机的 IP 地址及端口。</p><p>以 Chrome 浏览器为例，按如下方式设置：</p><p>Settings &gt; Advanced &gt; System:Open proxy settings &gt; LAN settings</p><p><img class="center1" src="/image/lan_setting.jpg" width="80%"></p><p>这样，虚拟机就可以正常访问网络了。</p><p>打开一个网页试试，</p><div class="center">![](/image/tianya_screen.png)</div><p>成功！</p><p>注：如果 Windows 10 中使用了 Chrome 或 Firefox 浏览器，我们可以下载 SwitchyOmega 插件来更加科学方便地管理代理规则，比如，我们按照如下方式配置代理：</p><div class="center80">![](/image/omega1.png)</div><p>上述 Surge 提供了代理的功能，实际上还有其他软件也可以提供类似代理，比如 Shadowsocks，</p><p>它也提供了 HTTP Proxy 的功能，只需要简单设置即可让虚拟机连接。</p><p>如下：</p><!-- <div class="center">![](/image/ss_server.jpg)</div> --><p><img class="center1" src="/image/ss_server.jpg" width="50%"></p><p>如上，正常情况下，为了安全，代理通常被设置成本地（也即 127.0.0.1）。这里，为了使虚拟机可以使用这个代理端口，我们需要把它改成 0.0.0.0。</p><p>SwitchyOmega 代理规则设置如下：</p><div class="center80">![](/image/omega2.png)</div><p>配置完成之后，我们再来测试一下，打开 YouTube，</p><div class="center">![](/image/youtube_screen.png)</div><p>现在我们的 Host-Only 虚拟机也可以颗学上网了 😊。</p><p>注：由于代理的缘故，经过实测，上网速度会略慢一些。</p><h4 id="如何添加多个-Host-Only-虚拟网卡"><a href="#如何添加多个-Host-Only-虚拟网卡" class="headerlink" title="如何添加多个 Host-Only 虚拟网卡?"></a>如何添加多个 Host-Only 虚拟网卡?</h4><p>我们可以在 Parallels Desktop Preferences 设置页添加多块虚拟网卡，如下：</p><div class="center80">![](/image/pd_pref1.png)</div><p>添加之后，在宿主机 Mac 的“Network Preferences”页面就可以看到这块虚拟网卡了。</p><p>一台 VM 一次只能使用一块虚拟网卡，也就是一个 Host-Only 地址，</p><p>我们可以在 Device &gt; network 中进行切换，如下：</p><div class="center70">![](/image/device_network.png)</div><p>全文完！</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Macbook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Virtual Host </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11 Memory Model</title>
      <link href="/C/core-techs-concurrency/"/>
      <url>/C/core-techs-concurrency/</url>
      
        <content type="html"><![CDATA[<h3 id="Memory-Model（C-）"><a href="#Memory-Model（C-）" class="headerlink" title="Memory Model（C++）"></a>Memory Model（C++）</h3><p>Acquire 与 Release 语义</p><p>对于 Acquire 来说，保证 Acquire 后的读操作不会发生在 Acquire 动作之前<br>对于 Release 来说，保证 Release 前的写操作不会发生在 Release 动作之后</p><p>X86-64中Load读操作本身满足Acquire语义，Store写操作本身也是满足Release语义。但Store-Load操作间等于没有保护，因此仍需要靠mfence或lock等指令才可以满足到Synchronizes-with规则。</p><h3 id="内存一致性模型-Memory-Model"><a href="#内存一致性模型-Memory-Model" class="headerlink" title="内存一致性模型 Memory Model"></a>内存一致性模型 Memory Model</h3><p>内存一致性模型从程序员视角，由内存序Memory Ordering和写操作原子性Store Atomicity来定义，针对不同线程中原子操作的全局顺序：</p><p>Strong Consistency / Sequential consistency 顺序一致性<br>Release Consistency / release-acquire / release-consume<br>Relaxed Consistency</p><p>C++11相应定义了6种内存模型：</p><p>std::memory_order_seq_cst 所有读写操作不能跨过，写顺序全线程可见<br>std::memory_order_acq_rel 所有读写操作不能跨过，写顺序仅同步线程间可见、<br>std::memory_order_release 所有读写操作不能往后乱序、<br>std::memory_order_acquire 所有读写操作不能向前乱序、<br>std::memory_order_consume 依赖该读操作的后续读写操作不能向前乱序<br>std::memory_order_relaxed 无特殊要求</p><p>C++ 中 voldatile 等于插入编译器级别屏障，因此并不能阻止 CPU 硬件级别导致的重排。C++11 中 volatile 语义没有任何变化，不过提供了 std::atomic 工具可以真正实现原子操作，而且默认加入了内存屏障（可以通过在 store 与 load 操作时设置内存模型参数进行调整，默认为 std::memory_order_seq_cst）。</p><p>C++ 实践中推荐涉及并发问题都使用 <code>std::atomic</code>，只有涉及特殊内存操作的时候才使用 <code>volatile</code> 关键字。这些情况通常 IO 相关，防止相关操作被编译器优化，也是 volatile 关键字发明的本意。</p><p>可参考：<br><a href="https://zhuanlan.zhihu.com/p/55901945" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/55901945</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>南昌小孩都不说南昌话的几个原因</title>
      <link href="/%E5%8D%97%E6%98%8C/nanchang-nanchangdialect/"/>
      <url>/%E5%8D%97%E6%98%8C/nanchang-nanchangdialect/</url>
      
        <content type="html"><![CDATA[<p>其实这个现象我很早就注意到了，家里亲戚生的小孩，几乎不说南昌话。满口的普通话，让人觉得无比陌生和充满距离感。南昌崽俚子不说南昌话？作为南昌土生土长的 80 后，早在十几年前我就想吐槽这个现象。南昌小孩不说南昌话并不是小孩的错，而是父母把对自己文化的不自信感强加在小孩身上的结果。他们不教小孩南昌话的大多原因是认为南昌方言粗鄙，市井，觉得说普通话显得文明，其实这是相当肤浅的认知！</p><p>为什么肤浅？我这篇文章就是为那些愿意坐下来对“南昌人是否该学好南昌话这个话题”进行深度思考的人而写的。</p><p>（注：本文全文约 1 万字，预计阅读时间 40 分钟。）</p><p>在我看来，<strong>如果你是南昌人，那么说好一口正宗的南昌话几乎应该是一个必须要掌握的技能。</strong>为什么？我就从下面几个因素来探讨。</p><h2 id="1、南昌话历史底蕴深厚"><a href="#1、南昌话历史底蕴深厚" class="headerlink" title="1、南昌话历史底蕴深厚"></a>1、南昌话历史底蕴深厚</h2><p>相比北方满蒙色彩浓重的普通话，南昌方言是一门非常古老的语言。早在唐代，以南昌方言为代表的赣方言已经相当成熟了，南昌话在宋代时期作为官话在南昌地区（洪州）通行。宋代有大量的文字（书、信、诗）使用南昌方言的读音和用法（下面将举例），可以说南昌方言就是宋代语言活化石。</p><p>南昌方言的读音和用法对外人来说比较难懂，因为其仍沿袭宋代读音和用法，而对一门语言来说，其特点保留得越原始，离现代越久远就越难懂。比如广东话和闽南话，它们大多仍沿袭唐代音，古老程度冠绝前列，南昌方言的古老程度也不遑多让。</p><p>对方言历史进行一下简单的考古就会发现，南方的这些方言和现在从北方传过来的普通话相差太多，<strong>普通话是北方语系，完全是因国家政策推广而被普遍使用。</strong>有人就表示，南方方言和普通话本质上甚至已经不能是算方言的差距了，而是完全可以归为两种不同的语言，就像英语和西班牙语。</p><p>南昌话作为赣方言的代表，与粤方言、闽方言和客家话都有着较密切的亲属关系。比如说，客家方言就派生自赣方言。懂客家话的人应该知道南昌话与客家话很相近（比如：南昌人和客家人都称鼻子为“鼻公”，都叫“太公（祖父）、太婆（祖母）、阿公（外公）、阿婆（外婆）”等）。当然，它们都是移民运动的产物，赣方言是唐宋以前北方移民的方言和赣地区原古百越民族的语言相互融合的产物，而客家方言则是宋元时期赣北、闽南地区的移民的方言和岭南地区土著居民的方言（原始粤语）融合的产物。</p><p>但是为什么客家话，闽南话，粤语都在各地被保留的很好，而南昌话却被自己人嫌弃甚至到已渐渐被普化侵蚀甚至面临消失的处境呢？一方面是受到普通话冲击的影响，但更重要的还是我们上一辈对历史文化的漠视和自信缺乏所导致的。</p><p><strong>如果我们缺乏对南昌方言这门语言悠久历史的认知，而只是肤浅的从语音语调，词汇等表面去理解，我们就会对它产生极大的误解。</strong>每每想到这种现象就让我脑壳侵痛。下面我们下面就来看一下一些典型的南昌话在各个历史时期中的文字记载吧：</p><p><strong>去归（回家）</strong> 汉•王充 《论衡·骨相》：“ 高祖为泗上亭长，当去归之田，与吕后及两子居田。”</p><p>*<em>企 （站） *</em>《汉书•高帝纪上》：“日夜企而望归。”【引】仰望；盼望。《北史•阳修之传》：“乡曲人士，莫不企羡。”</p><p><strong>线鸡（被阉的公鸡）</strong> —— 宋•戴复古 《访[1]许介之途中即景》诗：“区别隣家鸭，群分各线鸡。” 元 汤式 《庆东原•田家乐》曲之一：“线鸡长膘，绵羊下羔，丝茧成缲。“</p><p><strong>杌[wui]子（凳子）</strong> 宋•曾慥《类说》引《摭遗》:“唐明皇召安禄山,用矮金裹脚杌子赐坐。”《水浒》第二十四回“(武松)掇个杌子,自近火边坐地。”《二刻拍案惊奇》第七回:“东老正要问他来历,恰中下怀,命取一个小杌子,赐他坐了。”</p><p><strong>熨[yū]贴（平整）</strong> 金代•戏曲家董解元《西厢记》：“柳眉星眼，杏腮桃颊，口儿小，脚儿弓，扮得熨贴。” 元代杂剧《百花亭》第一折：“他见俺淹润温柔熨贴，弄玉傅香无尽歇。”</p><p>*<em>撇脱（利索） *</em>（形容做事干脆利索，洒脱，性格豪爽） 是一个古汉语，《二刻拍案惊奇》卷九：“素梅也低低道：‘撇脱些！我要回去。这事做得不好了，怎么处？’”</p><p><strong>左[zié]（戏弄/欺骗）</strong> 明朝 吴承恩 《西游记》第三十一回：“八戒道：‘你但干事，就左我们。’行者道：‘如何为左你？’”</p><p><strong>腌臜/腌里巴臜（肮脏）</strong> 清朝 文康《儿女英雄传》第三十二回：“里头是腌里巴臜的两间头发铺。”</p><p><strong>嚼蛆（胡说八道 ）</strong> 清初《豆棚闲话》第八则：“我是听别人嘴里说来的，即有差错，你们只骂那人嚼蛆乱话罢了。”</p><p>类似这样的例子还有太多太多，我就不一一列举。</p><h3 id="2、南昌话发音特点"><a href="#2、南昌话发音特点" class="headerlink" title="2、南昌话发音特点"></a>2、南昌话发音特点</h3><p>很多南昌人嫌弃南昌话的一个重要原因是，南昌话听起来比较冲，给人以咄咄逼人的感觉，感觉像吵架。这种说法不胫而走，好像被大家广为认同，那么，这是真的吗？ 照我说，是真也不真。</p><p>因为如果仅从发音特点来判断，<strong>南昌话是古语，特点是短音多，许多音声仄平，而且保留了许多入声调</strong>（普通话以北方话为基础，北方话在历史上受北方少数民族语言影响较大，导致入声调已经完全消失）。</p><p>邵百鸣教授在《南昌方言》一书中对此南昌话的发音特点有详细解读，主要体现在，南昌话声母中<strong>送气音较多，韵母中圆唇后元音[o]、[ɔ]多，声调中多短促的入声调</strong>（古语中的入声调在普通话中已完全消失，但是在南方许多方言中依然有大量保留）。这些特点使得南昌话许多音节的音值较高、较短，听上去气势足，声调明朗，清晰，非常适合辩论。</p><p>从技术角度上，对南昌话的发音还有很多解析，我就不一一列举。总而言之，南昌话的发音却是特点鲜明，在外人看来有些“咄咄逼人”。但如果仅因为发音问题就去责究南昌话那就真的太肤浅而无知了。每种语言都有它自身的发音特点。南昌话的这些发音特点既不能把你定义为素质差的人，也不可能为你贴上任何不好的标签，它的发音只是这门语言的特点，跟你的素质完全无关。<strong>如果仅从表面现象就否定自己的母语，你很难相信这样的人会在其它方面有较深的见解。</strong></p><p>简单看完了南昌话的发音特点，下面就来看几首常见的诗词，体会一下这些发音特点是如何在古诗词中展现平仄韵律的（非常有意思）：</p><p>朱雀桥边野草花，乌衣巷口夕阳<strong>斜</strong>。旧时王谢堂前燕，飞入寻常百姓<strong>家</strong>。《乌衣巷》——刘禹锡</p><p>今朝郡斋冷，忽念山中<strong>客</strong>。涧底束荆薪，归来煮白<strong>石</strong>。《寄全椒山中道士》——韦应物</p><p>前不见古人，后不见来<strong>者</strong>。 念天地之悠悠，独怆然而泪<strong>下</strong>。《登幽州台歌》 ——陈子昂</p><p>故人具鸡黍，邀我至田<strong>家</strong>。 绿树村边合，青山郭外<strong>斜</strong>。 开轩面场圃，把酒话桑麻。<br>待到重阳日，还来就菊花。<br>《过故人庄》 ——孟浩然</p><p><strong>这些诗词用普通话读完全不押韵，而用南昌话读则完全押韵！</strong></p><p>类似的诗句还有太多，我就不一一列举。</p><p>再看一个例子，<br>宋代朱熹有句名言：“问渠哪得清如许，为有源头活水来。”从现代汉语来看，很难了解“问渠”的意思。“渠”本来和“去”同音，在南昌话中，“去”说成“且”；“他（它、她）”也说成“且”。所以，朱熹说的是“问且”，就是现代汉语中的“问它”。至于“许”字，就是南昌人说的“hei（音和“嘿”相近）”，比如“嘿好/嘿坏…”。因此，“问渠哪得清如许”翻译成现代汉语就是：“问它为什么那么清。”</p><h4 id="3、南昌话表现力强"><a href="#3、南昌话表现力强" class="headerlink" title="3、南昌话表现力强"></a>3、南昌话表现力强</h4><p>南昌话作为一门丰富又完善的语言，其表现力可不是现在的普通话所能比拟的。不仅表现形式丰富，其用法也极其形象生动。</p><p>南昌话表现力强主要体现在两个方面：1）用词丰富 2）生动形象（拟声、拟物、拟人、拟感词，俚语等）</p><p>下面我一一介绍</p><p><strong>1）用词丰富</strong><br>同一种意思，南昌话中有多种表达方式。比如形容脏时，普通话就是脏，很脏，肮脏，邋遢等词，南昌话除了能直接使用这些说法之外，还有非常多的词可以表达脏以及其程度。比如：也泄，辣哒，糗稀，巴窝，结壳，生疮，腌臜[eà za]/腌里巴臜，哈死巴人，乌毛尖罩，一身爬了蛆，一头的厄屑等。不仅用词多，还形象生动。在表达程度时，普通话中是，好/很，非常，极其，特别，一直等词，南昌话除了这些词，还有有大量的表达程度的词，比如：平整，端(duo)张，来事，冒有挡，吃价(qia ga)，到句，绝杀，绝（做得很坏），杀火，冒有影，头世(xi)造多了恶，紧，一径里，记得定了等等。</p><p>形容很拼命很努力时，南昌话有：森命里，牙命里，搏命里等。形容快是用：风快，扎西，骚皮嗲子，得紧带活，撇脱。</p><p>形容物品特征状态的形容词就更多了，比如最常见的形容状态、颜色、味道等词，这里简单列举几例：橘绿、闪黄、汀清、宣红、煞白、乜[miè]乌、乜暗 、笃紫 、修青；鲜甜，纠酸，刮淡，劈[pī]鲜，鳖腥，叮寒/溜咸，学[hō]球，棚[pùng]香，拨[bò]辣。每种颜色每种味道都用了一个独特的程度词来搭配，这可比普通话中单一的“很”的表达力强了好几个档次啊。</p><p>用来形容人的词就更多了，比如贬义的：<br>形容人蠢：鹅头鹅脑，木根里、藤根里，森根里，二愣子，脑膜炎，搭到了头，愚子，鹅卵，森卵，森崽，森雀了灭，森得洛维奇，森头耷脑，愚短命鬼里，鹅国佬，憨包，挨，锯[kiè]木，眠/眠猴，不得转，不懂眼等等。<br>能力差：梭，换，利息货，挨病，鼻屎。<br>性格：冲，桑，龌龊，郎抗，熬烈，邪，麻辣，结赖，雀博，牙黄口臭，色，虽，好恰鬼/虽鬼子，秀/秀皮，秀皮铁哒，瘟性，祸钵兜子，辣答，也泄/也泄鬼，牙办，作翘，斗霸，亡愣骨(里)，路皮等等。<br>外貌：糗憋怪，长得巴了窝，豆屎眼，嗲眼珠里，矮子鬼/矮崽子/矮婆里，灭鼓哒黑，更[kang]瘦/更筋鬼瘦等等。</p><p>褒义的：<br>形容智商能力：精灵，得转，结棍，杀火，吃价(qia ga)，辣，撇脱，涪叫。<br>性格：杀辣，善，罗，左[zié]等等<br>外貌：咳气，莽子，富嫩，端张，修长。</p><p><strong>2）用词生动形象</strong><br>从上面的例子中我们也可以看到，除了表达方式多种之外，其实每一种表达方式都非常形象生动。接下来我还要再举一些例子，来证明这个语言是多么有魅力：</p><p>结棍（厉害）：棍子打得过来都能接住，你说厉不厉害。<br>客气（漂亮）：一个女孩子对人客客气气，你说她的心灵美不美。<br>夹沙糕：你吃一块糕，吃到了沙子，是不是有点受不了。我们用这样的一种食品来描绘一个女人的无理取闹是多么的形象。<br>企（站）：“企”是古汉语中站的说法，企鹅其实就是站鹅（笑出声）。</p><p>其实不止如此，南昌话中还有很多拟感的词，比如普通话中的毛毛虫，南昌话中叫“<strong>毛辣子</strong>”，被毛毛虫咬到了，皮肤就会有刺辣的感觉，直接用这种拟感的词做名词，不比毛毛虫这种说法更科学生动吗？再比如普通话中的破裂，南昌话中叫 “<strong>边</strong>”，破的东西东西分成两或者几边了，直接用边来形容东西被打破了，多么形象。再比如形容人放纵过度或狂暴时，南昌话用”<strong>亡了形</strong>“来表达，连形都没了当然是放松或狂怒过度啦。形容事物因天气太冷并冻僵的状态是，叫“<strong>愣住</strong>”，你看，不仅人可以愣住，万事万物都可以愣住了，好形象。形容人拌嘴吵架，南昌话叫“<strong>嚼牙膏</strong>”，牙膏都要嚼，可见说的话有多无聊了。形容需要从一种预期之外的或危险的地方撤离时，叫“<strong>走鱼</strong>”，鱼到了岸上需要赶紧离开，当然得走啦。“<strong>耕</strong>”，是一种很费力的动作，南昌话里面，也有他的妙用。比如人很多时，想要推开人群挤进去，就可以用耕。还有，想表达骑车时使劲蹬踏的动作，也用耕。是不是非常形象呢？如果想要用普通话来表达费力蹬车，你得说好长一段废话，但是用南昌话，一个耕字就够了。</p><p>这样的表达方式在南昌话中可谓比比皆是，我就不一一列举了，真是赞叹南昌老祖宗们的丰富想象力，你还有什么理由不喜欢南昌话。</p><p><strong>3）不雅语</strong><br>不雅语是我必须要提的一个话题，因为正是因为这个让很多人觉得南昌话不雅，粗鄙，市井。我只能说，如果你持这种观点的话，那么就真的是见识短了！要知道，普通话推广以前，我们中古方言可是叫雅语，上面已经介绍过，<strong>古音声调多，被北方少数民族入侵之后，官话就融合了这些少数民族发音的特点，声调只有四声，入声调也消失，发音变得简化。</strong>建国后为了提高普通民众的识字率，普通话也对古字进行了简化，所以简单来说，现在的汉字是简化版的中文。而南昌话保留了（南）宋代的通行官话，是更加丰富的。</p><p>而且，从词汇上来讲，哪门语言没有不雅语，粗俗语？ 全世界的语言里面都用智商、生殖器及排泄物当作骂人的话来使用，这几乎是人类表达方式的共性。普通话（北方话）因政策推广，它中的“傻逼，傻屌”这种不雅语被传遍大江南北，但人们并没有因此而说普通话是一门不雅的语言。英语中也有 bullshit，douche bag, motherfucker, dickface, asshole, pussy, pissed 等不雅词，但并没有被人们认为是一种不雅的语言。因为我们都知道，不雅的只是这些词汇，而不是这门语言。而且，这些所谓的不雅词汇其实也是人类感情表达的必需品，是必然存在而不可能消失的。一门语言并不会因为有这些不雅的词汇而变成糟糕的语言。相反，它反而会因为其具有的丰富表达能力而吸引人们。</p><p>南昌话骂人其实非常有特点，加上南昌方言的口音特点，经常就有人形容说，听南昌话骂人就像是在唱歌，令人捧腹。如果拿南昌话中所谓的不雅语出来跟普通话对比，你就知道普通话中那仅有的那些词汇在这方面的表现力上是有多么干涩和无力了。</p><p>举个最简单的例子，现在的网络流行语<strong>“然并卵”</strong>就是出自南昌方言，在南昌方言中，这种类似的这种表达还非常多，现在人们喜闻乐见地用普通话来传播这些有意思的表达，却对其出处横加指责，真是滑之大稽。</p><p>另外，说到不雅语，虽然我们自诩为文明古国，其实我们说话的方式可能在西方国家某些人看来一点也不文明，为什么这么说呢？Youtube 上有个叫 Fulinfang拂菻坊（地址：<a href="https://www.youtube.com/watch?v=yR0yo7Zaoks）" target="_blank" rel="noopener">https://www.youtube.com/watch?v=yR0yo7Zaoks）</a> 的英国人用他在中国生活中的一些经历和现象做了一些分析对比，解释了为什么中国人的很多行为或沟通方式被外国人认为不礼貌甚至粗鄙。比如人们在公共场合喜欢高声说话，声调很高，给人感觉粗鲁，商店的售货员几乎不怎么说敬语（比如请，谢谢等），即使偶尔使用这些敬语也并不走心等等。他分析得非常精准（我非常推荐大家看看这个视频），对每种现象都给出了分析，比如中国人沟通注重效率，什么“请”，“不好意思”，“谢谢你”等敬(fei)语(hua）在某些注重效率的场合就会被省略，而西方人则一会儿一个 excuse me， 一会儿一个 thank u/I appreciate it，虽然看上去很礼貌，但是沟通效率低。还有，比如如果外国人听不懂中文，这时候你在那里bablabala大声说话，他会觉得你说话怎么跟吵架一样啊，在加上中文发音的特点与英文发音特点不同（中文发音有声调，而英文发音没有，声调只是用来表达感情）所以就更容易加重别人对这种语言沟通方式的误解。这种现象套在南昌话上也是一样的。区别在于外国人看中国人是觉得中国人不礼貌（误解），而外地人看南昌人却觉得南昌话不礼貌。前者归结到说话的人素质不高，后者却归结到语言粗鄙。说到底，这种奇怪的逻辑还是因为不了解语言、文化之间的差异和特点，南昌人不从自身素质上找原因，反倒怪起语言来了。这就跟中国人被外国人认为粗鲁或素质低，就不学中文改学洋文是一个道理，这是掩饰问题而不是解决问题。</p><h4 id="4、文化自信"><a href="#4、文化自信" class="headerlink" title="4、文化自信"></a>4、文化自信</h4><p>文化自信，这可能是我最想要说的重点了。因为这<strong>不仅涉及到对方言母语的认可、自豪感，还包括对自身价值的认识。</strong>许多南昌人对自己的文化不自信是体现在方方面面的，而且说到不自信，这还不只是南昌人的问题，许多中国人都对自己的文化不自信（比如崇洋媚外这种现象已经见怪不怪了）。以前我记得在学校的时候看到一个外国人都跟看猴子似，觉得好高大上，后来我大学去了上海，我们学校几乎是整个上海市内录取外国留学生最多的学校，我大二那会儿因为经常玩轮滑（一堆爱好者天黑了就去操场刷）认识不少喜欢夜间活动的外国人，我觉得他们也并没有传说中的那么神，至少没觉得高大上，有个土耳其人还借我钱不还（我怎么还记着这事😂），所以我就破除了对老外的迷信思维，把他们当普通人来看待，不会在他们面前丢失自我。</p><p>丢失自信的后果最直接的后果就是容易受别人评价（诋毁）的影响。我们知道，当一个人不自信时，别人说什么负面的话，不管是事实与否，都会导致你自己对自己的评价下降。<strong>而当一个人自信起来，总是充满能量，散发光芒的。</strong>我举个最俗的例子，马云，又丑又矮，智商也不出众。但是人家商业感觉好，执行力强（所以成功）。所以你可以看到，他在任何场合都不会因为别人歧视他的长相而失去自信，他总是能量充足，这让那些想对他那些外在缺陷作出负面评价的人都不由地失去底气。人们都想靠近他，学习他，吸取能量，这就是自信的力量。</p><p>南昌人在面对自身方言受到负面评价时，身上没有干货（没有认识到这门语言的魅力），那就只能失去自信，甚至认同这种负面评价。一旦认同这种负面评价，就想要回避，所以很多南昌家长就会出现这种情况，既然大家都说南昌话不好，那我就不学总可以了吧，我只说普通话，这样我总显得文明吧。这种逻辑实在是荒谬至极，而<strong>这种自我矮化只会导致多个后果，既不利于文化的传承，也不利于以后自身价值的发挥。</strong></p><p>在我看来，<strong>南昌人要提高对自己文化的自信，一方面要好好了解下南昌方言的历史，认识到它的魅力，当你有了干货，建立了自信，那么，在面对批评时你也能理性回击，而那些想要诋毁你的人将会失去底气。</strong></p><h4 id="5、认同感"><a href="#5、认同感" class="headerlink" title="5、认同感"></a>5、认同感</h4><p>文化认同是建立在文化特征上的，你有这个特征我也有这个特征，那么我们容易产生共鸣和认同感。<strong>会说南昌话是南昌人的一个重大特征，甚至可以说是最明显的特征。</strong>不夸张的说，除了身份证户口本，没什么比语音更有力量来向别人证明你是南昌人。即使你不喜欢南昌，由于你没法选择自己的出生和养育，所以你也不可能隐藏你南昌人的身份。与其回避，何不正大光明的面对呢。我在外生活多年，别人问我是哪里人时，我都不会划个范围似的说自己是江西人，我都直接说我是南昌人。南昌人就是我的标签，我记得5年前我办上海户口的时候，民警喊我新上海人，我相当不乐意。</p><p>有时候我们也会骂嘴里骂着南昌人，但是我想说的是，这样做就跟我们天天嘴里骂着中国人，骂着国足，差不多是一样的节奏，爱之深责之切。我的根子在这里，我知道它的病症在哪里，我希望它能改进，这就是我们大多数人内心的想法。有谁会不爱自己的家乡呢？不爱生养自己的家乡的人，你能指望他会对什么东西投入真挚的感情？天方夜谭。</p><p>出门在外的人这种感情尤其强烈，很多南昌人没出过家门可能体会没那么深，但是当你去了外地，听着别人说着一口家乡话，而你却只能和同乡说着普通话，有时候这是一种强烈的对比。在这种情况下，你丢失了标签，丢失了特色。你到了广东，看着别人彼此说着一口流利的广东话，你想融入就得去学，你到了北京，想要融入说话也要带点京腔可能才有那么点意思，到了上海，如果会说点上海话，上海人对你的认同感和好感又会增加几分。<strong>你看看，不管你在哪里，你都需要有你的标签和特征，不然你就像一个没根的人，飘着，想要使劲寻找落脚点。</strong>别人的方言随着城市经济的发展和地位的上升，方言在不断扩大影响，而我们却要抛弃自己的方言，尤其是一门这么优秀的方言，这实在是非常不可取的。90 年代广州曾经发起过一场保卫粤语的运动，当时官方不允许学生课上及课外讲粤语，最后在广州人坚决的抗争下官方才妥协。我们南昌人甚至都不用抗争，自己就 GG 了，不得不让人觉得揪心。</p><p>语言是文化认同的一个重要途径，很多人出了省读书才知道自己语言的重要性。在外面，与来自同一个地方的人，说上几句家乡话，那是多么的暖心，<strong>如果你连家乡话都不会说，那么别人之间说那种家乡话而产生温暖的、连接的感觉你可能永远都没有机会体会。</strong></p><p>此外，我在说说自卑这个话题，自卑无非是觉得自己差，对自己评价低，在社会上，自卑的人很难被人喜欢，因为如果你自己都不认可自己的话，怎么让别人认可你呢？</p><p>你走到外省，甚至国外，你却表达自己对家乡的厌恶的话，我相信作为外人，大部分人即使不明说，也会在内心瞧不起你，不会认可你。类似的情况还有，比如你从一家公司离职了，你却在外面到处说这家公司的坏话，或许你受了委屈，但是你这种行为依然是不明智的（就算要黑也要匿名啊），新公司的HR会对你另看一眼，至少我做面试官的时候这类人我首先就会刷掉。如果受了委屈，正确的方式是你讲诉遭遇，而尽量少去主观评价，比如说些什么公司sb啊，领导脑残啊之类话的。这样，别人就会帮你评价了，也不会对你印象变差。当然，话题有点扯远了。。。意思就是这个意思。</p><p>再顺带讲一下文化多样性的重要行，学习一门语言不是目的，而只是掌握一种交流的途径，我们<strong>学习普通话是为了与其它省市持不同方言的人交流，这也是当年国家推广普通话的主要目的。而绝对不是因为说普通话这门语言更文明，因为学普通话就丢掉自己的母语方言，这是走火入魔。</strong>我们学习自己的语言既是对自身价值的认可，也是我们定义自己特征的一个重要方式。目前我们教育最大的一个问题就是同质化，什么都要大同，消除特色，消灭不同，从学校里面出来之后都成了一个模样，毫无特色，像是工厂生产出来的产品一样。这是让人觉得很悲哀的一件事，这也是我们国家创新能力枯竭的一个重要原因，只在一个标准下认可好与不好，而不是在大的范围内认可不同人的特点和区别。其实我们应该尊重特色，容许百花齐放，这样才能更好的发展。</p><h4 id="6、南昌话是一门技能"><a href="#6、南昌话是一门技能" class="headerlink" title="6、南昌话是一门技能"></a>6、南昌话是一门技能</h4><p>掌握任何一门语言都是掌握一门技能，多掌握一个技能就多一条发展的道路，这个道理象鼻非常浅显。</p><p>就像学习英语一样，我们为什么要学习英语，就是为了多一门技能，以便在未来某个时点需要的时候能用的上。说白了，我们从小学英语就是在为将来作技术储备。<strong>南昌话作为一门语言，我们也完全可以把它看作一项技能，而且它比英语的适用场景多了太多。掌握好这门语言，它就是会成为你的财富，在某些场合，某些时间点，你都会发现它可能大有用途。</strong></p><p>学语言的目的是为了交流，学英语我们没有交流的环境，但是学南昌话可就不一样了，我们除了跟家人，还可以跟朋友，同学使用。以后工作了，或者去到外地了，去到国外了，遇到同乡的人，说上几句家乡话，特别亲切。或许在某些特殊场景下别人会因为你的乡音而对你好感特发。像我这种，碰到会说南昌话的老乡，就觉得特别亲切。</p><p>不仅南昌话是一门技能，而且这项技能是可以轻易获得的。这得益于我们有天然的语言环境。我曾经有个小表弟，从小也是家长不教南昌话，然后上小学的时候，让婆婆（只会说南昌话）带了一个暑假，那南昌话就说得很溜了。说白了，有语言环境的加持，再加上小孩子在这个时期可塑性极强，掌握南昌话基本上就是一个白送的技能包。不会有人认为多掌握一门语言是一种负担吧，这个世界不可能有人会因为你会说家乡话而看低你，如果真有这样的人，那是他的问题而不是你的。我相信相信大多数人只会因为你是南昌人却不会说南昌话而怀疑你的能力。毕竟，<strong>有天然的语言环境，你都学不好一门母语方言，我很难相信你的学习能力能有多好。</strong></p><p>而且，<strong>如果不学好自己的南昌方言，你相比那些会上海话和普通话的上海人，会广东话和普通话的广东人，以及所有那些掌握自己方言和普通话两种语言的人（两开花）来说，你就有天生的缺陷。</strong></p><p>很多人小时候不学南昌话，等长大了，出门在外工作了，事业功成名就了，又去寻根，学南昌话，那可是真就太难了，而且，那真是本末倒置了。</p><h5 id="最后，做个总结。"><a href="#最后，做个总结。" class="headerlink" title="最后，做个总结。"></a>最后，做个总结。</h5><p>其实我不想把文章写得太长（已经一万字了，此处再砍掉了一万字！)，对读者的负担有点大，而这篇文章主要也是针对许多为人父为人母的家长所写的，如果你愿意坐下来好好思考一下是否该学南昌话，那么就真的应该好好读一下这篇文章，进行一下思考。</p><p>总的来说，我并不是要强迫南昌人一定要学好南昌话，虽然我非常提倡。但是每个人的具体情况是不一样的，比如有些南昌人已经移居外地，缺乏说南昌话的场景，那么考虑到实际情况教小孩说南昌话会遇到一些困难。但是，你要知道，我们在海外有大量的华人，它们即使移居国外，仍意识到教授小孩中文的重大意义，我们有什么理由不像他们学习呢。所以，我仍然建议在小孩可塑性强的时候学好它，在天然的语言环境优势下，它几乎就是一个白送的技能。这样你从小就能数量掌握母语方言和普通话两种语言，何乐而不为。</p><p>最后，<strong>但是不管哪种情况不学南昌话，我都希望不是因为觉得南昌话不好这个理由而不学它。因为这是站不住脚的，是知识浅薄、见识低和自我矮化的表现。</strong>南昌话相比北方语系特点的普通话，有着数千年历史的沉淀，它的表达方式多样，用词形象生动，在国内七大各大方言种类中，具有独特的魅力。<strong>我们应对自己的母语方言自信，去传承它，而不是诋毁它。</strong></p><p>最后，感谢您的阅读！</p><p>全文完！<br><br></p><blockquote><p>注：我制作了一个常见的南昌话的方言汇总，虽然远远达不到很全的程度，但是基本覆盖了日常生活中大部分比较常见的南昌话表达。有兴趣的读者可以去看一下。</p></blockquote><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> 南昌 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文化 </tag>
            
            <tag> 方言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南昌方言表达方式汇总</title>
      <link href="/%E5%8D%97%E6%98%8C/nanchang-nanchang-vocab/"/>
      <url>/%E5%8D%97%E6%98%8C/nanchang-nanchang-vocab/</url>
      
        <content type="html"><![CDATA[<h2 id="介词-Preposition"><a href="#介词-Preposition" class="headerlink" title="介词 Preposition"></a>介词 Preposition</h2><p>介词又叫前置词，后接名词、代词等，表示该词与句中其他成分的关系（比如时间、地点、方式、原因、数量）。介词不能单独使用。<br>比如，汉语中最常见的介词有：在那时；在那里，向前走；通过这种手段，依我看，把我灌醉，被人尊敬，关于这件事；为你鼓掌，为了胜利；超过半数。<br>任何语言中，介词都是比较稳定的词，不太会出现变种。南昌话与普通话的区别主要体现在读音上。</p><p>在    —    在<br>读 chèi，或“类”，或“得”，属于语系内口音变化（比如近郊口音），有点类似于英语中 thank you，而印度人发音发成 dank you 的感觉。</p><p>依    —    榨<br>依照、沿着的意思。例：“榨我话个做就够了”，“榨都个条路一径里走”。</p><p>往    —    往<br>读 mòng ，例：（道别时）恁往哪里走？</p><p>被    —    驮<br>例：嫩想驮打系啵？</p><p>让    —    让[niòng]<br>例：我还小，让嗲子我撒。</p><h2 id="语气词-Interjection"><a href="#语气词-Interjection" class="headerlink" title="语气词 Interjection"></a>语气词 Interjection</h2><p>语气词通常包含祈使，感叹，拟声等用来加强语气的词。这里列举最常见的具有南昌话发音特点的语气词。</p><p>语气词</p><p>哇塞         —   哇呀也<br>我擦         —   饿啜<br>这             —   隔[ga]（表语气。表示对当下既成事实的一种无可奈何而又不得不接受的感觉，通常这种事实的发生是突然的或意料之外的，让人无奈，甚至有些茫然不知所措。例：“夹要死，钱落不了”，“夹切了货”，“夹郎办”，“夹总满意了撒”。）<br>这下完了   — 夹切了货/夹脱了卵<br>吃去死     — 恰切死 （表示不值得吃的语气）<br>吃得作呕    — 恰得做鸟（同上，不值得吃）<br>玩去死     — 聂切死 （表示不值得玩的语气）<br>真是的     — 秃系个/壳系个（表示埋怨的语气。例：嫩硬壳系个，让嗲子佢[jié]不好啊。）<br>算了         — 脱卵（表示不计较。例：“脱卵，不要跟佢计较”。也可表示完蛋了的意思。如：嘎脱了卵。）<br>这样         — 个样（也可连读成“港”，类似普通话中的“这样”连读成“酱”。）<br>没话说     — 么有话（话读 wà，么有话可连读成“谬[miǔ]话”。例：既然港样，饿谬瓦。）<br>那样         — 黑样<br>怎样         — 郎样<br>也对啊     — 也系（例：也系 ho，饿郎毛想到啊！）</p><h2 id="名词-Noun"><a href="#名词-Noun" class="headerlink" title="名词 Noun"></a>名词 Noun</h2><p>主要包括动植食物，工具物品，时间地点，以及与人相关的名词（比如：身体部位、疾病、职业等）</p><p><strong>动植食物</strong></p><p>青蛙      —     蛤马/客[kiè]马<br>蝌蚪      —     蛤蟆林子<br>壁虎      —     壁蛇子<br>麻雀      —     奸雀子<br>蝉          —     嘉劳子<br>蝙蝠      —     檐老鼠<br>公鸡      —     样鸡<br>母鸡      —     闲鸡<br>蚯蚓      —     寒斤子<br>虱子      —     色<br>乌龟      —     博涅<br>草鱼      —     晚鱼（学名“草鱼”或“鲩鱼”）<br>青鱼      —     铁头晚（比草鱼略大，头更尖）<br>鲫鱼      —     泽鱼<br>毛毛虫  —     毛辣子/毛辣里<br>牛舌头  —     牛招台</p><p><em>以下注意读音</em></p><p>猪          —     猪[jù]/猪咕里（养猪 — 看猪）<br>牛          —     牛[niáo]/牛咕里<br>虾          —     哈<br>蛆          —     吹<br>螃蟹      —     螃孩<br>树        —     续<br>生姜      —     僧姜<br>草莓      —     草迷<br>茄子      —     qiá子<br>荸荠      —     鼻舅<br>糯米      —     洛米<br>花生      —     发[fà] 僧<br>冰棒      —     冰胖<br>锅巴      —     窝巴<br>鸡蛋      —     鸡叹<br>豆浆      —     透浆</p><p><strong>时间</strong><br>时间      — 时[xi]间<br>很早      — 清时[xi]蛮早<br>晚        — 晚（读“腌”）<br>很晚      — 灭晚<br>傍晚      — 断夜边子<br>中午      — 中午边子<br>上午      — 上揪<br>下午      — 下揪<br>除夕      — 三十夜晚</p><p><strong>地点</strong><br>村子      — 村盘子/盘子<br>巷子      — 巷子[hàng]<br>家里      — 屋里<br>美国      — 米国<br>瀛上      — 瀛[liáng]上（南昌西边的一个地方，那里有南昌最大的墓园。例：不听话的话，饿就叮嫩到瀛上切。）<br>客厅      - 堂瓦里</p><p><strong>身体部位</strong><br>眼珠      — 眼睛居里<br>眉毛      — 迷毛<br>鼻子      — 鼻[pi]公<br>舌头      — 涩头<br>牙齿      — 牙期<br>胡子      — 无子<br>颈        — 颈[jiǎng]拉里<br>胸脯      — 胸面下<br>奶        — 来[lǎi]<br>背        — 背夹<br>肋骨      — 肋八骨<br>痂        — 咖[ka]（满头的咖）<br>手        — 手[xiǔ]<br>手指      — 急头子<br>手指甲    — 急生<br>拳头      — 捶头<br>手臂      — 噶骨里<br>腋下      — 嘎拉里<br>腿部      — 脚骨里<br>小腿肚    — 鱼鱼肚子（鱼读“nié”）<br>脚        — 脚[jiō]<br>脚趾      — 脚急头子<br>脚趾间    — 脚急牙里<br>腹股沟    — 卡里/卡拉里<br>屁眼      - 屁股牙里<br>屄        — 憋<br>屌        — 裸鸡/卵<br>包皮      — 卵皮子<br>污垢      — 狗刮</p><p><strong>疾病</strong><br>癌症      — 严病<br>疝气      — 气鼓卵<br>疟疾      — 打摆子<br>中暑      — 中许<br>脑膜炎    — 老麻炎 （也形容喜欢乱说话的人）<br>近视眼    — 近系眼<br>斜眼症    — 嗲眼里<br>打针      — 打今<br>吃药      — 恰药[yō]<br>生病      — 生病[sàng biàng]<br>治病      — 诊[zǎng]病</p><p><strong>职业</strong><br>流氓/地痞      —       罗汉/赤膊罗汉<br>混黑道的       —       打罗的<br>收二手废品     —       换方<br>生意人         —       窝倌哩<br>叫花子         —       告化里</p><p><strong>其它</strong><br>衣服      — 衣裳<br>汗衫      — 汗褂里<br>裤子      — 苦里<br>鞋子      — 孩里<br>袜子      — 挖子<br>背心      — 背搭子<br>内裤      — 裤头子<br>奶嘴      — 奶吸[ji]子<br>零钱      — 零哥子/零毫子/刨皮子<br>纸        — 几<br>小板凳    — 痦子<br>座位      — 位子<br>绳子      — 形子<br>被子      — 劈货<br>太阳      — 逆头<br>扑克      — 博克<br>火种      — 火帚[ju]<br>碎屑      — 恶屑<br>扫帚      — 扫帚[ju]/苕帚/苕帚棍里<br>棍子      — 条棍子<br>拐棍      — 拐棍里<br>鞭子      — 扫里（打人用的条状物）<br>珠子      — 珠里/珠珠里/珠古子<br>石头      — 摩罗谷子<br>杯子      — 把碗<br>勺子      — 瓢子/瓢杆/瓢棍<br>麻球      — 麻圆<br>煤球      — 煤烂<br>池塘      — 塘（例：屋里门口有口脱大个塘）<br>船        — 算 [suan]<br>陷阱      — 猫眼屎[xi]<br>窗户      - 格子<br>鹅卵石    - 磨罗股子</p><h2 id="代词-Pronoun"><a href="#代词-Pronoun" class="headerlink" title="代词 Pronoun"></a>代词 Pronoun</h2><p>代词是用来代替名词、动词、形容词、数量词、副词的词。可分三类： 人称代词， 疑问代词，指示代词。</p><p><strong>人称代词</strong><br>我             —    饿/饿恁<br>你             —    恁(nεn)/嫩<br>他             —    佢/佢[ji/jie/gie]<br>自己         —    自简[gan]<br>我们         —    饿嘎/饿咚<br>你们         —    嫩嘎<br>他们         —    佢嘎<br>你家         —    嫩屋里/母里<br>我家         —    饿屋里</p><p><strong>疑问代词</strong><br>什么         —    什[xi]哩（做什哩/恰什哩）<br>谁             —    哪[lǎ]个<br>怎么         —    郎样</p><p><strong>指示代词</strong><br>这           —    个[gǒ]/个里<br>那           —    嘿/嘿里<br>这样         —    港样/个样</p><p><strong>数量词</strong><br>五           —    哼[hen]<br>多少？       —    几多？<br>一个         —    一杂<br>一袋         —    一弟<br>一点点       —    一滴滴子/一米米子/一朵朵子<br>很少         —    嗲嘎子/嗲把子<br>没有         —    冒有<br>全是         —    庆系（全是，到处是。例：不要捂得手上庆系油）<br>这么多     —    个多<br>这么少     —    个少<br>一顿         —    一餐（例：冇写作业，驮爷娘打了一餐）<br>一坨         —    一朵（例：一朵屎）<br>一泡         —    一泼（例：一泼尿）</p><p><strong>称呼</strong></p><p>男人      -   男夹火(哩)<br>女人      -   女夹火(哩)<br>老头      -   (老)棺材<br>老太婆     -  老妈子/老妈里<br>师傅      -   老坐<br>年轻人     -  老短<br>年轻人     -  短命鬼子<br>20多岁的人      -   二多子<br>30多岁的人      -   三多子<br>40多岁的人      -   四多子<br>男孩子     -  崽俚子<br>女孩子     -  女崽子<br>小孩子     -  细伢子/细宁子<br>婴儿      -   猫伢子<br>爷爷      -   嗲嗲[dià]<br>奶奶      -   婆婆<br>爸爸      -   爷[yá]<br>妈妈      -   娘[nióng]<br>父母      -   爷娘<br>舅舅      -   母舅[qiù]<br>侄子      -   侄[qì]子<br>弟弟      -   老弟/老老<br>夫妻俩     -  俩八老子<br>媳妇       -   新妇<br>女朋友     -  马子/波子<br>男朋友     -  凯子<br>活宝      -   元宝<br>傻子      -   森头/鹅头<br>男傻子     -  咖头<br>女傻子     -  咖婆<br>蠢孩子     -  森崽<br>坏孩子     -  憋崽子<br>妖精      -   精[jiàng]怪<br>老和尚     -  老博涅</p><h2 id="形容词-Adjective"><a href="#形容词-Adjective" class="headerlink" title="形容词 Adjective"></a>形容词 Adjective</h2><p>主要列举一些表述物理特征、性状以及一些抽象状态的形容词。</p><p><strong>特性/状态</strong><br>厚           —   哒厚/腾厚<br>薄           —   奢薄<br>轻           —   飘轻/旁轻<br>重           —   脱重/腾重/的重<br>软           —   东软/溜软<br>硬           —   邦硬/敲硬<br>冷           —   冰冷<br>冰住的        —   愣住（因天太冷而被冰冻僵结冰）<br>热           —   忽热/骨热<br>烫           —   飞滚<br>松           —   乓松<br>紧           —   给紧/铁紧<br>麻           -   给麻（读 “giè” 或 “kiè”）<br>脆           —   博脆</p><p>有嚼劲        —   揪韧<br>有韧性        —   宁揪<br>劲道足        —   杀（形容酒度数高/刺辣感/劲足）<br>好吃         —   好恰/好来事<br>烂           —   夸烂/夜烂<br>腌           —   腌（读“鹌 àn”）<br>蔫           —   蔫[niàn]<br>干           —   焦干/邦干<br>湿           —   辣湿<br>脏           —   腌赞（读“牙渣”）/腌里八赞<br>太脏         —   糗了稀/扒了窝/结了壳/生了疮/脏不垃圾<br>软韧         —   韧[nìn]了（食物受潮变软）<br>严实         —   聂实[xi]<br>刺热         —   沾（火焰刺热，也表示光线太亮而刺眼。例：火太大了，沾得眼睛好难受）<br>圆           —   纠圆/纠古搭圆/秃圆<br>尖           —   溜尖<br>粘           —   哒粘<br>滑           —   咧滑<br>嫩           —   富嫩<br>平           —   沙平<br>快           —   风快<br>大           —   脱大/脱古脱大<br>小           —   嗲子大<br>小           —   嗲眼大子/滴眼大子/咪眼大子<br>斜           —   斜[qiá]/嗲[diá]（嗲眼里）<br>浓稠         —   念（例：个扎圆珠笔好念）<br>浓稠         —   泣/的[dèi]泣（例：这锅粥弄得的泣）<br>稀           —   霞（例：屙了霞屎里）<br>糊           -   剁糊<br>溢出         -   泼<br>满           -   撇满</p><p>东西破烂        -   耶丝垮烂<br>物件表面非常粗糙 - 麻里企刻<br>环境冷清       - 冰冷悄静，肃[xiu]静</p><p><strong>颜色</strong><br>红色       —   宣红<br>黄色       —   森黄<br>绿色       —   桔绿<br>紫色       —   肚紫<br>白色       —   雪白<br>黑色       —   蔑乌/蔑黑/蔑骨搭黑<br>透明       —   町清<br>亮           —   当亮/框亮<br>暗           —   灭暗</p><p><strong>味道</strong><br>甜           —   鲜甜<br>酸           —   纠酸<br>淡           —   刮淡<br>鲜           —   劈[pī]鲜<br>腥           —   鳖腥<br>咸           —   叮寒/溜咸<br>臭           —   学[hō]球<br>香           —   棚[pùng]香<br>辣           —   拨[bò]辣<br>馋死人   —   侯死人/浅死人（不仅可以指食物美味令人嘴馋，也可以指其它事物令人眼馋）</p><p><strong>抽象形容词</strong><br>真           —   今<br>假           —   噶[gǎ]<br>真品的   —   见/全见<br>假冒的   —   万<br>真货的   —   全见带把/全见不带万<br>境况好   —   跑火（例：生意好跑火。）<br>隐蔽       —   间[gan]（例：把东西藏得好间）<br>好听       —   听得一哈子<br>好玩       —   聂得一哈子<br>真品       —   见货/见根里<br>假货       —   万老八/万根里</p><p><strong>人的外貌</strong><br>漂亮     — 咳[kiè]气<br>丑       — 长得巴了窝<br>丑八怪    — 糗憋怪<br>五官正    — 平整/端[duō]张（例：长得端张）<br>皮肤嫩    — 富嫩<br>脸圆     — 纠圆（纠圆的脸/纠圆的屁股）<br>脸尖     — 溜尖（溜尖的下巴）<br>牙黄     — 生黄（生黄的牙期）<br>长发     — 修长（修长的头发）<br>粗腰     — 藤粗（藤粗的腰）<br>白         — 雪白[pa]<br>黑         — 灭黑/灭鼓哒黑<br>瘦         — 坑[kang]瘦/坑精鬼瘦<br>壮         — 哒壮<br>胖         — 哒胖<br>高         — 莽<br>矮         — 矮（例：矮子鬼/矮崽子/矮婆里）<br>斗鸡眼     — 豆屎眼<br>斜视症     — 嗲眼珠里<br>歪         — 趔（嘴歪了就说“嘴趔了”）<br>长相不端正   - 歪头劣脑<br>牙齿不齐    - 赊牙咧齿（延伸指物品破烂）<br>脸上脏乱    - 乌毛煎糟<br>邋遢       - 也脓剐泄</p><h2 id="形容人个性特征或状态"><a href="#形容人个性特征或状态" class="headerlink" title="形容人个性特征或状态"></a>形容人个性特征或状态</h2><h3 id="褒义"><a href="#褒义" class="headerlink" title="褒义"></a>褒义</h3><p><strong>智商</strong><br>聪明          —  精灵<br>脑子灵活  —  得转</p><p><strong>能力</strong><br>历害          —  结棍<br>厉害          —  煞火<br>厉害          —  恰架<br>厉害          —  辣/煞辣（玩得辣）<br>出色          —  来事 （例：“她弄菜的手艺好来事! ” ，“昨天的演出好来事！”）<br>麻利          —  撇脱（做事干净利索）<br>快           —  涪叫（有种虎虎生风的动感）</p><p><strong>性格品行</strong><br>说话很甜    —  嘴妈子摸了油<br>光说不做    —  帕雀<br>心狠          —  杀辣（多用于女子）<br>性格温和    —  善<br>幽默的      —  好罗<br>搞笑的      —  左 [zié]<br>（表示说的话、做的事，或个性很搞笑，很有意思。例：“恁好左啊”。<br>也做动词，表示“骗，耍”。例：恁不要左饿。）</p><p>老老实实    - 一老朴实<br>老实       - 老搭老实<br>为人不塌实  - 狭皮</p><p><strong>贬义</strong><br>智商</p><p>憨            —  酣（酣包）<br>傻            —  森/鹅（森头/森头耷脑/森叫）<br>不灵活       —  不得转（脑子不灵活/不开窍）<br>呆慢        —  癌/木（癌病/木根里，癌心病。形容做事拖拉、墨迹。）<br>磨蹭拖延     - 癌七癌八<br>木讷        —  木/锯[giè/kiè]木（脑子不灵活）<br>木讷        —  眠（脑细胞在休眠，形容人脑子迟钝。例：眠猴。）<br>很蠢的人     — 森头/鹅头/愚子<br>古怪        - 蹊跷古怪</p><p>能力</p><p>差           —  梭（能力差，性格软弱，小家子气。例：这都不敢去，好梭。）<br>慢           —  佛/换[fuàn]（做事慢）<br>累赘的人      —  利息货<br>差劲的人      —  鼻屎<br>做事慢的人    —  慢性病<br>手脚苯拙      - 瘸手拐脚</p><p>性格品行</p><p>性格冲        — 冲[chǒng]/桑 [sàng]<br>性格犟        — 龌龊（性格犟，难驯服，蛮不讲理。例：佢屋里崽好龌龊，不听话。）<br>脾气拗        —  郎抗（性格乖张，难沟通，难教导。例：恁不要在个里跟我狼狼抗抗，小心我一巴掌敷死恁切。）<br>脾气拗        —  邪（脾气拗、坏。例：恁郎港邪，瓦都瓦不装是。）<br>脾气拗        - 熬烈<br>泼辣          —  麻辣<br>缺德          —  绝（坏事做到极致）<br>缺德          —  雀博（心眼坏，做事恶劣。例：佢拿宁嘎自行车气门芯子拔掉了，好雀博）<br>污蔑人的       —  牙黄口臭（表示故意说一些无中生有的事来污蔑或冤枉人。例：恁不要在这里牙黄口臭，无中生有。）<br>吝啬          —  色 [sē]<br>吝啬的人       —  色鬼子<br>爱吃          —  虽<br>吃            —  好[hǎo]恰（佢相当好恰）<br>吃货          —  好恰鬼/虽鬼子（例：佢不晓得几好恰，硬系扎虽鬼子。）<br>不值得吃       - 恰得做梗/恰切死/头世冒恰过<br>邋遢          —  也泄（邋遢、不爱干净的）<br>邋遢鬼        —  也泄鬼（例：一个月都冒洗澡，好也泄。）<br>邋遢          —  辣答（脏，有时也形容人说话很脏。有时称女人为“辣答憋”。例：我不跟恁个扎辣哒鬼话事。）<br>调皮          —  秀[xiū]/秀皮（调皮，爱玩）<br>太调皮         —  秀皮铁哒（调皮程度更甚）<br>脸皮厚不怕人讨厌 - 耶皮刮脸<br>阴险          - 阴死痨病<br>瘟神          —  瘟性<br>爱惹祸的人     —  祸钵兜子<br>难相处的       - 结赖/结结赖赖（比如某人难相处，很麻烦）<br>留下          - 洛扎<br>留不下        - 不得落扎（形容乱跑，不停留）</p><h2 id="动词-Verb"><a href="#动词-Verb" class="headerlink" title="动词 Verb"></a>动词 Verb</h2><p>这里列举的动词主要与人相关，主要用来描述状态、行为或抽象动作。</p><p><strong>嘴巴动作</strong><br>说         — 瓦（瓦事，瓦什哩。还经常用于埋怨之意。例：佢晓得错了，不要紧瓦佢）<br>讲         — 雀（例：不要病得乱雀）<br>吸         — 吸[ji]<br>吮         — 寸（比如吸吮冰棒的时候，就叫寸）<br>吃         — 呷/恰（南昌人不分固体液体汽体一律用恰，恰烟/恰酒/恰茶/恰饭/恰得古饱）<br>吃素       - 恰斋<br>咬         — 得[dè]（不要得我—不要咬我）<br>塞         — 足（例：佢恰饱了，不要再足佢恰了）<br>张开口     — 牙开口<br>开口      — 住脊（常用在否定语中。例：老师话事的时候，嫩不要住脊！）<br>开口      — 开脊（例：只要嫩开句脊，我保证帮嫩办到）<br>作呕      — 作鸟（例：哈死巴宁，吃得作鸟啊）<br>痛得叫    — 呱[guié]叫/竭[jié/jiè]叫<br>打嗝      — 打 giè<br>鄙视      — 啜骂（例：嫩不要在个里啜骂宁）<br>骂骂咧咧   — 啜啜骂骂<br>挑肥拣瘦   - gan精to肥<br>讨好      - 讨好卖乖<br>不断欺骗   - 提七提八</p><p><strong>眼睛动作</strong><br>看          — 期/相/芒<br>斜眼看      — 嗲（例：嗲了一眼）<br>瞪          — 愣</p><p><strong>鼻子动作</strong><br>闻          — 熊<br>擤鼻涕  — 省[sěn/xǐng]鼻涕</p><p><strong>手部动作</strong><br>推         — 宣（例：我驮佢宣得搭了一跤）<br>挤         — 耕<br>突拉     — 嗲[dia] （表示突然发力的拉扯）<br>扯         — 哋[dè]（例：不要哋啊哋，我跟嫩又不西好熟！)<br>系         — 挮[tiā]（例：挮紧鞋带）<br>指         — 约（例：手不要乱药，约手匡脚）<br>抱         — 孪（例：佢两人关系不晓几好，一见面就孪都不放）<br>绑         — 顾（例：顾得给紧，顾紧些子）<br>戳         — 嘟（例：嘟佢一下看得佢困着了啵）<br>搓         — 凌（比如两张纸粘在一起，需要用手搓动它们使其产生缝隙，以便分开。这个动作就叫“凌”）<br>掐         — 咖（例：不要咖我的颈）<br>压         — 蜡（表示用手指压住，按住）<br>顶         — 堵（例：嫩堵都前漏，我抽到后漏）<br>擦         — 揩（揩油的揩）<br>拧         — 撅（例：让你乱雀，我撅烂嫩的嘴）<br>拧         — 纠（例：螺丝太紧了，我纠不动）<br>抬         — 抽（例：抽我一把）<br>抡拳打 — 挛[luān]（例：有人欺负嫩系啵，我帮嫩挛佢）<br>掌掴     — 敷/劈[pia]/搭（例：跟我在葛里装风，一把夫死嫩且/一把搭得过且）<br>砸         — 特（例：拿石头特死嫩切）<br>挠         — 择（例：择痒/择破了皮）<br>端         — 夺（例：夺碗饭来恰）<br>盛         — 添（例：添碗饭恰）<br>夹         — 捻（捻菜吃，表示用筷子夹菜吃）<br>扛         — 洒[sa]，典型的南昌话发音特点，发声的时候要快速收音。例：个弟水泥腾重，我洒不起哦）<br>锯         — 锯（例：把木头锯[giè/kiè]断）<br>撕         — 资[zì]/择 [zèi]<br>扔         — 叮[diáng]（例：叮掉个些垃圾）<br>扔         — 料（例：料得捞远）<br>碰         - 着（例：嫩不要着佢）<br>玩弄       — 咪（例：黑扎猫驮佢咪死了）<br>插秧       — 栽禾[wó]</p><p><strong>脚部动作</strong><br>蹲         — 跍[kú]（例：跍得地上屙尿）<br>站         — 企[qì]（例：企得饿脚骨里发软）<br>踢         — 键（例：驮人键了一脚）<br>踢         — 占（例：占死嫩去）<br>扫         — 逛（例：一脚逛嫩到黑边且）<br>踹         — 冈[gàng]（例：一脚冈嫩到黑边且）<br>跳         — 纵（例：纵得脱高）<br>溜         — 贤（例：情况不妙，扎戏贤）<br>张开     — 沙开（例：把脚沙开些）<br>摔         — 搭（例：走路踢到石头，搭了一跤）<br>追         — 搔（例：司机啊，帮我搔到前漏黑扎车子）<br>绊         —  款[kuàn]（例：“走路驮绳子款得搭了一跤”，“两个人款得手走路”）<br>搓         —  犁（用脚趾在地上转动或搓动，以便犁出一道缝）</p><p><strong>其它动作</strong><br>发抖        — 滂震[jīng]<br>光身子      — 打臊瓜<br>打赤膊      — 打赤[chā]瓜<br>放屁        — 打屁<br>沉          — 秦（沉在水里 — 秦在水里）<br>浮          — 浮[fú]</p><p>试          — 告（例：不要怕，先告一下再作）<br>睡          — 困（例：尼尼夜晚困得好晚）<br>拦          — 短（例：帮我短到佢）<br>赶          — 框/乓（例：框黑个告化里死走）<br>寻          — 孙/勤/群（例：勤东西/勤死）<br>撞          — 腾[tèn]（例：驮汽车腾到了）<br>造          — 槽[cào]（例：造房子/造恶）<br>照          — 射[sà]（例：拿手电筒射一下）<br>玩          — 蹑（例：星期天到饿屋里来蹑啵）<br>撒          — 把（给，撒的意思。例：“把滴子米拿鸡吃。”，另外，还可表示用来帮助婴儿拉屎拉尿，比如“把屎/把尿”）<br>压          — 渣 （例：“为了不让纸被风吹走，拿块脱大石头渣到”，“背着重物，饿快驮杂死了”）<br>聚          — 厄（表聚集状，如杂乱地厄在一起）<br>合          — 割（表合并状，例：合拢—割拢）<br>分          - 拨（例：嫩拨点子到老弟吃。意思是”你分一点吃的给弟弟吃“）<br>粘          — 巴（例：粘住了，巴都了）<br>堆          — 剁[tuò]（例：剁起来，剁得一起）<br>碾          — 切[qiè]（例：驮汽车切死了）<br>抢          — 参（例：帮我参扎位子）<br>亲          — 波/念（例：波一下表示亲一下）<br>惹          — 也[yǎ]<br>怼          — 撑（故意说反对的话来气人，俚语：“一句话撑嫩到壁上”）</p><p>搞乱     — 作（例：作得一屋哈死巴宁）<br>养育     — 看（看居，看狗，如果用在人身上表达沮丧的情绪。例：还不如看条狗）<br>准备      — 坐备[pi]（表示需要花费。例：这房子要坐备蛮长个时间才搭得起来。）<br>做饭      — 弄饭<br>做菜      — 弄菜<br>做事      — 祝事<br>盖房子    — 做屋（同上读“祝”）<br>回家      — 去归<br>种田      — 栽禾<br>耕田      — 冈田<br>砸烂      — 草掉（例：城管草不了佢个房子）<br>地震      — 地进<br>下雨      — 落雨<br>下雪      — 落雪</p><p><strong>舞</strong>是一个万能词，抽象动作，许多行动都能用这个词来引导。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">弄死你             — 舞死嫩切</span><br><span class="line">弄得我好难过        — 舞得饿好难受</span><br><span class="line">使不得             — 舞不得</span><br><span class="line">组装好了/修好了     — 饿舞正了</span><br></pre></td></tr></table></figure><p><strong>行为</strong><br>讲客气          — 作礼<br>赶时髦          — 作习子<br>浪费           — 凡[fuán]（花钱大手大脚/极度浪费）<br>现丑           — 贤世[xī]/嫌细（形容丢人现眼）<br>作对           — 斗把<br>作对           — 走翘步街<br>作对           - 兜老尿（存着隔夜的小便故意不倒（熏你），当然就是在与人作对啦）<br>作怪           - 作怪<br>作死           - 作死<br>寻死           — 勤死<br>惹事           — 也祸/勤祸<br>怂恿           - 雪祸<br>找麻烦         — 找络壳<br>找平衡         — 腾平（形容人计较得失，跟人比较）<br>逗弄           — 兜（表示耍弄、挑逗。例：佢好老实的，嫩不要兜佢。）<br>挑逗           — 杏（挠别人进行挑弄）<br>猜拳           — 㨂[dòng]捶/㨂拳<br>发声           — 发声[sàng]（例：不要在葛里跟我发声，小心我锄死嫩切）<br>犯蠢           — 发森/搭到了头<br>装蠢           — 装森/装鼾/装鼾搭森<br>骗               — 策（例：不要策饿）<br>骗人           — 策谎打白<br>骗人           — 欺[ji]欺左[zié]左（形容人不老实，顾左右而言他，回避重点，故意挑弄）<br>骗人           - 左[zié]七左八<br>赖皮           — 赖死<br>约定           — 腻（例：腻正了就不要变）<br>失约           — 放鸽子<br>约会           — 扎点子<br>做坏事          — 造恶（表示做了不该做的事，或者糊涂的事）<br>耍小聪明        — 玩脑浆<br>故意玩闹        — 装风<br>发脾气          — 发火/发毛<br>耍脾气          — 发邪/作邪/作怪<br>暗示           — 发轮子<br>点破/提示 — 打破司（表示在别人没看懂某事情的时候进行提示或暗示）<br>捣乱           — 打破机<br>吵架           — 港仗<br>打架           — 斗西（多指小孩之间的打闹）<br>斗殴           — 杀点子<br>拼命           — 搏[bǒ]命<br>宰客           — 杀猴子/捉猴子<br>讨好           — 托泡<br>搭讪           — 搭骆驼<br>吹牛           — 唆奅[pao]<br>聊天           — 谈讬[tó]<br>拌嘴           — 嚼牙膏<br>咒骂           — 纠<br>瞎讲           — 瞎雀/病得雀/雀病话里<br>胡说           — 乱雀<br>走后门         — 觘[chǎo]角<br>赊账           — 萨帐<br>拉屎           — 屙屎[xǐ]<br>擦屁股       — 揩屎[kai xǐ]<br>流脓           — 问脓<br>烤火           — 炙[za]火<br>游泳           — 划[fá]水<br>睡觉           — 瘫西/困告<br>做梦           — 眠梦（有时用来形容人在做白日梦，想法幼稚。）<br>做爱           — 啜憋<br>亲嘴           — 念嘴/打波<br>告诉           — 告送<br>逼迫           — 讹 [eó]（例：佢不喜欢个事，嫩不要讹佢做撒）<br>骂人           — 啜骂（引申为贬低/嘲笑的意思）<br>旧事重提   — 嚼蛆（不好的往事/恩怨重提）<br>威胁           — 磨汗（威胁性的说）<br>爱惜           — 惜惜旧旧<br>离开           — 走鱼/走驮（表示情况不对，需要撤离。比如没见到预期的人，或者身处险境，需要从这种处境下离开。）<br>逛街           — 框街/荡街<br>和水泥         — 打飞面（和水泥铺地面）<br>摔打物品       - 搭盆搭钵（摔打物品发泄气愤）<br>搬弄是非      - 学嘴学舌（形容背地里传话，搬弄是非）<br>仗势欺人      - 强横[wang]霸道<br>贸然唐突      - 冒搭冒失<br>不断欺骗      - 提七提八<br>不正经        - 罗七罗八<br>行为不端      - 七舞八lia/七弓八lia/七舞八港[gang]（形容品行不好，喜欢跟人吵架、闹矛盾或做坏事的人）<br>讲话罗嗦      - 低低得得（形容说话啰嗦不得要领）<br>挖空心思      - 搂搂钻钻<br>做琐事        — 咪咪咔咔[ka]/咪咪摸摸（形容人埋头做无谓的琐事）<br>零碎东西合拢   - 割割拢拢<br>背地乱议论     - 七七雀雀<br>养猪          - 看猪<br>放牛          - 样[yiāng]牛<br>打麻将        - 搓麻<br>旧事重提      - 呕屎（比喻吵架时翻起过往的纠纷、仇事、恩怨，甚至添油加醋。）</p><p><strong>感觉</strong><br>痛                 — 侵痛<br>酸                 — 纠酸/捞留（手/脚/背很酸）<br>无头绪              — 一头给紧<br>吓人的              — 哈宁嘎里</p><p><strong>心理活动</strong><br>得意           — 醒/醒得为死<br>担心           — 革/着革<br>害怕           — 佛/着佛/着吓[hā]<br>羡慕           — 候<br>馋/嫉妒        — 欠/着欠（例：看到别人有好恰个东西，有嗲子着欠。）<br>生气           — 着气<br>火冒三丈        - 坟头的火<br>着急           - 着急</p><p><strong>态度</strong><br>认真             — 拧真[jìn]<br>严肃认真         — 作固拧今/作固认真<br>认真地           — 正搭八气（形容正规，正式，严肃认真对待）<br>敷衍             — 敷衍了事<br>总错解话语        - 郑东郑[cang]西/郑七郑[cang]八<br>故弄玄虚          - 作兴作么[me]（形容故作玄虚、故作神秘）<br>讲多余或不该讲的话  - 多事劳谈<br>横蛮的样子        - 横眉竖眼/横皮咧眼<br>胆大妄为          - 天聋地哑（形容胆大妄为、不知利害）<br>没大没小          - 冒大冒细（形容眼里没有长幼尊卑）<br>嚣张             - 桑（形容人神气、傲慢、嚣张。比如“好桑”，“表得几桑”，“发桑”）<br>故意摆谱         - 作巧（故意摆架子。“巧”也用来形容人或商品很受欢迎，很抢手。）<br>故意摆谱         - 提[tiá]堂（故意形容人被满足要求之后，又提高价码故意为难、作对）<br>做作            - 作新作濹</p><p><strong>状态</strong><br>说好了的     — 瓦张了(个)<br>约定好的     — 腻张了(个)<br>放纵的         — 亡了形（表示压抑的状态在得到解放或释放后而兴奋过度的放纵、放松行为)<br>懒洋洋的       - 阑兴寡意（形容懒洋洋的、兴致不大）<br>生气了         — 着气了/着了气<br>吵了架         — 斗了西<br>遗失了         — 跌不了/落不了/舍不了<br>泄密           — 腥了水<br>露馅           — 抖囊<br>完了           — 切了货/脱了卵/脱了溲<br>中了计         — 驮了搭子<br>被骗了         — 驮了捉（来源于“捉猴子”。南昌话中，用“捉猴子”表示买东西时花了超过真实价值的高价。表示自己被当作猴子一样被人耍了）<br>淹死了         — 捂死了<br>知道了         — 晓得了<br>睡着了         — 困着了<br>喘气          — 端[duō]气（例：累得端气）<br>倒霉           - 倒壳<br>硬撑           - 硬驼<br>撑到了         — 敞[cǎng]到了（表示吃得太撑。例：港多恰个，夹硬会敞死。）<br>烫伤了         — 烙得了<br>转个圈         — 打个都包<br>跑掉了         — 嗦不了<br>跑掉了         — 贤不了<br>脑子坏了       — 搭到了头（通常用来形容做了一件很愚蠢的事）<br>困意浓         — 咪死眼瞌<br>犯困             — 打瞌困（也形容人犯糊涂）<br>糊涂             — 弗（例：嫩郎个弗哦）<br>扭到了脖子        — 熬到了颈<br>夜盲的         — 鸡毛瞎<br>耐我何         — 嗲饿卵/捉我扒皮/捉我脓样<br>露            — 咧（表示衣服未遮好或裤子因松往下掉而导致身体部位暴露。例：“衣裳冇穿正，肉都咧在外面”，“裤子咧不了”。）<br>整洁          — 端[duē]张（例：“穿得端张”，“屋里收拾得端张”）<br>花哨的         — 花鼓隆咚/花鼓叮咚（穿着花哨。例：“穿的花鼓隆咚”）<br>瑟瑟发抖       — 瑟瑟里（因犯错而表现出一种害怕被责备的样子）<br>湿冷          — 侵骨（身体淋了雨导致湿透）<br>再说          — 在着（例：等下在着，佢跑得阴间里切！）<br>慢悠悠         — 慢哒慢系<br>鲜活生猛       - 白活新鲜<br>活泼有生气的    - 白活的<br>人很有福气      - 福气妥妥[to]<br>手脚肢体乱动    - 约手匡脚<br>何必           - 何苦道得<br>欺骗父母       - 策爷策娘（意指什么人都敢骗）<br>自找麻烦       - 瘟猪寻[qín]水<br>失望/失算后的表情 -  白眼一剁<br>东西胡乱一大堆    - 夯不啷当<br>古怪出格        - 翻精撂怪<br>受损失后狼狈样子  - 皮塌毛落<br>一点都不知道消息 - 不得耳信<br>起初           - 起头发始<br>放心，无忧虑     - 安心安意<br>非常轰动        - 轰动叭节<br>半懂不懂/半吊子  - 二五八撑<br>自投罗网        - 送肉上砧<br>方方正正        - 四四登方<br>隔三岔五        - 三日两头<br>一心一意        - 一心一头<br>前俯后仰        - 前纵后仰<br>不知不觉        - 不警不觉<br>没发觉          - 不警觉/没警觉<br>言行靠不住      - 悉悉发发(指人言行靠不住)<br>粗心忙乱        - 悉悉霍霍（形容人粗心忙乱的样子）<br>所有角落        - 间间角角/眼眼角角<br>言行畏缩的样子   - 忍忍缩缩<br>争执/闹矛盾     - 岗岗节节/竞竞岗岗<br>物品杂乱的样子   - 令令郎郎</p><p><strong>人物关系</strong><br>交情深         — 穴货<br>心腹           — 吊刀<br>冤家           — 对头<br>吵了架         — 吵了角（形容冲突，比如还可以表示汽车相撞）</p><h2 id="副词-Adverb"><a href="#副词-Adverb" class="headerlink" title="副词 Adverb"></a>副词 Adverb</h2><p>副词是指在句子中表示行为或状态特征的词，用以修饰动词、形容词、其他副词或全句，表示时间、地点、程度、方式等概念。</p><p><strong>方位副词</strong><br>到处           — 册块/册拉/看拉<br>前面           — 前漏<br>后面           — 后漏<br>上面           — 上漏<br>下面           — 下漏<br>外头           — 外漏<br>里头           — 里漏<br>里面           — 吐里（例：放到碗吐里）<br>底上           — 笃上/笃嘎（例：桶笃上还有滴子）<br>附近           — 近团<br>老远           — 捞远<br>隔壁           — 隔壁 [ga biā]<br>地上           — 地下里（也可连读成“tia li”）</p><p><strong>程度副词</strong><br>非常           — 脱（脱大/脱小/脱快/脱慢）<br>极其           — 有什（常用于贬义，比如：有什难看，有什森，有什慢，有什雀博）<br>好/很         — 黑（黑难看，黑坏）<br>很             — 捞（捞晚/捞酸/捞紧/头捞晕）<br>很             — 几（几恰架，几辣）<br>平顺           — 平整（做人做事很稳/很漂亮），平平整整，熨贴/熨熨贴贴<br>没得挡         — 冒有挡<br>好吃/有劲      — 来事/过劲（例：这酒好来事）<br>到了极致       — 到了句<br>极致的        — 绝（读 què，贬义，形容“坏”。例：做事做得很绝）<br>尽           — 庆（例：不要庆恰一个菜，其它菜也尝尝）<br>极致的好      — 绝杀<br>真的很        — 当今<br>没边没际      — 毛有影[yǎng]<br>头世           — 头西（例：“头西造多了恶”，“这有什么好看的，头西毛看过啊？”）<br>余地          - 望涅（例：”没有望涅“）<br>盼头          - 望头<br>一下子         — 一刻什<br>一直           — 紧（表示没完没了，一直。例：一碗饭紧得黑里恰。）<br>一直           — 一径里（一径里系个种性格）<br>一直           — 定[diàng]（例：记得定了/带定了钥匙。表示要一直记着/一直带着。）<br>好好的       — 好里里（例：好里里个哭系里嘛？）<br>小心点       — 好生子（例：嫩跟佢好生子话撒）<br>故意地       — 特试（例：佢特试港话个，嫩冒听出来呀？）<br>使劲           — 攒劲<br>拼命地       — 森命里<br>拼命地       — 牙命里<br>拼命地       — 搏命里<br>更不用说   — 么撒（例：我有钱都不去那里，么撒没钱）<br>赶快           — 扎戏/风快<br>快点儿       — 骚皮嗲子（同上，表催促）<br>快点           — 得紧带活<br>差点儿       — 差嗲子/差嗲把子<br>破败了       — 凡[fuán]不了（表达哀丧的语气和心情，爷拐不了，娘也病了，这个家嘎硬翻不了。）<br>家里翻了   — 翻斗（吵架时用语。例：嫩屋里翻斗）<br>没什么用   — 冒卵用<br>不罢休       — 不得脱欠（例：已经给嫩买了衣裳，还想买孩里啊，表得个里不得拖欠撒。）<br>安心的       — 慰[yū]贴/一贴<br>脏            — 糗了稀/巴了窝/结了壳/生了疮<br>肮脏          — 腌臜[eà za]/腌里巴臜<br>太脏了       — 哈斯巴人（例：作得屋里哈斯巴宁）<br>做好了       — 捂正了（做好了/组装好了）<br>浑身           — 坟星（例：坟星辣湿）<br>满头           — 坟头（例：捂得饿坟头个气）<br>头脑糊涂     — 糊[fui]头颠脑<br>等一下子     — 打子<br>等下再办     — 打子再捉/等哈再捉<br>听地进       — 张（话不张/教不张）<br>宁愿           — 为愿<br>做得再好也没用   —  扇好也看得卵见<br>整齐妥当        - 熨贴/熨式八贴/熨式二贴<br>慢慢吞吞的      - 慢慢掸掸/慢掸慢掸（形容做事情慢慢吞吞的样子）<br>不断的麻烦      - 结结赖赖<br>现有的         - 晴念/现<br>像            - 呛</p><br>全文完！<br><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> 南昌 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文化 </tag>
            
            <tag> 方言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何看待 COCA 词频</title>
      <link href="/English/english-see-coca/"/>
      <url>/English/english-see-coca/</url>
      
        <content type="html"><![CDATA[<p>COCA 根据词频的统计提供了几个不同数量的词汇表，最大的有 6 万词汇。那么这个词汇表与我们常见的那些比较高阶的比如 TOEFL, GRE 词汇表有什么本质区别？</p><p>这些词表的本质都是基于单词的出现频率，比如 TOEFL/GRE 词汇表，它的选词就是来源于 TOEFL/GRE 这个考试中的试题或材料。那么出现在试题或材料中频率高的自然就会入选，其最大特点就是针对性强，适合应试。而 COCA 取词范围则非常广，而不仅限于某个试题库或材料库，因此更加科学和普遍。</p><p>COCA 只是提供了一个词表，告诉我们，这些词是使用比较频繁的，但是怎么去学习和记忆它们，却没有提供方法，所以这篇文章主要就讲讲该怎么看待这个词表，后续文章还会介绍该如何科学地利用这个词表提高自己的词汇。</p><p>先了解下 COCA 词表的局限</p><p><strong>（1）不是所有的词的“同源异形”都出现在 6w 词频表中</strong><br>比如 libel， 在 6w 词频表中，只出现了 <code>libel</code> 和 <code>libelous</code> 这两个词，其它的比如：<code>libelant</code>, <code>libeller</code>, <code>libelee</code> 等。</p><p><strong>（2）不同的形态出现频率不一样</strong><br>有些词，其源词出现词频靠后，但是它的其它形式却出现比较靠前，比如 <code>abash</code> 出现在第 44303 排名处，但是 <code>unabashed</code> 则出现在 16795 处。<br>同一个单词的不同释义，会出现多次</p><p>类似的，比如 <code>barb（倒钩；带刺的话，讽刺）</code>，它的被动形式 <code>barbed （讽刺的）</code>出现频率更高，<code>protracted （拖延的</code>） 也比 <code>protract</code> 出现频率高，<code>glittering（闪闪发光的）</code> 比 <code>glitter</code> 出现频率高，<code>woven （编织的） 比 weave 出现频率高</code>。这样的例子太多了，我就不一一列举。</p><p>甚至，有些词的词源并没有出现在 6 W 词表中，但是它的异形却出现了，比如 <code>stomp &quot;跺脚，重踩&quot;</code>，不在词表中，但是 <code>stomping</code> 却出现在 27957 处。</p><p><code>hoof “蹄，脚”</code> 也没出现在词表中，但是 <code>hoofed</code> 却在 37256 处。</p><p><strong>（3）某些常见词在 6w 词表中没得到体现</strong></p><p>比如 <code>chore &quot;家庭杂务；日常琐事&quot;</code>，没有出现在 COCA 中年，但它却是托福和雅思词汇。<br>有些词的词频跟感觉相差很远，比如 <code>low-ball</code> 这个词是非常常见的一个词，但是在 COCA 中统计的频率比较低（在 45000 名左右）。</p><p><strong>（4）与 TOEFL/GRE/Vocabulary.com 等词汇表的区别</strong></p><p>GRE 中的很多单词，都出现在 6 万词表中靠后的部分。有些 GRE 单词甚至不在这 6 万词表中，比如 <code>excogitate “认真想出，发明，设计出”</code>。</p><p><a href="http%3A//vocabulary.com">http://vocabulary.com</a> 提供了 12000 的词汇学习。它与 coca 的词频重合度也有区别。比如 <code>lurid “可怕的；色彩耀眼的</code>，就不在 coca 提供的 6w 词汇表中。</p><p>有些常见的事物或概念，在词频中出现可能并不高。比如 <code>isle 岛，小岛</code>。</p><p><strong>（5）词频的可靠性</strong></p><p>coca20000 以后的单词，其频率意义不大，因为差别非常小。<br>coca 提供的最大的词汇本只有 6 W，因此很多词典上的词不会出现在这个词表中。</p><p><strong>（6）有些词出现频率虽然比较高，但是记忆意义不大</strong></p><p>比如 <code>mackerel 鲭鱼，马鲛鱼</code>。这是一种海鱼，我们可能一辈子也见不到也吃不到这种鱼。很难建立直观的联想。所以即使背了，这种记忆也难以长期维持。</p><p><strong>（7）无效单词</strong><br>coca 词频一个很大的问题是，很多在平时单词书中根本不会作为新词进行背诵的单词也被列出了，比如那些缩略词，语气词，数字合成词，甚至有些商品名称等等。</p><p><strong>总结：</strong></p><p>COCA 词汇表不是一份拿来就能直接用的词汇表，它<strong>必须要加以处理</strong>才能变成适于背诵（实用的）的词汇表。</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何看待背单词</title>
      <link href="/English/english-see-vocab/"/>
      <url>/English/english-see-vocab/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要讲一讲背单词的一些方法论。</p><p>单纯拿着一本单词书来背单词是一件枯燥的事，其中的乐趣很少。没有目的性的背单词更是不可取，一是无法坚持，二是没有效果。</p><p><strong>背单词就好像是预习</strong>，阅读、听力或写作就好像是上课。我们在上课前先预备一些知识，以便上课的时候能够更加容易听懂。但是如果我门光预习，但不上课，那么这种预习在长期来看是没有任何意义的。</p><p>英语作为一门语言，它的<strong>学习过程是螺旋前进的</strong>，词汇，阅读，听力和写作的能力是交织联系并且互相促进的，我们没有办法先精通其中一项然后再精通另一项。当你词汇不够的时候，需要补充，到一定阶段之后，你阅读或者听力不够，不能对你的词汇进行正向促进，那么就需要补充阅读和听力，写作也是同理。</p><h4 id="重点单词"><a href="#重点单词" class="headerlink" title="重点单词"></a>重点单词</h4><p>还要认识到，不管你背多少单词，你永远都会遇到你不认识的单词。因此，背单词必须理清轻重缓急。</p><p>那么，<strong>哪类单词需要选择性忽略，而哪些又需要重点记忆？</strong></p><p>通常，名词，特别是专有明年词不会对阅读造成太大障碍（至少不会引起误解）。动词，形容词（副词）是我们需要重点记忆的，因为它们是影响阅读最核心的因素。</p><p>当然，也不是绝对的。比如：某些名词作宾语时，如果不知道意思，也会造成一定的阅读障碍，</p><p>比如：Michael got drunk and had a run-in with the police.</p><p>这里的 run-in 是指“争吵，吵架”。</p><h4 id="构词法"><a href="#构词法" class="headerlink" title="构词法"></a>构词法</h4><p>在词汇量掌握到一定程度之后，我们需要学习构词法，也就是要学会词根及词缀。有了构词法，我们才会不断提高我们对英语这门语言的掌握能力。</p><p>举个最简单的例子，doable 是由 do + able 构成的，根据这个构成法，我们还可以创造很多类似的新词。英语这门语言的词汇每天都在不断增加，最主要就是来自于它的词根的强大扩展能力。如果我们不懂构词法，而总是一味的死记硬背，那么永远都不可能跟上这门语言的发展，也就不可能掌握这门语言。</p><p>当然，对于普通的学习者来说，只是为了快速记住单词，那么并不需要去了解每个单词背后的故事和起源。而且，既然不是词汇研究学家，也没有太多时间精力在词源的学习上。</p><h4 id="背单词就是在认识世界"><a href="#背单词就是在认识世界" class="headerlink" title="背单词就是在认识世界"></a>背单词就是在认识世界</h4><p>背单词不只是背单词这么简单，背单词是一个了解世界，了解美国文化的过程。在背单词的过程中，我们会接触各种各样的食物，比如许多没听过的植物，动物，饮食，机械工具，学科，服装，舞蹈、音乐，体育，医学名词，天文知识，物理、化学名词等等等等，简直是百科大全。所以，背单词不仅仅是背单词那么简单，我们还在扩充我们对这个世界的认识，此外，单词中充斥着美国和西方文化，比如大量的宗教、艺术，政治，（希腊）神话，饮食类的词汇，我们普通中国人对这方面的文化接触甚少，所以在学习这类词汇的时候通常会隔着较大的理解和认知障碍，这是我们需要克服的，最好的办法就是去了解这些文化背景，然后再去学习这些词汇。</p><h4 id="抽象单词与具体单词"><a href="#抽象单词与具体单词" class="headerlink" title="抽象单词与具体单词"></a>抽象单词与具体单词</h4><p>单词可以分为两种，抽象的和具象的。我们应该先重点记忆抽象词。</p><p>Abstract words : home, beauty, freedom, love, peach, hate, truth, chaos, courage, faith, joy, belief, sadness, reality, success, defeat, need, idea, hurt, etc.</p><p>Concrete words: spoon, table, velvet eye patch, nose ring, sinus mask, green, hot, walking.</p><h4 id="单词的难易程度"><a href="#单词的难易程度" class="headerlink" title="单词的难易程度"></a>单词的难易程度</h4><p>先记忆容易的，再记忆难的。</p><h4 id="为什么英文词汇那么多？"><a href="#为什么英文词汇那么多？" class="headerlink" title="为什么英文词汇那么多？"></a>为什么英文词汇那么多？</h4><p>一方面是由英语这门语言的特点造成，另一方面还因为老外喜欢创造新词，举个例子，我们说公羊、母羊，几乎不创造新词，基本都是围绕最核心的羊这个词来进行合成。但是老外不一样，他们公羊用一个词 ram，母羊又用另一个词 ewe，羊又用好几个词，sheep, goat，mutton（羊肉）。这些词之间没有任何关联。大大就增加了外语学习者的学习负担。</p><h4 id="主动词汇-vs-被动词汇"><a href="#主动词汇-vs-被动词汇" class="headerlink" title="主动词汇 vs 被动词汇"></a>主动词汇 vs 被动词汇</h4><p>词汇量断层，有的人喜欢看美剧，然后零零散散积累了一些词汇，跟那些一砖一瓦背下来的词汇肯定有许多断层，也不够系统。</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>英语语料库及词频表介绍</title>
      <link href="/English/english-intro-corpus/"/>
      <url>/English/english-intro-corpus/</url>
      
        <content type="html"><![CDATA[<p>要学好英语，词汇是基础，词汇量的大小和掌握程度是一门语言的基石。而任何知识的学习，都包含<strong>学习材料</strong>和<strong>学习方法</strong>这是两个最核心因素。</p><p>这篇文章主要介绍学习材料。关于英语词汇的学习材料。</p><h3 id="一、大型词汇集（英文语料库）"><a href="#一、大型词汇集（英文语料库）" class="headerlink" title="一、大型词汇集（英文语料库）"></a>一、大型词汇集（英文语料库）</h3><p>顾名思义，语料库就是集合了英语书面和口语等各类英文表述方式的语言材料集合。它收集的英语词汇包罗万象，亘古棉今。是英文词汇的一个大全集合。</p><p>目前最知名的一些大型语料库主要有：GBC，BNC, COCA 等，下面分别介绍：</p><p>GBC, Google Book’s Corpus 1980-2008， 官网：<a href="https://googlebooks.byu.edu/" target="_blank" rel="noopener">https://googlebooks.byu.edu/</a>，拥有 1550 亿美国英语词汇。</p><p><img src="/image/english/google_books.png" alt=""></p><p>BNC - <a href="http://www.google.com/url?sa=t&source=web&ct=res&cd=4&ved=0CB8QFjAD&url=http%3A%2F%2Fcorpus.byu.edu%2Fbnc%2F&ei=wo6_S7-cFI77nAeYrM2WCg&usg=AFQjCNGeAHZ7DKfYUxHInldwiDV_wxcg6Q" target="_blank" rel="noopener">British National Corpus</a>，是有同等影响力的权威语料库，只不过它的选词是来自于英国英语，主要取自 1980 年的各类英文材料。</p><p>COHA, Corpus of Historical American English</p><p>COCA, Corpus os Contenporary American English</p><p>###二、N-GRAM 连词文法模型<br>N-GRAM 是一种连词分类法（模型），它表示一个词组或句子中连续出现的几个词。在人工智能领域，可以通过马尔可夫的概率模型来预测后续出现这些词的概率。 根据连词的数量，可以细分为 unigram, bigram ( or digram), trigram, four-gram, five-gram, etc. </p><p>Google 中的 N-GRAMS 模型采用的选词原则是：由连续的三到四个词组成的一串词（string，可以是句子也可以是一个句子的一部分）在语料库中出现的次数超过 40 次。这个原则又叫 “40 Token Threshold”。这样的好处就是，即使 GBC 的词汇量是 COCA 的 400 倍，但是 N-GRAMS 选出来的 N-GRAMS 数量则几乎一致。 </p><p>下面通过几个例子来理解 Google 的 N-GRAMS 模型。 我们搜索 [<code>j*</code>] groan（注：这里的 <code>j*</code> 表示形容词），可以搜到如下的结果：</p><p><img src="/image/english/google_ngrams.png" alt=""></p><p>下面是 Google 官网给出的 Google N-GRAMS 和 COHA N-GRAMS 的对比，</p><p><img src="/image/english/ngrams_compare.png" alt=""></p><p>解释下 tokens 和 types 的涵义，前者表示 token 总的出现次数，后者表示词组或句子的类型（the number of unique string）。</p><p>可以看到，COHA N-GRAMS 给出的结果中，types 数量要比 Google N-GRAMS 的数量要多。</p><p>简单来说就是，Google 集中，heavy groan 出现了很多次，但是 low groan + heavy groan hollow groan + muffled groan + … 出现的种类没有 COHA 集合中出现的多。</p><p>这种现象在更长的词组或句子中更明显，比如长度增加到 4 grams 或 5 grams，如图：</p><p><img src="/image/english/4n5grams.png" alt=""></p><p>在 2 中，COHA 给出的 types 远远超过 Google 的数量，达到 6 倍之多。可见，Google N-GRAMS 使用的 “40-token-threshold” 这个取词原则也有一些弊端。</p><p>###三、更多语料库：</p><ul><li><strong>Brown Corpus</strong> 100 万词汇。美国英语，1961 年全年，选词来自 15 个类别。</li><li><strong>LOB Corpus - Lancaster-Oslo-Bergen Corpus</strong> 100万词汇。英国英语，与 Brown Corpus 选词方式类似，1970 年编撰。</li><li><strong>ARCHER, A Representative Corpus of Historical English Registers</strong>（<a href="http://www.manchester.ac.uk/archer/" target="_blank" rel="noopener">http://www.manchester.ac.uk/archer/</a>），约 100 多万词汇，包含美国英语和英国英语，选词来自 1600-1999 年期间。</li></ul><p>#####总结：<br>我们可以看到，GBC 的词汇数量是宇宙级的，是 COCA 体量的 400 倍，它包含古今几乎所有出现过的词汇。从这个词汇集里面，我们可以了解几乎所有词根的变迁史。当然，这个天量的语料库对第二语言的学习者而言意义并不大，因为有些词在整个历史中仅出现过 1 词。GBC 官方自己甚至都没法确认这些词是不是完全是拼写错误造成，但是，它也指出，通过这个体量的词汇集与其它流行语料库比如 COCA 的对比，可以排除许多出现频率非常地的词。也就是通过对比比较，可以更加清晰词汇的主流使用范围。</p><h3 id="四、其它词库（SCOWL）"><a href="#四、其它词库（SCOWL）" class="headerlink" title="四、其它词库（SCOWL）"></a>四、其它词库（SCOWL）</h3><p><strong>SCOWL</strong>，Spell Checker Oriented Word Lists</p><p>这个词库主要是基于主流的英语词典制作，主要是用来作为各种英文输入工具的拼写检查的。</p><p>因此它的词库量相对上述动则几百万甚至上亿的语料库要小很多（词典大多是在 20 万左右的词汇数量）。但是，相对的，它也更加精细和准确，取词更加考究和流行。非常适合母语为非英语的人来进行学习和使用。</p><p>之所以介绍这个词库，主要是因为它可以作为辅助词库来帮助我们更好的理解词频和词汇分类，结合其它词频表，我们可以设计出更加合理词汇表来进行学习。</p><p>SCOWL 提供了几个制作好的词库供用户免费使用，其中比较流行的是 12Dict 词库以及它的一些衍生版本，下面简单介绍一下它们。</p><p>12Dict 来源于 n-Dict 项目，目的是以美式英语（American-English）为基础创建一个核心词汇列表。其中，n 是一个变量，表示来源的词库（权威词典）数量，最终被确定为 12。这 12 个词典由 8 本 ESL词典 和 4 本桌面词典组成。最小的包含 20000 条词目，最大的包含 46000 条词目。</p><h6 id="6of12-和-2of12"><a href="#6of12-和-2of12" class="headerlink" title="6of12 和 2of12"></a>6of12 和 2of12</h6><p>6of12 是作者从 12 本中选择了其中 6 本来生成的词汇列表，这个列表大约包含 32000 条单词和短语。</p><p>2of12 是作者从 12 本中选择其中 2 本来生成的词汇列表，它包含了约 41000 条词目。它的特点是：剔除了多词词组（multiword phrases），专有名词(proper names）和缩略语（abbreviations）。</p><p>关于这两个列表的详细介绍请查看 readme 文件，具体链接是：</p><p>Release 4 of the 12dicts word <a href="lists​wordlist.aspell.net">lists​wordlist.aspell.net</a></p><p><strong>lemmatize</strong><br>把单词按“同源异形”进行归类，具体意思就是：把（文中的词）按屈折变化形式（或异体形式）进行归类。<br>比如：”take” : [“taken”, “taking”, “took”, “takes”]。这些单词是“同源异形” 的，可以归为同一类，并且只用一个单词来表示。</p><p>在制作 list 时的具体做法就是：把文本文件处理成一个单词序列，对其中每一个单词，查找字典得到本体，加入到一个 dictionary 里，条目形式是：word: frequency ，单词每出现一次，frequency 加 1。</p><p>12Dict Release 5 增加了 2+2lemma 和 2+2gfreq 两个 List。按照上述方式分类计算词频之后，每个文件包含的词汇条目约 5 万左右。</p><p><img src="/image/english/lemma.png" alt=""></p><h3 id="五、核心词频库"><a href="#五、核心词频库" class="headerlink" title="五、核心词频库"></a>五、核心词频库</h3><p>这一部分是我要介绍的重点，因为，这一部分列出的几个词库收集的词汇量更加核心与精简，因此更加适合学习。</p><p>#####（1）柯林斯五星词频”（含 14600 词）<br>柯林斯五星词频来自于“柯林斯高阶双解学习词典”，即 Collins COBUILD Advanced Learner’s English-Chinese Dictionary。</p><p>这本词典对每个单词都进行了标记，从 0 到 5 共六个星级别。</p><p><img src="/image/english/collions_cobuild.png" alt=""></p><ul><li>五星 680 词</li><li>四星 1040 词（累计 1720 词）</li><li>三星 1580 词（累计3300词）</li><li>二星 3200 词（累计6500词）</li><li>一星 8100 词（累计14600词）</li><li>0 星 22480 词</li></ul><p>#####（2）“麦克米伦 7500 高频”</p><p>取词来源于“麦克米伦高阶英汉双解词典”，即 Macmillan English Dictionary for Advanced Learners。</p><p>这本词典收录了大约10万左右的单词量，并对这些词汇做了分级处理。属于7500核心词汇的统一以红色字体呈现，并继续分为三个等级，每个级别 2500 个词：一级是最最常用的词，标注三个非常醒目的星号★★★；二级常用词标注两个红星★★；三级标注一个红星★。并没有把它们作为一个单独的词汇表给出。</p><p><img src="/image/english/macillan_en_cn.png" alt=""></p><p><img src="/image/english/macmillan_samplepage.png" alt=""></p><p>#####（3） 专门类别的报刊期刊词频</p><ul><li>“纽约时报高频词汇”</li><li>“经济学人高频词汇”</li></ul><p>它们都是由民间英语爱好者对历年来的英文期刊文章进行统计而总结的出的词频词汇集，收词数也在 2 万左右。</p><p>对于这类词频词汇集，有兴趣的同学可以参考下面两篇文章：<br><a href="https://zhuanlan.zhihu.com/p/24718056" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24718056</a><br><a href="https://zhuanlan.zhihu.com/p/24854424" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24854424</a></p><h3 id="六、应试词表"><a href="#六、应试词表" class="headerlink" title="六、应试词表"></a>六、应试词表</h3><p>这里列出的应试词表大多是对应相应的英文考试的，它们包括：中考，高考，四级，六级，考研，专四，专八，托福，雅思，GMAT/GRE 一共 10 个类别的分类词汇。</p><p>所谓的应试词表，其实也是按照一定规则来进行提取和分类的。比如最高阶的 GRE 词汇表，其取词主要就来源于比较学术类的文章及资料，如果不是应试需要，通常情况下并不需要对这些词汇进行专门记忆。</p><h3 id="七、词典"><a href="#七、词典" class="headerlink" title="七、词典"></a>七、词典</h3><p>介绍完了词汇（频）集，最后有必要来介绍一下主流的六大英语词典。</p><p>这些词典都是双解（包括英汉双解和英英双解）、学习型的词典，非常适与非英语母语的人使用和学习。它们最大的特点就是既可以作为词典进行翻查释义，又可以进行学习。</p><p>这六大词典主要是：</p><ul><li>[OALD] Oxford Advanced Learner’s Dictionary 牛津高阶英汉双解词典</li><li>[LDOCE] Longman Dictionary of Contemporary English 朗文当代高级英语辞典（英英·英汉双解）</li><li>[MWALED] Merriam-Webster Advanced Learner’s English Dictionary 韦氏高阶英汉双解词典</li><li>[CCALD] Collins COBUILD Advanced Learner’s Dictionary 柯林斯 COBUILD 高阶英汉双解学习词典</li><li>[CALD] Cambridge Advanced Learner’s Dictionary 剑桥高阶英汉双解词典</li><li>[MED] Macmillan English Dictionary for Advanced Learners 麦克米伦高阶英汉双解词典</li></ul><p><img src="/image/english/sixdict.png" alt=""></p><p>在如今的网络时代，很多人都喜欢利用手机来进行英语学习，这些词典也都有移动端 App，不过多数是收费的。很多英语学习爱好者，对这些词库进行了提取，制作了 .mdx 离线词库文件，可以供我们离线下载使用。通常，我们会用到一些第三方词典软件，比如（Mdict，欧陆，Goldendict 等），他们可以支持导入各种离线词库。比如我在欧陆移动端的 App 中导入各种离线词库后，如下：</p><p><img src="/image/english/app_dicts.png" alt=""></p><p>单词的查询效果如下：</p><p><img src="/image/english/app_dict_searchpage.png" alt=""></p><p>可见，释义非常详尽。如果不是非词典研究者，这六本词典足以应付几乎所有英语学习场景。在我看来，选用其中任意 2 到 3 本作为主要词典来使用就已经足够。</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>COCA 词频表使用</title>
      <link href="/English/english-process-coca-list/"/>
      <url>/English/english-process-coca-list/</url>
      
        <content type="html"><![CDATA[<p>无意中看到一篇 COCA 语料库的介绍文章，然后自己就去 <a href="http://link.zhihu.com/?target=http%3A//testyourvocab.com/" target="_blank" rel="noopener">http://testyourvocab.com/</a> 测了下词汇，大约是 2 万多。</p><p><img src="/image/english/vocab_result.jpg" alt=""></p><p>神奇的是，我在以前的英语学习时从没接触过这个目前可以说是最知名的英语词汇词频统计库，虽然目测词汇量尚可，但是这个也不是绝对准确的，因为我测的时候感觉差不多认识的单词我就勾了 ，所以结果肯定有不少水分，而且统计方法还因人而异吧，我感觉我目前的词汇应该在 2 万左右。根据网上的论断，这个量貌似也挺大的。虽然我从小对英语学习就非常感兴趣，但是我印象最深的集中大量词汇输入还是在准备出国的时候，当然，这之前我也都是爱背单词的，只不过都是些笨方法，主要是我比较爱看英语相关的东西，而遇到生词了也会刻意去记忆，以前更是爱拿着生词本各种记。</p><p>所以，没接触过这个语料库我还是觉得挺惊讶的，它最有意思的一点就在于它的词频统计，如果我们能很好的利用这个词频表所统计出来的词汇，那对于英语的学习是非常高效的（我现在就在通过这个词频表进行复习和查漏）。</p><p>所以，下面先简单介绍一下这个库</p><p>COCA, 全称 Corpus of Contemporary American English，网站是 <a href="http://link.zhihu.com/?target=https%3A//corpus.byu.edu/" target="_blank" rel="noopener">https://corpus.byu.edu/</a> 它总结了英语国家使用频率最高的词汇，使用大数据的方法把 1990-2012 年美国最有代表性的报纸，杂志，小说，学术，口语（口语可能是用的电视剧或者脱口秀之类的节目转录的）汇集起来，每部分各占 1/5，生成 4.5 亿单词量语料库。<a href="http://link.zhihu.com/?target=https%3A//corpus.byu.edu/" target="_blank" rel="noopener">billions of words of data: free online access</a>COCA, 全称 Corpus of Contemporary American English，网站是 <a href="http://link.zhihu.com/?target=https%3A//corpus.byu.edu/" target="_blank" rel="noopener">https://corpus.byu.edu/</a> 它总结了英语国家使用频率最高的词汇，使用大数据的方法把 1990-2012 年美国最有代表性的报纸，杂志，小说，学术，口语（口语可能是用的电视剧或者脱口秀之类的节目转录的）汇集起来，每部分各占 1/5，生成 4.5 亿单词量语料库。</p><p>COCA词频表，是从众多语料库（corpus）中提取，用大数据的方法从各种文体中提取单词，并按照单词出现次数高低进行排序的一个词频表。</p><p>来看一下这个数据：</p><p>掌握前 500   单词，现实生活中能认识 72% 的单词；<br>掌握前 1000  单词，现实生活中能认识 79% 的单词；<br>掌握前 2000  单词，现实生活中能认识 87% 的单词；<br>掌握前 3000  单词，现实生活中能认识 90% 的单词；<br>掌握前 4000  单词，现实生活中能认识 93% 的单词；<br>掌握前 5000  单词，现实生活中能认识 94% 的单词；<br>掌握前 10000 单词，现实生活中能认识 97% 的单词；<br>掌握前 17634 单词，现实生活中能认识 99% 的单词。</p><p>为什么学了那么多仍然不能达到 99.99%？因为英语实际使用中存在大量专有名词，比如Trump 这个单词，在其竞选前后出现频率相差极大，COCA 中除了媒体来源外的语料中出现很少，而这两年看报纸则是想绕都绕不开。掌握这 17634 词后，学习一个新领域的英文，只要多剩下的 1% 的专有名词，基本就不存在生词障碍了。</p><p>其实，不用完全把表背完，掌握频率最高的一万多词汇就已经非常够用了，在网上，背单词的边际效益是递减的（当然使用词频表来背就可以使边际效益最大化），所以，对于那些迫切希望可以看懂更多英语文章的人来说，利用词频表来进行学习就可以最大化效率。</p><p>好了，这篇文章不是来详细介绍 COCA 到底怎么用的，而是怎么利用它的词频表的。</p><p>首先，需要下载词频表，COCA 官网提供了免费的前 5000 个单词，但是再往后，还提供了 20000 和 60000 词汇量的版本，均是收费的，不过可以在淘宝上购买，或者在网上找到免费的下载链接。</p><p>下面就基于最全的 60000 词汇量的文件，也就是 coca60000full.xlsx 这个 EXCEL 文件。它包含了所有的单词，以及词频统计，分类库等信，是信息最全的一个文件，其他所有衍生版本（比如 coca20000, coca口语等）均可由该文件生成。</p><p><img src="/image/english/coca6000xlsx.png" alt=""></p><p>文件内容预览图如下：</p><p><img src="/image/english/coca6000xlsx_preview.jpg" alt=""></p><p>如果觉得 EXCEL 文件中显示的大写格式不适应，可以通过下面的方法变成小写：</p><p>1、先插入一个空栏（比如在原 WORD 列的左侧插入）</p><p>2、选中空栏，输入公式 =lower(D:D)</p><p>如下：</p><p><img src="/image/english/coca_excel01.jpg" alt=""></p><p>然后，按住 Ctrl + Enter 或者 Command + Enter，就会把函数应用到整列了，效果如下：</p><p><img src="/image/english/coca_excel02.jpg" alt=""></p><p>注意：这时候如果我们删除大写单词的那列，小写列会变成乱码，因为引用的是公式。</p><p>我们可以这样做，选中 C 列，然后直接在本列进行复制粘贴（Ctrl + C， Ctrl + V），在粘贴的时候，选择只拷贝值（Values Only）这一个选项。</p><p><img src="/image/english/coca_excel03.jpg" alt=""></p><p>这样，我们就可以删除原列了。</p><p>好了，简单的 EXCEL 操作介绍完了，下面我们来看看，怎么继续得到我们想要的其他东西。</p><h5 id="脚本处理"><a href="#脚本处理" class="headerlink" title="脚本处理"></a>脚本处理</h5><p>选中单词列，把它复制到 TXT 纯文本文件中，这样就得到一个包含了 6 万单词的纯文本 coca60000.txt。</p><p>我们可以继续细分这个单词本，比如分成只包含前 2 万，前 3 万或前几万的版本，由于原始单词集是包含重复单词的（COCA 根据单词的不同释义列举了多次），所以，我们还可以提取出去重的单词集。当然，根据我们个人的单词学习和记忆需求，我们还可以来进行更多处理。</p><p>因此，下面要介绍的就是用于做这些处理的脚本文件 split.py。</p><p><img src="/image/english/coca_script.jpg" alt=""></p><h6 id="该脚本的大致功能解释如下："><a href="#该脚本的大致功能解释如下：" class="headerlink" title="该脚本的大致功能解释如下："></a>该脚本的大致功能解释如下：</h6><p><strong>1、去重（格式化）</strong></p><p>对于 coca60000 这个词汇集合，原文本包含了重复词汇（coca 根据单词的不同含义，分别列举了多次，形式上出现重复）</p><p>那么，就可以用 split.py 这个脚本进行去重，总量为 60023 的集合去重之后剩余 54150 个。</p><p>另外，还可以对文本进行一些简单的格式化，比如去掉单词前后的空格。</p><p><strong>2、分组</strong></p><p>该脚本支持对想要记忆的单词进行不同大小的分组，比如每 100 个或者 200 个一组，具体命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python split.py coca60000.txt 100</span><br></pre></td></tr></table></figure><p>命令执行成功之后，会在 output 目录中生成许多文件，每个文件按指定分组大小来进行分组，并以数字范围的形式（xxx_yyy）命名，如下：</p><p><img src="/image/english/coca_split_output.jpg" alt=""></p><p> <strong>3、生成可导入的格式</strong></p><p>欧陆词典是一个很流行的英文词典，可以加载不同的词库文件，因此许多人都非常乐于使用它来进行词汇的学习。</p><p>这个脚本支持把原单词本格式化成欧陆词典（<a href="http://link.zhihu.com/?target=http%3A//Eudic.net" target="_blank" rel="noopener">http://Eudic.net</a>）所支持的导入规则，比如，欧陆词典中的 “批量导入分组生词本”，它的规则如下：</p><p><img src="/image/english/eudict_import.jpg" alt=""></p><p>那么，只需要把 split.py 中的 batch_import() 函数打开，然后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python split.py coca60000.txt 15</span><br></pre></td></tr></table></figure><p>就会生成一个叫 coca60000_batch_import.txt 的文件 ，然后打开该文件，就可以看到其内容如下：</p><p><img src="/image/english/eudict_batch.jpg" alt=""></p><p>复制文本内容到 <a href="http://link.zhihu.com/?target=http%3A//eudic.net" target="_blank" rel="noopener">http://eudic.net</a> 中的文本框，就可以顺利导入所有分组。</p><p>好了，有了 COCA 词频表，脚本工具，以及背单词 APP，我们就可以愉快的背单词了 。</p><p>全文完！</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>12 岁男孩弑母无罪释放，最低刑责年龄保护了魔鬼？</title>
      <link href="/Life/life-criminal-age/"/>
      <url>/Life/life-criminal-age/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="/image/life/criminalnews.png" alt=""></p><p>今天刚看到新闻说这个事件，心里一阵发凉，其实早在过去几年就经常类似的青少年暴力案发生，在我国现在青少年刑事犯罪也不断的往低龄化方向发展，严峻的事实不断敲打着我们的神经，到底是哪里出了问题？ </p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>在回答这个问题之前，我先列举我国现行法律中对青少年责任年龄的规定：</p><ul><li><strong>民事责任</strong><br>我国在 2013 年通过的民法总则草案中，第十八条规定：<br>六周岁以上不满十八周岁的未成年人，为限制民事行为能力人。</li></ul><p>其理论依据是，6岁以上孩子可以独立实施纯获利益的民事法律行为或与其年龄、智力相适应的民事法律行为。也就是说，这个年龄界限的划分是考虑了心理承受能力和认识能力，并参考了接受教育的程度和知识的积累及社会的阅历深浅等诸多因素来决定的。</p><ul><li><strong>刑事责任</strong><br>自《中华人民共和国刑法(1997年)》开始实施以来，就对自然人犯罪主体的刑事责任年龄作了明确规定：</li></ul><p>已满十四周岁不满十六周岁的人，犯故意杀人、故意伤害致人重伤或者死亡、强奸、抢劫、贩卖毒品、放火、爆炸、投放危险物质罪的，应负刑事责任。</p><p>也就是说，14周岁以下的人，无论其心智是否健康、体格是否健硕、目的是否善良，他们都可以为所欲为而不被刑法追究。因为立法者认为，14周岁以下的人由于年龄尚小，智力发育尚不够完善，缺乏社会知识，还不具有完全识别和控制自己行为的能力，所以豁免刑罚处罚。</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>犯罪主体不到刑事责任年龄则不被刑法追究，但是悲剧却在不停上演，来看看这样一些案例（主体均是未满 14 周岁未成年人）：</p><p><img src="/image/life/criminalnews1.png" alt=""></p><p>　　这些个让每一个父母都疼到心尖的惨无人寰的案例发生后，都因犯罪主体刑事责任年龄不到而免于刑事处罚。</p><p><strong>同样的事情发生在国外，又是如何判罚的呢？</strong></p><p>　　据美国中文网援引洛杉矶时报消息，南加州 3 名中国留学生因施虐同胞，被洛杉矶波莫那高等法院判处6年到13年的监禁(最高可以判终身监禁)，被处罚的还有企图包庇孩子的父母。这个结果令国人震惊。</p><p>　　美国以民主自由著称，但无论是谁对他人造成人身伤害，都要付出惨痛的代价。在美国针对少年犯罪的司法程序由各州自行决定，但在上个世纪80年代之后，各地降低了追究刑事责任的年龄，加大了对少年犯的严惩力度。一些州可以在成人法庭审判10岁的少年犯。在全美50个州中，有27个州规定了追究刑事责任的最低年龄。在没有规定最低年龄的州，法官可以根据犯罪的严重和恶劣程度，决定在少年法庭还是移交一般刑事法庭进行审判。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>此外，我还在网上查阅到了如下一些可供参考的信息：</p><p>1996年，联合国儿童权利委员会建议各国政府将 <strong>12 岁</strong>作为刑事责任的最低年龄，并呼吁各国提高最低刑责年龄，以保护儿童权益。</p><p>菲律宾总统杜特尔特近期提出要把最低刑责年龄<strong>从 15 岁降低到 9 岁</strong>，该提案引发国际社会持续探讨。</p><p>2017 年以前，美国有 35 个州不设最低刑责年龄，其他 15 个州的最低刑责年龄均低于 10 岁，即截至 2017 年 3 月，那 15 个州的最低刑责年龄分别为 6 岁、7 岁、9 岁和 10 岁。</p><p>此后，纽约州和北卡罗来纳州逆其道而行，分别把最低刑责年龄提高至 16 岁和 18 岁。</p><p>下面是一张全美最低刑事责任年龄的分布图：</p><p><img src="/image/life/uscriminalage_distribution.png" alt=""></p><p>在中国，面对未成年人犯罪现象不断低龄化的趋向，目前的法律对低龄未成年人犯罪行为缺乏打击力度。现行责任年龄的划分使得刑罚的威慑力受到削弱，现实情况下往往是一放了之，结果不但无助于嫌疑人的改造，而且产生示范效应，让更多的同龄人产生“犯罪要趁早”的念头。</p><p>事实上，2017 年就有专家提议修改刑事责任年龄，并给出具体建议“从 14 周岁降低至 12 周岁”。更有专家列举了详细的修改建议，如下：</p><p><img src="/image/life/law_modify_recommendations.png" alt=""></p><p>就我个人经验来看，由于网络信息的发达，现在很多未成年都出现“早熟”的现象，他们更早的接触到这个社会的方方面面，已经在事实上具有很好的是非和责任分辨能力。面对越来越多的未成年暴力和悲剧的发送，在立法上降低刑事责任年龄已经迫不及待，我甚至认为应该像美国大部分州一样，把刑事责任年龄降低到 10 岁以下。</p><p>全文完！</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>寻宝挑战，由 “310 BTC Challenge” 所想到的</title>
      <link href="/Distributed-System/blockchain-blockchain-treasure/"/>
      <url>/Distributed-System/blockchain-blockchain-treasure/</url>
      
        <content type="html"><![CDATA[<p>先介绍下 310 BTC 挑战是怎么回事，</p><p>在 2018 年10月2日，一个自称为 Pip 的用户在 <a href="https://www.reddit.com/r/Bitcoin/comments/9kq7it/introducing_the_310_btc_bitcoin_challenge" target="_blank" rel="noopener">Reddit 网站</a>上（需翻墙访问） 上发布了一个帖子，声称他把含有 310 个 BTC（按当时价值，约 200 万美金，也即 1400 万人民币） 的钱包私钥隐藏在一张图片中，挑战的目标就是找到图片中隐藏的<strong>私钥</strong>，成功找到这个私钥的人自然就可以从钱包中提走所有 310 个 BTC。</p><p>题主把所有的信息都在隐藏在这张图片中，图片如下：<br><img src="https://bitcoinchallenge.codes/images/challenge.png" alt=""></p><p>这个挑战实际上一共包含了四个有奖励的钱包，它们分别有 0.31, 0.2, 0.1 和 310 个 BTC。令人意外的是，包含了这么丰厚奖励的难题很快就被人破解，帖子发布仅两天 0.1 BTC 被取走，第7天 0.2 BTC 被取走，第 8 天 310 BTC 被取走。</p><p>也就是说，仅仅 8 天时间，就有人拿走价值约 200 万美金的奖励。意外的是，这个事情却引起了大量的人对贴主进行口诛笔伐，甚至咒骂，有些人质疑题目设置得太过简单，奖励分配不均，也有人质疑贴主的动机，谴责他滥用 BTC 破坏社区等等。</p><p>总之，贴主的散财之举招来一片骂声，导致本来打算继续出题散财的贴主已经考虑取消后续的挑战了。</p><p>这个事情引发了我的一些思考，假如在未来的某一天，有人想在区块链上把一笔遗产转给某人，<br>这个人必须满足某些条件才能拿到这笔钱，那么他该怎么做呢？（听上去有点像《头号玩家》里的方式）</p><p>像贴主这样出一个密码学谜题肯定是一个方法，提供一些线索，让那个最终破解谜题的人拿到私钥从而提取奖励，就像寻宝活动。当然，也可以有一些其他的挑战方式，比如结合社会学和博弈学的相关原理等。</p><p>想贴主那样出线上挑战题的问题在于，出题者限于其知识和技能范围，很难把题目设置得很专业或者很难。而解题者通常非常专业，有文章就进行过类比，这种难度的题目在 Hacker Puzzle 圈就是普通难度（common problem）。</p><p>就拿这个 310 BTC challenge 来说吧，YouTube 上就有人公布了 0.1 BTC 和 0.2 BTC 的破解办法，看上去逻辑并不复杂，简单来说就是，通过图中给的像素规律和16进制数提示，找到 BIP39 中用于恢复私钥的 12 个助记词，从而最终拿到私钥。由于 310 BTC 这个奖励实在太丰厚，吸引了大量的人进行破解，事实上，310 BTC 这个大宝是被一个团队而不是个人破解的。由于前期 0.1 BTC，0.2 BTC 的破解给出的线索，很多人进行合作，并且在暗网有一个 information exchange 小组进行不断的交流，最终导致 310 BTC 很快就被破解和提取。</p><p>那么除了密码学谜题，还有什么方案呢？<br>我认为还有一种社会学方法，结合现实世界中的伦理与博弈。</p><p>简单来说就是，人们在得到这笔巨款之前，需要先付出一定的代价，或者作出一些非常违背人类本性的事情才能最终得到这笔钱。</p><p>比如，我们设计一个需要多人同时参与，类似囚徒博弈。每个参加游戏的人都需要支付一笔小额资金，在期望获得大奖的同时需要承担少量的风险。既然游戏是由多人参与的，那么规则也可以有多种，比如，所有人在两种选择中选择其中一种，只有当其中一个选项只有一个人选择，而其他所有人都选择了另外一个选择的时候，大奖得出归属。类似的比如还有所有人出一个数字，然后这个数字是中位数的人得到大奖。</p><p>当然，这里面结合了博弈，如果加入一些互相合作和竞争性质的规则，可能更具挑战性。这样设计的方式跟前面密码学谜题最大的区别就在于不需要太多专业知识，纯粹靠社会学的一些方法来决定奖励归属。这种方式并非完全科学，而且也取决于出题者想要把奖励留给哪种类型的人。如果，出题者想要把奖励留给聪明的人，那么可以考虑像最初的题主一样，设计需要精心考虑的题目，结合密码学，图形学，数学等逻辑缜密的题目。其唯一的缺点就是，一个人的智慧很难战胜群体，所以即使考虑周密也可能很快被破解。而如果想要把奖励给那些“不折手段”的玩家，这可以考虑结合社会学出题，这样的话，可以避免个人智慧被群体战胜的风险。</p><p>全文完！</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>理解 Hashgraph</title>
      <link href="/Distributed-System/distributed-system-understand-hashgraph/"/>
      <url>/Distributed-System/distributed-system-understand-hashgraph/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>Hashgraph 算法最早是在 2016 年由 Leemon Baird 博士发表的一篇论文“</p><p>The Swirlds Hashgraph Consensus Algorithm: Fair, Fast, Byzantine Fault Tolerance”（<a href="https://swirlds.com/downloads/SWIRLDS-TR-2016-01.pdf）”中公开，" target="_blank" rel="noopener">https://swirlds.com/downloads/SWIRLDS-TR-2016-01.pdf）”中公开，</a></p><p>根据其介绍，Hashgraph 算法实现了异步拜占庭容错（ABFT），因而能容纳非常高的吞吐量并能非常快速的处理交易（官网提供的数据显示，在真实环境下可以达到惊人的 250k TPS）。</p><h2 id="二、简介"><a href="#二、简介" class="headerlink" title="二、简介"></a>二、简介</h2><p>Hashgraph 是一种异步拜占庭容错算法（ABFT），它跟我们目前常见的 PBFT 算法最大的不同就是它是完全异步的。我们知道 PBFT 算法能支撑的网络规模是非常有限的最大原因就 PBFT 模型的通信复杂度是 O(N^2），随着节点数量的增加，需要通信的消息数量呈指数级别的上升。而 Hashgraph 突破性的抛弃 PBFT 中使用的消息同步机制，使用异步 BFT，通过保证最终确定性来确保算法的高效和安全。</p><p>Hashgraph 采用的是 DAG 数据结构，这跟当前的很多开源链（比如 Iota，byteball, nano 等）是类似的，因为它们都采用 DAG 作为底层数据结构模型。但是 Hashgraph 最特别的一点是，它无需中心权威节点，而是依靠独特的 Gossip about Gossip 和 Virtual Vote 两大机制来保证了算法可以在纯异步的环境中高效运行，并且通过绝对多数（超过 2/3 节点）强可见（强引用）机制来保证了共识结果的正确性（安全）。</p><p>Hashgraph 算法是一种拜占庭容错算法，它要求节点数量是相对固定的（总量为 N 需要预先设定），这样的话，它就可以通过大于 2/3 忠诚节点的比例原则来达到拜占庭容错。这跟当前公链模型下（比如 DAG 主链，POW，POS 等）这些算法在达到共识的条件上有一些区别，所以更适用于私链（或联盟链）。但是，由于其独特的性质（在保证去中心化的同时不需要繁重的工作量证明），Hashgraph 在未来的公链也有相当潜在的使用价值。</p><p>最后，再介绍一下 Hashgraph 跟其他开源项目在运作模式上的区别。</p><p>根据原作者发布的白皮书介绍，Hashgraph 仅是一个算法的名字，它既不是区块链项目（比如比特币，以太坊这种完整的可运行的系统），也不是开源的。它是由发明它的 Leemon Baird 博士所创建的 Swirlds, Inc 公司负责掌控，并运营在 Hedera 项目（<a href="https://www.hedera.com）之下。Swirlds" target="_blank" rel="noopener">https://www.hedera.com）之下。Swirlds</a> 公司对该算法申请了专利并进行了很强的技术保护，它致力于在企业之间以合作的方式来运作和使用基于 Hashgraph 开发的应用。</p><p>从这里我们可以大致看到，Hashgraph 是按照一个相对传统的方式在运作。虽然其核心算法的源代码并不公开，它还是做出了一定程度的开放来使得整个区块链社区和开发者受益，比如对外提供 SDK（<a href="https://dev.hashgraph.com/）。由于" target="_blank" rel="noopener">https://dev.hashgraph.com/）。由于</a> Hashgraph 算法是用 Java 和 LISP 实现的，因此很多基于 JVM 的语言都可以在其之上构建应用程序。当然，社区的开发者也基于 Hashgraph 公开的算法（论文）实现了许多其他语言的版本（比如 Go，Python, Javascript 等），由于算法的简洁和优雅，已经有越来越多的开发者被吸引。</p><h2 id="三、算法原理"><a href="#三、算法原理" class="headerlink" title="三、算法原理"></a>三、算法原理</h2><p>介绍完了 Hashgraph 的相关背景，我们接下来进入主题，也即算法原理。 </p><p>实际上，算法的大部分内容在论文中都有介绍，不过，毕竟论文发表的时间早，其中难免缺失许多细节。因此，Leemon 博士在其发表之后的数年时间内又不断对该算法做了更多更细致的描述和改进。在 Youtube 上也有它对该算法的一个长篇介绍，不过很多人看完仍然表示似懂非懂，不好理解。<strong>因此，这篇文章致力于把算法用更易懂的方式解释清楚。</strong></p><p>在介绍算法之前，先了解论文中所提出的几个基本概念，比如绝对多数（Super majority）和事件（Event）</p><ul><li><p>绝对多数<br>Super majority 很好理解，就是指超过三分之二的节点数量。</p></li><li><p>事件<br>Event 是 Hashgraph 中最基本的元素和概念，它跟我们常见的区块链（比如比特币）中的 Block 概念是类似的。Event 由每个节点自行创建，它主要包含四类元素：交易集合，时间戳，以及对两个 Parent Events 的引用哈希。</p></li></ul><p><img src="/image/p2p/event_structure.png" alt=""></p><p>在传统的区块链中，新产生的区块只能是只能有一个先导区块的，<strong>而在 Hashgraph 中，每个 Event 必须要链接两个 parent Events，其中一个必须是自己，而另一个则是收到的其他任意节点发来最新的 Event。</strong></p><p>我们来对比一下传统区块链的结构和 Hashgraph 的结构之间的区别，如下：</p><p><img src="/image/p2p/block_struct_compare.jpeg" alt=""></p><p>Hashgraph 算法的核心技术点是两个部分：谣言算法（Gossip about Gossip）和 虚拟投票（Virtual Voting）。</p><p>接下来，我会一步一步详细介绍！</p><p><strong>Gossip About Gossip</strong></p><p>Hashgraph 共识的机制和 hashgraph 结构的构建是通过 Gossip 过程来完成的（更多关于 Gossip 机制的介绍，可以参考我这篇文章：“<a href="http://mp.weixin.qq.com/s?__biz=MzI1NjExNDEzMQ==&mid=2247483770&idx=1&sn=38a6bdfa9b5ed48ae684c1a66ff9b33a&chksm=ea2aedc6dd5d64d0945421c4596a5a1875a5cfc936f8e376d25777bb53ecd3e1223ab017acd6&scene=21#wechat_redirect" target="_blank" rel="noopener">P2P 网络核心技术：Gossip 协议</a>”）。</p><p>Gossip 简单来说就是，节点随机选择一个可以连接的邻节点，向其发送一条信息（Event）。而 Gossip about Gossip 则是，收到 gossip 信息的节点，对该 gossip 信息进行签名，并且再把该签名打包进一个新的信息中，并随机发送给网络中的任一节点。这样，每个节点发出的 Gossip 信息都包含了对其收到的前一个 Gossip 信息的签名验证，实际上就是做了一个见证（Witness）工作。</p><p>注意这里的 Gossip 过程是非常简单的，收到 Event 信息的节点可以向<strong>任意一个或多个节点</strong>继续 Gossip 新的 Event。每一次 Gossip 都是对前一次信息的背书和见证。</p><p><strong>Local hashgraph copy</strong></p><p>我们用小写的 hashgraph 表示该算法底层使用的数据结构，参与共识的每个节点都会保存一份完整的 hashgraph 副本图，初始时（genesis），每个节点上的这个副本图都是空的，当开始有节点产生 Event 之后，就会在自己的 hashgraph 副本图上进行记录。</p><p>比如，每个节点都创建第一个 Event 时，他们各自的副本图如下：</p><p><img src="/image/p2p/localhashgraph01.jpeg" alt=""></p><p>当 A 收到 C 发来的 Event 时，A 就会更新本地的 hashgraph 副本，如下：</p><p><img src="/image/p2p/localhashgraph02.png" alt=""></p><p>同时，A 还会基于 a1 和 c1 创建一个新的 Event，并 Gossip 出去，如下：</p><p><img src="/image/p2p/localhashgraph03.png" alt=""></p><p>假设刚才在 A 收到 C 的 Event 时，C 也收到了 D 的 Event，那么各个节点的 hashgraph 副本图则会显示如下：</p><p><img src="/image/p2p/localhashgraph04.png" alt=""></p><p>某个时间点之后，大家都收到了彼此发给对方的消息</p><p><img src="/image/p2p/localhashgraph05.png" alt=""></p><p>可见，在节点相互 Gossip 通信的过程中，它们各自 hashgraph 副本的内容都不尽相同，但是有一点非常重要的就是，每个节点都会忠实的记录自己所创建的所有 Events。</p><p>比如上图中的节点 A 和 B，A 记录了自己所创建的所有 Events，即 a1 和 a2，而 B 同样记录了自己所有的 Events，b1 和 b2。但是 A 缺少 B 的所有 Events，而 B 则缺少 A 的最新 Event a2。</p><p>当 A 准备把 a2 发给（gossip）给 B ，如下：</p><p><img src="/image/p2p/gossipa2b.png" alt=""></p><p>并且，A 准备更新自己副本上 B 这部分的数据时，发现自己缺少 B 这部分前序的数据，因此，B 会把它的历史数据同步（Sync）给 A。而 B 的副本上由于已经有 a1 了，因此在收到 a2 之后无需再同步。</p><p><img src="/image/p2p/syncb2a.png" alt=""></p><p>最终，hashgraph 就会更新成如下状态：</p><p><img src="/image/p2p/localhashgraph_update.png" alt=""></p><p>现在，我们对于 Gossip 过程和副本结构有了一个初步的认识，接下来，我们来了解 Hashgraph 算法中定义了哪些状态</p><h5 id="可见"><a href="#可见" class="headerlink" title="可见"></a>可见</h5><p>由于 hashgraph 中，所有 events 都会引用两个 parent events，因此，如果一个 child event y 可以回溯到某个 ancestor event x，那么就说 y 可见 x。</p><p>而且，同一个节点产生的事件，后续事件总是可见先前所有事件。</p><p>如下：</p><p><img src="/image/p2p/event_visibility.png" alt=""></p><h5 id="强可见"><a href="#强可见" class="headerlink" title="强可见"></a>强可见</h5><p>当事件 Y 能找到事件 X 的所有路径中跨越了绝对多数的节点，那么事件 Y 强可见事件 X。白皮书中提到经过数学论证可以保证两个强可见的节点在虚拟投票时能获得一致的结果 </p><p>比如下图，想要判断 b5 是否强可见 c1，</p><p><img src="/image/p2p/stronglysee.png" alt=""></p><p>我们需要做的就是，把所有从 b5 能可见 c1 的路径都找出来，如果这些路径集合中，能够包含超过 2/3 的节点（也就是要包含至少 4 个节点），那么就说 b5 强可见 c1。</p><p>如下：</p><p><img src="/image/p2p/stronglysee1.png" alt=""></p><p>可以看到，b5 有 3 条路径都能可见 c1，这 3 天路径经过的节点分别是，path1: (B, C)，path2:(B, D, C), path3(B, E, C)，</p><p>三天路径一共经过了 B, C, D, E 4 个节点，满足超过 2/3 节点的要求，因此，可以确认事件 b5 强可见事件 c1。</p><p><strong>轮次 Round</strong></p><p>在 Hashgraph 中，根据事件所处的<strong>可见状态</strong>，把他们分为不同的轮次（Round）。</p><p>当一个事件强可见绝对多数节点上的先前事件时，我们就说该事件在一个新的轮次上，记为 R。</p><p>我们通过一个示意图来理解轮次的概念</p><p><img src="/image/p2p/roundconcept.jpeg" alt=""></p><p>上图中，事件 a5 强可见了 R 轮的 a1, b1, c1, d1 共 4 个事件，也就是说强可见了绝对多数节点的第 R 轮的事件，因此，a5 就在一个新的轮次 R + 1 上。</p><p><strong>创建轮</strong></p><p>所谓的创建轮（Creation Round），就是当一个事件被创建时，它所在的轮次。通常，一个事件被创建时，它会被立即赋予一个轮次号，跟其父事件是在同一个轮次一样。也就是说，如果同节点的父事件是 R 轮，那该事件被创建时也是在第 R 轮，它的创建轮就是 R 轮。</p><p>比如，上图中，初始（Genisis）情况下，所有节点的状态都是相同的，把当前状态定义为第 R 轮，并且 R = 1。后续创建的事件都是在第 R 轮的。</p><p>接收轮（Receive Round）很好理解，就是当某个事件强可见超过 2/3 节点的本轮或者上一轮的事件时，这个事件就达到了一个新的轮次，这个轮次就是他的接收轮。如下图：  </p><p><img src="/image/p2p/receiveround.png" alt=""></p><p>从上图中，我们可以看到，当 a5 和 d5 被创建时，它们的创建轮是第 R 轮，而当它们能够强可见绝对多数节点的第 R 轮的见证人事件（即 a1, b1, c1, d1）时，它的接收轮就变为 R + 1 轮，也就是说，a5 和 d5 都变成 R + 1 轮的事件了，并且，在它们之后创建的子孙事件都在 R + 1 轮。</p><p>这里需要注意的是：如果事件 a5 只能强可见 R 轮某节点的见证人时，a5 的轮次是不会增加的，依然为此在 R 轮。只有当其强可见绝对多数节点的第 R 轮的见证人，它的轮次才变为 R + 1 轮。</p><p><strong>见证人和知名见证人</strong></p><p>见证人（Witness），就是第 R 轮所创建的第一个事件。比如上图的 a1，b1，c1, d1 和 e1，它们都是各自节点的见证人事件。</p><p>知名见证人（Famous Witness），当 R 轮的见证人事件被 R + 1 轮的多数（超过 2/3）见证人强可见时，它就是知名见证人事件。</p><p><img src="/image/p2p/famous_witness.png" alt=""></p><p>由上图我们可以看到，c1 被 R +1 轮的大部分见证人事件强可见，因此 c1 就是知名见证人。</p><blockquote><p>我们注意到这里暗含了一个强约束条件，就是 R + 1 轮的见证人事件，这意味着 [a5, b5, c5, d5] 这几个事件必然是强可见大部分节点的第 R 轮见证人事件的，但不必然强可见 c1（比如他们都强可见 [a1, b1, d1, e1] 这 4 个见证人事件。所以，要判断 c1 是否是知名见证人，就必须要求 R + 1 轮的大部分事件都强可见 c1，一旦满足，说明 c1 就是知名见证人了，知名见证人意味着不可更改，这时候系统就可以对该事件进行 commit。</p></blockquote><p><strong>虚拟投票（Virtual Vote）</strong></p><p>上述 Event 状态变迁和系统状态变迁的过程其实也包含了投票的过程，投票是在上述状态变迁过程中完成的。</p><p>根据上述的算法介绍，我们知道一个 Event 的状态变迁过程是这样的：</p><p>可见 -&gt; 强可见某祖先 Event -&gt; 强可见绝对多数节点的祖先 Events -&gt; 轮次增加（即 Round + 1） -&gt; 大多数 R+1 轮 Witness 强可见 R 轮某个 witness -&gt; R 轮该 Witness 成为 famous witness -&gt; commit。</p><p>如图：</p><p><img src="/image/p2p/eventstate_migration.jpeg" alt=""></p><p><strong>虚拟投票</strong>实际上就是指上述两个黄色部分。它主要是分为两个步骤来进行的，① 处相当于 Pre-Vote 过程，这里其实是确定投票委员会成员，如果一个事件强可见大多数 witness，那么它对某 witness 的票就有效。而 ② 处则是 Pre-Commit 过程，收集投票委员会对某个祖先 Event 所投的票，如果票数超过 2/3，那么就可以把该 Event 标记为 Famous，也就是不可更改了。接下来只需要 commit 就行了。</p><p>注：R + 1 轮的 Witness 只会对 R 轮的 Witness 投票，R 轮 Witness 后续的 Events 不会收到投票。 Witness 是指 R 轮创建的第一个 Event，如下：</p><p><img src="/image/p2p/witness_votes.png" alt=""></p><p>我们来看一下想要把 R 轮的 c1 标记为 Famous 需要经过哪些步骤：</p><ul><li>1）找出每个节点所有满足 R + 1 轮的 Events<br>这是一个对每个节点的各 Event 进行不断回溯验证的过程。</li><li>2）判断每个节点中，R + 1 的 Event 是否强可见 c1，如果强可见，那就相当于投了一票赞成票（Yes）。</li><li>3）计算 Vote 数量，如果超过 2/3 的 Event 都投票 Yes。就把 c1 标记为 famous。</li></ul><p>实际上，计票过程是在 R + 2 轮进行的。因为即使 R + 1 轮所有 Event 都强可见 c1，它们彼此之间也互相不知道对方的投票情况。因此，必须由下一轮的 Event 来收集大家的投票结果。</p><p><img src="/image/p2p/round12.jpeg" alt=""></p><p>由上图可见，R + 1 轮的 [a5, b5, c5, d5] 以绝对多数的比例对 c1 形成了强可见状态，使得 c1 满足知名见证人条件。R+2 轮上的每个见证人则对 R+1 轮进行收集投票。如图，a9 强可见了 R+1 轮的这 4 个强可见 c1 的事件，因为已经超过绝对多数，因此 a9 可以立即确认 c1 事件，也就是 c1 已经达到全网共识而且不可更改。</p><blockquote><p>提示：Hashgraph 根据数学理论证明，任何一个 R+2 轮见证人如果对投票结果做出了决定，那么这个结果就是全网的结论，如果这轮见证人无法做出决定，就由下一轮见证人计票决定，直到得出确切结论。 </p></blockquote><p>事实上，R + 2 轮这个收集投票的过程只是一个学习共识结果并进行提交的过程，因为一旦知名见证人被确定，剩下的过程就只是各个节点把这个结果进行提交了。</p><h5 id="接收轮次和共识时间戳"><a href="#接收轮次和共识时间戳" class="headerlink" title="接收轮次和共识时间戳"></a>接收轮次和共识时间戳</h5><p>一旦某个轮次确定了所有的（or 绝对多数）知名见证人，就可以为这一轮次中的其他普通事件（non-witness）确定接收轮次和共识时间戳（Consensus timestamp）。 </p><p>如果一个事件被某轮的所有知名见证人（知名见证人数量必须超过 2/3）都可见，就说它的接收轮为这些知名见证人所在的轮次。</p><p>比如，第 R + 1 轮的所有知名见证人都已经得到确认，如果这些知名见证人都可见某个祖先事件，那么就说这个祖先事件的接收轮为 R + 1。</p><p>比如下图，假定 a5, b5, c5, d5 都是 R = 2 轮的知名见证人，它们都可见 a3 事件，我们就说 a3 在 R = 2 轮被接受。而对于 b4 来说，只有 b5 可见它，其他见证人并不可见它，因此，它的接收轮还不确定，只能等待后续轮次的见证人满足可见的条件，才能确定它的接收轮。</p><p><img src="/image/p2p/consensus_timestamp.jpeg" alt=""></p><p>现在假定我们有一个 Event x，其接收轮为 R + 1，我们想要确定其在所有 event 中的 timestamp。</p><p>Hashgraph 采用的方法是，先找出各个节点中的可见 Event  x 的最早 Events，然后把它们的 timestamps 集合取中位数作为 x 最终的 timestamp。比如，找到节点 A 中最早可见 x 的 Event，样，找到节点 B，C， D 中最早可见 x 的 Event 。对于 A 来说，最早可见 x 的就是 x 自己，而对 B， C， D 来说，最早可见可以是任意 Event。</p><p>为了便于理解，我画了一个示意图来描述，如下：</p><p><img src="/image/p2p/consensus_timestamp1.jpeg" alt=""></p><p>想要确定 a3 的 timestamp，我们从各个可见它的见证人节点中，查找最早可见 a3 的 events。</p><p>如上图，A 节点最早可见 a3 的时间就是 a3 自己，而 B 节点最早可见 a3 的则是 b3，同理得到 c4 和 d4。</p><p>这样，我们就得到一个 timestamp 集合：[a3, b3, c4, d4]，取它们的中位数，就得到一个基准 timestamp，把它作为 a3 的真实 timestamp。</p><p>根据相同的做法，我们可以得到其他所有 Events 的 timestamp，也就是说我们可以得到一个 Total order。</p><p><strong>Tie breaker</strong></p><p>当然，仅有 timestamp 可能还无法确定 Event 的先后顺序，因为很有可能两个 events 会有相同的 timestamp。所以还需要一些其他条件和规则来约定顺序。</p><p>在 Hashgraph 中，是按照如下规则来排序的</p><ul><li><p>Round received</p></li><li><p>Median timestamp</p></li><li><p>Extended median timestamp</p></li><li><p>whitened signature</p></li></ul><p><strong>全文完！</strong></p><p>本文欢迎转载，请务必注明出处。</p><hr><p><strong>相关阅读：</strong></p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Macbook pro 截屏尺寸与屏幕分辨率</title>
      <link href="/Macbook/Macbook-resolution-vs-picture-dimension/"/>
      <url>/Macbook/Macbook-resolution-vs-picture-dimension/</url>
      
        <content type="html"><![CDATA[<p>经常被屏幕分辨率和图片分辨率两个尺寸数据搞混，经过一番搜索终于弄清了这两个数据的原理。</p><p><strong>现象是：</strong><br>我的 MacBook Pro 15.4 英寸 Retina 屏幕分辨率为 2880×1800。我全屏截图得到的图片的分辨率却更高：3360×2100。</p><p><strong>解释：</strong><br>这是因为显卡能处理处理尺寸更大的图片，而显示屏的分辨率小于显卡能创造的图片尺寸。<br>显示屏的分辨率虽然只有 2560 x 1600，但是显卡能生成更高分辨率的图片。</p><p>测试：<br>（1）把 Display &gt; Resolution 的 Scale（如下）调到最大，如下：</p><p><img src="/image/macbook/mac_display_scale_max.png" alt=""></p><p>再次截屏，得到 3840 × 2400 大小的图片。</p><p>（2）把 Display &gt; Resolution 的 Scale（如下）调小，如下：</p><p><img src="/image/macbook/mac_display_scale_min.png" alt=""></p><p>再次截屏，得到 2880 × 1800 大小的图片。</p><p><img src="/image/macbook/capture_2880_1800.png" alt=""></p><p><img src="/image/macbook/img_info.png" alt=""></p><h3 id="官方："><a href="#官方：" class="headerlink" title="官方："></a>官方：</h3><p>屏幕截图大于显示屏大小的原因是因为随着 Retina Display 笔记本电脑的发布以及相应的 OS X 相关更新，屏幕尺寸“分辨率”现在得到了很大的不同（阅读，复杂的方式。<br>为了让用户保持简单，Apple现在提供五种不同的分辨率设置。这些设置都不提供明确的桌面像素密度供您选择。相反，Apple会要求您选择文字大小的首选项。</p><p><img src="https://macperformanceguide.com/images/mbpRetina2012/prefs-Retina-scaling.png@auto.html?dglyAS&dglySz=1350x894&dglyD=-C_uOz4mRs2vnBv7XR5p-Bh9s2cR4JGctvaFGNabfJUfSDgIGl6-siwsIiB-MQ8MtGn6_JfHOwRgFQuQAm2nK7w=" alt=""></p><p>每个选项都会缩放您的应用并以不同方式显示内容。字体越小，内部分辨率越高，最终将按比例缩小以匹配显示器的分辨率。<br>当您截取桌面屏幕截图时，您的图像尺寸与显示分辨率不同，因为OS X渲染的桌面实际上大于显示器的像素密度。<br>如果你的截图是 3,360 x 1,800，你可能在上面的显示设置屏幕上选择了第四个选项。</p><p>此中间设置使所有未更新的应用程序的有效分辨率为1,440 x 900，然后按比例放大2倍。 Retina 更新的应用程序呈现为 3,360 x 1,800 的显示。最终的 3,360 x 1,800 观看区域最终缩小至 2,560×1,600，以便在您的显示器上观看。<br>OS X 以预渲染分辨率（3,360 x 1,800）保存桌面的屏幕截图，而不是显示硬件的最终输出分辨率。</p><p>参考来源：<a href="http://macperformanceguide.com/mbpRetina2012-retina.html" target="_blank" rel="noopener">MacOS Retina Display Scaling</a></p><p>全文完！</p><br><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Macbook </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Theory and Practice needed for a Blockchain Expert</title>
      <link href="/Distributed-System/blockchain-overview-blockchain-expert/"/>
      <url>/Distributed-System/blockchain-overview-blockchain-expert/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>区块链面试是一个挺新的话题，主要得益于区块链行业 2018 年成为风口行业，不仅曝光度激增而且人才市场火爆，而我在年后也是接触了许多来参加面试的候选人，大部分是没有区块链从业经验的，为此我当时写了一篇《寻找适合恋爱的区块链工程师》，从面试官的角度来讲了如何寻找一个合格的候选人。</p><p>从经历来看，这个行业非常之新兴，并且人才也相当匮乏。作为我针对面试写的第二篇文章，我决定从一个从技术的角度来详尽阐述要成为一个区块链专家所必备的技术。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说到技术，我所指的主要还是研发。由于我负责的是技术岗，因此我对于技术上要求会比较严格（严格并不等于高），简单来说就是，基础知识需要十分扎实。许多过来参加区块链工程师面试的同学，大部分人给我的印象是，看过一点介绍区块链知识的书籍，问一点浅显的知识是能够答得上来，但是稍微具体一点的，就会变得含糊不清了。在我看来，区块链所要求的知识并非什么特殊的或者新兴的知识，除了密码学领域的知识需要专门了解之外，其他知识和技能几乎都是一些比较通用的网络开发核心知识，如果是从事网络服务端相关开发的，可能会对这部分知识比较熟悉。</p><p>由于区块链整个行业涉及到的范围非常广泛，下到各种基础设施，上到各种上层应用，它们对技能的要求范围是不一样的。根据我的经验，大致把区块链开发分为两个大的部分：技术层和应用层，以便候选人根据自己以往的专业技能背景选择自己合适的领域。</p><h3 id="一、核心层"><a href="#一、核心层" class="headerlink" title="一、核心层"></a>一、核心层</h3><p>核心层是区块链最下面的一层，这一层是底层技术与基础设施的开发。我们可以把这一层比作操作系统的内核，而应用层则是在操作系统之上构建各种软件。比如我们最常见的比特币网络，它的核心技术就来源于它的共识机制（POW），当然，对于大部分链来说，共识的原理都是其最核心的部件。要构建这样的共识机制，又需要更加底层的技术支持，比如：网络通信，数据存储，加密安全等等。所以，这一层对于技术的内涵要求比较高，这里的技术是一项综合的能力，我把它总结为三个部分：理论基础、专业经验以及技术能力。</p><h5 id="1）理论基础"><a href="#1）理论基础" class="headerlink" title="1）理论基础"></a>1）理论基础</h5><p>理论基础主要是指分布式系统理论，如果是专业出身（比如计算机专业-分布式系统方向），或者有过从事过分布式数据库，网络等相关的经验，那么可能会对这一部分相对了解或熟悉，熟悉并深入理解分布式网络的特点和各种算法是能够在区块链领域大有作为的前提之一。</p><p>这里，我简单列举需要掌握的一些分布式系统核心概念：</p><ul><li>全序/偏序，因果顺序</li><li>物理时钟/逻辑时钟</li><li>两阶段算法（2PC）/三阶段算法（3PC）</li><li>Safety &amp;&amp; Liveness</li><li>FLP 不可能定理</li><li>Paxos/Multi-paxos</li><li>Raft/Multi-Raft</li><li>CAP 理论</li><li>副本一致性，强/弱、最终一致性</li><li>简单哈希/一致性哈希</li><li>Base/ACID，分布式 ID 等等</li><li>BFT(Byzantine Fault Tolerance)</li></ul><p>关于这部分内容详细介绍，可以参见我的系列文章之《区块链核心技术：分布式理论》。</p><h5 id="2）专业经验"><a href="#2）专业经验" class="headerlink" title="2）专业经验"></a>2）专业经验</h5><p>专业经验则是指对目前最主流的区块链项目的掌握程度，比如 Bitcoin，Ethereum 等，了解账户模型，智能合约等等，而且，不仅是它们的运行原理，而且能在它们的基础上持续改进、开拓以及创新，比如对侧链，轻节点、分布式存储，扩容方案等有一定的理解等等。</p><p>为此，我也做了一个列表，主要展示对区块链的专业经验的一些要求：</p><ul><li>目前区块链主流共识算法之间的差异（比如 PBFT 与 POW 之间区别）</li><li>联盟链、公链及私链之间的区别，部署方式</li><li>针对区块链的攻击方式：51%算力攻击，Sybil 攻击，Eclipse 攻击，DDos 攻击</li><li>P2P 网络通信模式（Gossip，Totem，DHT 等）</li><li>Merkle Tree 数据结构</li><li>Bitcoin UTXO 模型，以太坊转账流程（GAS 计算，Nonce 值等等）</li><li>以太坊智能合约的编写，Solidity 相关知识</li><li>密码学（公钥/私钥，ECDSA，RSA，哈希算法），签名，多重签名，盲签名等等</li><li>以太坊协议 ERC20 ERC721 ERC223 ERC875</li><li>比特币（P2SH 地址，交易脚本等）</li></ul><p>这部分内容可以详见我的系列文章之《区块链核心技术：专业经验》。</p><h5 id="3）技术准备"><a href="#3）技术准备" class="headerlink" title="3）技术准备"></a>3）技术准备</h5><p>最后，技术能力则是一项通用能力，是网络编程，内存控制，操作系统，编解码，密码学，异步编程等等开发功底的一个综合考核。它是一个日积月累的能力，扎实的技术背景可以让我们快速适应区块链底层的开发。</p><p>为此，我列举了一些比较核心的研发能力和技术准备：</p><ul><li>数据结构（二叉树，trie 树，数组，结构体/类 等等）</li><li>算法（回溯/递归，字符串编码，排序，搜索等等）</li><li>锁（原子锁，互斥锁/自旋锁），死锁检测，内存泄露检测</li><li>多线程编程（共享内存，线程/进程/协程），用户态/内核态</li><li>同步、异步，阻塞/非阻塞，多路复用 I/O</li><li>异步编程/响应式编程范式，事件驱动</li><li>网络编程：TCP/IP/UDP 协议，time_wait 状态，socket/select/epoll, C10k 问题等</li><li>服务器编程：熟悉 Linux 编程，系统资源（如：cpu/io, disk usage 等）</li><li>HTTP 协议，RPC 通信，负债均衡等等</li></ul><p>这部分内容可以想见我的系列文章之《区块链核心技术：技术准备》。</p><h3 id="2、应用层"><a href="#2、应用层" class="headerlink" title="2、应用层"></a>2、应用层</h3><p>应用层是区块链最重要的一层，也是区块链行业能蓬勃和持续发展的力量来源。应用层主要涉及的是区块链产品，我们常见的有比如：数字钱包（imToken），分布式交易所（Cosmos，bitshare），浏览器插件（MetaMask），区块链游戏（CryptoKitties, FOMO3D），保险产品等等。</p><p>开发这些应用级别的产品，通常是与底层的区块链系统进行交互，因此，并不需要我们对区块链底层技术达到非常专业的掌握。但是需要我们对区块链的核心概念有了解，以便我们能与链的开发者能在同一语言上进行沟通而不至于误解。</p><p>当然，应用层的开发对技术的要求也是共同的，它虽然没有核心层对技术能力要求的那么高，但是其更加侧重对创新和落地</p><p>我会通过分析几个典型区块链应用，来展示思路而不是技术本身在应用层所展现的强大能量和生命力。</p><p>这部分内容可以详见我的系列文章值《区块链核心技术：编写应用》</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一部分：区块链核心技术：分布式理论概述</title>
      <link href="/Distributed-System/blockchain-part1-theory-foundamentals/"/>
      <url>/Distributed-System/blockchain-part1-theory-foundamentals/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>区块链行业是 2018 年最火热的行业，很多技术人员都纷纷转投这个行业，但是苦于缺乏理论背景，常常会感到力不从心。我面试过许多候选人，他们给我印象最多的就是，每个人都看过一点比特币或者以太坊的项目知识，知道一点它们的运作流程，但是当我试图了解更多细节时，回答便开始变得捉襟见肘。区块链技术仿佛云里雾里，看得见却又摸不着，为此，我决定从区块链的本质出发，详尽的叙述它的理论基础和技术背景，为立志进入区块链行业甚至想成为专家的人打开一扇通道。</p><p>由于涉及的内容非常多，因此，我决定把分成三个系列来阐述，分别是：理论基础，专业经验以及技术要求。</p><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>这篇文章是这个系列的第一篇：<strong>分布式理论</strong></p><p>我们知道，不论什么区块链项目（bitcoin, ethereum, etc..），他们都是运行在千千万万个独立的机器（矿机）上的，这本质上就是一个分布式网络。</p><p>区块链的核心技术主要就来自于分布式系统网络（我们也可以把它称作是点对点网络Peer to Peer），再加上其与<strong>密码学原理</strong>与<strong>经济激励机制</strong>的独特结合，才成就了如今欣欣向荣的数字货币市场。因而，要掌握好区块链的核心技术，就需要先系统的学习分布式系统理论，它是我们掌握区块链核心技术的关键。</p><p>这篇文章我会对分布式系统的理论发展脉络进行梳理和介绍，争取给读者一个最为清晰的分布式理论介绍。</p><h3 id="分布式系统定义"><a href="#分布式系统定义" class="headerlink" title="分布式系统定义"></a>分布式系统定义</h3><p>分布式系统理论是一个非常早就已经开始在研究的领域，几乎与互联网的出现是同时的，并且随着网络的发展不断发展。早期的互联网就是解决点对点通信的问题，后来随着规模化发展，中心化的网站变得流行，也就是现今互联网最突出的表现形式。</p><p><strong>分布式系统理论</strong>主要集中解决在一个网络中，不同的节点机器如何就某一个值达成一致的问题，也就是<strong>共识，</strong>这也就是区块链技术中最核心要解决的问题。既然共识是所有分布式系统需要解决的核心问题，研究人员也为这个问题研究了数十载，我们要掌握它，就必须先了解分布式系统的特点和核心问题，以及围绕它所产生的一些理论成果。</p><h3 id="分布式系统特点"><a href="#分布式系统特点" class="headerlink" title="分布式系统特点"></a>分布式系统特点</h3><p>分布式系统中节点的运行时相互独立的，它有两大特点：<strong>（1） 无共享内存</strong>，意味着一个节点不知道其他节点的状态；<strong>（2）没有全局时钟</strong>，意味着节点之间有着不同的本地时间。两个节点要合作完成一件事，只有一个途径，那就是互发消息。</p><p>既然是互发消息，我们就要解决两个核心的事情，<strong>一）收到的消息是否可信</strong>，也就是说，发消息的人发的消息是否是真实的消息而不是故意伪造的；<strong>二）消息的顺序</strong>，当一个节点收到两个不同节点发来的消息时，如何确定谁先发，谁后发。</p><h3 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h3><p>（1）容错类型分类<br>根据节点是否可以恶意伪造消息，我们把网络分为两种：非拜占庭网络（NON-BYZANTINE）和拜占庭网络（BYZANTINE）。</p><p>对于一个包含 N 个节点的网络来说，如果每个节点都真实坦诚的发出消息，那么我们就说这个网络是非拜占庭网络（Non-Byzantine），又叫 Fail-stop 模型，也就是说，他们要么正常工作，要么宕机停止工作，但是不会做 Malicious 事情。而如果存在恶意节点可以伪造消息，那么我们就说这个网络是拜占庭网络（Byzantine）。是否可以伪造消息这个前提假设实际上是我们人为添加的，在现实的环境中（比如公链），由于经济利益的关系，是有可能存在恶意节点的，因此公网环境通常是拜占庭网络，也就是说必须能够容忍存在恶意节点。而在私有环境中，比如某个公司部署的分布式数据库中，所有机器可控并且都是自己服务的，所以不存在作恶的情形，因此私有网络通常是非拜占庭网络。</p><p>对于非拜占庭网络和拜占庭网络，共识算法的本质是一样的，只不过约束条件不一样而导致算法有略微的差别。比如分布式数据库是最常见的非拜占庭网络，数据库主要解决各节点副本数据一致的问题，主流的算法有一致性哈希（Consistant Hashing），Paxos，Raft，zookeeper 中的 ZAB 协议等等。而区块链系统则是最常见的拜占庭网络，解决全网对同一区块的共识问题，主流的算法有 POW，POS，DPOS，PBFT 等等。</p><p>（2）时间模型分类<br>根据网络对时间模型（timing model）的约定不同，我们把网络分为三种：同步网络，异步网络，和半同步网络。<br>在论文中，这三种时间模型的定义如下：</p><ul><li><p>同步网络 Synchronous<br>同步网络对时间的假设是必须要有一个时间上限，消息在一个确定的时间范围内到达接收方。</p></li><li><p>异步网络 Asynchronous<br>异步网络对于时间的无要求，消息可以在任意时间到达接收方。</p></li><li><p>半同步网络 Partially synchronous<br>这种模型略微复杂，Dwork, Lynch 和 Stockmeyer 在 1984 年发表著名的论文<a href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf" target="_blank" rel="noopener">《Consensus in the Presence of Partial Synchrony》</a>中提出的，也叫 DLS Protocol 或 DLS Algorithm，它包含两种 Partial Synchrony 模型：</p></li><li><p>假设消息被最终投递的时间上限是存在的，但是具体数值不是已知和先验的。那么系统的目标就是不管真正的时间限制是多少都能达到最终共识。</p></li><li><p>假设消息被最终投递的时间上限已知，但是它们只在某个未知的时间点（Global Standardization Time）才开始满足。那么系统的目标就是只要这个时间点到达，共识就一定能达到。</p></li></ul><p>DLS Protocol/Algorithm 的具体原理和步骤是：<br>每一轮共识过程都被划分为 “trying” 和 “lock-release” 阶段：<br>1）每一轮都有一个 proposer 并且从一个它们都相信的数值开始通信<br>2）proposer 提出一个值 v，这个值需要至少 N - x 个节点都已经知道<br>3）当一个节点收到这个提议的值 v，那么它必须把自己 lock 在这个值上，然后广播自己 lock on v 的状态<br>4）如果 proposer 收到 x + 1 个节点发来的 lock on v 信息，它就 commit 这个值。</p><p>DLS 协议是共识领域的一个重大突破，因为它创造了一个新的网络分类，那就是 Partial Synchrony，并且在这个网络模式下，共识被证明是可行的。</p><p><img src="/image/p2p/fail_time_model.png" alt=""></p><h2 id="分布式系统算法的演进"><a href="#分布式系统算法的演进" class="headerlink" title="分布式系统算法的演进"></a>分布式系统算法的演进</h2><p>在介绍这两种不同网络条件下的分布式算法之前，我们需要先理解分布式系统中的核心问题及相关理论背景。</p><p>最早提出 Consensus/Agreement 问题的是 1978 年 Lamport 的论文 <a href="http://research.microsoft.com/users/lamport/pubs/time-clocks.pdf" target="_blank" rel="noopener">“Time, Clocks and the Ordering of Events in a Distributed System”</a> 。虽然论文中没有明确把问题定义为 Consensus 或 Agreement，但是他详细讨论了消息如何在有限时间内在不同处理器（Processors）中传输，其本质就是 Consensus。在这篇经典的论文中，他提出了 Total Order，Partial Order，Causal Order，Logical Clocks 等被现在认为是分布式理论中最基础、最核心的概念，他还使用 “Happen before” 关系来定义事件发生的顺序，并且给出了一个算法，使得在整个分布式系统中，在全局范围下，每个处理器观察到的事件的顺序都是一致的。他还介绍了一个分布式状态机（distributed state machine），在同一初始状态下的一组状态机，并保证他们在这同一状态开始，按照相同的顺序来处理后续的所有事件。也就是说，每一个人都用相同的方式处理下一条消息，而这，本质上就是共识。这个算法的目的就是得到事件发生的全局唯一顺序。但是 Lamport 描述的这个系统是不容错的，也就是说，一旦有一个处理器出现故障了，那么其他处理器就必须等待，整个系统就无法继续运行下去了。</p><p>关于逻辑时钟（Logical Clocks）是用来确定事件发生顺序的核心要素，Colin Fidge 在 1991 年发表的 “Logical Time in Distributed Computing Systems” 论文中对其做了详尽的定义和阐述，Figde 定义了 Partial Ordered Clocks，即偏序时钟（又称“部分有序时钟”），包含 5 个核心条件：<br>1）Sequential order<br>2）Process Creation<br>3）Process Termination<br>4）Synchronous（unbuffered）message-passing<br>5）Asynchronous（buffered）message-passing<br>6）Transitivity。<br>由这些条件，再加上时间戳（Timestamps）信息，就可以得到所有的 Partial Ordered Pairs，并由此确定所有事件的 Total Order，如下图，用标量来表示：</p><p><img src="/image/p2p/total_order.png" alt=""></p><p>偏序时钟还可以用向量时钟（Vector Clocks）来表示，同样可以用来确定 Total ordering。</p><p><img src="/image/p2p/vector_clocks.png" alt=""></p><h3 id="2PC-Two-Phase-Commit-Protocol"><a href="#2PC-Two-Phase-Commit-Protocol" class="headerlink" title="2PC (Two-Phase Commit Protocol)"></a>2PC (Two-Phase Commit Protocol)</h3><hr><p>1979 年，也就是在几乎与 Lamport 论文发表的同时，Jim Gray 发表了<a href="http://research.microsoft.com/~Gray/papers/DBOS.pdf" target="_blank" rel="noopener">“Notes on Database Operating Systems”</a>，这篇文章中描述了一个两阶段提交算法（Two-Phase Commit Protocol） ，简称 2PC。两阶段分别是 Prepare Phase 和 Commit Phase，在这个算法中，需要除了参与方节点（Cohort），还需要引入一个第三方角色，叫做 TC（Transaction Coordinator，即“事务协调员”），·</p><p>1）Phase one（Proposal Phase）：Coordinator 提供一个值，然后联系每个 Cohort，询问他们是否赞成这个值</p><p>2）Phase two（Commit-or-Abort Phase）：如果每个 Cohort 都赞成，Coordinator 就再联系他们一次，让他们进行 commit。否则，一旦收到一个不赞成，就让他们 abort。</p><p>下图是 2PC 有限状态机的状态变迁示意图：</p><p><img src="/image/p2p/2pc_graph.png" alt=""></p><p>注：coordinator 无需是一个特点节点，任何一个节点都可以充当，只要他们想要发起一个 2PC 共识。</p><p>我绘制了一个更简单的图来展示两阶段的过程：</p><p><img src="/image/p2p/2pc_demo.png" alt=""></p><p>在这篇文章中，作者也总结出了分布式系统算法最重要的两个特性：<strong>安全性（Safety）</strong>和<strong>活性（Liveness）</strong>，任何一致性算法必须要满足这两个特性以使得整个系统是一个确定性系统（Deterministic System）。</p><p>注：Safety 和 Liveness 性质最早是由 Lamport 在其 1977 年发表的论文<br><a href="http://www.cis.umassd.edu/~hxu/courses/cis481/references/Lamport-1977.pdf" target="_blank" rel="noopener">Proving the Correctness of Multiprocess Programs</a>中进行总结和证明的。</p><h5 id="Safety-and-Liveness"><a href="#Safety-and-Liveness" class="headerlink" title="Safety and Liveness"></a>Safety and Liveness</h5><p>Safety 和 Liveness 的具体含义如下：</p><ul><li><p><strong>Safety</strong>，也叫 Correctness，是指系统或算法能够正确运行，不会接受冲突的值。它有两点基本要求：</p><ul><li>如果有一个节点 commit，那么所有节点都会 commit，没有任何节点 abort</li><li>如果有一个节点 abort，那么所有节点都会 abort，没有任何节点 commit</li></ul></li><li><p><strong>Liveness</strong>，也叫 Avalibility 或者 Termination，是指系统或算法能够正确结束，不会出现永久等待的情况。也就是说在有限的时间内，算法一定会结束，<strong>最终状态一定是确定的</strong>，系统能够继续往下执行不阻塞。两个基本要求是：</p><ul><li>如果没有节点 abort，那么在规定的最大时间范围内，所有节点都会 commit。</li><li>如果有一个节点 abort了，那么所有节点也会就最终状态达成一致。</li></ul></li></ul><p><strong>那么， 2PC 有没有解决上述两个问题呢？答案是没有。</strong> 这是因为，一但某个节点失败或者消息丢失，那么即使是有 Timeout 条件约束，也无法保证 Liveness。这是因为参与节点没有办法分辨 TC 到底是宕机 Crash 了，还是仅仅由于事务繁忙而导致长时间未响应，这样，参与方就无法知道该如何进行下一步，从而导致整个系统状态不确定。</p><p>比如下面这种失败场景：</p><p>TC 发出 commit 决定给 A，A 收到并且执行 commit，但是这时候 TC 和 A 同时 crash，那么其余的 cohorts 将既不能 commit 也不能 abort。</p><p>这也就是为什么 2PC 被称为同步算法，它解决了 Safety 问题，但是却没解决 Liveness 问题。</p><p>更多关于 2PC 内容可以参考这篇文章：</p><p><a href="http://www.the-paper-trail.org/post/2008-11-27-consensus-protocols-two-phase-commit/" target="_blank" rel="noopener">http://www.the-paper-trail.org/post/2008-11-27-consensus-protocols-two-phase-commit/</a></p><h3 id="3PC-Three-Phase-Commit-Protocol"><a href="#3PC-Three-Phase-Commit-Protocol" class="headerlink" title="3PC (Three-Phase Commit Protocol)"></a>3PC (Three-Phase Commit Protocol)</h3><hr><p>为了克服 2PC 导致的 Liveness 问题，人们就想出来一个办法，把 commit-or-abort 阶段拆成 2 个子阶段。把最终决定（commit or abort）先发布给每个 Cohort，在确保每个人都知道最终决定之后，再执行 commit 或者 abort。</p><p><img src="/image/p2p/3pc_demo.png" alt=""></p><p>可见，实际决定过程还是前面两个阶段，而 Phase III 则用来做最后通知，即使这个阶段中任何机器出现故障，Phase II 中得到的决定都不会丢失。</p><p>那么现在再来分析一下，3PC 是否解决了 2PC 中 Liveness 问题呢？ 答案是肯定的。因为可以看到，假如 Phase II 中出现 TC 和 A 出现同时 crash 的情况，那么因为没有人收到 preCommit，所有的 cohorts 都能 abort。而如果其他 cohorts 已经收到过 preCommit 结果，那么即使他们 crash，只要在 Phase III 中增加 Timeout 就可以另他们最终都 commit 之前的结果。因此，系统总是能够正确结束，状态确定。</p><p>3PC 又被称为一个 Non-blocking 算法。<strong>但是 3PC 又出现了新的问题，那就是它无法保证 Safety。</strong>具体的场景就是，在面对网络分区（Network Partition）的时候，Correctness 失效。</p><p>比如，A 从 TC 收到 preCommit 之后，A 与 B，C 之间断网，TC 也故障。那么，在 Timeout 超时时间过后，A 会 commit，而 B，C 由于尚未收到 precommit，则会 abort，那么，最终，A 和 B，C 的状态变得不一致。</p><p>那么是否存在一种协议或算法，可以<strong>同时保证 Safety 和 Liveness 呢？</strong></p><p><strong>答案是，在纯异步的网络条件下，不可能。</strong> 这就要谈到一个分布式领域中最具影响力之一的定理，FLP 不可能定理。</p><h3 id="FLP-Impossibility"><a href="#FLP-Impossibility" class="headerlink" title="FLP Impossibility"></a>FLP Impossibility</h3><hr><p>1985 年，Fischer, Lynch 和 Patterson 三位教授发表了著名的 <a href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf" target="_blank" rel="noopener">Impossibility of Distributed Consensus with One Faulty Process </a>论文，这是分布式领域中最具影响力之一的论文，其后来获得 Dijkstra 奖。这篇论文证明了一个惊人的结论，那就是：在异步通信场景，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性。在此前的研究中，同步通信网络中的一致性被证明是可以达到的，因此在之前一直有人尝试各种算法解决以异步环境的一致性问题，有个 FLP 的这个结论，这样的尝试终于有了答案。</p><p>需要强调的是，FLP 是指在异步网络（Asynchrounous network）中，什么是同步网络/异步网络呢，我在《Reactive Programming》一文中有阐述，简单来说，异步网络对时间（Timeout）的要求非常宽松，纯的异步环境是现实场景的一个体现，比如随着移动终端的发展，手机会为了省电而关机，也会因为不在服务区而离线，也就是说，一个节点可能随时离线而不回复网络，而何时重新加入网络则是不确定的。其最大的难处在于无法分辨一个节点是出现故障宕机还是只是由于繁忙没来得及回复，从而导致其他节点无法做出合适的处理。</p><p><strong>注：对于同步网络来说，3PC 是可以同时保证 Safety 和 Liveness 的。</strong></p><h3 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h3><hr><p>到了 1990 年，Leslie Lamport 提交了后来被称为 Paxos 算法的著名论文 <a href="http://research.microsoft.com/users/lamport/pubs/lamport-paxos.pdf" target="_blank" rel="noopener">“The Part-Time Parliament”</a>，但是由于该算法晦涩难懂而被委员会忽略了，直到 1996 年 Butler Lampson 在  <a href="http://research.microsoft.com/lampson/58-Consensus/Acrobat.pdf" target="_blank" rel="noopener">“How to Build a Highly Availability System using Consensus” </a>论文中提及才重新被注意到，并在 1998 年得到正式发表。此后，在 2001 年，Leslie lamport 在 <a href="http://research.microsoft.com/users/lamport/pubs/paxos-simple.pdf" target="_blank" rel="noopener">Paxos Made Simple </a>论文中用更简洁的语言描述了 Paxos 算法。</p><p>Paxos 算法的理论基础是：给定一组固定数量的节点，选取任何一组大多数成员，这些选择中，都必然有至少一个节点是公共的。</p><p>如图：</p><p><img src="/image/p2p/paxos_majority.png" alt=""></p><p>对于一个有 3 个节点的网络来说，至少 2 个节点才能组成大多数，也就是 AB，AC，BC，他们之间任意两个都必然至少有一个公共节点，换句话说，任意一组 Majority，都和其他任何一组 Majority 都至少有一个公共节点。这样的话，下一组 Majority 选取的时候，必然存在一个公共节点，记住上一组 Majority 所做的决定。</p><p>比如，上一个决定是 AB 所做的，而下一个决定轮到 BC 的时候，由于 B 记住了上一轮的决定，因此，可以容忍消息的丢失，延迟，甚至乱序等各种情况。只要有一个节点能够与这个网络中的大多数节点通信（至少两次，也就是一个来回），<strong>那么系统总是能以上一轮共识的结果为基础进行下一轮共识而不会出现混乱或丢失状态</strong>。</p><p>Paxos 算法本质上是一个 2PC 算法，主要区别在于所有节点都是平等的可以并发提出议案，并且使用一种机制来记录议案号的顺序来避免冲突，同时它对于响应数也更加宽松。Paxos 中有两种角色：Proposer 和 Acceptor 。其中 Proposer 就相当于 2PC 中的 Coordinator，只不过，在 Paxos 中，每个人都可以成为 Proposer，所有人都是平等的（egalitarian）。也就是说，两个 proposers 可以同时发出提案，由 acceptors 根据收到的议案号大小来决定是否接受议案。2PC 要求所有节点在 Prepare/Abort-or-Commit 阶段都回复 yes/no，而 Paxos 则只要求大多数回复即可。Acceptor 就相当高于 2PC/3PC 中的 Cohort。</p><p>Paxos 采用大多数回复的就可确认共识，其原理就在于：任意两个大多数集合中必然存在交集节点，这个节点一旦同意了 2 个 Proposals 中的一个，就必然不会同意另外一个，从而不会导致 consensus 冲突。</p><p>Paxos 中使用 proposal number 来表示议案的全局顺序，每个 acceptor 都可以同时记录收到的多个 proposal number，并且只接受比当前最高 proposal number 更高的议案。</p><p>算法大致流程如下：</p><p><img src="/image/p2p/paxos_timeline_demo.png" alt=""></p><p>注：一个节点可以同时担任 Proposer 和 Acceptor 两种角色，为了简化，上图把两种角色分开进行描述。</p><p>Paxos 是一个异步算法（可以运行在异步网络环境中），其完全实现了 Safety 特性，也在很大程度上也能够达到 Liveness 的要求（又叫 Imperfect Liveness）。为什么不能完全达到 Liveness 呢，这是由异步网络的 FLP 不可能定理决定的。虽然，理论上，Paxos 没有显式的 Timeout 要求，但是，通常它只有在用同步的方式（也就是说，消息投递有时间上限）才能正确可靠的运行。</p><p>实际上，从上述 Paxos 的算法过程演绎我们就可以看到，Paxos 算法中可能存在活锁，如下：</p><p><img src="/image/p2p/paxos_livelocks.png" alt=""></p><p>我们可以看到，在第一个 Proposer 进行 ACCEPT 之前，Acceptor 又收到并同意第二个 Proposer 的议案号，导致第一额 Proposer 的 ACCEPT 被拒绝。两个 Proposer 在不断的竞争提交议案，然后不断被 Reject，导致整个系统无法始终无法达成共识，算法在不断循环往复。这种活锁现象就会导致 Paxos 无法满足 Termination 性质（即 Liveness），所以严格的来说，它不是一个正确的一致性算法。</p><p>注：Lamport 在自己的论文中建议使用 Leader 来代替 Paxos 中的 Proposer，而 Leader 则可以通过随机或其他方式来选定（Paxos 中假定随机过程会极大降低 FLP 发生的概率）。简单来说，只要我们在工程中能够实现随机地选择 Proposer，那么出现活锁的概率是非常低的。</p><h3 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi-Paxos"></a>Multi-Paxos</h3><hr><p>现在我们对 Paxos 算法有了清晰的理解，现在有必要介绍一下 Multi-Paxos 算法，它是使得 Paxos 能够工程化的重要实践。</p><p>为了区分，我们通常把前述 Paxos 算法称为 Basic Paxos。可以看到，Basic Paxos 已经解决了分布式系统最核心的一致性问题，也就是对某一个值能达成一致。但是还有一个问题我们并没有解决，那就是如何确定各个不同 Proposal 各个议案号的顺序。</p><p>我们可以看到，Basic Paxos 中是通过不断提交议案，通过议案号的冲突拒绝来更新议案号的，效率非常低下，而且可能导致活锁。这是由于每个节点是独立运行的，没有全局时钟，每个节点都根据本地时戳（local time）来产生议案号（Proposal number），而本地议案号显然无法确定其真实的前后顺序（提交顺序），因为即使是先提交的，由于网络原因也可能晚到达。即使每个节点都采用相同的基准序号（比如都从 0 开始），也存在两个 Proposer 同时提交相同的序号而产生竞争（Contention），从而造成活锁现象，不仅极大的影响效率，还威胁到算法的 Liveness 性质。</p><p>所以，从现实的角度来说，我们必须对 Basic Paxos 进行优化。可以看到，Basic Paxos 中，每个节点都需要独立运行 Prepare 和 Accept 两个阶段，而 Prepare 阶段是准备议案的过程，正是这个过程中产生的议案号导致了竞争，因此，我们可以把这个过程优化掉，让所有节点都运行同一个 Prepare 过程，这样议案号就不会冲突的，因为每个人都是按顺序得到一个新议案号的。</p><p><img src="/image/p2p/prepare_original.png" alt=""></p><p>变成这样：</p><p><img src="/image/p2p/prepare_with_leader.png" alt=""></p><p>我们引入 Leader 角色来完成统一的 Prepare 过程，每个 Proposer 需要提交议案时，就从 Leader 这里领取一个议案号，这样，每个议案都会有唯一单调递增的序号，就不会冲突了。</p><p>既然引入了 Leader ，那么就存在谁来当这个 Leader 的问题了，也就是 Leader 选举。很简单，把 server ID 作为每个节点的标识，然后运行一遍 Basic Paxos 就可以选出一个大家都共识认可的 Leader。</p><p>解决了序号冲突问题，我们还有一个涉及性能的，非常关键的部分，那就是 <strong>Basic Paxos 一轮只能对一个议案达成共识，这个在现实环境中是非常低效的</strong>。如果我们能够在一轮就对多个议案（互不冲突）达成共识，那么效率将大大提升。</p><p>Multi-Paxos 算法就是为了解决上述问题而产生的。在 Multi Paxos 中，由于有了 Leader 节点来完成 Prepare 过程，因此，Proposal 总是唯一的，不会被覆盖，其他节点只需要处理 Accept 过程。而且，Leader 一旦选出，除非故障宕机，它永远是 Leader，不会退位，共识过程使用 Round ID 来表示，每一轮共识，Leader 可以提交多个议案（不冲突即可），可以一次对多个议案达成一致。</p><p>简单来说，Multi-Paxos 把共识分成了两个阶段：Leader Election Phase 和 Consensus Phase。先选取 Leader，一旦 Leader 确定之后，就进入下一个阶段，由 Leader 接受请求之后，省去了 Prepare 过程，直接生成单调递增的议案号，并向其他节点发出 Accept 请求，当收到大多数响应之后，就可以确认 Commit。</p><p>这里还需要提及的是 WAL（Write Ahead Log） 技术，它可以用来实现记录一致和回滚。因此，分布式日志是用来解决分布式网络中各种问题的一个重要技术，这里就不展开讨论了。</p><p>由于 Lamport 在论文中只是对 Multi-Paxos 提及了一下，并没有阐明具体实现细节。所以现在开源项目中 Multi-Paxos 的变种非常多。</p><h3 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h3><hr><p>Raft 就是 Multi Paxos 变种中的其中一种，由斯坦福大学 的 PhD 学生 Diego Ongaro 和他的导师 John Ousterhout 在 2013 年发表的论文“In Search of an Understandable Consensus Algorithm”中提出，由于其易于理解的特性，这篇论文一发表就得到了大量的赞誉和推崇。而在工业界，基于 Raft 原理所实现的一致性协议更是得到了广泛的应用（比如 etcd）。</p><p>Raft 最大的特点是强调了领导者选举的过程，通过单调递增的任期号以及连续的日志编号来记录每一轮共识的提交结果。Raft 突出易理解性，它主要利用日志的连续性做了一些简化，主要体现在两个方面：<br>（1）Leader 正常时：由 Leader 向 Follower 同步日志<br>（2）Leader 宕机是：选举新 Leader，执行 Leader Election 算法</p><p>Raft 协议主要分三个部分，1）Leader 选举 2）日志复制 3）Safety 验证。</p><p>Raft 使用 Term number 来表示共识轮次，单调递增，使用 LogEntry 来记录所有落地信息（term number，commit id，etc.）。Raft 对 Leader 的作用进行了强化，比如日志复制只能从 Leader 节点复制到其他节点。此外，Leader 的选举增加了超时机制，以便确保选举不会失败。此外，对于 Leader 的要求也更高了，其日志集必须包含最新的 term，以及 commit id，也就是作为 candidate 其必须包含最全的日志才能竞选 Leader，而 Multi paxos 中则无这个要求。</p><p>至于如何判断哪个日志是更新的，直接比较 last entry 所在的 term id 以及 index 即可。</p><p>至于 Safety 的验证，除了正常流程不会导致冲突之外，我们还需要保证在系统出错（Fail-stop），也就是 Leader 故障宕机的情况下，新 Leader 选举之后依然能够保证所有节点副本一致，不会出现丢失和覆盖的情况。</p><p>我们可以通过下面这个场景来简单分析一下：</p><p>当 leader crash 时，新的 Leader 如果不包含前一个 Leader 所有已提交的日志 CLE（committed log entries），如何避免不一致？</p><p>Raft 算法中的要求是，一个 candidate 要想选举成为 new leader，它必然需要得到大多数 servers 的投票同意，那么至少有一个 server 会包含上一次（也就是最新的）CLE。如果这个 Candidate 的 CLE 比这个大多数 server 的 CLE 都要新，那么它就包含了所有的 CLE，满足成为新 Leader 的条件。而如果存在一个 CLE 比当前 Candidate 的 CLE 新，那么就不满足称为新 Leader 的条件，从而被拒绝。</p><p>对于 follower crash 那就简单多了，只要其不影响网络的大多数分布（比如网络只有 3 个节点，在宕机 1 个之后只剩余 2个节点，就没法形成大多数），就对 Safety 没有任何影响。follower 失败时，只是不更新本地日志而已，重启并再次连入网络之后，从 Leader 复制最新日志到本地即可。</p><h5 id="与-Multi-Paxos-的区别"><a href="#与-Multi-Paxos-的区别" class="headerlink" title="与 Multi-Paxos 的区别"></a>与 Multi-Paxos 的区别</h5><p>Raft 协议强调日志的连续性，Multi-Paxos 则允许日志有空洞。日志的连续性蕴含了这样一条性质：如果两个不同节点上相同序号的日志，任期（Term）相同，那么这和这之前的日志必然也相同的。Raft 协议利用日志的连续性，Leader 可以很方便的得知自己的 Follower 拥有的日志的情况，Follower 只要告诉 Leader 自己本地日志文件的最后一个日志的序号和 term id 就可以了；同时由于已经提交的日志本身也是连续的，只需要记录最后一条已经提交的日志的位置，就可以判定这条日志之前所有的日志都已被提交。而 Multi-Paxos 则不行，所以当新 Leader 产生时需要每个日志重新用 proposer  number 重走一遍所有的日志。</p><p>简单来说，Raft 对于 Leader 故障，Membership 变更的方法做了详尽的阐述，利用连续的日志来做了许多简化，相比 Paxos/Multi-Paxos 是一个更规范并易于实现的共识算法。</p><h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h3><p>接下来，再介绍一个分布式系统中极其著名的 CAP 理论，又叫不可能三角。</p><p>早在 2000 年 7 月，加州大学伯克利分校的 Eric Brewer 教授在 ACM PODC 会议上提出 CAP 猜想。2 年后，麻省理工学院的 Seth Gilbert 和 Nancy Lynch 从理论上证明了CAP。之后，CAP 理论正式成为分布式计算领域的公认定理。</p><p>CAP 理论讲的是一个分布式系统<strong>最多只能同时满足</strong>一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p><p><img src="/image/p2p/cap_therory.png" alt=""></p><p>由于 CAP 理论证明了三者不可兼得的结论，那么在实际应用中，我们通常需要对其做出权衡取舍。</p><p>来看下面三种情况：</p><p>1）CA without P：如果不要求 P（不允许分区），则 C（强一致性）和 A（可用性）是可以保证的。但其实分区不是你想不想的问题，而是始终会存在，因此CA的系统更多的是允许分区后各子系统依然保持CA。</p><p>2）CP without A：如果不要求 A（可用），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很多传统的数据库分布式事务都属于这种模式。</p><p>3）AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。</p><p>对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。</p><p>对于涉及到钱财这样不能有一丝让步的场景，C必须保证。网络发生故障宁可停止服务，这是保证CA，舍弃P。貌似这几年国内银行业发生了不下10起事故，但影响面不大，报到也不多，广大群众知道的少。还有一种是保证CP，舍弃A。例如网络故障事只读不写。</p><h3 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><p>下面来介绍一下分布式一致性算法在分布式数据库中的应用，之所以要介绍这部分内容，是因为分布式数据库目前是分布式算法最为普遍的应用（比特币本质上也是一个分布式数据库），了解它也是我们进入分布式领域重要的步骤。</p><p>分布式数据库相比传统数据库最大的特点是<strong>水平扩展（Scaling）</strong>能力，这也是其最大优势。实现水平扩展的关键就是使用多个节点来分片存储数据，使得极大的扩大了存储容量的上限。扩展性（Scalability）是相对于系统来说的，而数据分片（Sharding）则是相对数据本身来说的，是实现扩展性的一种方法。通常数据会根据预先设定的规则（比如根据 Range，或者 Hash）切分，然后由数据分发器（Distributor）按照规则分发到不同的节点机器中进行存储。</p><p>由于本文只涉及分布式一致性算法的应用，因此不详细介绍数据分片的设计。不同的节点机器保存不同 Range 的数据，比如节点 A 保存 Key 范围在 [0, 99] 范围内的数据，节点 B 则是 [100, 199]， 节点 C 为 [200, 299]，以此类推。。。</p><p>示意图如下：</p><p><img src="/image/p2p/shard_by_range.png" alt=""></p><p>但是作为一个数据库系统，那么数据的可靠性，也就是容错性（Fault tolerance）是最为关键的。这也就是分布式一致性算法最能体现价值的地方了，那就是副本数据的复制，保证副本数据跟主数据的一致。一旦主数据丢失，可以立即从副本数据中恢复。</p><p>这是对于任何数据库系统来说都是最为关键的（即使是传统数据库，也需要有主从备份，异地容灾等架构设计和措施），因此，我们为上述系统设计冗余备份如下：</p><p><img src="/image/p2p/shard_by_range_with_dup.png" alt=""></p><p>从上图可以看到，每台机器都保存了另外两个 Range 数据的备份，任何一台数据出现故障，都可以从其他机器中恢复其原本保存范围内的数据。</p><h5 id="副本一致性"><a href="#副本一致性" class="headerlink" title="副本一致性"></a>副本一致性</h5><p>有了副本方案，我们需要保证的就是副本数据能够实时的与主数据同步，比如，A 机器是负责对外提供 [0, 99] 范围数据的所有读写操作的，当有数据需要写入该范围时，A 会向 B 机器和 C 机器发出写请求，得到 B 或 C 的响应之后（超过半数）就可以写入了。这时候，系统中至少有 2 台机器写入了新数据（AB，AC 或 ABC）。可以保证副本数据与主数据的一致。目前主流的分布式数据库都会采用 Paxos 或 Raft 等一致性算法来实现副本同步的操作。</p><h5 id="强一致与弱一致（最终一致性）"><a href="#强一致与弱一致（最终一致性）" class="headerlink" title="强一致与弱一致（最终一致性）"></a>强一致与弱一致（最终一致性）</h5><p>强一致要求所有机器都写入才返回客户端操作，这时候系统对外界来说是强一致的，即一旦写入，从任何一台机器都都可以立即读取到这个结果。而弱一致只要求写入大部分机器即可返回，这时候系统对外界来说是弱一致的，执行写入操作之后，如果立刻读取，在某些机器上可能无法读到这个结果，而是过一段时间之后会读到正确结果。但是特点是，在一段时间之后，一定会读到该结果，这也就是为什么也称作最终一致性的原因。</p><p>弱一致性的设计会大大提高系统的响应速度，因此很多数据库系统都采用这种方式。</p><h3 id="一致性哈希（Consistant-Hashing）"><a href="#一致性哈希（Consistant-Hashing）" class="headerlink" title="一致性哈希（Consistant Hashing）"></a>一致性哈希（Consistant Hashing）</h3><hr><p>上面介绍了使用 Key Range 的方式，也就是数字范围，来处理分布式系统中的数据分片问题，我们提到了还有一种使用哈希的方式来分片。</p><p><strong>一致性哈希就是解决如何把数据分布在哪些机器上的</strong>，其本质上是一种负载均衡算法。如果机器的数量是有限的，那么一致性哈希可以把数据比较均匀的分布在各个机器上。</p><h5 id="简单哈希（Basic-Hashing）"><a href="#简单哈希（Basic-Hashing）" class="headerlink" title="简单哈希（Basic Hashing）"></a>简单哈希（Basic Hashing）</h5><p>在介绍一致性哈希之前，先介绍下<strong>简单哈希</strong>。</p><p>简单哈希很简单，其做法是，先对 Key 执行哈希运算，然后把这个值对节点总数量取余，即 hash(key) % n。由于哈希函数计算出来的值是在一定范围内的，比如 0 - 2<sup>32</sup>-1 之间。取余之后，会得到一个 [0, n) 范围内的值，这个就对应我们的机器号，我们把这个 Key 相对应的数据存到该机器即可。</p><p>简单哈希虽然看上去很好，但是面对以下两种情形的时候会显得无所适从：</p><ul><li>其中一台机器出故障坏了，这时候节点数量变更为 n-1，此时的映射公式变成 hash(key) % (n-1)</li><li>需要新增机器的时候，此时的映射公式变成 hash(key) % (n+1)</li></ul><p>可见，一旦出现需要增减机器的情况，对 key 进行取余运算的结果都会不同，这样，所有的数据都会被重新分配到新的机器上。这也就意味着，所有的数据都需要重新迁移，可以想而知这样会给系统带来多大的复杂性和性能损耗，系统几乎失去了扩展能力。</p><h5 id="一致性哈希（Consistent-Hashing）"><a href="#一致性哈希（Consistent-Hashing）" class="headerlink" title="一致性哈希（Consistent Hashing）"></a>一致性哈希（Consistent Hashing）</h5><p>为了解决简单哈希带来的问题，一致性哈希的解决方案就出来了，<strong>它最大的特点就是可以尽可能地降低节点变动带来的数据迁移开销</strong>。</p><p>一致性哈希对简单哈希进行了改进，摒弃了取余来进行映射的方法，取而代之的是对机器（可以用机器的 IP 或者主机名为关键字）也使用同样的哈希函数进行哈希运算，得出的结果会与之前的会在同一哈希空间。并且，他把哈希结果映射到了一个闭合的哈希环上（Hash Ring），也就是哈希运算的值空间，其范围是在 [0, 2<sup>32</sup>-1] 之间，0 和 2<sup>32</sup>-1在零点中方向重合。</p><p>比如，对 A，B，C 三台机器进行 Hash 运算后得到</p><p>Hash(NODEA) = KEY1;<br>Hash(NODEB) = KEY2;<br>Hash(NODEC) = KEY3;</p><p>数据对象的哈希结果和机器的哈希结果在同一个值空间，值空间是一个闭合环，这里，我用一个下面这个图来直观的显示：</p><p><img src="/image/p2p/hash_ring.png" alt=""></p><p>从上图我们可以清晰的看到，机器和数据的哈希值都在环上了，那如何把数据分布到哪台机器上去呢？一致性哈希使用了最简单直观的办法，那就是把数据的哈希值沿着哈喜欢顺时针“行走”，把遇到的第一台服务器作为其目标存储机器，就像这样：</p><p><img src="/image/p2p/hash_ring1.png" alt=""></p><p>为什么一致性哈希能以较小的代价解决集群机器增减情况导致的数据迁移问题呢？</p><p>我们从两个方面来分析：</p><p>1）机器出现故障宕机，我们假如 C 机器宕机，那么原来 C 机器上的数据就无法访问了，那么我们只需要把这些数据（如果有备份的话）迁移到 D 机器上即可，而根据一致性哈希，任何新写入的数据，自然都会被存储到 D 节点上去。也就是说，系统一旦发生机器减少的情况，只需要迁移单个机器的数据。</p><p><img src="/image/p2p/hash_ring2.png" alt=""></p><p>2）增加一台机器，假设需要增加一台机器 E，这台机器经过哈希，位于 C 和 D 之间，这时候，部分原本存储在 D 机器上的数据需要迁移到 E 节点，并且，新写入的、哈希值位于 C 和 E 之间的数据，将不会再存储到 D 节点而是会存储在 E 节点。如下：</p><p><img src="/image/p2p/hash_ring3.png" alt=""></p><h5 id="数据的均衡分布（虚拟节点）"><a href="#数据的均衡分布（虚拟节点）" class="headerlink" title="数据的均衡分布（虚拟节点）"></a>数据的均衡分布（虚拟节点）</h5><p>采用了一致性哈希并不能保证数据会均匀分布在各台机器上，由于使用机器 IP 或主机名做哈希运算得出来的哈希值在 [0, 2<sup>32</sup>-1] 空间内可能是不均匀分布的，这样就会造成某台机器保存大量数据，而某台机器却保存极少量数据。为了平衡各台机器的使用，我们可以使用虚拟节点（Virtual nodes）来实现避免这个问题。</p><p>具体原理和方法非常简单，如下：</p><p>如果有 N 台机器，那么我们就把哈希空间（比如 [0, 2<sup>32</sup>-1]）分成 N 等分，每个等分可以看做是一个虚拟节点，每个虚拟节点对应一个实际的物理节点，这样我们可以为他们建立一对一的映射关系。这样，我们要存储的数据会被均匀分布在 N 个虚拟节点上，而通过虚拟节点，又存入真正的物理节点上。就实现了数据的均衡分布。</p><p><img src="/image/p2p/consistant_hash_virtualnode.png" alt=""></p><p>对于一致性哈希，网上也有大量的实现可以参考，比如开源的 ketama。</p><h2 id="分布式系统的其他理论"><a href="#分布式系统的其他理论" class="headerlink" title="分布式系统的其他理论"></a>分布式系统的其他理论</h2><p>除了上述核心原理及理论成果，分布式系统中还有很多其他理论用来解决实际问题，比如 BASE，ACID 等等。</p><h2 id="拜占庭协议"><a href="#拜占庭协议" class="headerlink" title="拜占庭协议"></a>拜占庭协议</h2><hr><p>前面所有的内容我们都假定节点是诚实的，每个节点都诚实的发出每个消息，节点的失败模型是 Fail-Stop 的，也就是只存在故障宕机不工作或者运行良好诚实工作两种情况。但是，在真实的世界中，却存在节点故意伪造消息的情况，而拜占庭协议的产生就是为了解决真实世界中可能存在的作恶情况。</p><p>实际上，拜占庭协议非常简单，只不过比之前介绍的非拜占庭协议 Paxos，Raft 等多了一个约束条件而已，那就是节点可以伪造消息。</p><h3 id="两个将军问题"><a href="#两个将军问题" class="headerlink" title="两个将军问题"></a>两个将军问题</h3><p>讲到拜占庭协议，就必须要先讲到<a href="http://hydra.infosys.tuwien.ac.at/teaching/courses/AdvancedDistributedSystems/download/1975_Akkoyunlu,%20Ekanadham,%20Huber_Some%20constraints%20and%20tradeoffs%20in%20the%20design%20of%20network%20communications.pdf" target="_blank" rel="noopener">两军问题（Two General’s Problem）</a>，因为最早是起源于它。两军问题描述了两个将军在攻击同一个敌人的场景。将军1一个是领导，将军2 是跟随者。每个将军的军队都无法仅靠自己的力量成功打败敌军，所以他们需要合作并同一时间发起攻击。这看起来是一个简单的情况，但有一点要注意：</p><p>为了两军的沟通和决定作战时间，将军 1 必须要派遣一个信使穿过敌人的营地去把攻击时间告诉将军2。但是，信使可能会被敌人抓住因而信息无法传到友军。那会导致将军 1 发起攻击时，将军 2 和他的军队还呆在原地。</p><p>即使第一条信息传到了，将军2号也需要确认 ACK（这里与 TCP 的握手过程非常相似）他收到了信息，所以他要派遣一个信使回去，因此重复上一个信使可能被抓的情况。这会延伸到无限的 ACK，两位将军将无法达成一致。</p><p>没有任何办法可以保证第二个要求，那就是每个将军都要确保对方同意了攻击计划。两个将军都总会怀疑他们最后的信使是否能到达。</p><p>下面就是两军问题的通信模型：</p><p><img src="/image/p2p/two_generals.png" alt=""></p><p>很快，两个将军问题就被<a href="https://en.wikipedia.org/wiki/Two_Generals%27_Problem#Proof" target="_blank" rel="noopener">证实</a>是<strong>无解</strong>的。</p><h3 id="拜占庭协议-1"><a href="#拜占庭协议-1" class="headerlink" title="拜占庭协议"></a><strong>拜占庭协议</strong></h3><p>于是，在 1982 年，Lamport、Shostak 和 Pease 三人一起对一个带反转的广义版本的两个将军问题进行了描述，这个场景中两个以上的将军需要对攻打他们共同敌人的时间作出同意。它增加的一个复杂性就是，其中一个或几个将军有可能是叛徒，意味着他们可以对他们的选择撒谎（比如他们同意在0900发起攻击但实际上他们不）。</p><p>两个将军问题中领导者－跟随者的关系变成了指挥官－中尉的组合。为了在这里达成共识，指挥官和每个中尉必须就同一个决定达成一致（为了简单，只有<strong><em>攻击</em></strong>或<strong><em>撤退</em></strong>）。</p><p><img src="/image/p2p/byzantine_general_problem.png" alt=""></p><p>这里除了第二个条件之外，如果指挥官是叛徒，还是必须达成共识。结果，所有的中尉成为了多数票。</p><p>在这种情况下达成共识的算法是基于一个中尉所观察到的大多数决策的价值。</p><p>拜占庭协议得出来的一个定理：对于任意 m，如果有多于 3m 的将军和至多 m 个叛徒，算法可以达到共识。</p><p>也就是说，只要 2/3 的成员是诚实的，算法就能达到共识。如果叛徒多于 1/3，无法达到共识，这些军队无法协调他们的攻击，敌军胜利。</p><h5 id="拜占庭容错"><a href="#拜占庭容错" class="headerlink" title="拜占庭容错"></a>拜占庭容错</h5><p>拜占庭容错是一个定义容许属于拜占庭将军问题失败类别的系统的特性。拜占庭故障 (Byzantine Failure) 是<a href="https://en.wikipedia.org/wiki/Failure_cause" target="_blank" rel="noopener">失效模式</a>中最困难级别的。这意味着没有任何限制，也不会假设节点可以具有的行为类型（例如，一个节点可以生成任何类型的任意数据时假装成一个诚实的成员）。</p><p>其实我们注意到，拜占庭协议跟非拜占庭协议最大的特点就是对请求-应答节点数量的要求，在非拜占庭网络中，要对某个值达成一致，只需要收到大多数回复即可，也就是大于 1/2 的节点数，而在拜占庭网络中，则要求收到大于 2/3 的回复。</p><h5 id="区块链与拜占庭容错"><a href="#区块链与拜占庭容错" class="headerlink" title="区块链与拜占庭容错"></a>区块链与拜占庭容错</h5><p>区块链本质是一个去中心化帐簿，由于它存储在这些帐簿中的价值，不良成员有巨大的经济动机去尝试造成故障。所以，拜占庭容错的解决方案是区块链技术的核心要求。</p><p>比如，拿<a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener">比特币</a>来说，它一个重大突破就是利用“<a href="https://en.bitcoin.it/wiki/Proof_of_work" target="_blank" rel="noopener">工作量证明”(Proof-of-Work)</a>来作为拜占庭将军问题的概率解决方案。</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5 分钟理解什么是“响应式编程（Reactive Programming）”</title>
      <link href="/Programming/network-programming-reactive-programming/"/>
      <url>/Programming/network-programming-reactive-programming/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>许多人都听过异步编程，同步编程，但是好像对<strong>响应式编程</strong>这个新名称感到很陌生，即使我们在实际项目中已经在使用这种编程方式。</p><p>这篇文章就是来介绍响应式编程（Reactive Progamming）到底是怎么回事。</p><p>如果我们在 Google 中输入 Reactive Programming，试图了解这到底是怎样的一种编程模式，我们很快会发现大量的文章，但是看完我们就会迷糊，概念还是不是那么清晰。这可能是因为许多介绍文章对领域的强关联导致的。比如最常见的一种介绍是用一种数据流（data stream）的方式来展现，还有就是前端领域的控件事件流，虽然这些场景是响应式编程适合的，但是对我来说，总觉得还是不够直观。因为我面对的是分布式系统的编程场景。</p><p>其实响应式编程没必要跟具体的应用领域关联，它是一个可以普遍适用的概念和编程模型。</p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>分布式网络系统中，各个参与方节点的运行是相互独立的，没有共享内存，没有全局时钟。各节点通过消息来进行沟通。在传统的理念中，我们会把这样的网络根据他们通信方式描述成同步和异步的。简单来说，同步网络是对消息的到达时间有限定要求（time bounded），以便保证网络活动的确定性。而异步的网络，则对消息的到达没有任何限制。即使发出的消息丢失了，也不会损害网络的活性。用一个具体的例子来理解就是，节点 A 发送了一个消息给节点 B，期待得到 B 的回复，以便通过某个决议或者完成某件后续事情，这个依赖等待的要求，就是同步网络。因为他依赖一个答复才能进行后续动作。换句话说，如果一个节点发送消息之后，不依赖另一个节点的答复也能正常运行，那么就是异步网络。</p><p>在同步网络中，如果 B 由于网络原因（掉线，或者CPU繁忙，等等）没有在限定时间内回复，A 既不能确定消息已经发送给 B，也无法确定后续步骤什么时候才能开始，因此，网络活动变得不可预测，无法结束，也就是没有了确定性。业界已经证明了，在实际的网络中，如果不对网络条件施加任何限制，那么网络确定性是永远无法达到的。因此，为了保证网络活动的确定性，我们通常会网络条件施加一些限制，比如，最典型的就是消息到达的时间限制。</p><p>解释了同步网络和异步网络的区别，我们再来看同步编程和异步编程，其实我们接触这两个编程模式很久了。同步编程简单来说就是，发出一个任务，然后等待执行。而异步编程就是，发出一个任务，不等待结果，就继续发出下一个任务。至于上一个任务的执行结果，我们可以通过两种方式获得，一个是主动的轮训，另一个是被动的接收反馈。由于在异步编程中，我们从不等待执行结果，就可以进行其他任务（前提是这个任务本身不依赖上一个任务的结果）。如果要执行的某个其他任务依赖于上一个任务的结果，那么我们可以每隔一段时间轮训一次，或者另外开一个线程去等待接收任务结果。无论哪种情况，我们的网络都不会阻塞在某一个单独的任务上。</p><h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><p>现在，我们很自然的过渡到响应式编程（Reactive Programming）这个概念上，它是一种基于事件模式的模型。<strong>在上面的异步编程模式中，我们描述了两种获得上一个任务执行结果的方式，一个就是主动轮训，我们把它称为 Proactive 方式。另一个就是被动接收反馈，我们称为 Reactive。</strong> </p><p>简单来说，在 Reactive 方式中，上一个任务执行结果的反馈就是一个事件，这个事件的到来将会触发下一个任务的执行。</p><p>这也就是 Reactive 的内涵！我们把处理和发出事件的主体称为 Reactor，它可以接受事件并处理，也可以在处理完事件后，发出下一个事件给其他 Reactor。两个 Reactors 之间没有必然的强耦合，他们之间通过消息管道来传递消息。Reactor 可以定义一些事件处理函数，根据接收到的事件不同类型来进行不同的处理。如果我们的系统复杂，我们还可以专门定义不同功能类别的 Reactors，分别处理不同类型的事件。而在每个 Reactor 中对事件又进行细分处理。</p><p>需要强调的是，实现 Reactive 模型最核心的是<strong>线程</strong>和<strong>消息管道</strong>。线程用于侦听事件，消息管道用于 Reactor 之间通信不同的消息。与他们相关的是事件管理器用于注册、注销事件，而消息分配器则会根据消息类型分发。</p><p>下面是一个 Reactive 模型的示意图：</p><p><img src="/image/network/reactive_demo.png" alt=""></p><h3 id="术语理解"><a href="#术语理解" class="headerlink" title="术语理解"></a>术语理解</h3><p>在了解了上述异步编程模型的本质之后，我们再来看一些我们常见的术语，就会发现一切都变得清晰明了了。</p><p>比如，依赖链（Dependency chain），假定我们有一个事件依赖链是这样：睡觉 -&gt; 吃饭 -&gt; 饿了，很直觉的是，在这个依赖链中，只有满足了后面的条件，前面的才会执行。</p><p>这种依赖链是这个世界普遍的一种场景，一种正向的处理模式是，每隔一段时间就轮训检测是否满足睡觉的条件，在检查是否能睡觉的时候，会先检查是否已经吃饭，检查是否已经吃饭的时候，又会先检查是否饿了。那么这就是 Proactive 模式！而 Reactive 模式则反过来，先有事件的触发，然后事件来到响应方，响应方进行处理，这种方式也叫 Pub/Sub 模式。我们在 OOP 语言中，也会用到同样的概念和逻辑，我们把之叫做 Observer 模式，而在 Funcaitonal Programming 中，也有同样的概念，它可以用 monads 来实现。</p><p>比如，我们有一个 Publisher ，会产生 “饿” 事件，同时还有一个或多个 Subscriber，在收到 “饿” 事件的发生之后，进行响应（比如更新状态或者作出其他预先注册好的行为）。</p><p>总的来说，Reactive Programming 就是编写关于怎么响应事件的编程模式，这些事件包括：用户输入，数据流，系统状态的变化等等。</p><p>总结一下，响应式编程通常会用在一个事件流相关的场景中，在一个事件流中，一旦触发第一个事件，后续的事件会被依次触发，就像一个 Pipeline 系统，不断有输入和输出。</p><h3 id="响应式编程的设计与实现"><a href="#响应式编程的设计与实现" class="headerlink" title="响应式编程的设计与实现"></a>响应式编程的设计与实现</h3><p>接下来，讲一下实现上的架构设计与实现。</p><p>通常 Reactor 的数量可以是预先定义的，因为一个系统，我们通常可以约束它处理哪些预定义的事件，比如有处理网络连接的 Reactor，处理日志收集的 Reactor，处理数据存储的 Reactor 等等，各司其职。而错误（未定义）事件则可以单独放在一个专门处理 Error/Exception 的 Reactor 中。通过事件管理器，每个 Reactor 可以根据要发出或者接收的消息，即时地创建一个线程/协程去执行响应的操作。发出和接收消息可以根据业务的复杂度，分开单独线程，也可以放在一个线程。这样的设计架构简单而清晰。</p><p>下面是一个简单的示意图：</p><p><img src="/image/network/thread_demo.png" alt=""></p><p>全文完！</p><p><strong>相关阅读：</strong></p><p><a href="https://www.jianshu.com/p/8279d6fd65bb" target="_blank" rel="noopener">P2P 网络核心技术：Gossip 协议</a><br><a href="https://www.jianshu.com/p/e41aa1428df3" target="_blank" rel="noopener">P2P 网络核心技术：UPnP 和 SSDP 协议</a><br><a href="https://www.jianshu.com/p/eba4673b0d9a" target="_blank" rel="noopener">P2P 网络核心技术：Kademlia 协议</a></p><p>…</p><p>如果你喜欢我的文章，欢迎关注微信公众号“知辉”，搜索 “deliverit” 或</p><p>扫描二维码</p><p><img src="https://upload-images.jianshu.io/upload_images/1452123-0bf067df9e5fb332.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/258/format/webp" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>音阶图</title>
      <link href="/Music/music-uk-cmajor-scale/"/>
      <url>/Music/music-uk-cmajor-scale/</url>
      
        <content type="html"><![CDATA[<p>本文列举 C 大调音阶图，下面第一个图是自己制作的。</p><p><img src="/image/music/uk_c_major_scale.png" alt=""></p><p>大调：全全半全全全半<br>C Major: C D E F G A B C<br>G Major: G A B C D E F# G<br>F Major:  F G A Bb C D E F<br>A Major: A B C# D E F# G# A</p><p>小调：全半全全半全全<br>A Minor: A B C D E F G A<br>E Minor: E F# G A B C D E<br>D Minor: D E F G A Bb C D</p><p>下面的图，带彩色，即可以熟悉 C 和弦，又可以熟悉指板</p><p><img src="/image/music/uk_cmaj_color.png" alt=""></p><p><img src="/image/music/uk_scale_real.png" alt=""></p><p><img src="/image/music/uk_scale_gray.png" alt=""></p><p>记忆的时候要分组结合图形规律</p><p><img src="/image/music/uk_scale_group.png" alt=""></p><p>1、同颜色方框的排列形状是一样的，总结出来就三种情况，大家可以把 指板分块 单独记忆，再试着联系起来<br>2、我把所有的 1 都标红了，这些位置应该首先记住，以它们为中心去推导记忆<br>3、所有的 半音 都用黄色椭圆圈出来了，它们应该是第二步的定位点，也是我们后期定调的关键一步</p><p><img src="/image/music/uk_1.png" alt=""></p><p><img src="/image/music/uk_scale_explain.png" alt=""></p><p><img src="/image/music/scale_full.png" alt=""></p><p><img src="/image/music/c_major_01.png" alt=""></p><p><img src="/image/music/uk_scale_all.png" width="60%"></p><br>全文完！<br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Music </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ukulele </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ukulele Common Chords</title>
      <link href="/Music/music-uk-chord/"/>
      <url>/Music/music-uk-chord/</url>
      
        <content type="html"><![CDATA[<p>常用 4 和弦：C、Am、F、G/G7</p><p><img src="/image/music/chord_4_common.png" alt=""></p><p>再加上下面 2 个 Em/Em7、Dm<br><img src="/image/music/chord_2_common.png" alt=""></p><p>这就是 C 大调家族的 “国际六大和弦“</p><p>关于常见和弦，也有其他说法，比如常见的 7 个和弦，常见的 20 个和弦等等。</p><p>Ukulele 常用的 7 个和弦，实际上和弦类型还是上面的几种。只不过把 G 和 G7 分开计算而已。<br>Ukulele 常见的 20 个和弦，则是把各大调的主和弦、其对应的 Minor 和弦、以及 7 和弦加进来计算。<br>如下：</p><p><img src="/image/music/chord20_common.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Music </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ukelele </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链新型共识算法：Snowflake to Avalanche</title>
      <link href="/Distributed-System/blockchain-avalanche/"/>
      <url>/Distributed-System/blockchain-avalanche/</url>
      
        <content type="html"><![CDATA[<p>这篇文章介绍一个最新的区块链共识算法，它于 2018 年 5 月首次发布，是由一组共识协议构成的一个共识家族。相比于目前的主流的共识算法，它有一些重大创新和突破，非常值得探索。</p><h3 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h3><p>在 2018 年 5 月纽约举行的 Token Summit III 上，康奈尔教授埃米·冈·瑟勒（Emin Gun Sirer）发布了一个新型的区块链共识协议，它是由一组算法组成的家族，声称它是公式算法的重大突破和创新，这个算法家族集成了经典的 Non-Byzanting 共识算法和 Nakamoto 共识算法（即 POW） 两者的特点。用他们的话来说就是，简单而又强大无比。</p><p>目前国内科技界对这个共识协议还甚少了解，所以我决定动手对它进行一个详尽的介绍和分析。</p><p>这个算法的论文在 ipfs 讨论小组中被释出，如下：</p><p><img src="/image/p2p/avalanche_ipfspublish.jpeg" alt=""></p><h3 id="2、简介"><a href="#2、简介" class="headerlink" title="2、简介"></a>2、简介</h3><p>这篇论文中主要介绍的这种 BFT 协议是一组协议构成的（简称“协议家族”，Consensus family），它是基于亚稳态（metastable）模型的，这种模型可以提供很高概率的 BFT 安全性保证。 作者声称这个协议可以达到 1300 tps，交易也只需要 4 秒的确认延迟。</p><p>论文中讲到，“协议家族”的思想主要受到 Gossip 协议的启发（关于 Gossip 的运作机制，我在另一篇文章中有<a href="http://mp.weixin.qq.com/s?__biz=MzI1NjExNDEzMQ==&mid=2247483770&idx=1&sn=38a6bdfa9b5ed48ae684c1a66ff9b33a&chksm=ea2aedc6dd5d64d0945421c4596a5a1875a5cfc936f8e376d25777bb53ecd3e1223ab017acd6&scene=21#wechat_redirect" target="_blank" rel="noopener">详细介绍</a>）。</p><p>具体的思路是，通过不断反复对网络中的节点进行抽样（收集它们对某个提议的响应），最后可以把所有的诚实节点导向到同一个共识结果（agreement）。这里有一个关键的参数叫做 security parameter，通过调整这个参数可以把共识失败的可能性降到最低。</p><p>作为与目前主流的 Nakamoto Consensus（POW）算法的对比，作者指出，“协议家族”是一种更加绿色环保，安静并且非常高效的算法。</p><p>我们知道，在 POW 中，有一个重大的 tradeoff 就是用 Liveness 来换取冲突交易。我们知道 Liveness 是指在有效时间内一定会有一个确定结果（也叫 termination），而 POW 则不提供对每笔交易（包括冲突交易）的最终确定性的保证，但是提供了一个概率机制来保证这个结果的确定性程度。</p><p>而在“共识家族”中，只会为 “virtuous transaction” 保证 Safty 和 Liveness。也就是说，对于那些诚实的节点，他们的交易不会冲突，而且可以保证最终结果的确定性。</p><p>因为“共识家族”假定诚实节点总是会按规矩办事（correct clients follow the protocol as prescribed），它们不会作弊。而拜占庭节点则可能会发出流氓交易（rogue transactin）， “共识家族”对拜占庭发出的交易不做出任何 Liveness 的保证。（the protocols do not guarantee liveness for rogue transactions, submitted by Byzantine clients, which conflict with one another）</p><h3 id="3、协议构成及特点"><a href="#3、协议构成及特点" class="headerlink" title="3、协议构成及特点"></a>3、协议构成及特点</h3><p>“协议家族”一共是由 4 个协议构成的，先从 Non-Byzantine 协议开始：Slush，在其基础上逐渐构建 Snowflake，Snowball 和 Avalanche 这 3个 BFT 协议。它们全都基于亚稳态模型（metastable mechenism）。 </p><p><strong>下面就简单介绍下这组协议的特点：</strong></p><p><strong>1）</strong>首先，与 Bitcoin 类似，采用的也是概率安全保证机制。但是不同之处在于，采用了适量的、非常小的 choice ε （抽样参数），使得共识失败（consensus failure）的可能性非常小，几乎不可能。 </p><p><strong>2）</strong>其次，没有采用单一的 RSM （Replicated State Machine）模型，而是采用了一种叫做 <strong>“认证节点之间的并发共识模型”</strong>（Parallel Consensus Model with Authenticated Clients）。简单来说就是，可信的节点彼此维护自身独立的 RSM，并且他们之间还可以把自己的 RSM 的所有权（Ownership）进行 转移。系统为有关联的交易维护一个 Partial order（不了解 Partial Order 概念的可以去查看 Leslie Lamport 的论文《Time, Clocks, and the Ordering of Events in a Distributed System》）。 </p><p><strong>3）</strong>最后，对不良节点（misbehavior clients），不保证 liveness。但是对诚实节点（Well-behaved clients），它们的交易最终会被正确处理，既保证 safty 也保证 liveness。</p><p>整个系统实现的是类似比特币的机制，但是性能和扩展性都得到极大的提升。</p><p><strong>这里需要注意的是：</strong></p><p>“共识家族”对诚实节点（Correct nodes）和拜占庭节点（Byzanting nodes）的行为作了提前约定：诚实节点绝不会发出冲突交易，而拜占庭节点也不可能伪造一笔与诚实节点冲突的交易（也就是说，拜占庭节点发出的“伪造”交易，只会与自己以前发出过的交易冲突（比如双花 double spending），但是不可能与诚实节点的交易冲突），拜占庭节点可以伪造许多彼此冲突的交易，但是诚实节点只会采用其中一笔交易。</p><p>也就是说，最终，“共识家族协议”可以保证在存在拜占庭交易的情况下，共识的最终结果只会是接受一组互不冲突的交易集合。</p><p>此外，“共识家族”也采用了 UTXO 模型。</p><p><strong>Safty 和 Liveness</strong></p><ul><li><p>Safty：没有两个诚实节点会接受冲突的交易</p></li><li><p>Liveness：任何一笔由诚实节点发出的交易都会被其他节点所接受</p></li></ul><p>安全系数：ε<br>概率保证：1 - ε</p><h3 id="4、Slush-协议"><a href="#4、Slush-协议" class="headerlink" title="4、Slush 协议"></a>4、Slush 协议</h3><p>Slush 是“协议家族”的第一个协议，它是一个非拜占庭协议（Non-byzanting protocol，后续三个协议都是 BFT 协议），这个协议的运作原理如下：</p><p>1）所有节点最初是 uncolored 状态<br>2）当节点收到一个 client 发来的交易请求之后，它就立刻把自己变成 tx 中设置的 color，同时发起一笔 query。 </p><p>2.1)  执行 query 时，节点会随机选择一个相对小的节点样本 k，向他们发出 query 。</p><p>2.2)  如果是 uncolored 的节点收到 query，那么就染色，并回复 color。同时还会发起一个 query（也就是 Gossip）。</p><p>2.3)  如果是已经 colored 的节点收到 query，那么就回复自己已染的 color。 </p><p>2.4)  如果没有在限定时间内收到 k  个响应，那么节点就会从（之前 sample 后）剩余节点中继续选择一些节点发出 query。直到收集到所有 k  个 响应。 </p><p>2.5)  一旦收集到 k 个响应，就判断是否能存在一个 同颜色/总颜色的比率 fraction ≥ αk，α &gt; 0.5，它是一个协议参数（protocol parameter）。 如果 αk 阈值（threshold）满足，并且并且 sampled color 跟节点自身的 color 不一样，那么节点就会把自己的 color 变成 sampled color。然后，继续回到 query 步骤，发起新一轮的 query，总共发起 m 轮。最终，节点会在 m 时间期限内决定最终的 color。</p><p><strong>下面总结一下这个协议的特点：</strong> </p><p>######（1）简单状态（simple state）</p><p>节点是 memoryless 的，在每一轮 query 之间，除了 color，不保存其他任何状态。 </p><p>######（2）小样本（small sample）</p><p>不像其他共识算法，每轮必须向所有节点发出请求。Slush 只需要向一个很小（常量 k）的随机样本集发出 query。 </p><p>######（3）反复抽样（repeated sampling）</p><p>通过反复抽样，可以放大随机扰动。比如，即使初始状态是一个 50/50 的对等分裂状态（收到了两种冲突的 color 响应 ，且他们数量相同），抽样过程中的随机扰动（perturbation) 也会导致一种 color 会获得轻微的优势，然而协议通过反复的抽样可以不断放大这种优势。</p><p>######（4）抽样轮数或时间期限（用 m 表示）</p><p>如果 m 足够大，Slush 算法可以保证所有节点都有同等的机会被染色（colorized），每个节点每轮通信都会有一个常量的，可以预测的通信消耗。m 会随着 n 变大。 m 是指轮数或时间限制。 如果 Slush 被用在有 Byzantine 节点的网络中，那么由于 adversary 节点可以故意把自己翻转（flip）成一个与主流 color 不一样的 color 来打乱平衡，使得整个网络的安全性大大降低。 因此，我们把 Slush 协议作为 BFT 协议的原始状态，它不能提供完整的 BFT 保证。</p><h3 id="5、Snowflake-协议"><a href="#5、Snowflake-协议" class="headerlink" title="5、Snowflake 协议"></a>5、Snowflake 协议</h3><p>也叫 “BFT Snowflake”，它是“协议家族”的第二个协议，在 Slush 的基础上扩展而来。</p><p>Snowflake 为每个节点增加一个 counter， 用来记录一个节点当前 color 的可信度。 具体来说就是，counter 记录有多少连续的 sample 都产生了同一个 color。 如果一个节点的 counter 超过了某个阈值 β，它就会接受当前的 color。这个 β 是另外一个 security parameter。 </p><p><strong>Snowflake 对 Slush 的改进非常简单，下面也做个总结：</strong></p><p>（1）每个节点维护一个 counter 变量 。<br>（2）每当 color 进行改变，节点都会把 counter 值重置为 0。<br>（3）一旦 query 得到的响应结果中包含同一 color 的数量 ≥ αk，那么该节点就会把 counter 加 1。</p><p>当 Snowflake 选择了一个合适的 β 参数，和一个理想的 ε 安全系数，就可以同时保证 Safty 和 Liveness。 </p><p>论文在后面还介绍了一个 phase-shift 点，correct node 更倾向与做出一个决定而不是维持在一个 bivalent 状态。 并且，还会有一个叫做 point-of-no-return 的时间点，Byzantine node 在 phase-shift 之后失去控制，而 Correct node 则在 point-of-no-return 点之后开始 commit color。</p><h3 id="6、Snowball-协议"><a href="#6、Snowball-协议" class="headerlink" title="6、Snowball 协议"></a>6、Snowball 协议</h3><p>Snowball 是共识家族中的第三个协议，它对 Snowflake 协议做了改进，进一步增加了共识结果的可靠性（confidence）。</p><p>我们知道，Snowflake 中的状态标志是易逝的（ephemeral），counter 的值在每次 color 发生改变的时候都会被 reset。</p><p>虽然，理论上来说，Snowflake 可以保证对最小的状态做出很强的保证。 但是 Snowball 进一步做出了改进，方法是添加一个更持久的可信度标志，使得协议安全性更高。 </p><p>具体来说，Snowball 增加了一个 Confidence Counter ，用来记录能够产生指定 color 的达到 threshold 的 query 数量。 一个节点在经过一定数量的对某个 color 进行连续 query 之后，它对于该 color 的信心（信任程度）就会超过其他 color。 </p><p><strong>总结，Snowball 对 Snowflake 的主要改进如下：</strong></p><p>（1）每执行一次成功的 query，节点就把对该 color 的 confidence counter 值加 1。</p><p>（2）当节点对自身当前 color 的 confidence counter 值小于对新的 color 的 confidence counter 的值时，把当前 color 置换成新的 color。</p><p>Snowball 不仅比 Snowflake 更难攻击，而且协议更加通用化了。</p><p>下图是论文中对 Snowball 执行流程的伪代码描述：</p><p><img src="/image/p2p/snowball_psuedocode.jpeg" alt=""></p><h3 id="7、Avalanche-协议（DAG）"><a href="#7、Avalanche-协议（DAG）" class="headerlink" title="7、Avalanche 协议（DAG）"></a>7、Avalanche 协议（DAG）</h3><p>Avalanche 是“共识家族”中的第四个协议，也是最后一个协议，它在 Snowball 的基础上添加一个动态的仅限追加（append-only）DAG 结构来记录所有的交易。</p><p><img src="/image/p2p/avalanche_dag.jpeg" alt=""></p><p>这个 DAG 有一个单一的 sink 节点，也就是上图中的 genesis vertex。 </p><p>维护一个 DAG 这样的结构有两大优势： </p><p><strong>1）高效</strong></p><p>给 DAG 中的一个节点投票就意味着给从 genesis vertex 到该节点的路径上的所有节点都投票。 </p><p><strong>2）安全</strong></p><p>缠结了交易，类似比特币中对区块的组合方式，使得过去的决定非常难以被改变。 当节点创建一笔交易的时候，它需要引用一个或多个 parents 交易，由此，新的交易就与 parents 交易形成了 DAG 结构的边，不可分割。我们把后续发起的新交易叫做 child 交易，而过去的旧交易叫做 parent，child 和 parent 之间无需有任何的直接依赖关系。同时，我们把由 直接 parent 可以到达的所有祖先交易叫做祖先交易集（ancestor set），把可以引用的所有 child 叫做子孙交易（progeny）。 </p><p>维护 DAG 结构最大的一个挑战就是在面对冲突交易（conflicting transactions）的时候如何抉择与处理。 为了简化，我们把交易称为 T，当一个 T 被 queried 的时候，所有由 T 可达的 ancestry 都是当前节点 u 会优先考虑发送 query 的选项（preferred options）。如果超过一定 threshold 的 responders 投了 positive 票。那么我们就说，这个交易 T 就收集到了一个 Chit。表示为 CuT = 1，否则的话， CuT = 0。 节点 u 根据交易 T 的 progeny 的 chit sum 来计算 confidence。</p><p>论文中对 Avalanche 协议执行流程的伪代码描述如下：</p><p><img src="/image/p2p/avalanche_pseudocode.jpeg" alt=""></p><hr><h4 id="Avalanche-论证与实现细节"><a href="#Avalanche-论证与实现细节" class="headerlink" title="Avalanche 论证与实现细节"></a>Avalanche 论证与实现细节</h4><p>Avalanche 是“共识家族”的核心协议，下面介绍它的论证和详细实现流程：</p><p>先来看一个 T 的生成过程：</p><p><img src="/image/p2p/avlanche_t.jpeg" alt=""></p><p>我们用 Tu 表示节点 u 所记录的所有交易集合，它可以被拆分为互斥的两个冲突集合 PT , T ∈ Tu ，由于冲突是传递的，所以，如果 Ti 和 Tj  是互相冲突的交易的话，那么PTi = PTj 。</p><p>如果 T 选择的 Parent 是 T’，那么我们就用 T’ ← T 来表示，用</p><p><img src="/image/p2p/confidence_dut.png" alt=""></p><p> 来表示存在一条路径从 T 到 T’。</p><p>那么节点 u 就可以通过下面的公式来计算 confidence 值 du(T) ：</p><p><img src="/image/p2p/confidence_dut1.png" alt=""></p><p>除此之外，节点 u 还维护了一个本地已知的节点集合（Nu ⊆ N），为了简单起见，我们可以假定 Nu = N ，不同节点构建的 DAG 肯定是兼容的。具体来说就是，如果一个节点中存在  T’ ← T ，那么系统中其他节点也都必然满足 T’ ← T ，反则亦反。</p><p>每个节点都会实现一个基于事件驱动的状态机模型，主要围绕发送 query 、收集 votes 以及通知其他节点新交易 T 的存在这三个过程。</p><p><strong>具体流程就是：</strong></p><p><img src="/image/p2p/ontime_query.png" alt=""></p><p>当节点 u 收到 k 个响应，就检查其中是否存在至少 αk 个 yes-vote，如果存在，就表示 T 收集到了一个 Chit，记为 CT = 1，否则，记 CT = 0。</p><p>上述的过程会为 DAG 结构中的每个元素（即交易）标记上 Chit 值以及它关联的 confidence 值的大小。Chit 值是一次 sample 过程产生的，是不可变的值，而 confidence 则是会累加的，随着交易的增多，DAG 图的扩展会不断增加。</p><p>注意，confidence 之所以是会不断增加，是因为 Chit 值 CT 的取值只能是 0 或 1，所以 confidence 是 monotonic 增加的。</p><p>下面是论文中展示的一个经过不断抽样 sampling query 之后，交易被打上 chit value 和 confidence value 的 DAG 图：</p><p><img src="/image/p2p/dag_demo.jpeg" alt=""></p><p>上图中，颜色更深的方块表示 confidence 更高。每个节点用一个 pair 对 <code>&lt;chit, confidence&gt;</code> 来表示。比如，T2 的 confidence 是 5，它比 T3 （0）的 confidence 高。这也就意味着，T2 的后代比 T3 的后代更容易收集到 Chits。</p><p>最后，跟比特币一样，Avalanche 也把对最终交易的确认时间点（acceptance point）和决定权交给了应用层。应用层通过自己定义的谓词（Predicate），把接受交易的风险加入考虑。</p><p>确认一笔交易可以通过一个叫做 “safe eary commitment” 的动作来完成。对于诚实交易 T（virtuous transaction)，如果它是在包含它的冲突交易集 PT 中的唯一交易，并且受到的 Chit 超过阈值 β1，那么就认为 T 是可以接受的。如果一个诚实交易 T 由于 liveness 问题没被接受，那么它依然可以通过重新选择不同的 parents 交易来被接受。</p><p>由于不同的交易只会消费和生成自己的 UTXO，彼此互不相干，因此，任何交易都可以重新选择 parents。</p><hr><h4 id="网络模型与验证"><a href="#网络模型与验证" class="headerlink" title="网络模型与验证"></a>网络模型与验证</h4><p>为了验证“协议家族”的可靠性（Safety &amp; Liveness），对其网络模型以及实现条件进行了一些约束。</p><p><strong>1）网络模型（Network Model）</strong></p><p>假定是同步网络，同时，使用了一个全局的协调器（Scheduler）来随机选择发起节点。</p><p><strong>2）参数及变量</strong></p><p>用 C 表示诚实节点（Correct Node），B 表示拜占庭节点（Byzanting Node，c=|C|，b=|B|。</p><p>样本大小 k ∈ N+，抽样率 α 的值设置为 ：0.5 &lt; α ≤1。</p><p>Red 和 Blue 分别代表两种冲突的交易选择（conflicting choices）。</p><p>抽样方式采用超几何抽样（hypergeometric sample），被采样的k 个节点在完成前不会进行替换。</p><p>使用随机变量 <img src="/image/p2p/hkn1.jpeg" alt=""></p><p> 表示 R 在一次 sample 中收到的投票数，x 表示 R 收到的总投票数。</p><p>那么，query 达到阈值 αk 或者更多票的概率可以用下面的公式来表示：</p><p><img src="/image/p2p/hkn2.png" alt=""></p><p><strong>3）尾限（tail bound）</strong></p><p><img src="/image/p2p/tailbound.png" alt=""></p><p><strong>全文完！</strong></p><p><strong>相关阅读：</strong></p><p>…</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么你应该拥有一个 GV 号</title>
      <link href="/Life/life-get-gv/"/>
      <url>/Life/life-get-gv/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇文章主要为国内童鞋介绍 GV 的用处，如何申请以及如何使用。</p><p>GV 全称叫 Google Voice，是 Google 于 2009 年推出的 VOIP 服务，推出快 10 年了。我们知道 Google 在国内是被封锁的，访问不了，显然 Google Voice 也是封锁的访问不了，那么我们国内的童鞋要它由什么用呢？</p><p>Google Voice 提供的是网络电话服务，一个 GV 号就相当于一个美国国内的电话号码，美国电话号码的样式如下：214-198-1033。GV 号可以完成美国号码同样的功能，比如接打电话，呼叫转移，语音留言，接发短信等等。拥有一个 GV 号就相当于拥有一个美国国内的电话号码。就这么简单。</p><h3 id="1、有什么作用？"><a href="#1、有什么作用？" class="headerlink" title="1、有什么作用？"></a>1、有什么作用？</h3><p>现在来说说，这个电话号码我们能用来做什么，</p><p>首先，最简单直接的用途就是用来注册一些需要接受验证码的账号，有些美国的网站或者服务，是需要用手机来接收验证码才能注册的，比如雅虎、微软邮箱，还有 Netflix 等。现在，国内的大部分网站或者手机 APP 都强制要求电话号码进行实名注册了。鉴于国内的大环境，隐私保护是一个大问题，一旦你用自己的电话号码注册了这些网站，他们就会把你的个人信息卖给一些营销公司，你就会莫名其妙收到各种推销广告，烦不胜烦。但是，我注意到的是，有一些国内的网站或者手机 APP，可以支持用国外的手机号码来接受验证码来注册账号，那么 GV 号就有用武之地了，直接用来接受验证码即可。由于是国外号码，并不是你天天在使用的手机，营销公司爱咋推送就咋推送吧，它一方面也有成本，另一方面也不太能骚扰到我们。</p><p>除此之外，我来举几个具体的示例，比如 Telegram，作为国外互联网深度用户，这是我平时用得比较多的聊天工具，比微信安全很多。注册 Telegram 也是需要电话号码的，但是，如果我们只有国内电话号码用来注册的话，那会比较尴尬，因为 Telegram 本身就是被封锁的，那么需要通过一些特殊的方法才能访问。既然都需要特殊的方法了，那么使用国内电话号码肯定就不安全了，所以，最好是使用一个国外的号码，最好的选择就是 GV 号了。</p><p>还有 Twitter，Facebook 这些，都可以用 GV 号来搞定。此外，微信也可以用 GV 号来注册，如果你喜欢弄个微信小号，或许可以试一试，我没试过。</p><p>其实，GV 号还有很多其他用途，比如美国银行认证之类的比较高级。Google 推出 GV 服务的初衷是降低通话费用，所以，GV 号用来拨打国外电话是最正统的用途了，因为通话非常之便宜，而且，还支持语音留言，在国外，语音留言可是非常普遍的事情。</p><h3 id="2、怎么申请？"><a href="#2、怎么申请？" class="headerlink" title="2、怎么申请？"></a>2、怎么申请？</h3><p>说了这么多好处，那么怎么申请 GV 号？</p><p>对于国内的大部分普通用户来说，可能没那么简单。因为要访问许多很多国外的网站（比如 Google）提供的服务我们都需要一个前提，那就是梯子。梯子简单来说就是一个可以帮助你突破网络封锁的东西。</p><p>除了梯子这个前提，我们还需要一个 Google 账号，毕竟是 Google 自家提供的服务。</p><p>然后直接打开 GV 的官网主页（ <a href="https://www.google.com/voice" target="_blank" rel="noopener">https://www.google.com/voice</a>），进行注册就可以了。</p><p>需要注意的是，注册 GV 时，是需要关联一个真正的美国电话号码的，需要用这个号码来接受一个验证码。这就又变成先有鸡还是先有蛋的问题了，我们作为国内用户，鸡也没有，蛋也没有，苦逼啊。但是办法总比困难多，很多网站就提供临时美国电话号码，比如 TextNow.com，他们提供一个临时的美国电话号码可以用来接收验证码。这样，我们就可以假装自己有一个美国电话号码，就能用来注册 GV 号了。</p><p>但是理想是丰满的，现实是骨感的！由于注册的人次太多，GV 对注册增加了许多限制，比如，临时号已经不管用了，也就是说，使用 TextNow.com 这类网站提供的号码来注册 GV 号是没法注册成功的。这样的话，我们只有使用真正的美国电话卡才行了，这个简单，直接淘宝上搜“美国电话卡”就行了，如果真的对 GV 号有很大的需求，买一张美国电话卡的成本也不算高。其实有了美国电话号码，还有啥做不了的呢。</p><p>此外，注册过程一定要保证是访问 GV 官网的 IP 美国境内 IP 地址，否则的话，注册也会失败。这当然不是要求我们跑到美国去上网，只需要我们的代理地址是美国境内的就行了。</p><p>最后，那些图省事的，直接去 Telegram 上找人买一个 GV 号吧，也就 10 到 50 块钱左右，还能选个靓号。</p><h3 id="3、怎么使用-GV-号"><a href="#3、怎么使用-GV-号" class="headerlink" title="3、怎么使用 GV 号"></a>3、怎么使用 GV 号</h3><p>有了 Google Voice 号码之后，那么我们怎么使用？</p><p>其实很简单，我们在手机上装一个 Google Hangouts 就可以了。如下图：</p><p><img src="/image/hangout_setting.png" alt=""></p><h3 id="4、怎么保号"><a href="#4、怎么保号" class="headerlink" title="4、怎么保号"></a>4、怎么保号</h3><p>需要注意的是，GV 号长期不用是有可能被谷歌回收的，因此，如果想要长期拥有一个 GV 号，那么需要注意谷歌对于回收号码的政策。</p><p>通常来说，如果<strong>半年内</strong>使用 GV 号码<strong>主动</strong>发短信或者打电话，那么肯定不会被回收。</p><p>此外，Google 在回收前，会提前发邮件给你，如果你没做出应答，回收后的30天，你仍可以找回，超过的话，只能重新申请了。</p><p>保号的成本其实是很低的，因为 Google Voice 的美国号码拨打美国、加拿大号码是免费的，发短信也是免费的。</p><p>当然，此外，防止回收还有个办法（由 <a href="https://kn007.net/func/go.php?url=https://blog.lwl12.com/" target="_blank" rel="noopener">lwl12</a> 提供），可以用 IFTTT，详细动作见<a href="https://kn007.net/func/go.php?url=https://ifttt.com/applets/131839p-keep-google-voice-active" target="_blank" rel="noopener">传送门</a>。</p><p><strong>相关阅读：</strong></p><p>暂无</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>寻找适合恋爱的区块链工程师</title>
      <link href="/Distributed-System/distributed-system-candidate-like-friend/"/>
      <url>/Distributed-System/distributed-system-candidate-like-friend/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>作为区块链技术面试官，面试了不少人，对于怎么挑选到合适岗位的区块链人才，深感不是一件容易的事，有一次正巧看到一篇《像谈恋爱那样去招人》，感触颇深。因此，这篇文章打做一个总结，阐述如何成为一个合格的技术面试官以便能挑选到想要的区块链技术人才。</p><p>想要找到适合恋爱的区块链工程师，来看看我们需要做哪些准备吧。</p><h3 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h3><p>就像谈恋爱一样，你得先清楚你喜欢什么样的人，有的人喜欢萝莉，有的人喜欢御姐，有的喜欢热情奔放，有的人喜欢孤傲冷艳，但最重要的是你得知道喜欢什么样的。用人部门也一样，如果你在面试之前都不清楚自己想要的人是什么样的，那么后续的过程不可能顺利，面试过程会变得很没目的。撒网式招人的结果只能是抓来小鱼小虾，很难捕到大鱼大牛。也就是说，你每个女生/男生都去勾搭一遍，最后发现你只能吸引到胖女孩和丑男。所以，如果不明确自己想招什么人就把人拉来面试一通，那么本身就跟我这篇文章的主旨不符，请出门左转。</p><p>所以，在决定要什么样的区块链工程师之前，先问自己几个问题：</p><h5 id="1、是否做底层链开发？（想谈恋爱还是结婚）"><a href="#1、是否做底层链开发？（想谈恋爱还是结婚）" class="headerlink" title="1、是否做底层链开发？（想谈恋爱还是结婚）"></a>1、是否做底层链开发？（想谈恋爱还是结婚）</h5><p>是否做底层链开发这很关键，因为这决定了他对区块链底层技术的专注度，是否对技术有倾心的热爱。另外一层含义就是你对技术的追求，因为这方面的要求都相对会更高。它还包括了你包含对技术之路坎坷的认识，过程中的欣喜与痛苦，你都能恰到好处的平衡。说白了，你是在找一个适合结婚的人。</p><p>如果你并不需要一个底层链开发工程师，那就没必要这样要求你的候选人。因为你只是想要开发一个应用级别的产品，你出于对这个想法的热爱，你一定要跟这个应用来一场恋爱，不管结果如何，那么你的选择余地就大了很多，很多候选人都符合这个特征，他们出于对某个行业，某个领域或者某种技术的热爱而选择了这个行业，有的人喜欢比特币的纯粹，有的人喜欢以太坊的包容万象，有的人喜欢区块链游戏，那么，按照这些要求去寻找你的候选人吧，他们就是你要恋爱的对象。</p><h5 id="2、需要掌握哪些开发技术？（C-，Java，Go-Nodejs-etc）"><a href="#2、需要掌握哪些开发技术？（C-，Java，Go-Nodejs-etc）" class="headerlink" title="2、需要掌握哪些开发技术？（C++，Java，Go, Nodejs, etc）"></a>2、需要掌握哪些开发技术？（C++，Java，Go, Nodejs, etc）</h5><p>取决于团队正在使用何种技术，这里说的技术不仅是指语言上的，还包括领域上的，比如网络开发和桌面开发显然差别很大，做大数据的和做工程开发的共同点也不是很多。另一方面，虽然语言只是工具，但是学习一门新的语言达到熟练运用的程度还是需要一定的学习成本的，而如果候选人本身就已经熟练使用某门开发语言，那么学习成本将大大降低，即插即用的候选人是每个团队都非常渴望的。</p><p>所以，如果你团队是使用 Java的，那么尽量不要去招 C++ 的并劝他们转型，不仅学习成本高收益小，而且对方转型之后也优势尽失，大概率是双输的局面。跟谈恋爱一样，不要试图改变对方，而是突出对方的优势，然后包容其那些不影响大局的缺陷。</p><h5 id="3、需要多少经验？（谈过几个男-女朋友）"><a href="#3、需要多少经验？（谈过几个男-女朋友）" class="headerlink" title="3、需要多少经验？（谈过几个男/女朋友）"></a>3、需要多少经验？（谈过几个男/女朋友）</h5><p>经验这个东西非常珍贵，尤其是区块链行业，有经验的人不多，有丰富经验的人更少。虽然恋爱经验多变渣男渣女的概率大，但是也不能否认恋爱经验可以帮助你在后来的感情问题处理上更加成熟。因此，如何衡量经验在区块链研发过程中的作用和权重就显得非常重要。在我看来，区块链的工程研发最重要的还是实战经验，如果只是看看书本介绍，或者短期参与过一些外围项目，讨论会，演讲会等，都很难比得上实战（hands on）经验。很多候选人过来面试的时候声称看过以太坊或比特币的源码，手动部署过节点，甚至基于这些源码研发过一些项目，这可以说是比较珍贵的了，但是可惜的是，由于平台的缺乏，他们大多数依然还是对其中许多概念模糊不清，没有一定时间跨度的积累，在开发正式项目的时候依然会显得茫然。其实我最看重的还是思考和总结，如果没有停下来思考的习惯，不仅说明候选人的学习能力不强，而且你会担心他以后的成长空间。</p><p>简而言之，要寻找一个合格的区块链工程师，经验不是最重要的，但是不能没有。过来参加面试的候选人或多或少都会至少看过源码，动手改过或开发过相关的工程，最重要的是要考核他们在这个过程中的收获，如果发现候选人没有思考和总结的能力，请出门左转。</p><h3 id="二、面试"><a href="#二、面试" class="headerlink" title="二、面试"></a>二、面试</h3><p>到这个阶段时，通常是面试官和候选人已经被彼此吸引了。面试官看到合适候选人的简历时心情通常是小鹿乱撞，满怀期望，毕竟有区块链背景的候选人在市场上可是香饽饽啊。所以，这时候就需要进入试探期。</p><p>有些讲究的公司会先进行一轮电话面试，避免出现男/女神也会拉屎这种幻想破灭的情形。电话面试的主要目的还是进一步筛选，尤其是这种新型行业，很多人号称有区块链技术背景，但实际上他只是在网上看过几篇介绍文章。所以，这个过程可以帮助我们排除一些简历上的明显的水分。另外，还可以借此确认一下候选人目前的状态，跳槽的意愿等等。不过，由于过程都是在电话中进行的，就像在 QQ 或微信中网恋，可以对对方有一个模糊的印象，但是网恋肯定是生不出孩子的，所以我们还是需要约定一个正式面试的时间，并且把重心放在正式面试，也就是现场面试上。</p><p>现场面试就是面试官和候选人的第一次正式约会了，时间地点的选择都不能太过随意，站在面试官的角度，在一个相对空闲的时间段参加面试不会显得仓促，也能更全面的对候选人进行考察。</p><p>当然，时间地点在整个面试过程中仅仅是第一步，要进行一场有收获的面试，面试官还需要做到下面几点：</p><h3 id="1、专业性-Professional"><a href="#1、专业性-Professional" class="headerlink" title="1、专业性 Professional"></a>1、专业性 Professional</h3><p>专业性是我最强调的一个原则。我们是来招专业区块链人才的，因为我们首先就必须专业，否则要被人耻笑。这个道理就好比你去一家餐馆吃饭，他们给你上了菜却没有及时提供餐具，或者菜单上有的菜但是点的时候却没有，你会觉得他们不专业。又或者一个房产中介给你推销房子，但是你问起周边配套，比如学校，医院等信息，对方却不能说清一二，你也会觉得不够专业。</p><p>作为招聘方，我们要在面试过程中体现我们的专业性。这里的专业性不仅仅是指技能上的，还包括礼仪和流程上的，往往后者更加重要。把面试想象成是一场约会的话，那么约会的整个过程都应该提前规划好（时间，地点，流程安排，话题准备等等）。而且，由于双方目的明确（打着招区块链工程师的幌子，却招其他工种在这里是不存在的），所以通常会很容易进入话题。这个时候，我们才进入技能专业的话题上，我们可能需要聊聊比特币或者以太坊的技术细节，如果我们聊到炒币的话题上去，显然我们就进入了一个误区。</p><p>总的来说，专业性体现在很多方面，每个人看法也不一样。在我看来，一方面用人部门需要做好充分准备工作，另一方面就是要掌握面试过程中的一些技巧，我大致列举了下面几个需要特别强调的点：</p><h5 id="1）是否了解过候选人？"><a href="#1）是否了解过候选人？" class="headerlink" title="1）是否了解过候选人？"></a>1）是否了解过候选人？</h5><p>如果连正式面试前，连简历都没看过，从选人从何而来，将去何方，有何优势，是否适应区块链开发，等等信息。有了这些信息，你才不用查户口，而是可以有针对性的答疑解惑。这个过程可比相亲简单多了，相亲的时候你通常对对方一无所知，很多时候很难避免查户口式沟通，但是现在候选人简历摆在你面前，了解简历再进行面试是做到专业性最基本的要求。所以这里其实是考察你面试前的准备工作。</p><h5 id="2）聊什么话题？"><a href="#2）聊什么话题？" class="headerlink" title="2）聊什么话题？"></a>2）聊什么话题？</h5><p>技术面试就是技术面试，尽量少扯一些有的没的，比如你去过哪玩，你喜不喜欢打篮球，玩 LOL。虽然这些问题有助于提高沟通平滑度，但还是把他们留给 HR 吧。技术面试官则一定要把握主旨，那就是要让候选人体会到我们是在招区块链工程师，你需要懂区块链，你得懂共识算法是怎么回事。</p><p>我遇到过几个候选人没展现专业性的，比如我看到有的候选人面试的是区块链工程师岗位，但是我看到简历上竟然把计算机二级证书列上了，我当时就善意地提醒了一下候选人，我们是来面试区块链开发，如果你是在寻求一个财务或市场职位，我觉得列举这个算是一个加分项，但是如果作为专业的开发人员，看到这个东西，我会觉得你很不专业。还有一个例子就是，让一个候选人描述线程进程的区别，他用了网页 Tab 和 QQ 窗口做例子，我想说虽然这个描述没错，但是更像是一个不专业的人在用他能理解的方式去描述一个专业的事情。专业知识上的沟通，在我看来，就是在一个语境下，两个人能用同一种语言在进行灵魂的对话。</p><h5 id="3）流程和礼仪是否令人愉悦？"><a href="#3）流程和礼仪是否令人愉悦？" class="headerlink" title="3）流程和礼仪是否令人愉悦？"></a>3）流程和礼仪是否令人愉悦？</h5><p>前面讲了，专业不仅体现在知识和技能上，还体现在各项流程和礼仪上。我这里举几个例子，比如，不再核查候选人资格，通过初筛后进入面试流程的人，其硬性条件已经合格，如果再以这个理由拒绝候选人，那么就显得业余。还有一些明显非常业余的行为也应该尽量避免，比如面试官迟到，候选人来到公司长时间都没人接待，一面跟二面问大量同样的问题，面试过程中打电话，无故离开，借口领导不在，HR 不在，没时间改期再约等等。<br><strong>专业，需要我们平时多多观察和体会这个词的内涵。</strong></p><h3 id="2、氛围"><a href="#2、氛围" class="headerlink" title="2、氛围"></a>2、氛围</h3><p>面试气氛的营造很是面试顺利的重要因素，这要求我们掌握基本的沟通技巧和面试礼仪。轻松愉快的气氛更容易引导候选人展示其优势。我遇到过有的候选人是对比特币情有独钟的，对方仔细研究过部分比特币源码，所以我会尽量把话题引向他熟悉的领域，而不是问一些他了解甚少的以太坊。</p><p>所以面试官尤其要注意一些宗旨：面试官和候选人是平等的，虽然存在一定的考核场景，但是面试终究是一个双方选择的过程。面试官切不可盛气凌人。好的面试官应该通过适当的引导，淡化面试过程中紧张的气氛。</p><p>面试的目是让应试人展现自己的知识、能力和性格。而不是体现面试官有多厉害，故意刁难面试者，有些面试官自身没有经过一定的培训，也缺乏这方面的意识，容易造成角色定位上的偏差。</p><p>所以，谦虚和开放的心态非常重要，每个人的背景和经历都不尽相同，很可能候选人的知识广度超过面试官，或者在某个领域的专业技能也超过面试官。因此，一个优秀的面试官必须保持非常开放的心态，保持谦虚能够更好的利用这种场景，发掘候选人更多的亮点。当然，面试官需要一点控场能力，不能让候选人偏离岗位主题过远。</p><h3 id="3、考察与发掘"><a href="#3、考察与发掘" class="headerlink" title="3、考察与发掘"></a>3、考察与发掘</h3><p>很多候选人都善于夸大简历中的经历，除了虚构一些自己并不掌握的技术，还有一个普遍的现象就是把别人的经历拿来作为自己的。因此，对简历上列举的技能和经历进行核查，在我看来是非常重要的一环，这个不仅涉及到技能水平的问题，还涉及到候选人的道德品质问题。当然，要区别包装和造假的区别，对于适当的美化，只要不是造成质变的造假，都不应过分追究。</p><p>想要确定简历上的水分有多少，一定要与他聊简历上的项目，很多候选人把别人的经历写成自己的，这种情况我们需要深入的去了解具体项目中的细节，甚至可以具体到代码实现，逻辑结构，机制原理。如果候选人倾向于泛泛而谈，那么我们就可以对他有一个基本的认识。</p><p>对于不同职业阶段的候选人，或多或少都曾经历过一些亮点或者闪光点，如果候选人不善于表达，或许就不容易被发现。因此，作为面试官，更多的像是一个“伯乐”的过程，要善于发现候选人的闪光点，当然，这里的闪光点不仅限于岗位要求，它包括很多很多方面（比如沟通能力，诚信，逻辑思维，兴趣动力等等），这些闪光点的发现能更加有助于评估候选人对于岗位的适应性。就比如我前面说到的，如果候选人对某个区块链项目熟悉，那么我们就应该顺藤摸瓜，挖掘他的掌握程度，这样，即使他所做的项目跟我们的项目不一样，我们也可以知道他的创造力和学习能力。</p><p>另外，对于技术上的亮点，我们通常还可以让候选人自己阐述一下项目中遇到过什么坑，怎么解决的，以往的经历中有没有觉得自豪的部分之类的。然后根据对方的描述来进一步深入讨论。</p><h3 id="4、非技术因素"><a href="#4、非技术因素" class="headerlink" title="4、非技术因素"></a>4、非技术因素</h3><p>除了纯技术上的评估，面试官还应该关注下列这些特质：<br>•   1）这个人是否追求卓越，是否有主人翁精神，是否有探险/创新/接受新事物的精神，是否愿意承担责任等等。<br>•   2）沟通力，幽默，气氛。文化适应性，适应能力。<br>•   3）职业规划</p><p>总结起来，这些特质会影响他可能会为公司创造的价值，以及你是否愿意和这人一起工作。</p><p>当然，我们不应对这些特质吹毛求疵，我们需要知道，很多伟大的人都是性格怪异的，有些性格并不是他创造价值的障碍，最重要的是要明确我们需要的重点是什么。如果爱她/他，那就包容她/他吧，毕竟区块链的人才真的很宝贵。</p><h3 id="5、结束面试"><a href="#5、结束面试" class="headerlink" title="5、结束面试"></a>5、结束面试</h3><p>面试的时间根据面试官自身的把握应该要有一个控制，在我看来，一个完整的面试我一般会进行 1.5 小时至 2 小时。因为，区块链工程师面试通常需要涉及到画一些示意图（共识流程，数据结构，程序架构等），还少不了现场编编码解决问题等，需要一定的时间才能对对方有一个相对合理的了解。但是有时候，需要提前终止面试，比如面试过程中发现候选人明显不符合岗位的要求，以至于面试官觉得接下去已经是浪费时间，那么可以及时终止面试以节约双方的时间。</p><p>我就遇到过，候选人上来就各种巴拉巴拉一顿吹一个月就看完了以太坊的全部源码，而他在这之前甚至连 Go 语言都没用过。遇到这种情况，我一般都会让对面把逼先装完，然后问一下他的薪资期望，然后送他到楼梯口说声再见。还有一种情况是，候选人有口臭，我遇到过，当时我试图保持镇定，但是由于我位于正对面，气味比较浓烈，我最终还是觉得无法接受这种形象的人作为同事而提前结束了面试。</p><p>这里提前结束面试的时候，一定要注意礼貌，不能让对面感觉是被冒犯了，我觉得不冒犯别人也是一种素养，所以我尽力做到对即使不满足岗位要求的人也做到礼貌的拒绝。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>完美的面试可能过于理想化，也没有统一的标准的来定义，但是一场好的面试是有迹可循的，对于面试官和候选人来说都是一次挑战，尤其是技术面试，面试官和候选人都需要投入脑力和综合素质上的交互才有可能达成一个好的结果。期待每个面试官都能在实践中完善自己的面试方法论，也期待大家遇到更好的区块链工程师候选人。</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P2P 网络核心技术：Gossip 协议</title>
      <link href="/Distributed-System/distributed-system-p2p-gossip/"/>
      <url>/Distributed-System/distributed-system-p2p-gossip/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>Gossip protocol 也叫 Epidemic Protocol （流行病协议），实际上它还有很多别名，比如：“流言算法”、“疫情传播算法”等。</p><p>这个协议的作用就像其名字表示的意思一样，非常容易理解，它的方式其实在我们日常生活中也很常见，比如电脑病毒的传播，森林大火，细胞扩散等等。</p><p>Gossip protocol 最早是在 1987 年发表在 ACM 上的论文 《Epidemic Algorithms for Replicated Database Maintenance》中被提出。主要用在分布式数据库系统中各个副本节点同步数据之用，这种场景的一个最大特点就是组成的网络的节点都是对等节点，是非结构化网络，这区别与之前介绍的用于结构化网络中的 DHT 算法 Kadmelia。</p><p>我们知道，很多知名的 P2P 网络或区块链项目，比如 IPFS，Ethereum 等，都使用了 Kadmelia 算法，而大名鼎鼎的 Bitcoin 则是使用了 Gossip 协议来传播交易和区块信息。</p><p>实际上，只要仔细分析一下场景就知道，Ethereum 使用 DHT 算法并不是很合理，因为它使用节点保存整个链数据，不像 IPFS 那样分片保存数据，因此 Ethereum 真正适合的协议应该像 Bitcoin 那样，是 Gossip 协议。</p><h5 id="这里先简单介绍一下-Gossip-协议的执行过程："><a href="#这里先简单介绍一下-Gossip-协议的执行过程：" class="headerlink" title="这里先简单介绍一下 Gossip 协议的执行过程："></a>这里先简单介绍一下 Gossip 协议的执行过程：</h5><p>Gossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。</p><p>下面，我们通过一个具体的实例来体会一下 Gossip 传播的完整过程</p><p>为了表述清楚，我们先做一些前提设定：</p><p>（1）Gossip 是周期性的散播消息，把周期限定为 1 秒<br>（2）被感染节点随机选择 k 个邻接节点（fan-out）散播消息，这里把 fan-out 设置为 3，每次最多往 3 个节点散播。<br>（3）每次散播消息都选择<strong>尚未发送过的节点</strong>进行散播<br>（4）收到消息的节点不再往发送节点散播，比如 A -&gt; B，那么 B 进行散播的时候，不再发给 A。</p><p>这里一共有 16 个节点，节点 1 为初始被感染节点，通过 Gossip 过程，最终所有节点都被感染：</p><p><img src="/image/p2p/gossip_demo.gif" alt=""></p><p>下面来总结一下</p><h3 id="Gossip-的特点（优势）"><a href="#Gossip-的特点（优势）" class="headerlink" title="Gossip 的特点（优势）"></a>Gossip 的特点（优势）</h3><p><strong>1）扩展性</strong><br>网络可以允许节点的任意增加和减少，新增加的节点的状态最终会与其他节点一致。</p><p><strong>2）容错</strong><br>网络中任何节点的宕机和重启都不会影响 Gossip 消息的传播，Gossip 协议具有天然的分布式系统容错特性。</p><p><strong>3）去中心化</strong><br>Gossip 协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。</p><p><strong>4）一致性收敛</strong><br>Gossip 协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logN。</p><p><strong>5）简单</strong><br>Gossip 协议的过程极其简单，实现起来几乎没有太多复杂性。</p><p>Márk Jelasity 在它的 《Gossip》一书中对其进行了归纳：</p><p><img src="/image/p2p/gossip_pseudo_code.png" alt=""></p><h3 id="Gossip-的缺陷"><a href="#Gossip-的缺陷" class="headerlink" title="Gossip 的缺陷"></a>Gossip 的缺陷</h3><p>分布式网络中，没有一种完美的解决方案，Gossip 协议跟其他协议一样，也有一些不可避免的缺陷，主要是两个：</p><p><strong>1）消息的延迟</strong><br>由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。<strong>不适合用在对实时性要求较高的场景下。</strong></p><p><strong>2）消息冗余</strong><br>Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了<strong>消息的冗余</strong>，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送而且不反馈，因此，即使节点收到了消息，还是会反复收到重复消息，加重了消息的冗余。</p><h3 id="Gossip-类型"><a href="#Gossip-类型" class="headerlink" title="Gossip 类型"></a>Gossip 类型</h3><p>Gossip 有两种类型：</p><ul><li>Anti-Entropy（反熵）：以固定的概率传播所有的数据</li><li>Rumor-Mongering（谣言传播）：仅传播新到达的数据</li></ul><p>Anti-Entropy 是 <strong>SI model</strong>，节点只有两种状态，Suspective 和 Infective，叫做 simple epidemics。<br>Rumor-Mongering 是 <strong>SIR model</strong>，节点有三种状态，Suspective，Infective 和 Removed，叫做 complex epidemics。</p><p>其实，Anti-Entropy 反熵是一个很奇怪的名词，之所以定义成这样，Jelasity 进行了解释，因为 Entropy 是指混乱程度（disorder），而在这种模式下可以消除不同节点中数据的 disorder，因此 Anti-Entropy 就是 anti-disorder。换句话说，它可以提高系统中节点之间的 similarity。</p><p>在 <strong>SI model</strong> 下，一个节点会把所有的数据都跟其他节点共享，以便消除节点之间数据的任何不一致，它可以保证最终、完全的一致。</p><p>由于在 SI model 下消息会不断反复的交换，因此消息数量是非常庞大的，无限制的（unbounded），这对一个系统来说是一个巨大的开销。</p><p>但是在 <strong>Rumor Mongering (SIR Model)</strong> 模型下，消息可以发送得更频繁，因为消息只包含最新 update，体积更小。而且，一个 Rumor 消息在某个时间点之后会被标记为 removed，并且不再被传播，因此，SIR model 下，系统有一定的概率会不一致。</p><p>而由于，SIR Model 下某个时间点之后消息不再传播，因此消息是有限的，系统开销小。</p><h3 id="Gossip-中的通信模式"><a href="#Gossip-中的通信模式" class="headerlink" title="Gossip 中的通信模式"></a>Gossip 中的通信模式</h3><p>在 Gossip 协议下，网络中两个节点之间有三种通信方式:</p><ul><li>Push: 节点 A 将数据 (key,value,version) 及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据</li><li>Pull：A 仅将数据 key, version 推送给 B，B 将本地比 A 新的数据（Key, value, version）推送给 A，A 更新本地</li><li>Push/Pull：与 Pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 则更新本地<br>如果把两个节点数据同步一次定义为一个周期，则在一个周期内，Push 需通信 1 次，Pull 需 2 次，Push/Pull 则需 3 次。虽然消息数增加了，但从效果上来讲，Push/Pull 最好，理论上一个周期内可以使两个节点完全一致。直观上，Push/Pull 的收敛速度也是最快的。</li></ul><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>对于一个节点数为 N 的网络来说，假设每个 Gossip 周期，新感染的节点都能再感染至少一个新节点，那么 Gossip 协议退化成一个二叉树查找，经过 LogN 个周期之后，感染全网，时间开销是 O(LogN)。由于每个周期，每个节点都会至少发出一次消息，因此，消息复杂度（消息数量 = N * N）是 O(N^2) 。注意，这是 Gossip 理论上最优的收敛速度，但是在实际情况中，最优的收敛速度是很难达到的。</p><p>假设某个节点在第 i 个周期被感染的概率为 pi，第 i+1 个周期被感染的概率为 pi+1 ，</p><p>1）则 Pull 的方式:<br><img src="/image/p2p/gossip_pull_equation.png" alt=""></p><p>2）Push 方式：<br><img src="/image/p2p/gossip_push_equation.png" alt=""></p><p>可见，Pull 的收敛速度大于 Push ，而每个节点在每个周期被感染的概率都是固定的 p (0&lt;p&lt;1)，因此 Gossip 算法是基于 p 的平方收敛，也称为概率收敛，这在众多的一致性算法中是非常独特的。</p><p>全文完！</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P2P 网络核心技术：UPnP 和 SSDP 协议</title>
      <link href="/Distributed-System/distributed-system-p2p-upnp/"/>
      <url>/Distributed-System/distributed-system-p2p-upnp/</url>
      
        <content type="html"><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>UPnP， Universal Plug and Play，中文是 “通用即插即用”。在理解 UPnP 之前，我们先了解一下传统的 PnP 技术，因为 UPnP 是对于传统 PnP（即插即用）概念的扩展。</p><p>传统的 PnP <strong>“即插即用”</strong>是指 PC 电脑在添加硬件设备时可以自动处理的一种标准。在 PnP 技术出现以前，当需要为 PC 电脑安装新的硬件（比如：声卡，CD-ROM，打印机）时，这些设备需要用到 PC 电脑的 DMA 和 IRQ 等资源，为了避免硬件设备对计算机这些资源使用上的冲突，我们就需要<strong>手工为新添加的硬件设备设置中断和 I/O 端口</strong>（比如，想要为添加的声卡占用中断 5，就找一个小跳线在卡上标着中断 5的针脚上一插）。这样的操作需要用户了解中断和 I/O 端口的知识，并且能够自己分配中断地址而不发生冲突，对普通用户提出这样的要求是不切实际的。</p><p>PnP “即插即用”技术出现以后，可以<strong>自动为新添加的硬件分配中断和 I/O 端口，用户无须再做手工跳线，也不必使用软件配置程序</strong>。唯一的要求就是操作系统需要支持 PnP 标准，同时所安装的新硬件也符合 PnP 规范的。</p><h2 id="UPnP-协议介绍"><a href="#UPnP-协议介绍" class="headerlink" title="UPnP 协议介绍"></a>UPnP 协议介绍</h2><p>现在我们讲 UPnP，在网络世界里，<strong>当一个主机加入网络时，其行为模式跟我们上述的添加和删除设备是类似的。</strong>尤其是在私有网络和公网交互的时候，私有网络中的主机使用的是内网 IP 地址，是无法被外网的主机直接访问的。必须借助 NAT 网关设备（本地路由器）把内网地址映射到网关的公网地址上。</p><p>简单来说就是， NAT 网关设备拥有一个公网 IP 地址（比如 10.59.116.19），内网中的主机（比如 192.168.1.101）想要与外界通信的话，NAT 网关设备可以为其做一个端口映射（比如：180.59.116.19 :80 —&gt; 192.168.1.101 :80），这样，外部的主机发往 NAT 网关的数据包都会被转发给内网的该主机，从而实现了内网中的主机与外部主机的通信。</p><p><img src="/image/p2p/p2p_nat01.png" alt=""></p><p>当内网中的主机想要被外界主机直接访问（比如开放 80 端口，对外提供 HTTP 服务），我们就需要在 NAT 设备中为当前主机手工配置端口映射，如果内网中有多台主机都想要被外界主机直接访问的话，我们必须在同一个 NAT 设备上为这些主机分别做端口映射，它们之间不能使用有冲突的端口。这个过程需要用户手工一一配置，显然给用户带来了很大的麻烦。</p><p><img src="/image/p2p/p2p_nat02.png" alt=""></p><p>UPnP 技术标准的出现就是为了解决这个问题，只要 NAT 设备（路由器）支持 UPnP，并开启。那么，当我们的主机（或主机上的应用程序）向 NAT 设备发出端口映射请求的时候，<strong>NAT 设备就可以自动为主机分配端口并进行端口映射</strong>。这样，我们的主机就能够像公网主机一样被网络中任何主机访问了。</p><h2 id="UPnP-的应用场景"><a href="#UPnP-的应用场景" class="headerlink" title="UPnP 的应用场景"></a>UPnP 的应用场景</h2><p>UPnP 典型的应用场景就是家庭智能设备的互联，还有，目前在网络应用比如 BitTorrent, eMule，IPFS，Ethereum 等使用 P2P 技术的软件，UPnP 功能为它们带来极大的便利。比如：利用 UPnP 能自动的把它们侦听的端口号映射到公网地址上，这样，公网上的用户也能对当前的 NAT 内网主机直接发起连接。</p><h3 id="实现-UPnP-所需条件"><a href="#实现-UPnP-所需条件" class="headerlink" title="实现 UPnP 所需条件"></a>实现 UPnP 所需条件</h3><p>必须同时满足三个条件：</p><ul><li>NAT 网关设备必须支持 UPnP 功能；这是因为它需要扮演控制点（239.255.255.250:1900）的角色，控制点提供的是 SSDP 服务。</li><li>操作系统必须支持 UPnP 功能；比如 Windows 系列操作系统；</li><li>应用程序必须支持 UPnP 功能；比如 Bt、eMule、IPFS, Ethereum 等。</li></ul><p>以上三个条件必须同时满足，缺一不可。</p><p><strong>注：</strong>大多数路由器都是支持 UPnP 的，有的是默认开启，有的需要手工开启。</p><p><img src="/image/p2p/router_unpn_enabled.png" alt=""></p><h4 id="UPnP-这么好，那么我们应该立即开启吗？"><a href="#UPnP-这么好，那么我们应该立即开启吗？" class="headerlink" title="UPnP 这么好，那么我们应该立即开启吗？"></a>UPnP 这么好，那么我们应该立即开启吗？</h4><p>非也，如果我们的电脑并不需要 UPnP 所提供的功能，比如，我们的电脑并不想要对外直接提供服务，也不运行上述 P2P 软件，那么我们就无需开启 UPnP。因为一旦开启 UPnP，就意味着我们把自己的主机暴露在公网环境中，任何主机都可以向我们的电脑发起连接，NAT 设备会对所有收到的数据包不进行任何 authentication 认证而转发给我们的主机，这样，路由防火墙就会完全失效，我们的主机就很容易受到恶意的网络窥探，感染病毒或者恶意程序的几率也大大增加。</p><p><strong>注：</strong>上述 NAT 设备通常就是指我们本地的路由器。</p><h2 id="SSDP-协议"><a href="#SSDP-协议" class="headerlink" title="SSDP 协议"></a>SSDP 协议</h2><p>介绍完了 UPnP 的概况，为了完整性，现在再介绍一下 UPnP 规范下的 SSDP 协议，SSDP 全称是 Simple Service Discover Protocol 简单服务发现协议，这个协议是 UPnP 的核心，在 UPnP 中定义了一组协议框架，其中有控制点，根设备等概念，UPnP 设备通过 SSDP 协议与根设备（用户设备）进行交互。SSDP 是应用层协议，使用 HTTPU 和 HTTPMU 规范，基于 UDP 端口进行通信。</p><p>SSDP 使用一个固定的组播地址 <code>239.255.255.250</code> 和 UDP 端口号 <code>1900</code> 来监听其他设备的请求。</p><p>SSDP 协议的请求消息有两种类型，第一种是服务通知，设备和服务使用此类通知消息声明自己存在；第二种是查询请求，协议客户端用此请求查询某种类型的设备和服务。</p><h4 id="1）设备查询"><a href="#1）设备查询" class="headerlink" title="1）设备查询"></a>1）设备查询</h4><p>当一个客户端接入网络的时候，它可以向一个特定的多播地址的 SSDP 端口使用 <code>M-SEARCH</code> 方法发送 “ssdp:discover” 消息。当设备监听到这个保留的多播地址上由控制点发送的消息的时候，设备将通过单播的方式直接响应控制点的请求。</p><p>典型的设备查询请求消息格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">M-SEARCH * HTTP/1.1</span><br><span class="line">S:uuid:ijklmnop-7dec-11d0-a765-00a0c91e6bf6</span><br><span class="line">Host:239.255.255.250:1900</span><br><span class="line">Man:&quot;ssdp:discover&quot;</span><br><span class="line">ST:ge:fridge</span><br><span class="line">MX:3</span><br></pre></td></tr></table></figure><h4 id="典型的响应格式："><a href="#典型的响应格式：" class="headerlink" title="典型的响应格式："></a>典型的响应格式：</h4><p>响应消息应该包含服务的位置信息（Location 或AL头），ST和USN头。响应消息应该包含cache控制信息（max-age 或者 Expires头）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: max-age= seconds until advertisement expires</span><br><span class="line">S: uuid:ijklmnop-7dec-11d0-a765-00a0c91e6bf6</span><br><span class="line">Location: URL for UPnP description for root device</span><br><span class="line">Cache-Control: no-cache=&quot;Ext&quot;,max-age=5000</span><br><span class="line">ST:ge:fridge // search target</span><br><span class="line">USN: uuid:abcdefgh-7dec-11d0-a765-00a0c91e6bf6 // advertisement UUID</span><br><span class="line">AL: &lt;blender:ixl&gt;&lt;http://foo/bar&gt;</span><br></pre></td></tr></table></figure><h4 id="2、设备通知消息"><a href="#2、设备通知消息" class="headerlink" title="2、设备通知消息"></a>2、设备通知消息</h4><p>在设备加入网络时，它应当向一个特定的多播地址的 SSDP 端口使用 NOTIFY 方法发送 “ssdp:alive” 消息，以便宣布自己的存在，更新期限信息，更新位置信息。</p><p>#####（1）ssdp:alive 消息<br>由于 UDP 协议是不可信的，设备应该定期发送它的公告消息。在设备加入网络时，它必须用 NOTIFY 方法发送一个多播传送请求。NOTIFY 方法发送的请求没有回应消息。</p><p>典型的设备通知消息格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NOTIFY * HTTP/1.1</span><br><span class="line">HOST: 239.255.255.250:1900CACHE-CONTROL: max-age = seconds until advertisement expires</span><br><span class="line">LOCATION: URL for UPnP description for root device</span><br><span class="line">NT: search target</span><br><span class="line">NTS: ssdp:alive</span><br><span class="line">USN: advertisement UUID</span><br></pre></td></tr></table></figure><p>#####（2）ssdp:byebye消息<br>当一个设备计划从网络上卸载的时候，它也应当向一个特定的多播地址的 SSDP 端口使用 NOTIFY 方法发送 “ssdp:byebye” 消息。但是，即使没有发送 “ssdp:byebye” 消息，控制点也会根据 “ssdp:alive” 消息指定的超时值，将超时并且没有再次收到的 “ssdp:alive” 消息对应的设备认为是失效的设备。</p><p>典型的设备卸载消息格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NOTIFY * HTTP/1.1</span><br><span class="line">HOST: 239.255.255.250:1900NT: search target</span><br><span class="line">NTS: ssdp:byebye</span><br><span class="line">USN: advertisement UUID</span><br></pre></td></tr></table></figure><p>全文完！</p><p>参考资料：<br>1、SSDP 协议原文：<a href="http://tools.ietf.org/html/draft-cai-ssdp-v1-03" target="_blank" rel="noopener">http://tools.ietf.org/html/draft-cai-ssdp-v1-03</a><br>2、UPnP协议框架：<a href="http://www.upnp.org/specs/arch/UPnP-arch-DeviceArchitecture-v1.0.pdf" target="_blank" rel="noopener">http://www.upnp.org/specs/arch/UPnP-arch-DeviceArchitecture-v1.0.pdf</a></p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P2P 网络核心技术：Kademlia 协议</title>
      <link href="/Distributed-System/distributed-system-p2p-kademlia/"/>
      <url>/Distributed-System/distributed-system-p2p-kademlia/</url>
      
        <content type="html"><![CDATA[<h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>Kademlia 是分布式散列表（DHT，Distributed Hash Table）的一种，类似的还有 Chord，Pastry 等。DHT 技术是去中心化 P2P 网络中最核心的一种路由寻址技术，可以在无中心服务器（trackerless）的情况下，在网络中快速找到目标节点。现在随着区块链技术的火热，这个 P2P 网络的底层技术也被越来越多的人了解。</p><p>这篇文章主要介绍 Kademlia 技术原理，以及其在 IPFS，以太坊等项目中的实现。</p><p>先从直观上来看一下 P2P 网络中节点之间连接的方式</p><p><img src="/image/p2p/p2p_tracker.png" alt=""></p><p>图（1）是早的 BtTorrent 网络，需要一个中心服务器也就是种子服务器，来帮助各个 Peers 节点找到彼此进行文件下载。</p><p><img src="/image/p2p/p2p_trackerless.png" alt=""></p><p>图（2） 是实现了 Kademlia 协议的 P2P 网络，每个节点维护一个路由表，仅记录离自己最近的一些节点信息，通过迭代查找，来连接网络中其他的节点。</p><h2 id="2、背景知识"><a href="#2、背景知识" class="headerlink" title="2、背景知识"></a>2、背景知识</h2><p>网上有太多关于 Kademlia 协议原理的文章，我就不详细介绍了，这里我只列出 Kademlia 中最关键的几个部分：</p><ul><li><p><strong>Node ID</strong> 在 P2P 网络中， 节点是通过唯一 ID 来进行标识的，在原始的 Kad 算法中，使用 160-bit 哈希空间来作为 Node ID。</p></li><li><p><strong>Node Distance</strong> 每个节点保存着自己附近（nearest）节点的信息，但是在 Kademlia 中，这个距离不是指物理距离，而是指一种逻辑距离，通过运算得知。</p></li><li><p><strong>XOR 异或运算</strong> XOR 是一种位运算，用于计算两个节点之间距离的远近。把两个节点的 Node ID 进行 XOR 运算，XOR 的结果越小，表示距离越近。</p></li><li><p><strong>K-Bucket</strong> 用一个 Bucket 来保存与当前节点距离在某个范围内的所有节点列表，比如 bucket0, bucket1, bucket2 … bucketN 分别记录[1, 2), [2, 4), [4, 8), … [2^i, 2^(i+1)) 范围内的节点列表</p></li><li><p><strong>Bucket 分裂</strong> 如果初始 bucket 数量不够，则需要分裂（具体跟实现有关）</p></li><li><p><strong>Routing Table</strong> 记录所有 buckets，每个 bucket 限制最多保存 k 个节点，如下图：</p></li></ul><p><img src="/image/p2p/kad_routingtable.png" alt=""></p><ul><li><p><strong>Update</strong> 在节点 bootstrap 过程中，需要把连接上的 peer 节点更新到自己的 Routing table 中对应的 bucket 中</p></li><li><p><strong>LookUp</strong> 查找目标节点，找到与目标节点最近（nearest/closest）的 bucket，如果已在 bucket 中，则直接返回，否则向该 bucket 中的节点发送查询请求，这些节点继续迭代查找</p></li><li><p><strong>收敛 &amp; 时间复杂度</strong> 查找会最终收敛至目标节点，整个查询过程复杂度是 Log N</p></li></ul><p>下面详细介绍每个部分：</p><h4 id="1、Node-ID"><a href="#1、Node-ID" class="headerlink" title="1、Node ID"></a>1、Node ID</h4><p>Kademlia 中使用 SHA1 哈希来计算 Node ID，SHA1 是一个 160 bit 的哈希空间，整个 ID 长度是 160 个位， 也就是 20 个字节。</p><p>IPFS 中都使用 SHA256 来计算 Node ID，ID 长度是 256 位的哈希空间， 也即 32 个字节。</p><p>Ethereum 使用 sha3，也是 256 位哈希空间， 32 字节。</p><p><img src="/image/p2p/kad_nodeid.png" alt=""></p><h4 id="2、Node-Distance-与-XOR"><a href="#2、Node-Distance-与-XOR" class="headerlink" title="2、Node Distance 与 XOR"></a>2、Node Distance 与 XOR</h4><p>直接对两个 Node ID 进行 XOR 运算，就可以得出他们之间的距离。</p><p>比如，当前节点的 NodeID 是 1101，它与另一个节点 1010 的距离计算如下：</p><p><img src="/image/p2p/kad_distance_xor.png" alt=""></p><p>结果是：0101，用十进制数来表示就是 5，也就是他们距离相差 5。</p><p>注：为了简化，这里的节点 ID 我们假设只有 4 bits 长度。</p><p>Kademlia 中，根据当前节点的 Node ID 与它保存的其他 peer 节点 Node ID 的匹配的最多的前缀 bit 个数来构建一颗二叉树（Binary Tree），</p><p>这里前缀匹配的 bit 数也叫 LCP，Longest Common Prefix，的从上面的运算我们可以观察到，当前节点 1101 与 1000 的前缀只有最高位是匹配的。因此，其</p><p>LCP 就是 1。Kademlia 中根据 LCP 来划分子树。当前节点的每个 LCP 都是一个子树。</p><p>比如：假设节点的 ID 是 0011，那么它可以划分为 LCP = 0, 1, 2, 3 一共 4 个子树，如下：</p><p><img src="/image/p2p/kad_nodeid_160.png" alt=""></p><p>所以，对于一个 160 bit 空间的 Node ID 来说，一共会有 160 个子树，也就是 160 个 buckets。每个 bucket 可以通过 XOR 的结果来索引。</p><p>Kad 协议要求每个节点知道其各子树的至少一个节点，只要这些子树非空。在这个前提下，每个节点都可以通过 ID 值来找到任何一个节点。</p><p>3、K-Bucket &amp; Routing Table</p><p>从上图中可以看到，每个子树就是一个 K-Bucket，而且，子树中也包含许多 leaf 节点，每个 leaf 节点都表示一个 Peer。</p><p>Kademlia 中把子树中包含的 leaf 节点数量被设置为最多 k 个。这样可以有效控制整棵树的膨胀。</p><p>routing table 使用 K-Bucket list 来保存上述信息。</p><h4 id="4、K-Bucket-更新"><a href="#4、K-Bucket-更新" class="headerlink" title="4、K-Bucket 更新"></a>4、K-Bucket 更新</h4><p>由于在真实的分布式网络中，由于网络的波动等因素，节点可能是频繁加入和退出网络的，而 kBucket 中保存的是相对静态的信息，因此需要随着一些条件的变化来进行相应的更新，最典型的需要更新 kbucket 的场景就是，当连上一个新的节点，或者有查询原本不在 kbucket 中的节点时。</p><p>kademlia 通过记录 kbucket 中每个节点的最近访问时间戳来判断节点的活跃度。</p><p>当需要更新一个 kbucket，时 取决于两个因素：</p><ul><li><p>kbucket 未满，则直接添加</p></li><li><p>kbucket 已满，则判断是否存在剔除失效节点，存在，则用新节点替换，不存在，则抛弃新节点。</p></li></ul><h4 id="5、Peer-finding"><a href="#5、Peer-finding" class="headerlink" title="5、Peer finding"></a>5、Peer finding</h4><p>想要直观理解 Kademlia 算法的查找过程，我们可以通过一个例子来体会：</p><p>小明想要加撩公司里的美女小芳，但是不知道她微信号，那么他就从自己的微信好友（同事）中挑出 k 个最可能认识她的人，然后依次问他们有没有她的微信号，假如其中一个叫小华的认识小芳，那么他就会直接告诉小明，这样小明就不用继续问其他人了。假如不认识，那么小华就会给告诉小明他微信好友中最有可能认识小芳的 k 个人的联系方式，然后小明继续问这 k 个人，然后整个过程就一直循环迭代下去，直到最终有一个人肯定知道小芳的微信号。</p><p>Kademlia 查找就是这样一个过程。</p><h3 id="K-Bucket-详解"><a href="#K-Bucket-详解" class="headerlink" title="K-Bucket 详解"></a>K-Bucket 详解</h3><p>下面，我们更具体的例子来深入理解 kBucket 构建，分裂及更新等过程，最后，我们再详细解析 Peer LookUp 过程。</p><h4 id="1）构建与更新"><a href="#1）构建与更新" class="headerlink" title="1）构建与更新"></a>1）构建与更新</h4><p>假设当前节点 A 的 Node ID 是 110，初始状态时，没有连接任何其他节点，因此，只有一个 空 bucket，里面没有任何元素。</p><p><img src="/image/p2p/lookup_tree_init.png" alt=""></p><p>当一个新节点 B 连上当前节点 A 时，A 先计算距离 d = A ^ B，由于距离 d 就是我们 bucket 数组的索引，因此可以直接找到对应的 bucket[d]，</p><p>然后进行如下判断：检测其是否已经存满 k 个节点</p><ul><li>如果未满，则直接添加进 kbucket 即可</li><li>如果已满，检测 bucket 列头元素是否能够 ping 通，如果 ping 通，则抛弃新节点，无法 ping 通，则用新节点替换失效节点</li></ul><p>Kademlia 算法在不同的项目中会有不同的实现，区别主要在于 kbucket 数据结构及其相关方法。</p><p>比如，典型的 Kademlia 实现是，先根据 ID 空间预先分配 kbucket 数量的空间（比如 160 位，就分配 160 个 buckets 空间，256 位就直接分配 256 个 buckets 空间，这样，后续计算 distance 的时候可以直接 distance 作为 bucket 索引），还有就是 IPFS 这种，也是原始 Kademlia 论文中提到的，动态分配 buckets，如果节点少的时候，就只有一个 bucket，当节点不断增加之后，原 bucket 不断分裂，具体就是，每次满了 k 个元素，原 bucket 就分裂成 2 个。这样的话，对于内存空间是一个优化。而以太坊中的实现又略有不同，它使用固定数量的 buckets，但是却限定在 17 个，而不是 256 个，它通过一个 log 映射表来把新节点均匀分布在各个 buckets 中。</p><h4 id="核心常量："><a href="#核心常量：" class="headerlink" title="核心常量："></a>核心常量：</h4><ul><li>Alpha 3</li><li>K 20</li><li>nBuckets 160</li></ul><p>Alpha 是查询的并发数，也就是最多返回节点的数量，比如，发出一个查询，最终返回结果中包含 Alpha 个节点信息（包括了目标节点）。如果 Alpha 是 1， 那么只返回目标节点。</p><p>K 就是每个 bucket 中最多能保存的节点数量（通常是 20 ），从另外一个方面也可以把其理解成资源的副本。也就是说，一个资源，在一个分布式网络中，一共有 k 个节点保存了它的副本。</p><p>nBuckets 就是 Routing Table 中 bucket 的数量。</p><p>2）查找 LookUp</p><p>假设现在的当前节点是 001，它想要查的目标节点是 101 节点。</p><p>001 保存的 Routing Table 信息如下</p><p><img src="/image/p2p/lookup_rt001.png" alt=""></p><p>我们先计算 001 与 101 节点的距离，001 ^ 101 等于 100，最高位的 index 是 2，因此，我们去 bucket 2 中查找是否有目标节点，发现没有，因此，我们依次向 bucket 2 中的节点发出查询请求，也即先向 110 发出查询请求，</p><p><img src="/image/p2p/lookup_rt001_.png" alt=""></p><p>即</p><p><img src="/image/p2p/lookup_rt001tree.png" alt=""></p><p>110 节点的 Routing Table 信息如下：</p><p><img src="/image/p2p/lookup_rt110.png" alt=""></p><p>节点 110 收到请求后，计算 110 ^ 101 结果是 011，匹配前缀数量是 1，因此，去 bucket 1 中查找，bucket 1 中也没有 101，因此向 100 发送请求，</p><p><img src="/image/p2p/lookup_rt110_.png" alt=""></p><p>即</p><p><img src="/image/p2p/lookup_rt110tree.png" alt=""></p><p>节点 100 保存的 Routing Table 信息如下</p><p><img src="/image/p2p/lookup_rt100.png" alt=""></p><p>100 收到请求后，计算 100 ^ 101，结果是 001，最长匹配前缀数量 2，因此去 bucket 0 中查找，</p><p><img src="/image/p2p/lookup_rt100_.png" alt=""></p><p>即</p><p><img src="/image/p2p/lookup_rt100tree.png" alt=""></p><p>有 100 的 Routing Table 可知，目标节点 101 就正好在 bucket 0 中，直接返回!</p><p>我们可以看到，整个检索过程是不断收敛的，查询复杂度是可以证明是 Log N</p><p><img src="/image/p2p/lookup_divergency_convergency.png" alt=""></p><p>全文完</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IPFS 是怎么工作的？</title>
      <link href="/Distributed-System/ipfs-how-ipfs-work/"/>
      <url>/Distributed-System/ipfs-how-ipfs-work/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>我们知道，一个存储服务，最基本的功能就是存和取。IPFS 中提供了这两种语义，那就是 add 和 get 操作。<br>在 IPFS 系统中执行 add 操作，就是执行了一次存操作，放在网络的概念里，就是“上传”操作。而 get 就更好理解了，就是取操作，在网络世界里，也叫 “下载”。</p><p>IPFS 号称点对点无中心化文件系统，没有单点故障，也就是文件一旦被“上传”到 IPFS 网络中，就会被永久保存。而要想下载一个本地没有的文件，只要 IPFS 网络中有，简单的执行 get 就很快能下载到数据。那么 add 操作的背后到底做了什么？get 又是怎么获取数据的？</p><p><strong>这就是本文要探究的主题！</strong></p><p>先来看一下 add 和 get 的基本操作过程</p><p><img src="/image/ipfs_add_get.gif" alt=""></p><p>当一个 IPFS 节点执行 add 操作时，它会把文件进行分块 block，通过构建一个 Merkle 树根节点，来把每个子块节点都连接起来，每个 block 都会用一个唯一的 Cid 进行标识。</p><p>block 数据会被保存到本地的 blockstore 中。但是需要注意的是，除此之外，block 数据并不会立刻主动上传到 IPFS 网络中，也就是与其连接的 peers 节点中。除非，某 peer 节点曾经请求过该 block 数据。</p><p>add 执行逻辑如下图所示：</p><p><img src="/image/ipfs_add1.png" alt=""></p><p>理解这一点非常重要，因为，我们很容易会把 IPFS 想象成一个会自动备份数据的分布式数据库，就像传统的冗余备份机制一样。实际上，IPFS 并不会这样做。这是由 IPFS 在公网环境中运行和传统分布式数据库在私有网络中运行的场景要求不一样所导致的。作为互联网基础设施，这种设计不仅减少网络带宽占用，还能为网络提供可靠、恒久的数据保存机制。</p><p>这就涉及到 get 机制的原理了，先看下图：</p><p><img src="/image/ipfs_get.gif" alt=""></p><p>上图展示了 ipfs 执行 get 命令的执行流程。</p><p>对于当前节点来说，所有与其连接的 peers 节点会构成一个 swarm 网络。</p><p>当本地节点发出一个 get 请求时，它首先会从本地的 blockstore 中查找请求的数据，如果没有找到，它便会向 swarm 网络发出请求，通过 DHT Routing 找到拥有该数据的节点，一旦找到一个拥有所请求数据的节点，该节点会把数据反馈回来。然后，本地节点会把收到的 block 数据缓存一份到本地的 blockstore 中，这样，整个网络中就相当于多了一份原数据的拷贝。当有更多的节点都请求该数据的时候，就变得更加容易，而由于越来越多的节点都存有该数据，数据就变得几乎不可丢失。</p><p>这也就是 IPFS 网络能够永久保存数据的原理，只要有任何一个 IPFS 节点拥有某数据，这个数据就可以被全网所获取。</p><p>那么，执行 IPFS 的 add 命令之后，为什么直接访问 <code>ipfs.io</code> 网关就能获取到数据呢？</p><p>比如，在浏览器中打开类似 <a href="https://ipfs.io/ipfs/QmR4WZy1rfXX868yFsTcqHun5y61c1jh2oQhDqWD97FEM2" target="_blank" rel="noopener">https://ipfs.io/ipfs/QmR4WZy1rfXX868yFsTcqHun5y61c1jh2oQhDqWD97FEM2</a> 这样的网站地址，就能直接访问到刚才我们添加的数据！</p><h4 id="原理是这样的："><a href="#原理是这样的：" class="headerlink" title="原理是这样的："></a>原理是这样的：</h4><p>IPFS 网关，即 <a href="ipfs.ios"></a>，实际上扮演的是一个 IPFS 节点的作用，当我们打开上述网站的时候，其实就是向 IPFS 网关发出了一次请求，IPFS 网关会代理我们（因为我们不是 IPFS 节点，我们只是浏览器而已）向拥有这个数据的 Peer 节点（就是我们本地节点）发出 block 请求，一旦获取到数据，网关会先自己缓存一份，同时，把请求到的数据通过 HTTP 协议转发给我们！</p><p>也就是说，任何一台机器，只要打开浏览器，都能通过上述地址访问到我们刚才执行 add 命令时添加的数据。一旦 IPFS 网关第一次缓存节点数据之后，再次请求时，它就无需再向原节点请求数据了，只要 Hash 值没有变化，就可以直接把之前缓存的数据返回给浏览器。</p><p><img src="/image/ipfs_gateway.gif" alt=""></p><h4 id="更多细节"><a href="#更多细节" class="headerlink" title="更多细节"></a>更多细节</h4><p>实际上，Peer 节点在执行 add 命令时，还会广播自己拥有的块信息。同时，它还会维护一个该 swarm 网络中所有已发给当前节点的 block 请求列表，一旦 add 命令都添加的数据满足请求列表，就会向对应节点主动发送数据，并更新该列表。</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>德州扑克的一点小心得</title>
      <link href="/Life/life-texas-holdem/"/>
      <url>/Life/life-texas-holdem/</url>
      
        <content type="html"><![CDATA[<p>今天是 7/12，WSOP 主赛事已经打到 Day 7 决出了最后的 9 人 FT。周末 7/15 会决出最后的冠军。虽然一直在关注着比赛，但是没时间看直播，毕竟平时还是很忙的。</p><p>不过，德州扑克是我最喜爱的一款扑克类游戏之一，所以突发灵感，顺便写一点关于德扑的一些心得。</p><p>小时候虽然算是在“麻将世家”长大，虽然会玩，可惜对麻将兴趣不大。反而扑克类的游戏比如德扑，升级等我都挺喜欢，德扑是我最喜欢的之一。其实虽然我喜欢德州扑克，并非我喜欢赌博，而是因为我常常不仅把它作为一款游戏来看待。我也把自己定位为一个初学者，虽然看过几本经典书籍，但是实战方面还是太少了。我觉得它独特的魅力来自于需要结合数学和心理学的知识来辅助决定。</p><p>事实上，德州扑克对数学概率的计算要求是比较简单的，但是行为学、心理学等内容在其中所占的比例却非常重要。比如，扑克史上号称打牌最具观赏性的职业玩家 Tom Dwan 就是一个极能运用这些技巧的人，YouTube 上有很多他用一手空气牌 bluff 对手拿下大 Pot 的经典牌局。当然，心理学并不仅仅表现在 bluff 上面，还有很多更深层面的东西。</p><p>德州扑克是一种公共牌（Community card）游戏，通常是 6 - 9 人玩，德州扑克的规则很简单，但是想要玩好可不容易，是一种典型的入门容易，精通难的游戏。</p><p>我记得当年还在读大四的时候才第一次接触这个游戏，当时火了一小阵，我学会了一点玩法，热情过后，慢慢的周围也没什么人玩了。虽然如此，但还是断断续续也会去关注一些扑克赛事的新闻，就像现在不怎么打篮球了，但是篮球新闻还是每天会看一样。</p><p>WSOP 锦标赛是 6 月份就开始的，一共 70 多个赛事，由于拉斯维加斯跟中国有 15 小时时差，也就是说拉斯维加斯每天 11 am 开赛的话，这里就是凌晨 2 点，所以没法看直播，虽然每天的赛程都会进行到很晚，比如 12pm 这种（这里则是15 pm），毕竟拉斯维加斯是不夜城嘛，但是白天又要上班，也不能看，只能偶尔看看精彩视频。</p><p>要玩好德州扑克，我总结下来，主要有这几个方面：</p><p><strong>1）位置</strong></p><p>德州扑克是一款跟位置极其相关的游戏，很多时候，同一副手牌，位置的不同决定了打法的不同。这是因为德州扑克是一种信息不对称的游戏，玩家依据现有的信息作出决策，并进行博弈。位置的不同导致了信息的不对称，先行动的人由于获得的场上资讯少，总是会有一些劣势，尤其 UTG 位的玩家。而后行动的人获得的信息多一些，行动上的选择面更多。一个最简单的例子就是，前位玩家是紧凶风格，前位玩家拿到 AJs 或者 KJ 这类牌，你很难下一个大的筹码，因为你不知道你的手牌是否领先。后位玩家如果 3bet，有时候你牌面没有足够好的话，也不敢 call。</p><p>因为对手大概率是 AA。这时候你读到对方牌了，如果你 Call 的话，那就是把自己交给命运，虽然 AA All in 并非每次必胜，但是根据概率期望原理，长期来算总是赢利的。</p><p><strong>2）人数</strong></p><p>德州扑克的玩法跟玩家多少也有关系，玩家多的时候，翻前拿到 AJ，KQ 这类牌都很难称为好牌，All IN 的胜率会在人越少的时候越高。因为人数多，拿到同等好牌或者更好牌的人的概率也大。人数少的时候，比如单挑，T9s 或者 T 以上的手牌 All in 胜率都不低。随着牌局的进行，Pot 的变大，很多玩家在没有足够的赔率的时候都会选择弃牌，剩下的玩家的手牌往往会比想象中的弱，甚至打到河牌时，是两幅听牌在对决，河牌都没中的话比高牌大小了。</p><p><strong>3）筹码量</strong></p><p>筹码的深浅有时候对游戏的玩法起着非常决定性的作用。德州扑克通常分为两类，一种是现金局（Cash Game），一种是锦标赛（Tournament）。通常 100 个大盲是标准买入，150 大盲以上的买入就可以说是标准的深筹了！ 而 200 大盲这个深度也是一般扑克室允许的上桌最大买入。现金桌一般筹码会比较深，因为盲注不会提高。而锦标赛由于盲注级别会随着时间而提高。因此，锦标赛初期筹码深，但是后期盲注升高之后就变浅了，一个 50 BB 以内的筹码深度就可以算是浅筹了，这时候玩家的牌风会变紧，偷盲和保盲会激烈进行。由于锦标赛不支持重买，也就是一条命打到底，所以存活很重要。而且，由于筹码浅，一般都不会打满 4 条街，主要较量都击中在翻前和翻牌圈。而现金桌则不一样，筹码深的情况下，大部分都足够打满 4 条街，这也导致牌局变数大，小牌逆转的几率提高。</p><p>玩家手中持有不同筹码量的时候，玩法也很大区别，筹码量大的人显然优势更大，因为犯错的成本低，而筹码量小的人，几乎没有主动权，同是 All IN 的情况下，筹码小的人只有一次犯错机会，失败就全盘结束。而筹码量多的人则有更多犯错机会，从而达到筹码压制的效果。</p><p><strong>4）赔率计算</strong></p><p>赔率主要分为两个部分一个是成牌赔率，一个是底池赔率。</p><p>底池赔率是由跟注额和底池大小来计算的，比如底池有 $70，需要跟注的钱是 $20，那么底池赔率就是 3.5:1，相当于 34% 的概率能赢得底池。</p><p>成牌赔率涉及到补牌的计算，比如转牌听同花，那么有 9 张听牌（13-4），9/46 ≈ 20%，也就是赢牌的概率低于赢得底池所需的概率。这个时候跟注就是一个长期负 EV 的行为。但是我们还忽略了一点，那就是隐含赔率，隐含赔率是一种条件赔率，是在假设你击中听牌之后，可能再从对手身上赚到更多的钱。比如击中听牌之后，在河牌圈对手很大概率依然会跟注你的下注，那么这个跟注额就计算在隐含赔率中。隐含赔率够大的话，那么即使当前成牌概率小于底池赔率，也可以考虑跟注。</p><p><strong>5）心理</strong></p><p>前面说了，掌握对手的风格，洞悉对手的心理，隐藏自己的情绪，这个是一个上乘的玩家所应具备的素质。不要在不了解对方的情况下试图诈唬，诈唬新手或紧手玩家可能都会付出代价。对手下注的时候，观察他的表情，看看他是不是露怯了？德州扑克把玩家的风格分为 4 类，tight/loose, aggressive/passive。有的玩家只玩 AA, AK, KK, QQ 这些大牌，那么他玩法很紧，有的玩家 27, 38 这些烂牌也玩，入池率高，说明很松。有些玩家是跟注站，有牌就跟，不管赢率。有的玩家是惊弓之鸟，bet 大一点他就弃牌。还有的人喜欢那小牌偷鸡。所以，想要获得长期的胜率，那么观察选手的性格是非常重要的。马云不是说吗，德州扑克有时候不需要看牌，只需要看对手的眼睛。这个是非常有道理的。</p><p>当然，聪明的玩家不仅需要会观察对手，还需要隐藏情绪，通常，玩家拿到大牌会很高兴，有的人会流露出来，比如开始变得话多，表情变得自信等等，而拿到弱牌时又表现得沮丧，如果这些真实的情感被对手读取，那是致命的。所以，一定要懂得隐藏情绪。此外，下注额也有讲究，是价值下注还是诈唬，不同情况不同处理。如果确认自己是领先的，这时候，下注一个合适的注额，让牌弱的人不要跑掉，如果手持 AA 上来就 All In，那么牌小的就都跑了，那么就拿不到多少价值，这个时候需要一些策略引人上钩，比如 slow play，或者翻前打 3 bet。如果是弱牌，或者空气牌，遇到松软玩家，位置好的话则可以诈唬。</p><p>隐藏情绪是隐藏牌力重要的一方面。德州扑克最难的地方就是每一条街的决定，在电视直播或转播中我们可以看到有的选手经常会为到底跟注还是弃牌花上十几分钟甚至半个小时的时间来思考。这个时候通常只有两个选择，要么跟注，要么弃牌，尤其是在底池巨大，筹码套牢的情况下。想想一下，20 万筹码，已经投了 10 万到底池，河牌还需要 All In 才能跟注，而这个时候牌面复杂，自己可能领先，可能落后。比如 QQ 遇到可能的暗 Set 之类的。套牢的情况下很难弃牌，所以这时候不仅需要牌局判断，还需要一些弃牌的勇气。跟注也是一样，遇到大 bet，只要赔率合适，也要果断跟注。当然，我见过一个女选手，头特别铁，即使成牌概率低，底池赔率低，她也要跟注，结果她运气还特别好，河牌总是能击中听牌，对于这种玩家，我只能说，敬而远之。我还见过一个大妈选手诈唬一个女职业 Pro，结果还成功了，我看电视里她手都在有点不自然了，那个女职业 Pro 居然没看出来，也是奇怪。</p><p>德州扑克中有太多策略需要用到心理学，意志力，决心方面的因素，这就是这个游戏迷人的地方吧，事实上，创投圈（创业和投资）的人还挺推崇这个游戏的，那些知名大佬比如比尔盖茨，巴菲特，国内的有李开复，马云、王小川等，甚至体育界也不少人喜欢，比如菲尔普斯，C 罗，内马尔等。</p><p>在我看来，通过玩德州扑克，我至少可以在下面一些方面获得一些收益：</p><p>（1）掌控情绪，我有时候看扑克比赛的视频，有些高端玩家也会在某些情况下失控，有些人甚至需要借助一些工具（比如带墨镜，戴头套，戴耳机）来帮助自己控制和隐藏表情、情绪。Phil Hellmeth 是一个职业大神，但是他拿到好牌被 bb 之后也经常骂骂咧咧的，失去风度。Laak 也是职业 Pro，他经常戴个头套来保护自己，Phil Ivey 是传奇牌手，虽然他大多数时候没什么表情，但是他也会有苦恼的时候，Dwan 是有名的诈唬之神，演得一手好戏，但是他也难避免在一些情况下露出惊慌。可见，控制情绪说起来容易，实际上可没那么容易，这些都是职业 Pro，大神一样的人物，都难免露出一些人之常情。</p><p>（2）大局观，大局观是一个很模糊的概念，在牌桌上要保持长期盈利，需要有一个大局观，尤其在锦标赛类的游戏中这点体现更加明显，没有必要为了一个小的底池而赌上全部筹码。</p><p>（3）探究人性 我觉得研究别人的心理是一件很深奥的事情，说实话我没有这方面的天赋，所以我经常会判断失误，比如我觉得他没骗我，结果他把我唬得团团转，或者我觉得他在骗我，结果他很老实。人世间也是这样，经常会把人之间的关系看得比较简单直白，不明白尔虞我诈。所以，在关于如何更好的了解别人方面，我觉得有进步的空间。这个其实是一个很有益处的事情，因为我们人类社会就是一个关系社会，讲究社交，如果能更好的理解别人，理解别人的需求，感受别人的心理，那么无疑对双方都是有裨益的。</p><p>（4）自信，我在情绪低的时候，有时会自我怀疑，工作效率也会降低，而在情绪高的时候，工作效率极高，可见我在这方面的掌控力也需要提高。</p><p>（5）投资理念，以前我投资基本没什么策略可言，虽然以前也学过金融工程方面的知识，但是可没鸟用，自己操作起来还是不行。买股票亏了不少钱，还喜欢一把梭。买币嘛就更不提了，1.6w每个的时候买了 5 个比特币，居然也亏钱！所以，要学会在低潮的下注甚至 All In，在高峰的时候弃牌！</p><p>其实，只要带着学习的态度，很多事情都可以让人学到东西，德州扑克只是一个途径而已，一个游戏，工作之余偶尔玩玩，不沉迷也不推崇！而我，可能暴露了自己是一个爱学习的好孩子。</p><p>全文完！</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 德州扑克 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPFS 能做什么？</title>
      <link href="/Distributed-System/ipfs-what-ipfs-can-do/"/>
      <url>/Distributed-System/ipfs-what-ipfs-can-do/</url>
      
        <content type="html"><![CDATA[<p>IPFS 作为一个去中心化的存储项目，它主要定义了一套协议，从数据的标识格式，到网络协议，再到应用。IPFS 的愿景听上去非常诱人，那么现阶段，我们能用 IPFS 来做什么呢？</p><p>IPFS 能做的事情太多啦，所以，我这里仅举几个例子：</p><p><strong>1）搭建一个分布式网站（博客，WIKI）</strong></p><p>很多人喜欢自己建网站，比如购买一个 WordPress 服务器，或者自己在 VPS 上搭一个静态博客，这些方法的最基本要求就是必须要有一台服务器，我们需要至少去主机提供商，或者去云服务商购买一些空间。有了 IPFS，这些要求都不需要啦，我们只需要在本地把网站上传到 IPFS 网络就可以了。也就是说，我们自己的本地电脑就可以作为网站服务器了！激动人心的时刻。前提是，我们得需要能连上 IPFS 网络。不幸的是，现阶段，祖国把 ipfs 网关给封了😂。</p><p><strong>2）搭建一个分布式网盘服务</strong></p><p>现在虽然还有一些网盘能提供一些免费的存储服务，但是大多数空间比较有限。</p><p>我们可以通过 IPFS 来搭建自己的分布式私有网盘，不仅可以节省空间，还无需冒着隐私泄密的风险。</p><p><strong>3）网络视频播放器</strong></p><p>可能你会以为这是又一个快播，但是，我始终相信那句话。技术是无罪的，有罪的是用的人。所以，你要做黑客，还是要做白帽子，起决定因素的不是技术，而是你的动机和方法。如果你是一个电影迷，可以自建家庭 NAS，用 IPFS 来做私有存储，是一个不错的好应用。</p><p><strong>4）作为区块链的存储解决方案</strong></p><p>在以太坊存数据太贵了，现在的区块链架构上，想要做到大文件、大数据的存储，是不现实的。而 IPFS 就是一个很好的补充，把数据存在 IPFS 网络中，而把数据的标志（Hash）存在区块链中，鱼与熊掌便可兼得，妙哉！</p><p><strong>5 ）去中心化交易所？</strong></p><p>去看了下 OpenBazzar 的代码实现，相当有想法哦。以后的去中心化交易所是大势所趋啊，Vitalik 今天都发话了，希望中心化交易所“尽可能死绝”，话虽重了点，但是也暴露了现在中心化交易所的乱象，大家都在忙着割韭菜，圈钱。所以，如果你关注行业前沿，那么这是一个很好的切入点。喜欢的小伙伴搞起！</p><p>上面是我简单列举的几个 IPFS 的应用例子，仅作抛砖引玉，欢迎大家狗尾续貂 [二哈]。。。</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Macbook 必备软件列表</title>
      <link href="/Macbook/Macbook-apps-for-macos/"/>
      <url>/Macbook/Macbook-apps-for-macos/</url>
      
        <content type="html"><![CDATA[<p>本文列出系统所装软件（本人必用）</p><h3 id="工作效率"><a href="#工作效率" class="headerlink" title="工作效率"></a>工作效率</h3><ul><li><p>Afred 必备</p></li><li><p>Office 2016<br>描述：Office 三件套，Macbook 下不想开虚拟机只能用这个了。</p></li><li><p>为知笔记（WizNote）</p></li><li><p>OneNote</p></li><li><p>XMind 8</p></li><li><p>XMind zen (收费)</p></li></ul><h3 id="密码管理"><a href="#密码管理" class="headerlink" title="密码管理"></a>密码管理</h3><ul><li>1Password (收费)</li><li>Bitwarden<br>描述：密码管理软件，必备</li></ul><h3 id="系统工具"><a href="#系统工具" class="headerlink" title="系统工具"></a>系统工具</h3><ul><li>iStat Menus (收费）<br>描述：状态栏显示 CPU、温度等信息。</li><li>CleanMyMac （收费）</li><li>Tencent Lemon</li><li>DaisyDisk（收费）<br>描述：查看硬盘使用情况，用于查找什么东西占了你的大块空间。免费用户启动的时候需要等待。</li></ul><p>压缩/解压</p><ul><li><p>iZip Unarchiver</p></li><li><p>Keka</p></li><li><p>Paragon NTFS for Mac<br>描述：读取 NTFS 格式的硬盘（NTFS 常见于 Windows 下的硬盘格式）</p></li></ul><h3 id="词典工具"><a href="#词典工具" class="headerlink" title="词典工具"></a>词典工具</h3><ul><li>有道词典</li><li>欧路词典 Eudict</li><li>Dictionary（系统自带）</li></ul><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><ul><li><p>Parallels Desktops<br>描述：MacOS 下最好用的虚拟机。正版太贵了，300 RMB 起。而且大版本升级需要重新购买，否则旧版本不支持最新的 Mac 系统。</p></li><li><p>VMware Fusion（收费）<br>描述：Parallels Desktops 的替代品。</p></li></ul><h3 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h3><p>浏览器三件套</p><ul><li>Chrome(Canary 版本)</li><li>Firefox</li><li>Tor Browser</li></ul><p>Chrome 常用插件：</p><ul><li>Vimium</li><li>SwitchyOmega</li><li>Chrono Download Manager</li><li>LastPass</li><li>Bitwarden</li><li>GreenAddress</li><li>Nimbus Screenshot &amp; Screen Video Recorder</li><li>OneNote Web Cliper</li><li>Clear Cache</li><li>Click&amp;Clean</li><li>User Agent Switcher</li><li>Awesome Screenshot</li><li>Bukket（截图/屏幕）</li><li>Marmoset（制作代码截图、输出线框和标记代码）</li><li>Linkclump（批量打开网页中多个链接）</li></ul><p>浏览器：开发相关插件</p><ul><li>LiveReload</li><li>Vue.js devtools</li><li>React Developer Tools</li><li>ng-inspect for AngularJS 1.x</li><li>EnjoyCSS</li><li>Page Ruler</li><li>WhatFont</li><li>Dimension</li><li>TinEye Reverse Image Search（能快速搜索到几乎所有图片的源文件）</li><li>Search by Image （谷歌自己的图片搜索插件，右键直接搜索）</li><li>BuiltWith Technology Profiler（查看网页所使用的技术）</li><li>Wappalyzer（功能和 BuiltWith 类似）</li><li>Code Cola（可视化编辑 CSS）</li><li>Perfectpixel（让你对网页进行半透明图像叠加，并做像素对像素的比较）</li></ul><p>网络代理</p><ul><li>ShadowsocksX-NG-R8</li><li>Surge for Mac 3 （收费）</li><li>Charles （收费）</li></ul><p>上传下载</p><ul><li>百度网盘</li><li>迅雷</li></ul><h3 id="视频图片"><a href="#视频图片" class="headerlink" title="视频图片"></a>视频图片</h3><ul><li>PhotoShop CC 2019</li><li>Skitch</li><li>Keynote</li><li>Movist（收费）</li></ul><p>录屏/抓屏</p><ul><li>ScreenFlow</li><li>Giphy Capture （GIF 制作）</li><li>GIF Brewery 3</li><li>LICEcap</li></ul><p>阅读器</p><ul><li>Kindle</li><li>CAJViewerMac<br>描述：知网提供的看 CAJ 文献的工具</li></ul><h3 id="娱乐工具"><a href="#娱乐工具" class="headerlink" title="娱乐工具"></a>娱乐工具</h3><ul><li>QQ/微信</li><li>阿里旺旺</li><li>Telegram（必备）</li><li>Discord</li><li>网易云音乐/QQ音乐，etc</li></ul><h3 id="编程工具"><a href="#编程工具" class="headerlink" title="编程工具"></a>编程工具</h3><ul><li><p>Sublime Text 3<br>描述：性能高效的文本编辑器。</p></li><li><p>iTerm 2<br>描述：必备的命令行工具。</p></li></ul><p>文本对比工具</p><ul><li><p>kaleidoscope（收费）</p></li><li><p>Beyond Compare 4</p></li><li><p>DiffMerge</p></li><li><p>SourceTree<br>描述：图形化代码版本管理工具。</p></li><li><p>Navicat Premium（收费）<br>描述：图形化数据库管理工具。</p></li><li><p>Xcode<br>描述：苹果官方 IDE。</p></li><li><p>Paw（收费）<br>描述：HTTP 请求模拟工具。</p></li><li><p>Wireshark<br>描述：老牌的抓包工具，最新版本用 QT 写了界面，再也不依赖于坑爹的 X11了</p></li><li><p>Docker<br>描述：另装 Docker 全家桶，包括 VirtualBox 和 Kitematic。</p></li><li><p>SSH Shell<br>描述：XShell 的替代品</p></li><li><p>Dash<br>描述：API 查询工具（HTML/CSS/Javascript, PHP 等等）</p></li><li><p>FileZilla（FTP 文件传输工具）</p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>Sketch（收费）<br>描述：原型设计，轻量易用的矢量设计工具</li></ul><p>全文完！</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Macbook </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MacOS 下命令行使用代理</title>
      <link href="/Macbook/Macbook-macbook-cmd-proxy/"/>
      <url>/Macbook/Macbook-macbook-cmd-proxy/</url>
      
        <content type="html"><![CDATA[<p>Mac 下的 ShadowsockX-NG 可以自动开启 http 代理，默认端口是 1080，如下：</p><p><img src="/image/macbook/cmd12.png" alt=""></p><p>默认 Socks 5 端口是 1086，如下：</p><p><img src="/image/macbook/socks5_port.png" alt=""></p><p>要想在命令行中实现代理访问网络，在命令行 export 如下两个变量的值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://127.0.0.1:1080</span><br><span class="line">export https_proxy=http://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>如果是 fish，则使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set http_proxy "http://127.0.0.1:1080"</span><br><span class="line">set https_proxy "http://127.0.0.1:1080"</span><br></pre></td></tr></table></figure><p>如果某些网站还是无法连接，这是因为默认情况下，ShadowsockX-NG 使用的是 PAC 白名单过滤列表，我们可以把 ShadowsockX-NG 设置为全局模式，这样，所有连接就都会走代理了。</p><p>设置完成之后，使用 go get 等工具就可以自动实现代理上网了。</p><p>注意：代理连接使用完成之后，记得把环境变量重置。</p><br><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Macbook </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IPFS 中的 BitSwap 协议</title>
      <link href="/Distributed-System/ipfs-ipfs-bitswap/"/>
      <url>/Distributed-System/ipfs-ipfs-bitswap/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>BitSwap</strong> 是 IPFS 网络中定义数据块交换方式的协议，它是一个一种基于统一格式的消息对等协议，有别于 request/response 方式。简单来说就是，在 IPFS 中，请求和响应的消息都使用同一类型的消息包。由于在 IPFS 网络中，所有的 Peers 都是对等节点，不存在 BitTorrent 中那样的 Tracker 服务器，所以通信方式更加简单。</p><p>BitSwap 协议还定义了如何请求数据、如何发送数据以及向谁发送数据等策略，每个节点都可以有自己的策略，作为数据交换的核心模块，BitSwap 使用一些预定义的激励机制来促进网络中数据的流动，通过一个点对点之间的传输记录账本来达到互惠的目的。</p><p>IPFS 网络中使用 Bitswap 协议获取数据块一个最大的特点是，请求的数据块是跨文件的，这个是跟 BitTorrent 最大的区别所在，因为在 BitTorrent 中，块请求都是基于文件的，一个 Peer Swarm 都是对同一个文件（目录）进行数据传输。而在 IPFS 中，由于数据请求是基于块的，任何类型的数据块，只要其哈希值一样，都可以拿为己用，一个 Peer Swarm 对应的是整个 IPFS 网络中的数据，因此所有的数据块都可以被用来使用，实现真正的跨文件数据交换。这不仅大大减少了数据的冗余，还大大提高的块检索的效率。显然，BitSwap 的效率比 BitTorrent 更高。</p><p> <img src="/image/swarm.png" alt=""></p><p>基于上，BitSwap 协议定义了 Message, Networking, Decision Engine 以及 WantList 等主要模块。</p><h3 id="1-Message-Protocol"><a href="#1-Message-Protocol" class="headerlink" title="1. Message Protocol"></a>1. Message Protocol</h3><p>IPFS 中使用 Protocol Buffer 对消息进行编码，Peers 之间通信的消息分为两种，一种是 WantList 用于描述请求，第二种是 Block 用于表示传递的块数据。<br>WantList 中包含了 blockCid, priority, cancel, full 等字段用于描述要请求的 Block 索引，优先级以及是否是完整请求等信息。</p><p>我们知道，在 IPFS 中，文件被分为若干 Chunks，也叫 Blocks，Block 是 IPFS 网络中最基本的数据操作单位。每个 Block 使用一个 CID 标识符来索引，CID 是一个自描述的索引结构体，它集成了对 Block 编码所使用 codec, length, hash 等信息，可以唯一标识一个 Block。因此，要想从 Peer 下载一个 Block，只需在告诉它 CID 即可，收到 Block 时我们也可以容易进行验证。</p><p>实际上，由于 IPFS 中使用了 Multicodec 自适应编码协议，因此消息发送前还会添加 multicodec 前缀，这样，就使得消息的格式范围大大增加了，而不仅仅是 Protobuf。比如 JSON, Cbor 等都可以支持！更加强大的是，IPFS 还定义了一套 Multistream 作为网络流的格式协议，因此它甚至还能支持协议的不同版本。</p><p> <img src="/image/ipfs_msg.png" alt=""></p><h3 id="2-Networking"><a href="#2-Networking" class="headerlink" title="2. Networking"></a>2. Networking</h3><p>Networking 模块定义了消息发送和处理，查找 Block Providers，Announce Keys，Session 管理，路由等组件。</p><p>1）Message Stream<br>在 IPFS 网络中，消息都是被打包成 Multistream 流进行传输的，Peer 接收到一个 Stream 之后，会先对其解码成对应的消息格式，然后根据消息内容的要求决定是响应请求还是接收块数据。<br>如果 Decision Engine 决定响应 WantList 请求，那么 BitSwap 会从本地的块数据库中取出块数据，往 Peer Request Queue 中添加一个任务，把块数据发送给对方。</p><p>2）Provider<br>当前节点想要下载一个数据块，本地块数据库中未找到时，就会调用 BitSwap 的网络模块（DHT）查找 Providers，一旦找到，就会连接它并向其发送 WantList 请求，<br>如果收到了块数据，那么会把存入本地的块数据库。更新本地的 WantList 以及传输记录账本，更新 Session 等一些列操作。</p><p>3) Announce<br>Announce 操作是本地节点作为 Key Provider 进行的。在 IPFS 网络中，Block 是用 Key 来标识的（即 Cid Prefix），因此，每当本地新增一个 Block 数据是，provide worker 会异步的向网络中进行 Announce 操作，以声明自己拥有某个块。这样，当其他 Peer 想要下载时，就可以根据 DHT Table 方便的找到要连接的 Providers。</p><p>4）Session<br>Session 管理 Peers 之间的连接，包括 Peers 的请求状态（优先级，是否已取消？等），以及 Peer 存活状态等等信息。</p><h3 id="3-Decision-Engine"><a href="#3-Decision-Engine" class="headerlink" title="3. Decision Engine"></a>3. Decision Engine</h3><p>Decision Engine 是 BitSwap 协议的信用管理模块。它管理一个请求队列，使用一个账本来记录节点之间的传输记录，并以此决定是否响应对端的下载请求。<br>之所以建立一个信用账本，主要是为了以下目的：</p><ul><li>提高节点之间数据交换的效率</li><li>防止 freerider</li><li>防止一些攻击行为(比如：女巫攻击)</li><li>对信任的节点建立宽松机制</li></ul><p>需要注意的是，信用记录是两个节点之间的，分为 Credit 和 Debt 两部分，比如，节点 A 向节点 B 发送过数据，那么 A 就拥有对 B 的 Credit，相反，B 欠了 A 的 Debt。如果 A 对 B 拥有的 Credit 超过 Debt，那么下次其向 B 发出 WantList 请求块数据的时候，B 就会立刻反馈数据。总的来说，A 的 Credit 减去其 Debt 就是净值，IPFS 中使用负债率（debt ratio，r）来表示。</p><p>负债率的公式是：</p><pre><code>debtRatio = bytes_sent/(bytes_recv + 1)</code></pre><p>节点根据负债率来计算出这个节点的发送率 P (send|r) = 1− 1/(1+exp(6−3r))</p><p>根据这两个函数可以发现，当负债率达到某一个值的时候负债率会急剧下降。</p><p>这个模型表达的意义：如果一个节点只接受数据不分享数据，别人发送给它数据的概率会越来越低（到达某一个值后就会急剧降低接近0），如果节点持续保持分享数据，别的节点向你发送数据的概率就会越来越大。</p><p>Decision Engine 会记录下来和其他节点通信的账单（数据收发），可以保持节点间数据交换的历史和防止篡改。当两个节点之间建立连接的时候，BitSwap 会相互交换账单信息，如果账单不匹配，则清除重新记账。恶意节点可能会故意“丢失”账单，以希望清除掉自己的债务。其它交互节点会把这些都记下来，如果总是发生，节点就会被拒绝。</p><p>这套信用系统跟 BitTorrent 和 Emule 的信用系统是类似的，Tit-for-Tat，其信用记录都是基于传输节点双方的，并不是全局共享的，也就是说，即使你往某个节点传输了大量的数据，如果你想要的数据不在那个节点上，你也无法根据你的贡献度从整个 IPFS 网络受益。</p><p>为此，IPFS 的团队开发了一个全新的 Filecoin 项目，它就是构建与整个 IPFS 网络之上的激励层。后续文章再介绍。</p><h3 id="4-WantManager"><a href="#4-WantManager" class="headerlink" title="4. WantManager"></a>4. WantManager</h3><p>WantManager 模块主要是管理 WantList 请求的，它是一个实现模块。WantList 是核心数据结构，通过管理一个消息队列，一旦有新的 WantList Entry 添加，就会触发消息队列的工作线程，从而往指定的 Peer 发送数据块。WantManager 提供了一些机制来保证数据块的分发，比如发送失败时会等待一定间隔后进行重发 Rebroadcast，通过 WantList Gauge 监控发送过程，完成数据下载之后的请求取消等。</p><p> <img src="/image/wantmanager.png" alt=""></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>假如我们想要下载一个 Video 文件，我们知道它的哈希是：<code>Qmdsrpg2oXZTWGjat98VgpFQb5u1Vdw5Gun2rgQ2Xhxa2t</code>，因此，在启动 <code>ipfs daemon</code> 之后，我们执行：</p><pre><code>$ ipfs get Qmdsrpg2oXZTWGjat98VgpFQb5u1Vdw5Gun2rgQ2Xhxa2t﻿</code></pre><p>这时候，IPFS 的 WantManager 会计算出 WantList，搜寻网络中的 Peers 并下载相应的 Block。<br>我们可以通过下列命令查看 WantList。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ipfs bitswap wantlist</span><br><span class="line">QmYEqofNsPNQEa7yNx93KgDycmrzbFkr5oc3NMKXMxx5ff</span><br><span class="line">QmUmDEBm9a8MYyqRdb3YQnoqPmqAo4cEWdKQErirFJdSWD</span><br><span class="line">QmY5VJPbsRZzFCTMrFBx2qtZiyyeLhsjBysyfC1fx2gE9S</span><br><span class="line">QmdbzYgyhqUNCNL8xU2HTSKwao1ck2Gmi5U1ygjQuJd92b</span><br><span class="line">QmbZDe5Dcv9mJr8fiqp5aJL2cbyu64tgzwCS2Vy4P3krCL</span><br><span class="line">QmRjzMzVeYRE5b6tDF3sTXMV1sTffno92uL3WwuFavBrWQ</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>找到我们拥有 Debt 的节点列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QmSoLMeWqB7YGVLJN3pNLQpmmEk35v6wYtsMGLzSr5QBU3</span><br><span class="line">QmSoLnSGccFuZQJzRadHn95W2CrSFmZuTdDWP8HXaHca9z</span><br><span class="line">QmUh2KnjAvgEbJFSd5JZws4CNvt6LbC4C1sRpBgCbZQiqD</span><br><span class="line">Qmc9pBLfKSwWboKHMvmKx1P7Z738CojuUXkPA1dsPrvSw2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>选择一个并查看我们是否从该节点下载过数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ipfs bitswap ledger QmSoLMeWqB7YGVLJN3pNLQpmmEk35v6wYtsMGLzSr5QBU3</span><br><span class="line">Ledger for &lt;peer.ID SoLMeW&gt;</span><br><span class="line">Debt ratio: 0.000000</span><br><span class="line">Exchanges:  11</span><br><span class="line">Bytes sent: 0</span><br><span class="line">Bytes received: 2883738</span><br></pre></td></tr></table></figure><p>全文完！</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Part II, Algorithms</title>
      <link href="/System-Programming/core-techs-02-algorithms/"/>
      <url>/System-Programming/core-techs-02-algorithms/</url>
      
        <content type="html"><![CDATA[<h2 id="Big-O-notation"><a href="#Big-O-notation" class="headerlink" title="Big-O notation"></a>Big-O notation</h2><h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p>Greatest Common Divider</p><p>gcd(a, b) = the greates number g where g/a and g/b</p><h3 id="1-Euclid’s-algorithm"><a href="#1-Euclid’s-algorithm" class="headerlink" title="1. Euclid’s algorithm"></a>1. Euclid’s algorithm</h3><p>欧几里德算法又称<strong>辗转相除法</strong>，用于计算两个整数 a,b 的最大公约数。其计算原理依赖于下面的定理：</p><p>定理：gcd(a, b) = gcd(b, a mod b)</p><p>证明：a 可以表示成 <em>a = kb + r_，则 _r = a mod b</em><br>假设 d 是 a,b 的一个公约数，则有 <em>d|a</em>, <em>d|b_，而 _r = a - kb_，因此 _d|r</em><br>因此 d 是 <em>(b,a mod b)</em> 的公约数</p><p>假设 d 是 <em>(b,a mod b)</em> 的公约数，则 <em>d | b, d |r_，但是 _a = kb +r</em><br>因此 d 也是 (a,b) 的公约数</p><p>因此 (a,b) 和 (b,a mod b)的公约数是一样的，其最大公约数也必然相等，得证</p><p>欧几里德算法就是根据这个原理来做的，其算法用 C++ 语言描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> Gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Stein-algorithm"><a href="#2-Stein-algorithm" class="headerlink" title="2. Stein algorithm"></a>2. Stein algorithm</h3><p>欧几里德算法是计算两个数最大公约数的传统算法，他无论从理论还是从效率上都是很好的。但是他有一个致命的缺陷，这个缺陷只有在大素数时才会显现出来。</p><p>Stein 算法由 J. Stein 1961 年提出，这个方法也是计算两个数的最大公约数。和欧几里德算法 算法不同的是，Stein 算法只有整数的移位和加减法，这对于程序设计者是一个福音。</p><p>为了说明 Stein 算法的正确性，首先必须注意到以下结论：</p><p>gcd(a,a) = a，也就是一个数和他自身的公约数是其自身<br>gcd(ka,kb) = k gcd(a,b)，也就是最大公约数运算和倍乘运算可以交换，特殊的，当 k=2 时，说明两个偶数的最大公约数必然能被 2 整除。</p><h2 id="Prime-Number-amp-Divisibility-os-Numbers"><a href="#Prime-Number-amp-Divisibility-os-Numbers" class="headerlink" title="Prime Number &amp; Divisibility os Numbers"></a>Prime Number &amp; Divisibility os Numbers</h2><h2 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h2><ul><li>Topological Sorting</li></ul><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><ul><li>Binary Search</li><li>Depth/Breadth First Search</li></ul><h2 id="Tree-traversal"><a href="#Tree-traversal" class="headerlink" title="Tree traversal"></a>Tree traversal</h2><h2 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h2><h2 id="Greedy-Algorithm"><a href="#Greedy-Algorithm" class="headerlink" title="Greedy Algorithm"></a>Greedy Algorithm</h2><h2 id="Divide-and-Conquer"><a href="#Divide-and-Conquer" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h2><h2 id="Dynamic-Programming-Advanced-Dynamic-Programming"><a href="#Dynamic-Programming-Advanced-Dynamic-Programming" class="headerlink" title="Dynamic Programming (Advanced Dynamic Programming)"></a>Dynamic Programming (Advanced Dynamic Programming)</h2><h2 id="Shorted-Path"><a href="#Shorted-Path" class="headerlink" title="Shorted Path"></a>Shorted Path</h2><h2 id="Sieve-of-Eratosthenes"><a href="#Sieve-of-Eratosthenes" class="headerlink" title="Sieve of Eratosthenes"></a>Sieve of Eratosthenes</h2><ul><li>Dijkstra</li><li>Bellman-Ford</li><li>Floyd-Warshall</li></ul><h1 id="Classic-Problems"><a href="#Classic-Problems" class="headerlink" title="Classic Problems"></a>Classic Problems</h1><ul><li>Lowest Common Ancestor, LCA</li><li>Longest Common Path, LCP</li></ul><p>Three level of algorithm depends on the difficulties:</p><h3 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h3><ul><li>Brutal Force Search</li><li>Greedy Algorithms</li><li>Data Structures (Array, LinkedList, Binary Tree, Stack/Queue, Map, etc.)</li><li>DFS &amp; BFS</li></ul><h3 id="Intermediate"><a href="#Intermediate" class="headerlink" title="Intermediate"></a>Intermediate</h3><ul><li>Binary Search</li><li>Dynamic Programming</li><li>Divide &amp; Conquer</li><li>Branch Bound</li></ul><h3 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h3><ul><li>Number Theory</li><li>Game Theory</li><li>Graph Theorem<ul><li>Shortest Path</li><li>Max Flow</li><li>Bipartite </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> System Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Part I, Data Structures</title>
      <link href="/System-Programming/core-techs-01-data-structures/"/>
      <url>/System-Programming/core-techs-01-data-structures/</url>
      
        <content type="html"><![CDATA[<h2 id="Basic-Data-Structures"><a href="#Basic-Data-Structures" class="headerlink" title="Basic Data Structures"></a>Basic Data Structures</h2><ul><li><p>array</p></li><li><p>linked-list:doubly linked list, circular linked list</p></li><li><p>tree</p><ul><li><p>N-ary Tree</p></li><li><p>Balanced Tree</p></li><li><p>Binary Tree</p></li><li><p>Binary Search Tree</p></li><li><p>AVL Tree</p></li><li><p>Red Black Tree</p></li><li><p>2–3 Tree</p></li><li><p>Minimum Spanning Tree (Prim and Kruskal algorithms)</p></li></ul></li></ul><ul><li>stack</li><li>heap</li><li>queue: priority queue</li><li>hash table</li><li>graph:Undirected/Directed Graph, Adjacency Matrix/List, Euler path</li><li>string</li></ul><h2 id="Advanced-Data-Structrues"><a href="#Advanced-Data-Structrues" class="headerlink" title="Advanced Data Structrues"></a>Advanced Data Structrues</h2><ul><li>Trie (also known as “Prefix Tree”)</li><li>Segment Tree</li><li>Fenwick Tree (also known as “Binary Indexed Tree”)</li><li>Suffix Tree</li><li>Suffix Array</li></ul><h2 id="Disjoint-Data-Structures"><a href="#Disjoint-Data-Structures" class="headerlink" title="Disjoint Data Structures"></a>Disjoint Data Structures</h2><ul><li>disjoint set union</li></ul><p><a href="https://www.hackerearth.com/zh/practice/data-structures/disjoint-data-strutures/basics-of-disjoint-data-structures/tutorial/" target="_blank" rel="noopener">https://www.hackerearth.com/zh/practice/data-structures/disjoint-data-strutures/basics-of-disjoint-data-structures/tutorial/</a></p>]]></content>
      
      
      <categories>
          
          <category> System Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>I/O Operations in Linux</title>
      <link href="/System-Programming/core-techs-linux-io-zero-copy/"/>
      <url>/System-Programming/core-techs-linux-io-zero-copy/</url>
      
        <content type="html"><![CDATA[<h2 id="几种-IO-方式介绍"><a href="#几种-IO-方式介绍" class="headerlink" title="几种 IO 方式介绍"></a>几种 IO 方式介绍</h2><p>Linux 中文件访问的几种方式</p><p>1、标准文件访问 （缓存IO）<br>用户访问磁盘中数据时，通常通过read()或者write()调用完成，操作系统会先将数据读取或者写入到page cache中，然后再写入磁盘，Linux默认写入磁盘方式为deferred write</p><p>2、同步访问<br>相对于标准访问方式，同步访问需要在写入磁盘后才返回，而标准访问可以在写入page cache后就返回</p><p>3、内存映射<br>Linux通过将一块内存区域和一个外部设备或者文件关联起来，操作系统将对内存的操作映射为对外部设备或文件的操作，Linux提供了mmap</p><p>4、直接访问（直接IO）<br>直接在用户空间访问文件，不需要内核空间的page cache支持，对于一些通过应用程序自身进行缓存控制的程序（例如数据库）比较适用</p><p>5、异步访问<br>用户程序在写入或者读取磁盘数据时无需阻塞，由操作系统异步，提升了用户程序的效率</p><h3 id="缓存IO和直接IO对比"><a href="#缓存IO和直接IO对比" class="headerlink" title="缓存IO和直接IO对比"></a>缓存IO和直接IO对比</h3><p>缓存IO需要由DMA将文件数据读入到page cache，然后通过page cache读取数据，如果一个文件需要频繁访问，能够减少文件直接访问次数，但是在大量文件访问的程序中，存在很多用户程序，内核page cache和磁盘文件的数据copy，就会带来很高的cpu负载。</p><h3 id="如何进行直接IO调用"><a href="#如何进行直接IO调用" class="headerlink" title="如何进行直接IO调用"></a>如何进行直接IO调用</h3><p>linux中文件操作主要通过read(),write(),open()这三个操作完成，在函数操作中通过O_DIRECT标识符完成</p><h3 id="直接IO的使用场景"><a href="#直接IO的使用场景" class="headerlink" title="直接IO的使用场景"></a>直接IO的使用场景</h3><p>由于直接IO调用减少了数据的copy次数，对于一些需要大量数据复制（到内存或者网络）或者对数据缓存能够通过应用控制（例如数据库）的场景，会有很大的性能提升</p><h2 id="Zero-Copy"><a href="#Zero-Copy" class="headerlink" title="Zero Copy"></a>Zero Copy</h2><p>Linux 中传统的 I/O 操作是一种缓冲 I/O，I/O 过程中产生的数据传输通常需要在缓冲区中进行多次的拷贝操作，例如一次网络请求中，如果需要读取磁盘文件，需要经过四次copy过程和多次的内核和用户态的上下文切换，下面是一次传统web请求中，从磁盘读取数据到返回数据结果的过程中数据在内存中的copy过程</p><p>也可以通过 Efficient data transfer through zero copy 这篇文章详细了解</p><p>zero copy技术可以避免数据的多次copy，减少不必要的上下文切换（内核态和用户态），降低CPU的资源浪费，尤其在处理大量网络请求的应用中，zero copy显得更加重要。</p><h2 id="linux中zero-copy实现方式主要实现方式"><a href="#linux中zero-copy实现方式主要实现方式" class="headerlink" title="linux中zero copy实现方式主要实现方式"></a>linux中zero copy实现方式主要实现方式</h2><p>1) 直接IO技术（减少page cache）<br>2) 从page cache 直接copy到目标缓冲区<br>3) mmap()：应用程序调用了 mmap() 之后，数据会先通过 DMA 拷贝到操作系统内核的缓冲区中去。接着，应用程序跟操作系统共享这个缓冲区，适用于大数据范围的copy，但是当多个进行修改时，会收到一个SIGBUS中断信号，而且必须有效的解决才能避免一些问题。<br>4) sendfile()：sendfile() 系统调用利用 DMA 引擎将文件中的数据拷贝到操作系统内核缓冲区中，然后数据被拷贝到与 socket 相关的内核缓冲区中去<br>5) splice()：Linux2.6.17引入，和sendFile机制类似，但是可以在fin和fout之间互相copy数据，而不是单向。<br>6) copy-on-write：多个进程共享一块 buffer，当一个进程需要修改 buffer 数据时，会将 buffer 数据 copy 到进行内存单独修改，COW 技术通过读共享内存减少了内存的 copy<br>7) 通过硬件的支持，直接从 kernel buffer 到网卡等终端，减少了一次 kernel buffer 到 socket buffer 的 copy</p><h2 id="Zero-Copy的实际应用场景"><a href="#Zero-Copy的实际应用场景" class="headerlink" title="Zero Copy的实际应用场景"></a>Zero Copy的实际应用场景</h2><p>Nginx，在 Nginx 性能优化中，有一个配置是 sendfile on/off,以下是官方文档的说明<br>By default, NGINX handles file transmission itself and copies the file into the buffer before sending it. Enabling the sendfile directive eliminates the step of copying the data into the buffer and enables direct copying data from one file descriptor to another<br>当nginx在处理静态资源请求时，开启sendfile对性能有一定的提升，当然还需要根据实际场景，结合其他配置使用。可以通过 Optimisations Nginx, bien comprendre sendfile, tcpnodelay et tcpnopush 详细了解</p><p>C10k 问题的解决中，Zero Copy 对于 IO 的提升是一个关键点，具体可以通过 [The C10K problem][] 查看</p><p>Kafka, Netty, RocketMQ 等中间件</p><p>消息中间件中对于消息持久化通常保存在文件中，对于一个高吞吐量的消息中间件，对文件读写通常采用以下方案（Java为例）</p><ul><li>NIO：主要在java.nio包中，通过FileChannel相关方法实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">"message.data"</span>), <span class="string">"rw"</span>).getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后通过read和write方法写入数据</span></span><br><span class="line">fileChannel.read(ByteBuffer[] dsts, <span class="keyword">int</span> offset, <span class="keyword">int</span> length);</span><br><span class="line">fileChannel.write(ByteBuffer[] srcs, <span class="keyword">int</span> offset, <span class="keyword">int</span> length);</span><br></pre></td></tr></table></figure><ul><li>MMAP：RocketMQ默认采用异步mmap的方式实现消息刷盘</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, filechannel.size();</span><br></pre></td></tr></table></figure><p>Reference:<br><a href="https://www.jishuwen.com/d/2QwJ" target="_blank" rel="noopener">https://www.jishuwen.com/d/2QwJ</a></p><p>[The C10K problem][<a href="http://www.kegel.com/c10k.html#top]" target="_blank" rel="noopener">http://www.kegel.com/c10k.html#top]</a></p>]]></content>
      
      
      <categories>
          
          <category> System Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Part III, Linux Process</title>
      <link href="/System-Programming/core-techs-03-linux-process/"/>
      <url>/System-Programming/core-techs-03-linux-process/</url>
      
        <content type="html"><![CDATA[<p>Five core module of Linux </p><ol><li>Process Scheduling</li><li>Memory Management</li><li>Filesystem</li><li>Communication between Processes</li><li>Networking</li></ol><p><img src="/image/coretech/5core_module.gif" alt=""></p><h3 id="Linux-进程的管理与调度"><a href="#Linux-进程的管理与调度" class="headerlink" title="Linux 进程的管理与调度"></a>Linux 进程的管理与调度</h3><p>5个互斥状态<br>state 域能够取 5 个互为排斥的值。系统中的每个进程都必然处于以上所列进程状态中的一种。</p><p>状态  描述<br>TASK_RUNNING    表示进程要么正在执行，要么正要准备执行（已经就绪），正在等待 cpu 时间片的调度<br>TASK_INTERRUPTIBLE  进程因为等待一些条件而被挂起（阻塞）而所处的状态。这些条件主要包括：硬中断、资源、一些信号……，一旦等待的条件成立，进程就会从该状态（阻塞）迅速转化成为就绪状态TASK_RUNNING<br>TASK_UNINTERRUPTIBLE    意义与 TASK_INTERRUPTIBLE 类似，除了不能通过接受一个信号来唤醒以外，对于处于 TASK_UNINTERRUPIBLE 状态的进程，哪怕我们传递一个信号或者有一个外部中断都不能唤醒他们。只有它所等待的资源可用的时候，他才会被唤醒。这个标志很少用，但是并不代表没有任何用处，其实他的作用非常大，特别是对于驱动刺探相关的硬件过程很重要，这个刺探过程不能被一些其他的东西给中断，否则就会让进城进入不可预测的状态。<br>TASK_STOPPED    进程被停止执行，当进程接收到SIGSTOP、SIGTTIN、SIGTSTP或者SIGTTOU信号之后就会进入该状态<br>TASK_TRACED 表示进程被 debugger 等进程监视，进程执行被调试程序所停止，当一个进程被另外的进程所监视，每一个信号都会让进程进入该状态。</p><p>进程状态 TASK_UNINTERRUPTIBLE 和 TASK_INTERRUPTIBLE 都是睡眠状态。</p><p>Linux Kernel 2.6.25 引入了一种新的进程睡眠状态，<br>TASK_KILLABLE   当进程处于这种可以终止的新睡眠状态中，它的运行原理类似于 TASK_UNINTERRUPTIBLE，只不过可以响应致命信号。</p><p><img src="/image/coretech/task_state.jpg" alt=""></p><p>进程标识符（PID）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pid_t pid;</span><br><span class="line">pid_t tgid;</span><br></pre></td></tr></table></figure><p>在Linux系统中，一个线程组中的所有线程使用和该线程组的领头线程（该组中的第一个轻量级进程）相同的 PID，并被存放在tgid成员中。只有线程组的领头线程的pid成员才会被设置为与tgid相同的值。注意，getpid()系统调用返回的是当前进程的 tgid 值而不是 pid 值。</p><p><a href="https://blog.csdn.net/gatieme/article/details/51383272" target="_blank" rel="noopener">https://blog.csdn.net/gatieme/article/details/51383272</a></p><p>CPU</p><p>关于CPU，有3个重要的概念：上下文切换（context switchs），运行队列（Run queue）和使用率（utilization）。</p><h3 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h3><ul><li>管道</li><li>共享内存</li><li>TCP socket</li><li>unix domain socket</li></ul><p>同步原语</p><ul><li>锁spinlock, shared_lock</li></ul><p>可重入/不可重入</p>]]></content>
      
      
      <categories>
          
          <category> System Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Honey Badger of BFT 协议详解</title>
      <link href="/Distributed-System/distributed-system-honey-badger/"/>
      <url>/Distributed-System/distributed-system-honey-badger/</url>
      
        <content type="html"><![CDATA[<p>###简介<br>加密数字货币的成功使得 BFT 共识协议不断的被应用在那些重要的领域尤其是金融行业。传统的 PBFT 是一种弱同步性质的共识协议，因为它的可靠性对网络中的时间处理延时依赖非常大。也就是说，网络的活性 Liveness 很大程度上会受到网络条件的影响。</p><p>HoneyBadgerBFT 作为一种异步的 BFT 共识协议，号称不依赖网络中的对时间条件的依赖。对比与传统的 PBFT 共识协议，它的效率都有显著提高。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>可以满足下面两个应用场景</p><p>1）由多个金融机构组成的金融财团共同基于  Byzantine agreement protocol 协作运行的联盟链，这样，就能保证快速、稳定的处理交易。<br>2）在无许可（permissionless）的公链中依然可以提供可以接受的（acceptable）的吞吐量和延迟。</p><p>###网络模型<br>HoneyBadgerBFT 系统假定每两个节点之间都有可靠的通信管道连接，消息的最终投递状态完全取决于敌方（adversary），但是诚实节点之间的消息最终一定会被投递。在整个网络中的总节点数必须大于三分之一的敌方节点，也就是 N ≥ 3F+1。</p><p>网络中的交易还依赖于一个全局顺序。</p><p>一个成功的网络，最后状态应该是这样的：</p><ul><li>任何诚实的节点确认了一笔交易 TX，那么其他所有的诚实节点也会确认这笔交易</li><li>任何诚实的节点确认了一笔交易 TX，其序号是 s1，而另一个诚实节点确认了另一笔交易 TX，其序号是 s2，那么要么 s1 发生在 s2 之前，要么之后。也就是说，其时间顺序是确定的。</li><li>如果一笔交易被发送到 N - F 个诚实节点了，那么最终每个诚实节点都会确认这笔交易。这就是可审查特性。</li></ul><p>###实现<br>HoneyBadgerBFT 使用了两个方法来提升共识效率。</p><p>1、通过分割交易来缓解单节点带宽瓶颈<br>2、通过在批量交易中选择随机交易块，并配合门限加密来提升交易吞吐量。</p><h5 id="下面就分别来详细解释这两种方法的原理"><a href="#下面就分别来详细解释这两种方法的原理" class="headerlink" title="下面就分别来详细解释这两种方法的原理"></a>下面就分别来详细解释这两种方法的原理</h5><p>1）交易分割传输<br>在网络中，批量的交易（总数为 n）需要打包传输给其他节点，作为共识发起方，一个节点需要把打包的交易发送 N - 1 份给其它节点。 如下：</p><p><img src="/image/p2p/transaction_split.png" alt=""></p><p>改进的方案是，把总数为 n 的交易分割成 N - 1 份，也就是说，每份包含 n / N - 1 条交易。 如图，把交易分成三个小块，每块发给不同的节点。这样原来一共需要发 3 * n 份交易数据就变成了只需要发送 n 份即可。</p><p><img src="/image/p2p/transaction_split1.png" alt=""></p><p>其他节点收到了分块的交易之后，分别再从其他节点收取缺失的交易块，这样，节点 A、B、C 之间的带宽就被充分利用了，而减少了 P 作为发起节点的瓶颈，整个系统的性能不会完全受限于 P 节点。</p><p><img src="/image/p2p/transaction_split2.png" alt=""></p><p>2）随机块的选择以及门限加密</p><p>由于 HoneyBadge BFT 是一种异步共识协议，节点之间收到交易是非同步的，随机的。也就是说，每个节点收到来自客户端的交易可以是不同的，交易到达各个节点的时间顺序也是不定的。</p><p>各节点收到交易信息之后，会把该交易放入它自身的 Input Buffer 中，后续收到的交易也依次按顺序放入其 Input Buffer。HoneyBadger 网络中是依靠 epochs 来作为时间间隔进行交易打包处理的，在一个 epoch 中，每个节点会从自身的 Input Buffer 中选一批交易，并广播给其它所有节点。最终，每个节点都会有形成一个有相同交易集的交易池，它们是这些节点广播出来的所有交易的并集，也就是 BatchA U BatchB U BatchC U …。</p><p>显然，这个交易池中可能存在重复的、无效的交易，需要剔除。</p><p>最终确认哪些交易还需要一个叫做 Binary Byzantine Agreement 的过程，简单来说就是，在所有节点之间进行一轮共识，得到一个最终确认的二进制数值，由这个二进制的对应的位来决定哪个交易会被最终确认。</p><p><img src="/image/p2p/binary_byzantine_agreement.png" alt=""></p><p>在进行 Binary Byzanting Agreement 完成之后，会得到一个确定的 Value，根据这个 Value 来确定交易集合。在剔除无效交易和重复交易之后，每个节点就可以立刻确认剩余的交易集（Asynchronous Common Subset ）。</p><p>需要注意的是，各节点广播时的交易都是按照顺序从自己的 Input Buffer 中取出的，为了防止这种策略被 adversary 节点监控到，从而对诚实节点进行网络干扰阻碍交易的发布和共识，Honey Badger 采用了一种 Random Selective 的优化方式随机选取一批交易。</p><p>就是，每个节点从自己的 Input Buffer 中随机选区一批交易，这样的好处有两个，一是可以防止 adversary 了解策略进行干扰或者攻击，二是随机选取一批交易可以很大程度上避免各节点提交的交易出现大量重复。原因是各节点虽然收到的交易顺序不一定一致，但在网络条件差不多的情况下，大部分交易顺序可能是相同的，随机选取而不是都按顺序选取可以避免大量的重复。</p><h6 id="门限加密-Threshold-Encrytion"><a href="#门限加密-Threshold-Encrytion" class="headerlink" title="门限加密 Threshold Encrytion"></a>门限加密 Threshold Encrytion</h6><p>因为 Adversary 的存在可能干扰 Binary Byzantine Agreement 的结果。因此，Honey Badger 提出了门限加密的方式来避免最终的交易集受到攻击。</p><p>门限加密的原理是允许任何节点使用一把主公钥来加密一条信息，但是解密则需要网络中所有节点来共同合作，只有当 f + 1 个诚实节点共同合作才能获得解密秘钥，从而得到消息原文。在这之前，任何攻击者都无法解密获得消息的原文。</p><p>具体过程如下：<br>由一个第三方的可信节点为每个节点生成公/私钥，使用一把主公钥（master public key）加密原交易信息得到一份 ciphertext，然后每个节点分别使用其私钥 SKi 和这份 ciphertext 得到完整解码秘钥的一个部分σi。</p><p>当节点拿到 f + 1 份 σi 时，配合 PK 就可以解密 ciphertext。</p><h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>以下性能测试结果来源于其官方论文截图（本人暂未测试）</p><p><img src="/image/p2p/performance_test1.jpeg" alt=""></p><p><img src="/image/p2p/performance_test2.png" alt=""></p><p><img src="/image/p2p/performance_test2.png" alt=""></p><p>官方论文：<br><a href="https://eprint.iacr.org/2016/199.pdf" target="_blank" rel="noopener">https://eprint.iacr.org/2016/199.pdf</a></p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在美国捡回一条小命</title>
      <link href="/Life/life-survive-in-us/"/>
      <url>/Life/life-survive-in-us/</url>
      
        <content type="html"><![CDATA[<p>美国的生活跟国内非常不一样，如果不小心，可能很容易把自己置于危险境地，我就曾遭遇过几次算是“惊险”的经历，想起来还是心有余悸的，事情还得从头说起。</p><p>在美国上学，首先要解决的就是住的问题，刚来美国的留学生，大部分都没车，而美国很多地方又几乎没有公共交通，因此，租房的地点选择非常重要。考虑到方便，许多人会考虑租校园内部的公寓，缺点是非常贵，而且数量有限，大部分人不得不租校外的房子。学校为了方便学生，就开设了一条公交路线，会途径附近几个公寓。这样，留学生或者家住得较远的学生就可以租在这条公交沿线的公寓里，方便了不少。</p><p>往学校西边方向的一处社区叫 McCallum，靠近贫民区，那边有许多公寓，公寓的房子本身比较一般（没有物业，没有小区门，全开放式的），但是有一点好处就是房租便宜，两室一厅的房子月租差不多在 $800 以内，相比于校内的公寓要便宜不少。因此，很多学生都选择租住在这个区域。有车的学生由于不受限与校车的范围，因此可以选择租更远一些的小区（比如往北的 plano 甚至更远一些），不但房子的选择余地大很多，房租也会更加便宜一些。</p><p>我来美国之前申请了学校公寓，但是太多人申请导致我被排在等待列表（Waiting list）上面。幸运的是，中国学生会安排的教会叔叔接待了我和其他几个留学生在家里暂住，但是不能长住。因此，暂住几天之后我就不得不先去找其他房子住了（毕竟不能一直住在教会叔叔家）。由于新来的学生都会聚集在一起，再加上学生会展开的迎新活动，很快我就找到了也正好在找房子租的其他中国学生，顺利的租住在了 McCallum 那片小区。</p><p>此后的一段时间，我就住在那片小区，虽然经常有人说这里不安全，但是我很长一段时间并没有亲身经历过，因此觉得还勉强算可以。唯一的就是那边黑人、墨西哥人确实比较多，作为外国人，我大部分时间还是比较谨慎，不会在外面随意逗留，尤其夜晚。</p><p>但是不幸的事还是发生了，记得是有一天，我在亚马逊上买了一个东西（具体什么忘了，好像是书），等到快递寄过来的时候，网上查询发现已经签收（快递员放在邮箱里），但是我并没有收到，打客服电话才发现，原来小区分 A、B 区，快递被送到另外一个区（就在相邻的另一片公寓）的同一门牌号处了。当时正好是在傍晚时分 7 点多，天色已经暗下来，那个房子也是在公寓的一楼，我没有想太多就去那敲门，打算告知寄错快递的事并请求对方帮我取回我的物品。当时门是半掩着，屋内有灯亮着，从窗口望去是有人在家活动的景象，我敲了几声门，没人应答也没人来开门，但是我听到几声急促的上楼的声音（公寓一共两层，是木制的房子，里面的楼梯也是木头的，因此能很清楚听到上楼的脚步声）。我很是疑虑，为什么明明有人却没人来开门呢。好奇之际，我就推门想看看究竟，结果这一推可没把我心脏给吓得跳出来。一个中矮个子留着胡子的黑人青年手里提着一把<strong>大大的机关枪</strong>（注意是机关枪，不是手枪！如下图）冲出来，嘴里骂着，很激动的枪头指着我。我被吓退很长一段距离。但是我没有撒腿跑，估计是本能觉得跑的话肯定是死路一条吧，那个枪是可以连发的而且是霰弹。我边抬着手边赶紧大步往后退，并且劝他冷静冷静再冷静，向他解释我没有恶意，只是快递寄错了。他托着枪的手一直激动的指着我，有几次像是要扣动扳机了，我甚至要闭着眼睛喊娘了，但是貌似理智已经战胜了紧张，我口里一直冷静地劝说着 “sorry，it’s a mistake”，他怼了我好一会儿，然后似乎想通了，终于枪头朝下，并向我走过来握手道歉，还向我解释他需要保护他房子里的孩子之类的。我这时候才发现手心全是汗，颈和脖子都湿了（内裤没湿我保证）。然后我告诉他我的快递在他的邮箱里面，需要他帮忙取一下，他也很愉快的答应了，放心的提着枪回了屋，然后顺利的帮我取回了寄错地址的快递。</p><p> <img src="/image/firegun.png" alt=""></p><p>这件事每每想起来始终都感觉背脊发凉，被一把那么大的枪指着，面对一个情绪激动还有点惊慌状的黑人，还能活下来，真是幸运。我也得感谢我当时的冷静，如果我也因为恐惧而变得手忙脚乱的话，估计就真的 GG 了。这件事也给了我一个大大的警醒，在美国可不能随便敲别人的门，尤其是天黑那种敏感时分，不管出于任何的理由。后来，McCallum 小区还真的发生过几起留学生被黑人持枪抢劫，脑袋都被敲破的事件，甚至还发生过非洲过来的留学生半夜出门被枪杀的事情，我在那个小区租住了半年多的时间，算是幸运。</p><p>后来也还遇到过一些意外的场景，比如在加油站加油时，一身邋遢的黑人跑来敲车窗借钱的事，我心情好的话都会给个几美元。虽然我知道借了肯定没法还的，但是也不知道他们是不是有武器，安全起见我都不想去招惹他们。</p><p>总结一些在美国生活时遇到的危险场景，感觉真的是处处都需要很小心，熟悉美国人的处事逻辑和规则非常重要，当然，要想在某些特殊场景下全身而退，除了需要运气，还需要一些机智。</p><p><img src="/image/standinus.jpeg" alt=""></p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Filecoin 介绍</title>
      <link href="/Distributed-System/blockchain-filecoin-introduction/"/>
      <url>/Distributed-System/blockchain-filecoin-introduction/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Filecoin 最终的释放日期虽然还没有定，但是应该也快了，所以这篇文章简单介绍一下它，这是一个我认为未来非常有前途的区块链公链项目。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>了解过 IPFS 的朋友肯定知道，这个项目是有野心想要颠覆 HTTP 模式的，暂且不说它最终能达到什么程度，但在我看来，绝对是一次大胆又有创造性的想法。</p><p>作为在存储方向写过几行代码的我来说，天然的对这个东西是极度感兴趣的，也有幸的是过去的很长一段时间我也在这个方向做着事情。IPFS 大胆的提出了在网络中进行分件高效分发和存储的实践，大量基于 IPFS 的应用也在到处开花。但是它有个缺陷，那就是缺乏一个有效的数据交易市场，有价值的数据如果缺乏一个有效的交易市场的就容易变成价值孤岛，Filecoin 也就应运而生了。它对 IPFS 提供了一个很好的补充，那就是激励机制，这个机制简单来理解就是类似于比特币那样的挖矿可以获得比特币奖励的机制，Filecoin 想要构建一个全局的 DSN （Data Storage Network）系统，创造一个整合了所有可用存储提供商（ storage provider ）的云存储市场，这些存储提供商通过达成某种共识协议来维持整个网络的运作，这种方式的合作可以有效的降低存储的价格，同时，数据也变得更加安全。</p><p>当然，要构建这样的 DSN 所需的挑战是巨大的，必须要满足：</p><p>1）有一个市场能够撮合存储交易<br>2）有一种机制使得网络参与者可以在哪种交易是允许的达成一致<br>3）有一种可靠的方式加密数据<br>4）有一种方式让客户相信他们的数据确实按要求保存了多个备份。<br>5）对存储提供商的服务记录有一个公开的共识，即使那个存储提供商在网络中是匿名的。</p><h3 id="Filecoin-主要提供了下面两大解决方案"><a href="#Filecoin-主要提供了下面两大解决方案" class="headerlink" title="Filecoin 主要提供了下面两大解决方案"></a>Filecoin 主要提供了下面两大解决方案</h3><h4 id="1、提出了-POS-和-POSt-两种共识算法"><a href="#1、提出了-POS-和-POSt-两种共识算法" class="headerlink" title="1、提出了 POS 和 POSt 两种共识算法"></a>1、提出了 POS 和 POSt 两种共识算法</h4><p>注意，这里的 POS 是指 Proof of Storage（而不是区块链技术中广义的 Proof of Stake 权益证明）。而 POSt 全称是 Proof of Spacetime，时空证明。</p><p>简单来说，Filecoin 提供了一个区块链账本用于记录数据存储的所有交易信息。</p><p>对于不明原理的用户来说，肯定会想知道为什么 Filecoin 可以提供比传统的直接销售存储空间更好的分布式存储解决方案。</p><p>简单来说，使用 Blockchain 的技术来做分布式存储有一个重大优势就是：Storage Provider 可以通过检查由其他 providers 历史提交的 proofs 来判断数据是否被完好的保存。</p><p>同时，一旦出现 provider instance 失败，网络也可以做出响应（移除 provider 或者 reallocating data），同时对 Provider 做出惩罚。而这些是传统的数据中介服务商（data brokage service）是做不到的。</p><p>至于共识算法方面，BTC 和 ETH 都浪费了大量的算力在毫无意义的挖矿计算上。而 Filecoin 则基于 Storage Provider 单位时间提供给网络的空间来决定他们的投票权，这种机制就叫 PoSt，Proof Of Spacetime。</p><p>这种设计也把 Filecoin 与它的直接竞争者区分开来，比如 Sia 是基于 POW 的，而 Storj 和 MaidSafe 使用的共识算法类似，他们也是基于 Proof of Storage 的，分别是 Proofs-of-Retrievability 和 Proofs-of-Resources。</p><p>由于物理保存的资源（数据）用来完成一个 PoSt 就是实际的数据，也就是说， PoSt 可以很简单的由这个数据得来，因此，无需额外的电力和计算消耗，美妙！</p><p>实际上， PoSt 是由一系列 Proof of Replication（PoReps）推算得来。因为存储了所要求的数据的 replicas 的 Provider 需要向客户出示证明（ Proofs），方式就是通过解决 Client 提出的密码学问题（Cryptographic Problems），这根比特币的挖矿形式上是一样的，不同之处在于，这个密码学问题是基于数据文件（sealed version of data）的，而作为存储提供商，必须在其实际保存了客户的全部文件副本的情况下才能解决该问题，因为只有 Provider 可以轻易访问这些数据 。当他们提出证明时，可以很容易的被其他节点验证，而这些节点无需存有数据。当然，除此之外，PoReps 被设计成可以防止存储提供商提供假数据证明来获得不当利益（undue rewards）。</p><h4 id="2、提供了一个挂单市场（BID-ASK-Market）"><a href="#2、提供了一个挂单市场（BID-ASK-Market）" class="headerlink" title="2、提供了一个挂单市场（BID-ASK Market）"></a>2、提供了一个挂单市场（BID-ASK Market）</h4><p>这是 Filecoin 另一个重要的方面，也就是数据的存储和检索市场，简单来说，就是数据的卖方和买房交易市场。</p><p>这个市场包含了 client bids，provider asks 以及后续的 BID-ASK 匹配算法，这些信息都会计入区块链账本（blockchain ledger）。</p><p>默认的 BID-ASK 结构最终得到一个双方认可的协议，这些协议是由如下来定义的：</p><p>1）一些周期性的 payments to providers 用来换取 PoReps<br>2）一定数量的 collateral，由 providers 提交</p><p>除了默认的由网络自动驱动的匹配策略（matching scheme） 和数据协议，filecoin 还提供 smart contract 功能，复杂的文件合约以及其他与存储无关的交易。</p><p>说了这么多 Filecoin 的原理和优势，下面来说一下它潜在的缺陷和可能致命的问题。</p><h4 id="Collateral-抵押金机制的风险"><a href="#Collateral-抵押金机制的风险" class="headerlink" title="Collateral 抵押金机制的风险"></a>Collateral 抵押金机制的风险</h4><p>Filecoin 在面对代币价格的（重大）波动会导致不可避免的存储合约违约风险。</p><p>因为我们知道，Filecoin 存储网络中，客户与存储提供商是基于交易市场中的合约的，在一个基本的存储合约中，一个重要的部分就是存储提供商需要提交一笔抵押金 Collateral。当 Filecoin 价格出现剧烈下滑时（比如华尔街砸盘），这笔 Collateral 的价值就会迅速下降，简单来说，这时候它对于存储提供商来说可能变得价值小到可以放弃了。这样的话，存储提供商就失去了继续保管用户数据的动机，他完全可以选择放弃这笔价值大幅下跌的 Collertal，而不去保存客户数据，也就是说，一旦 Filecoin 价格剧烈下跌，那么随之而来的就是大量的合约违约，整个市场就是非常混乱。</p><p>当然，这个风险并不是只有 Filecoin 才会遇到，其他类似的竞争者也会遇到，有些就提出了一些解决方案，比如 Storj，它提出了使用其他数字资产（BTC，ETH 等）或者其他可以用数字货币计价的法币（Fiat currencies）来作为支付手段。又比如，Sia 就提出了把 Siacoin 价格锚住 BTC 的想法，这些想法虽然不错，但是目前来看，还只是设想阶段，具体实施可能还会面临各种困难。</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Customizing Your Emmet Settings</title>
      <link href="/Sublime-Text/sublime-emmet-settings/"/>
      <url>/Sublime-Text/sublime-emmet-settings/</url>
      
        <content type="html"><![CDATA[<p>中文标题：Emmet 中修改和添加自定义的快捷代码段（Snippet）</p><p>Emmet 提供了许多自定义的 snippets，在 snippet.json 文件中可以找到所有。</p><p>如果我们想修改这些内置的 snippets，我们在该文件中修改即可。</p><p>不过，上述直接修改源文件的方法有个缺点，就是污染源文件，而且配置不可迁移（迁移这些设置到新的机器上非常不方便）。</p><p>我们可以通过 Emmet 提供的设置文件（<code>Emmet.sublime-settings</code>）来设置，这样更干净，而且可定制性更高：</p><p><img src="/image/sublime/emmet_in_pref.png" alt=""></p><p>注：如果 Preferences &gt; Package Settings 里面没有出现 Emmet，那么我们可以在 Package Resource Viewer 中进行修改。</p><p><img src="/image/sublime/emmet_settings.gif" alt=""></p><p>修改方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;variables&quot;: &#123;</span><br><span class="line">        &quot;lang&quot;: &quot;en&quot;,</span><br><span class="line">        &quot;charset&quot;: &quot;UTF-8&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    // Custom snippets definitions, as per https://github.com/emmetio/emmet/blob/master/snippets.json</span><br><span class="line">    &quot;snippets&quot;: &#123;</span><br><span class="line">        &quot;html&quot;: &#123;</span><br><span class="line">            &quot;snippets&quot;:&#123;</span><br><span class="line">                &quot;myviewport&quot;: &quot;\n&lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width, initial-scale=1.0\&quot;&gt;\n&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;abbreviations&quot;: &#123;</span><br><span class="line">                &quot;example&quot;: &quot;&lt;div class=&apos;example&apos; title=&apos;Custom element example&apos;&gt;&quot;,</span><br><span class="line">                &quot;mydoc&quot;: &quot;html&gt;(head&gt;meta[charset=&apos;utf-8&apos;]+title&#123;$&#123;1:文档标题&#125;&#125;)+body&quot;,</span><br><span class="line">                &quot;!!&quot;: &quot;!!!+mydoc[lang=&apos;zh-Hans&apos;]&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;css&quot;: &#123;</span><br><span class="line">            &quot;snippets&quot;: &#123;</span><br><span class="line">                &quot;@i&quot;: &quot;@import url(|);&quot;,</span><br><span class="line">                 &quot;pos&quot;: &quot;position:$&#123;1:relative&#125;;&quot;,</span><br><span class="line">                 &quot;pos:a&quot;: &quot;position:absolute;&quot;,</span><br><span class="line">                 &quot;d:b&quot;: &quot;display:block;&quot;,</span><br><span class="line">                 &quot;pt&quot;: &quot;padding-top:|;&quot;,</span><br><span class="line">                 &quot;c&quot;: &quot;color:#$&#123;1:000&#125;;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：<br>最外层 variables 定义全局变量，可通过 ${} 来引用。<br>根元素 snippets 下的 html, css 是指文件类型，<br>内层的 snippets {} 和 abbreviations {} 本质上都是定义了一段代码块，<br>abbreviations 就是缩写的意思，snippets 可以被 abbreviations {} 中直接引用。<br>并且，abbreviations {} 中的各项也可互相引用，比如：</p><p><img src="/image/sublime/snippets_var.png" alt=""></p><p>全文完！</p>]]></content>
      
      
      <categories>
          
          <category> Sublime Text </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Custom Your Auto Completion in Sublime Text 3</title>
      <link href="/Sublime-Text/sublime-auto-completion/"/>
      <url>/Sublime-Text/sublime-auto-completion/</url>
      
        <content type="html"><![CDATA[<p>打开：Preferences -&gt; Browse Packages</p><p>Mac 系统<br>在 Packages/JavaScript Completions 目录中找到 </p><p>Auto Completion 是在我们输入某个 word 或者 word 的一部分，然后直接按 Tab 就可以自动补全整个 word，或者补全一大段 snippet 的功能。<br>这个自动补全会自动判断我们在什么输入环境，这个输入环境是指，我们打开的文档是何种类型，比如<br>当我们打开的当前文档时 .cpp 类型的，那么我们输入 for + Tab 时，就会自动补全如下内容：</p><p><img src="/image/sublime/cpp_for.gif" alt=""></p><p>而在 .js 文件中，输入 for + Tab 时，则会自动补全如下内容：</p><p><img src="/image/sublime/js_for.gif" alt=""></p><p>Sublime Text 内置了各编程语言的 Auto Completion 相关的 snippet 及语法规则，如果我们想自定义，那么可以通过 Package Resource View -&gt; Open Source 的方式来编辑。</p><p>Sublime Text 3 中打开 Package Resource Viewer 的方法是：<br>按住 Shift + Command + P，输入 Package Resource Viewer，或者直接简写 prv 即可弹出对应的框，如下：</p><p><img src="/image/sublime/prvo.gif" alt=""></p><p>现在我们来看一下 .html 文件的自动补全和语法识别，并且根据需要自定义成我们需要的样式。<br>我们先试一下 Sublime Text 3 内置的自动补全：</p><p><img src="/image/sublime/scritptag.gif" alt=""></p><p>可以看到，输入 &lt;script + Tab 之后，自动补全了 type=”” 属性。<br>由于现在 ES6 并不推荐这个写法，所以我们希望自动补全的时候不要添加这个 type 属性，那该怎么办？<br>方法就是通过上面介绍的 Package Resource Viewer 来修改。</p><p><img src="/image/sublime/html_completion.gif" alt=""></p><p>可以看到，我们通过 <strong>prvo</strong> 找到 html_completion.py 这个文件，然后修改其中的 default_list 变量，<br>如下：</p><p><img src="/image/sublime/text_javascript.png" alt=""></p><p>把上述红色背景中的 <code>type=\&quot;${1:text/javescript}\&quot;</code>去掉即可。</p><p>修改其他 tag 的自动补全也是同样的方法。</p>]]></content>
      
      
      <categories>
          
          <category> Sublime Text </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言中使用 Future/Promise 编程模式</title>
      <link href="/Programming/go-go-future-promise/"/>
      <url>/Programming/go-go-future-promise/</url>
      
        <content type="html"><![CDATA[<p>现如今，应用执行时最普遍存在的瓶颈就是网络请求了。网络请求只要几毫秒，但是等到返回却要百倍的时间。所以，如果你执行多个网络请求，让他们都并行执行就是减少延迟最好的选择了。<a href="https://en.wikipedia.org/wiki/Futures_and_promises" target="_blank" rel="noopener">Future/Promise</a> 就是实现这一目的的手段之一。</p><p>一个 Future 就是说“将来”你需要某些东西（一般就是一个网络请求的结果），但是你现在就要发起这样的请求，并且这个请求会异步执行。或者换一个说法，你需要在后台执行一个异步请求。</p><p>Future/Promise 模式在多种语言都有对应的实现。最典型的 C++11 标准库中就提供了 future/promise，另外，再比如 ES2015 就有 Promise 和 async-await，Scala 也内置了 Future。</p><p>最后，虽然 Go 语言没有提供 future/promise 原语，但是我们可以使用 goroutine 和 channel 来实现类似的功能。下面给出一个简单的实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestFuture, http request promise.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RequestFuture</span><span class="params">(url <span class="keyword">string</span>)</span> &lt;-<span class="title">chan</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">byte</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> body []<span class="keyword">byte</span></span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            c &lt;- body</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        res, err := http.Get(url)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line"></span><br><span class="line">        body, _ = ioutil.ReadAll(res.Body)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    future := RequestFuture(<span class="string">"https://api.github.com/users/octocat/orgs"</span>)</span><br><span class="line">    body := &lt;-future</span><br><span class="line">    log.Printf(<span class="string">"reponse length: %d"</span>, <span class="built_in">len</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RequestFuture</code> 方法立刻返回一个channel，这个时候 http 请求还在一个 goroutine 后台异步运行。main 方法可以继续执行其他的代码，比如触发其他的 Future 等。当需要结果的时候，我们需要从 channel 里读取结果。如果 http 请求还没有返回的话就会阻塞当前的 goroutine，直到结果返回。</p><p>然而，以上的方法还有一点局限。错误无法返回。在上面的例子里，如果 http 请求出现错误的话，body 的值会是 nil/empty。但是，由于 channel 只能返回一个值，你需要创建一个单独的 struct 来包装两个返回的结果。</p><p>修改以后的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestFutureV2 return value and error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RequestFutureV2</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body []<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> res *http.Response</span><br><span class="line">        res, err = http.Get(url)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">        body, err = ioutil.ReadAll(res.Body)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">        &lt;-c</span><br><span class="line">        <span class="keyword">return</span> body, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法返回了两个结果，解决了第一个方法的局限性问题。使用的时候是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    futureV2 := RequestFutureV2(<span class="string">"https://api.github.com/users/octocat/orgs"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not block</span></span><br><span class="line">    log.Printf(<span class="string">"V2 is this locked again"</span>)</span><br><span class="line"></span><br><span class="line">    bodyV2, err := futureV2() <span class="comment">// block</span></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">"V2 response length %d\n"</span>, <span class="built_in">len</span>(bodyV2))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">"V2 error is %v\n"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的修改带来的好处就是 <code>futureV2()</code> 方法的调用可以是多次的。并且都可以返回同样的结果。</p><p>但是，如果你想用这个方法实现很多不同的异步功能，你需要写很多的额外的代码。我们可以写一个util 方法来克服这个困难。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Future boilerplate method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Future</span><span class="params">(f <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="title">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">        result, err = f()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">        &lt;-c</span><br><span class="line">        <span class="keyword">return</span> result, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>Future</code> 方法的时候会执行房里的很多 channel 方面的小技巧。为了能够达到通用的目的，这里可以使用一个从 <code>[]byte</code>-&gt;<code>interface{}</code>-&gt;<code>[]byte</code> 的类型转换。如果出现错的话会引发一个运行时的 panic。</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Convert int to []byte in Go</title>
      <link href="/Programming/go-convert-to-byte/"/>
      <url>/Programming/go-convert-to-byte/</url>
      
        <content type="html"><![CDATA[<p>在对 Go 语言中的数据进行加密解密的时候会需要把一些常用的数据类型转换成 []byte，因为 Go 提供的加解密函数接受的是 []byte 类型的输入。<br>本文探讨如何把常用的基本数据类型转换成 []byte，由于 string 类型的变量天然可以通过 []byte 强制转换，剩下的需要额外步骤来转换的基本数据类型主要就是数字类型了，比如 int, int32, uint64 等等。</p><p>把一个 int 类型的数据转换成 []byte 主要有下面几种：</p><p><strong>1. Use binary.Write() to convert a numeric value to []byte</strong></p><p>通过 Go 标准库提供的 binary 包，我们可以把指定大小的数字类型数据转换成 []byte，可参考如下例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var num uint16 = 1234</span></span><br><span class="line"><span class="comment">// binary.Write() does not accept int, it only accepts a numeric type with specific size, e.g. int32, float64, etc.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testBinaryWrite</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    <span class="comment">// for int32, the resulting size of buf will be 4 bytes </span></span><br><span class="line">    <span class="comment">// for int64, the resulting size of buf will be 8 bytes</span></span><br><span class="line">    err := binary.Write(buf, binary.BigEndian, x)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"binary.Write failed:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"% x\n"</span>, buf.Bytes())</span><br><span class="line">    <span class="keyword">return</span> buf.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. Convert to string first, then convert the resulting string to []byte</strong></p><p>主要思路是：先把 int 转换成 string，然后再把 string 转换成 []byte。<br>从数字类型转换成 string 类型相关的函数有： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatBool</span><span class="params">(b <span class="keyword">bool</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="keyword">float64</span>, fmt <span class="keyword">byte</span>, prec, bitSize <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="keyword">int64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">FormatUint</span><span class="params">(i <span class="keyword">uint64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>还可以使用下面的函数，它们可以把任意类型转换成 string。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprint</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>提示：推荐是用 FormatXXX 函数而不是 Sprintf 函数来进行转换，因为后者的效率比较低。</p><p>测试例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testStrconv</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    v, ok := x.(<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"x is not int"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">byte</span>(strconv.Itoa(v))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. Use fmt.Fprint() to convert anything to []byte</strong></p><p>函数原型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprint</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>测试例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fmt.PrintF 的默认写入格式是按照 ASCII 字符来写入。</span></span><br><span class="line"><span class="comment">// 比如，如果一个 int 类型的变量 a = 12345，fmt.PrintF 会把 12345 看做是 5 个 ASCII 字符（每个 ASCII 字符是一个 byte 大小）</span></span><br><span class="line"><span class="comment">// 因此，转换的结果就是对应的 ASCII 编码所表示的一串 byte [49 50 51 52 53]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testPrintFWrite</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    cnt, _ := fmt.Fprint(buf, x)</span><br><span class="line">    fmt.Println(<span class="string">"byte counts: "</span>, cnt)</span><br><span class="line">    <span class="keyword">return</span> buf.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hex to string</p><p>加解密程序中，如获取 md5 值等可能会经常需要用到把十六进制数（[]byte）转换成 string。<br>通常有两种方法：<code>fmt.Sprintf</code> 和 <code>hex.EncodeToString</code>。下面通过一个程序来比较一下两者的性能差别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/md5"</span></span><br><span class="line">    <span class="string">"encoding/hex"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LOOP = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeMd5</span><span class="params">(data <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    h := md5.New()</span><br><span class="line">    io.WriteString(h, data)</span><br><span class="line">    <span class="keyword">return</span> h.Sum(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"123456"</span></span><br><span class="line">    hexBytes := makeMd5(s)</span><br><span class="line">    s1 := fmt.Sprintf(<span class="string">"%x"</span>, hexBytes)</span><br><span class="line">    s2 := hex.EncodeToString(hexBytes)</span><br><span class="line">    fmt.Println(<span class="string">"result of fmt.Sprintf == hex.EncodeToString:"</span>, s1 == s2) <span class="comment">// 确保结果一致</span></span><br><span class="line"></span><br><span class="line">    start := time.Now()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; LOOP; i++ &#123;</span><br><span class="line">        fmt.Sprintf(<span class="string">"%x"</span>, hexBytes)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"fmt.Sprintf taken: %v\n"</span>, time.Since(start))</span><br><span class="line"></span><br><span class="line">    start = time.Now()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; LOOP; i++ &#123;</span><br><span class="line">        hex.EncodeToString(hexBytes)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"hex.EncodeToString taken: %v\n"</span>, time.Since(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>result of fmt.Sprintf == hex.EncodeToString: true<br>fmt.Sprintf taken: 10.285488ms<br>hex.EncodeToString taken: 2.080457ms</p></blockquote><p>可见，<code>fmt.Sprintf</code> 所需要的时间大约是 <code>hex.EncodeToString</code> 的 5 倍。</p><p>结论：最好避免使用 fmt.Sprintf 来转换数据类型（除非必要或者对性能要求不高）。</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言中的组合设计</title>
      <link href="/Programming/go-go-combination-design/"/>
      <url>/Programming/go-go-combination-design/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在 C++，Java 等面向对象的语言中，继承和重载是整个语言的核心价值，而 Go 语言并非是完全面向对象的语言，不支持对同一个类定义多个同名但不同参数的函数（也即重载 overload)，但是 Go 推崇一种叫做组合的设计理念，通过不同类型的组合能同样达到强大的软件设计能力，使得不同的类之间可以继承并且重写对方的函数签名相同的方法。</p><p>在本文中，将展示如何通过 Go 语言的组合设计方式来达到传统面向对象语言中的继承和覆盖效果。</p><p>我们知道，Go 语言中，struct 结构体类型的变量可以嵌套声明另外一个类型（普通类型或者结构体）做为其成员，这个内嵌的成员，有两种存在方式，一种是实名，另一种则是匿名，如果采用的是实名，那么就是（Go 语言中的组合设计模式），而如果是匿名（只有类型），那么就是继承模式。</p><p>外层结构体对象可以<strong>直接调用内嵌成员所声明的方法，而无需带成员名或类型名</strong>（匿名成员本来就只有类型名，而无成员名），而这种调用方式就像是外层结构体对象在调用自己声明的方法一样。</p><p>当外层结构体声明了一个函数与匿名内嵌成员所声明的函数同名时，再直接调用调用该函数，将会覆盖内嵌成员的同函数，也即是说，这实现了覆盖 override 效果。</p><p>如下，socketClient 用匿名的方式声明了一个 BaseService 成员变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> socketClient <span class="keyword">struct</span> &#123;</span><br><span class="line">    BaseService</span><br><span class="line">    id <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BaseService 内嵌的匿名成员变量，其定义了一个 <code>Start()</code> 方法，如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BaseService <span class="keyword">struct</span> &#123;</span><br><span class="line">    name    <span class="keyword">string</span></span><br><span class="line">    started <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bs *BaseService)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"BaseService Start..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>socketClient 可以直接调用匿名的内嵌成员 BaseService 的 <code>Start()</code> 方法，就像是自己的方法一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cli := &amp;socketClient&#123;id: <span class="number">666</span>&#125;</span><br><span class="line">    cli.BaseService = &amp;BaseService&#123;</span><br><span class="line">        name:    name,</span><br><span class="line">        started: started,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cli.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用上述这个特性，我们就可以实现类似 C++ 中的覆盖功能。因为，一旦 socketClient 自己也定义了一个与匿名成员一样的方法，再直接调用这个方法时，就会调用自己定义的，而不是成员的那个，这样就达到了重写覆盖 override 的效果。</p><p>完整例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BaseService <span class="keyword">struct</span> &#123;</span><br><span class="line">    name    <span class="keyword">string</span></span><br><span class="line">    started <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bs *BaseService)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"BaseService Start..."</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBaseService</span><span class="params">(name <span class="keyword">string</span>, started <span class="keyword">uint32</span>)</span> *<span class="title">BaseService</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;BaseService&#123;</span><br><span class="line">        name:    name,</span><br><span class="line">        started: started,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> socketClient <span class="keyword">struct</span> &#123;</span><br><span class="line">    BaseService</span><br><span class="line">    id <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *socketClient)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"socketClient Start() ..."</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> localClient <span class="keyword">struct</span> &#123;</span><br><span class="line">    BaseService</span><br><span class="line">    id <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(s Service)</span></span> &#123;</span><br><span class="line">    s.Start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cli := &amp;socketClient&#123;id: <span class="number">666</span>&#125;</span><br><span class="line">    cli.BaseService = *NewBaseService(<span class="string">"alex"</span>, <span class="number">1</span>)</span><br><span class="line">    test(cli)</span><br><span class="line"></span><br><span class="line">    cli1 := &amp;localClient&#123;id: <span class="number">888</span>&#125;</span><br><span class="line">    cli1.BaseService = *NewBaseService(<span class="string">"jack"</span>, <span class="number">1</span>)</span><br><span class="line">    test(cli1)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><blockquote><p>BaseService Start…                        # 继承<br>socketClient Start() …                     # 覆盖</p></blockquote><p>在这里，我们的设计还可以更进一步，因为在面向对象语言（C++, Java 等）中，最外层的对外接口通常是基类类型，比如做函数参数。而在 Go 语言中，最外层的通常是 interface{} 类型，而不能是 struct 类型，<br>简单来说就是，我们通常在 interface{} 中声明统一的调用函数，最终的调用都是通过调用子类中对 interface{} 接口所实现的函数，也就是说，我们需要达到的效果应该是根据 interface{} 接口中声明的函数，去调用子类的相应函数，而上述的继承和重写却是锚定基类 BaseService 去做的（基类声明了什么函数，子类也实现同名函数），显然不符合设计的要求。</p><p>因此，我们需要进一步改进.</p><p>因为 Service 接口的使用让我们看到了类似多态的效果，<br>我们可以把 Service 接口的声明看做是纯虚函数，而 BaseService 作为基类，但是我们在这个基类中声明一个 Service 类型的成员，由其子类去实现。<br>同时，BaseService 自身也有一个对 Service 接口的实现，在这个实现的内部，调用子类实现的相关函数！<br>比如 Service 接口声明了一个 Start() 函数，那么，BaseService 实现的 Start() 函数中，调用其子类实现的 Start() 函数。</p><p>这样的好处是，最终的子类，比如 xxxService 可以用虚基类 Service 中声明的统一的方法去调用。<br>而最终的子类的所有方法都会在 BaseService 中的方法内部被调用，也就是说，子类不需要实现任何 BaseService 中同名的方法，就可以达到重写目的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start() (<span class="keyword">bool</span>, error)</span><br><span class="line">    OnStart() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BaseService <span class="keyword">struct</span> &#123;</span><br><span class="line">    name    <span class="keyword">string</span></span><br><span class="line">    started <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">    impl Service</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bs *BaseService)</span> <span class="title">Start</span><span class="params">()</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">    bs.impl.OnStart()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bs *BaseService)</span> <span class="title">OnStart</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eventSwitch <span class="keyword">struct</span> &#123;</span><br><span class="line">    BaseService</span><br><span class="line">    message <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(evsw *eventSwitch)</span> <span class="title">OnStart</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    evsw.BaseService.OnStart()</span><br><span class="line">    message = <span class="string">"evsw message"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    esw := &amp;eventSwitch&#123;&#125;</span><br><span class="line">    esw.BaseService = BaseService&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        impl: esw,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    esw.Start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><p>这里 BaseService 作为基类，其实现了 Service 接口所声明的所有函数。<br>eventSwitch 作为最终的子类，跟最早的设计一样，eventSwitch 只是组合了 BaseService 匿名成员，并没有实现 Service 接口，但是却能够对其调用接口的所声明方法。</p><p>简单来说就是，只要子类组合了 BaseService 作为匿名成员，就可以使用 Service 声明的方法了。</p><h5 id="关键就两点："><a href="#关键就两点：" class="headerlink" title="关键就两点："></a>关键就两点：</h5><p>（1）虽然子类 eventSwitch 没有实现 Service 接口，但是却组合了 BaseService 匿名成员，这个匿名成员实现了 Service 接口所声明的方法，因此 evenSwitch 也就可以作为 Service 类型使用。<br>（2）在 BaseSerivce 中又声明了一个 Service 类型的成员，把 eventSwitch 保留在这个成员中，这样，BaseService 又能够动态调用子类的实现！</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tendermint 介绍</title>
      <link href="/Distributed-System/blockchain-tendermint-intro/"/>
      <url>/Distributed-System/blockchain-tendermint-intro/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Tendermint 是基于 POS 的一种开源区块链共识算法，其对传统的三轮共识过程做了优化，只需要两轮（prevote，precommit）即可达成共识，因其出色的设计得到了广泛的使用。</p><p>本文介绍其简单使用</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>执行如下命令获取源码并安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/tendermint/tendermint/cmd/tendermint</span><br><span class="line">go install ./cmd/...</span><br></pre></td></tr></table></figure><p>上述命令会把二进制 tendermint 安装在 $GOBIN 目录，安装成功之后，执行 <code>tendermint --help</code> 来查看帮助信息。</p><p>如果上述命令没有安装成功，则下载 glide 来进行安装必要的依赖，具体步骤如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/Masterminds/glide</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/tendermint/tendermint</span><br><span class="line">glide install</span><br><span class="line">go install ./cmd/...</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>默认情况下，tendermint 使用 $HOME/.tendermint 目录作为所有节点数据目录，可以修改环境变量 $TMROOT 来改变指向。</p><p>执行步骤是：先初始化，再运行节点<br><strong>(1) tendermint init</strong><br>这一步会创建一个私钥 <code>priv_validator.json</code>，和一个创世文件 <code>genesis.json</code>，这个创世文件包含了公钥。<br><strong>(2) tendermint node</strong><br>这一步是运行节点，启动后会自动连接 ABCI app，ABCI app 的侦听端口是 <code>127.0.0.1:46658</code>。如果 ABCI app 没有启动，那么执行 <code>tendermint node</code> 会提示无法连接，如下：<br><img src="http://upload-images.jianshu.io/upload_images/1452123-9ed8780f19476f9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>注意：</strong> 这里的 ABCI app 就是指 ABCI Server，而不是 ABCI client， tendermint node 相当于 ABCI client。</p><p>tendermint 提供了两个 app server，dummy 和 counter，它们都会侦听 46658 端口（不能同时运行 dummy 和 counter，端口冲突）。<br>先在其他 terminal 运行 dummy，其会侦听 46658 端口。</p><p>启动 dummy 之后，再运行 <code>tendermint node</code>。如果没有安装 dummy 的话，也可以直接在 tendermint 中运行一个进程内的 dummy，这相当于运行了一个单一的 blockchain 节点，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tendermint init</span><br><span class="line">tendermint node --proxy_app=dummy</span><br></pre></td></tr></table></figure><p>记住：这里 dummy 和 counter 名字虽然叫 app，但其相对 tendermint core 而言，是 ABCI Server， 而 <code>tendermint node</code> 则是 ABCI client。</p><p>以下的所有 ABCI App 都是值 ABCI Server。</p><p>ABCI App 被设计成跨语言的一个模块，作为一个独立的进程存在，也就是说，我们可以用任何语言来编写 ABCI app。比如，我们用其他语言编写了一个符合 ABCI 通信接口的  App，我们可以在指定 <code>tendermint node</code> 时通过 –proxy_app 选项来指定连接到该 App ，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tendermint node --proxy_app=/var/run/abci.sock</span><br></pre></td></tr></table></figure><p>执行上述命令之后，tendermint 会启动并连接 proxyApp，如果没有指定 –proxy_app，那么默认会连接到 localhost:46658。<br>注意这里，这里指定了 –proxy_app 的话，会连接该 app 侦听的端口。</p><p>此外，tendermint core 除了主动连接上述 proxy_app 的端口之外，还会侦听两个本地端口，分别是 p2p: 46656 和 rpc: 46657。</p><p>46656 是 core 节点 peer 之间交互的端口<br>46657 是 core 节点侦听 rpc 请求的端口。（实质是 app 通过该端口向 core 发送 RPC 请求）</p><h5 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h5><p>交易通常是由 App 发起的，我们可以通过 curl 命令来模拟发请求给 Tendermint core 的<br> RPC server，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:46657/broadcast_tx_commit?tx=\<span class="string">"abcd\"</span></span><br></pre></td></tr></table></figure><p>RPC server 返回的结果是 json 格式，想要获得好的显示效果，可以下载 <a href="https://jmhodges.github.io/jsonpp/" target="_blank" rel="noopener">jsonpp</a> 来进行 pretty print。</p><p>查看 status</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:46657/status | jsonpp</span><br></pre></td></tr></table></figure><h4 id="Tendermint-Networks"><a href="#Tendermint-Networks" class="headerlink" title="Tendermint Networks"></a>Tendermint Networks</h4><p>Tendermint 网络中节点有两种类型：validator node 和 non-validator node。</p><p>If we want to add more nodes to the network, we have two choices: we can add a new validator node, who will also participate in the consensus by proposing blocks and voting on them, or we can add a new non-validator node, who will not participate directly, but will verify and keep up with the consensus protocol.</p><p>当 tendermint core 收到一个 rpc 交易请求，并完成共识之后，会给 app server 发送请求。</p><h4 id="如何创建一个-Tendermint-App"><a href="#如何创建一个-Tendermint-App" class="headerlink" title="如何创建一个 Tendermint App"></a>如何创建一个 Tendermint App</h4><p>创建能运行在 tendermint core 上的 application 需要符合 ABCI，因为 core 会按照 ABCI 定义好的请求格式向 APP 发送请求，因此 app 必须能正确处理 ABCI 格式的请求。</p><p>因此，我们需要下载安装 ABCI ，步骤如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/tendermint/abci/cmd/...</span><br></pre></td></tr></table></figure><p>abci 提供了两个简单的 app：dummy 和 counter，还提供了一个 abci-cli 工具（用于向 ABCI server 发送 grpc 请求或者普通的 socket 请求）</p><h5 id="ABCI-CLI"><a href="#ABCI-CLI" class="headerlink" title="ABCI-CLI"></a>ABCI-CLI</h5><p>tendermint core 中有一个 proxy 包，它提供 NewABCIClient() 函数用来创建一个 abci client， core 用其连接  App ABCI Server</p><h5 id="ABCI-Server"><a href="#ABCI-Server" class="headerlink" title="ABCI Server"></a>ABCI Server</h5><p>abci/server 目录中定义了两种 server 类型： socket server 和 grpc server。</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tendermint abci</title>
      <link href="/Distributed-System/blockchain-tendermint-abci/"/>
      <url>/Distributed-System/blockchain-tendermint-abci/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>ABCI 是 Tendermint 中定义的一套 Core 和 App 交互的接口，它把共识引擎和应用层的逻辑进行解绑，可以帮助实现基于同一引擎上的高度定制化的 App 应用程序。</p><p>由于这种出色的架构设计把共识引擎独立出来，因此整个 tendermint  可以作为许多开源项目中一个可替代的底层共识机制来运作，大大的增加了其应用场景。</p><p>本文主要介绍 ABCI 的设计，以及 tendermint core 与 之的关系</p><p>下面是一段官方简介</p><p>Tendermint Core would be responsible for</p><ul><li>Sharing blocks and transactions between nodes</li><li>Establishing a canonical/immutable order of transactions (the blockchain)</li></ul><p>The application will be responsible for</p><ul><li>Maintaining the UTXO database</li><li>Validating cryptographic signatures of transactions</li><li>Preventing transactions from spending non-existent transactions</li><li>Allowing clients to query the UTXO database.</li></ul><p>翻译成中文就是</p><p>Core 所做的事</p><ul><li>节点之间共享 blocks 和 transactions 信息</li><li>建立不可更改的交易顺序</li></ul><p>Application 所做的事</p><ul><li>维护 UTXO database</li><li>验证签名的有效性</li><li>验证交易的合法性</li><li>运行 client 去查询 UTXO database</li></ul><h4 id="总结来说"><a href="#总结来说" class="headerlink" title="总结来说"></a>总结来说</h4><p>Core 是共识引擎，负责进行交易的共识<br>Application 则是状态机，记录交易开始的状态和最终 Commit 的状态</p><p>App 发出一笔交易，把状态（交易）信息发给共识引擎，共识引擎完成共识过程之后，把共识结果发回给 App，由 App 最终写入持久化。</p><h3 id="ABCI-主要以下几个要点："><a href="#ABCI-主要以下几个要点：" class="headerlink" title="ABCI 主要以下几个要点："></a>ABCI 主要以下几个要点：</h3><p>（1） 消息协议 （message protocol）</p><ul><li>protobuf,</li><li>consensus makes requests, application responds</li></ul><p>（2）Server/Client</p><ul><li>consensus engine runs client</li><li>application runs server</li><li>two implementations: async raw bytes, grpc</li></ul><p>（3） Blockchain protocol</p><p>Tendermint Core 主要维护 3 类连接：</p><ul><li>mempool connection: CheckTx</li><li>consensus connnections: 只有 commited 的 transactions 才会被 executed。</li><li>query connections: only uses Query and Info</li></ul><p><strong>Note:</strong> The mempool and consensus logic act as clients, and each maintains an open ABCI connection with the application, which hosts an ABCI server.</p><h6 id="ABCI-Server"><a href="#ABCI-Server" class="headerlink" title="ABCI Server"></a>ABCI Server</h6><p>要在不同的语言中使用 ABCI，这个语言必须要实现一个 ABCI server。</p><p>简单来说，需要实现：</p><ul><li>a socket server</li><li>a handler for ABCI Messages</li></ul><p>具体如下：</p><p>####（1）ABCI server</p><h5 id="1-Socket-Server"><a href="#1-Socket-Server" class="headerlink" title="1. Socket Server"></a>1. Socket Server</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SocketServer)</span> <span class="title">OnStart</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    s.BaseService.OnStart()</span><br><span class="line">    ln, err := net.Listen(s.proto, s.addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    s.listener = ln</span><br><span class="line">    <span class="keyword">go</span> s.acceptConnectionsRoutine()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：这里我们可以既通过 socket RPC 来实现（效率高），也可以通过 gRPC 来实现（效率低）。</p><ul><li><ol><li>Asynchronous raw byte server (比如 Tendermint Socket Protocol，Known as TMSP or Teaspoon)</li></ol></li><li><ol start="2"><li>GRPC</li></ol></li></ul><h5 id="2-ABCI-Server-Implementation"><a href="#2-ABCI-Server-Implementation" class="headerlink" title="2. ABCI Server Implementation"></a>2. ABCI Server Implementation</h5><p>在 ABCI Server 中，源码在 <code>abci/server/</code> 目录下：<br><strong>server/</strong><br>├── grpc_server.go<br>├── server.go<br>└── socket_server.go</p><p>比如，对于普通的 RPC 来说，在 socket_server.go 中的 handleRequest() 函数中，会根据 types.Request 的类型来调用 application 接口中的相关方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pull responses from 'responses' and write them to conn.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SocketServer)</span> <span class="title">handleResponses</span><span class="params">(closeConn <span class="keyword">chan</span> error, responses &lt;-<span class="keyword">chan</span> *types.Response, conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> bufWriter = bufio.NewWriter(conn)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> res = &lt;-responses</span><br><span class="line">        err := types.WriteMessage(res, bufWriter)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            closeConn &lt;- fmt.Errorf(<span class="string">"Error writing message: %v"</span>, err.Error())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> _, ok := res.Value.(*types.Response_Flush); ok &#123;</span><br><span class="line">            err = bufWriter.Flush()</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                closeConn &lt;- fmt.Errorf(<span class="string">"Error flushing write buffer: %v"</span>, err.Error())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SocketServer)</span> <span class="title">handleRequest</span><span class="params">(req *types.Request, responses <span class="keyword">chan</span>&lt;- *types.Response)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> r := req.Value.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> *types.Request_DeliverTx:</span><br><span class="line">        res := s.app.DeliverTx(r.DeliverTx.Tx)</span><br><span class="line">        responses &lt;- types.ToResponseDeliverTx(res.Code, res.Data, res.Log)</span><br><span class="line">    <span class="keyword">case</span> *types.Request_CheckTx:</span><br><span class="line">        res := s.app.CheckTx(r.CheckTx.Tx)</span><br><span class="line">        responses &lt;- types.ToResponseCheckTx(res.Code, res.Data, res.Log)</span><br><span class="line">    <span class="keyword">case</span> *types.Request_Commit:</span><br><span class="line">        res := s.app.Commit()</span><br><span class="line">        responses &lt;- types.ToResponseCommit(res.Code, res.Data, res.Log)</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里 handleRequest 的处理方式是写 channel，而不是直接 response，response 是在 handleResponse() 函数中根据 channel 中获得值进行处理的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pull responses from 'responses' and write them to conn.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SocketServer)</span> <span class="title">handleResponses</span><span class="params">(closeConn <span class="keyword">chan</span> error, responses &lt;-<span class="keyword">chan</span> *types.Response, conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> bufWriter = bufio.NewWriter(conn)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> res = &lt;-responses</span><br><span class="line">        err := types.WriteMessage(res, bufWriter)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            closeConn &lt;- fmt.Errorf(<span class="string">"Error writing message: %v"</span>, err.Error())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> _, ok := res.Value.(*types.Response_Flush); ok &#123;</span><br><span class="line">            err = bufWriter.Flush()</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                closeConn &lt;- fmt.Errorf(<span class="string">"Error flushing write buffer: %v"</span>, err.Error())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####（2）Application </p><h5 id="1-App-Interface"><a href="#1-App-Interface" class="headerlink" title="1. App Interface"></a>1. App Interface</h5><p>作为一个 ABCI server，其必须实现 Application 接口，这个接口的声明在 <code>tpes/application.go</code> 中，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Application <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Info/Query Connection</span></span><br><span class="line">    Info() ResponseInfo                              <span class="comment">// Return application info</span></span><br><span class="line">    SetOption(key <span class="keyword">string</span>, value <span class="keyword">string</span>) (log <span class="keyword">string</span>) <span class="comment">// Set application option</span></span><br><span class="line">    Query(reqQuery RequestQuery) ResponseQuery       <span class="comment">// Query for state</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mempool Connection</span></span><br><span class="line">    CheckTx(tx []<span class="keyword">byte</span>) Result <span class="comment">// Validate a tx for the mempool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Consensus Connection</span></span><br><span class="line">    InitChain(validators []*Validator)       <span class="comment">// Initialize blockchain with validators from TendermintCore</span></span><br><span class="line">    BeginBlock(hash []<span class="keyword">byte</span>, header *Header)  <span class="comment">// Signals the beginning of a block</span></span><br><span class="line">    DeliverTx(tx []<span class="keyword">byte</span>) Result              <span class="comment">// Deliver a tx for full processing</span></span><br><span class="line">    EndBlock(height <span class="keyword">uint64</span>) ResponseEndBlock <span class="comment">// Signals the end of a block, returns changes to the validator set</span></span><br><span class="line">    Commit() Result                          <span class="comment">// Commit the state and return the application Merkle root hash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ABCI Messages 所使用的 消息类型都是通过 Protobuf 协议定义的，在 <code>types/types.proto</code> 文件中声明（包括 Validator，Request, Response 等消息格式）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">enum CodeType &#123;</span><br><span class="line">    OK                    = <span class="number">0</span>;</span><br><span class="line">    InternalError         = <span class="number">1</span>;</span><br><span class="line">    EncodingError         = <span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Request &#123;</span><br><span class="line">    oneof value&#123;</span><br><span class="line">        RequestEcho echo = <span class="number">1</span>;</span><br><span class="line">        RequestFlush flush = <span class="number">2</span>;</span><br><span class="line">        RequestInfo info = <span class="number">3</span>;</span><br><span class="line">        RequestSetOption set_option = <span class="number">4</span>;</span><br><span class="line">        RequestDeliverTx deliver_tx = <span class="number">5</span>;</span><br><span class="line">        RequestCheckTx check_tx = <span class="number">6</span>;</span><br><span class="line">        RequestCommit commit = <span class="number">7</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Response &#123;</span><br><span class="line">    oneof value&#123;</span><br><span class="line">        ResponseException exception = <span class="number">1</span>;</span><br><span class="line">        ResponseEcho echo = <span class="number">2</span>;</span><br><span class="line">        ResponseFlush flush = <span class="number">3</span>;</span><br><span class="line">        ResponseInfo info = <span class="number">4</span>;</span><br><span class="line">        ResponseSetOption set_option = <span class="number">5</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Validator &#123;</span><br><span class="line">    bytes pubKey = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint64</span> power = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-App-Implementation"><a href="#2-App-Implementation" class="headerlink" title="2. App Implementation"></a>2. App Implementation</h5><p>Application 中声明的接口方法，既可以在具体的 application 代码中实现，tendermint 提供了 abci server 的两个简单实现，dummy 和 counter，侦听端口是 46658。<br>dummy 在 abci/example/dummy/dummy.go 中实现，而 counter 则在 abci/example/counter/counter.go 中实现。</p><p>ABCI Message 中最重要的就是 deliver_tx, check_tx, and commit 三类消息。</p><p>tendermint engine 的角色是作为 ABCI Client，因此任何一个 Validator 节点（也即 Tendermint Node）都是作为 ABCI Client，启动 Tendermint Node 之后就可以连接到 ABCI Server 了。</p><p>Tendermint 还提供了一个简易的 ABCI 客户端，即 abci-cli，通过 go get -u github.com/tendermint/abci/cmd/… 获得。<br>这样，就可以通过这个 abci-cli 给 ABCI Server 发消息了。<br>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ abci-cli <span class="built_in">echo</span> hello</span><br><span class="line">$ abci-cli info</span><br></pre></td></tr></table></figure><p><code>abci/abci-cli/abci-cli.go</code> 提供的是 command，而 client 代码的具体实现全部在 <code>abci/client/</code> 目录下<br><strong>client/</strong><br>├── client.go<br>├── grpc_client.go<br>├── local_client.go<br>└── socket_client.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> client == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    client, err = abcicli.NewClient(c.GlobalString(<span class="string">"address"</span>), c.GlobalString(<span class="string">"abci"</span>), <span class="literal">false</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的 client 类型是通过 transport 类型来指定的（默认是 socket）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(addr, transport <span class="keyword">string</span>, mustConnect <span class="keyword">bool</span>)</span> <span class="params">(client Client, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> transport &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"socket"</span>:</span><br><span class="line">        client = NewSocketClient(addr, mustConnect)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"grpc"</span>:</span><br><span class="line">        client = NewGRPCClient(addr, mustConnect)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        err = fmt.Errorf(<span class="string">"Unknown abci transport %s"</span>, transport)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的 transport 类型是 socket</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">app.Flags = []cli.Flag&#123;</span><br><span class="line">    cli.StringFlag&#123;</span><br><span class="line">        Name:  <span class="string">"address"</span>,</span><br><span class="line">        Value: <span class="string">"tcp://127.0.0.1:46658"</span>,</span><br><span class="line">        Usage: <span class="string">"address of application socket"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    cli.StringFlag&#123;</span><br><span class="line">        Name:  <span class="string">"abci"</span>,</span><br><span class="line">        Value: <span class="string">"socket"</span>,</span><br><span class="line">        Usage: <span class="string">"socket or grpc"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    cli.BoolFlag&#123;</span><br><span class="line">        Name:  <span class="string">"verbose"</span>,</span><br><span class="line">        Usage: <span class="string">"print the command and results as if it were a console session"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启动-Server"><a href="#启动-Server" class="headerlink" title="启动 Server"></a>启动 Server</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">srv, _ := server.NewServer(<span class="string">"tcp://0.0.0.0:46658"</span>, <span class="string">"socket"</span>, app)</span><br><span class="line"><span class="keyword">if</span> _, err := srv.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong><br>这里通过调用 <code>server.NewServer()</code> 来创建一个 Server，三个参数分别是，侦听地址，transport 类型（socket/grpc），app 实现。返回类型是 <code>cmn.Service</code>。具体的启动逻辑在 <code>srv.Start()</code> 里面。 SocketServer 内置了 BaseService 结构体成员变量，其实现了 Service 声明的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start() (<span class="keyword">bool</span>, error)</span><br><span class="line">    OnStart() error</span><br><span class="line">    Stop() <span class="keyword">bool</span></span><br><span class="line">    OnStop()</span><br><span class="line">    Reset() (<span class="keyword">bool</span>, error)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，最终是通过调用  OnStart() 来启动的，其过程很简单，简单来说就是调用 <code>net.Listen()</code> 和 <code>go s.acceptConnectionsRoutine()</code> 来启动侦听和接受连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SocketServer)</span> <span class="title">OnStart</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    s.BaseService.OnStart()</span><br><span class="line">    ln, err := net.Listen(s.proto, s.addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    s.listener = ln</span><br><span class="line">    <span class="keyword">go</span> s.acceptConnectionsRoutine()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全文完!</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链新型共识算法：Snowflake to Avalanche</title>
      <link href="/Distributed-System/blockchain-tendermint-consensus/"/>
      <url>/Distributed-System/blockchain-tendermint-consensus/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>分布式一致性算法一般可以分为两类：拜占庭容错和非拜占庭容错。<br>非拜占庭容错算法如 Paxos, Raft 等在当前的分布式系统中已经广泛使用，而拜占庭容错算法的实际应用范围相对来说小很多(特别是在区块链问世之前)。<br>Tendermint 属于拜占庭容错算法，它针对传统的 PBFT 算法做了优化，只需要有两轮投票即可达成共识，目前 Tendermint 算法主要应用在区块链系统中，这篇文章就从原理上来介绍 Tendermint 的共识机制。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>关于 Tendermint 算法的完整描述在<a href="https://github.com/tendermint/tendermint/wiki/Byzantine-Consensus-Algorithm" target="_blank" rel="noopener">这里</a>。</p><p>这里先介绍一下算法的流程，理解了算法流程之后，再来阐述该算法的安全性证明 (Proof of Safty) 和活性证明 (Proof of Liveness)。</p><p>下面这张图是 tendermint 状态转换图</p><p><img src="/image/p2p/tendermint_diagram.png" alt=""></p><p>算法主要有 NewHeigh -&gt; <strong>Propose -&gt; Prevote -&gt; Precommit</strong> -&gt; Commit 一共 5 个状态（阶段）。</p><p>上述每个状态都被称为一个 Step，首尾的 NewHeigh 和 Commit 这两个 Steps 被称为特殊的 Step，而中间加粗体的三个 Steps 则被称为一个 Round，是共识阶段，也是也是算法的核心原理所在。</p><p>需要注意的是，一个块的最终提交（Commit）可能需要多个 Round 过程，这是因为有许多原因可能会导致当前 Round 不成功（比如出块节点 Offline，提出的块是无效块，收到的 Prevote 或者 Precommit 票数不够 +2/3 等等），出现这些情况的话，解决方案就是移步到下一轮，或者增加 timeout 时间）。</p><p>这里，还要介绍一个重要概念：PoLC，全称为 Proof of Lock Change，表示在某个特定的高度和轮数(height, round)，对某个块或 nil (空块)超过总结点 2/3 的 Prevote 投票集合，简单来说 PoLC 就是 Prevote 的投票集。</p><p>Tendermint 中有两种类型的节点，Validator 节点和 Non-Validator 节点，顾名思义，只有 Validator 节点会参与共识投票，而普通节点作为 Non-Validator 节点，不参与共识投票，只协助传递状态或向 Validator 节点发送交易请求。</p><p>初始状态下（创世块），高度为 0， 此时，系统会基于 Round Robin 原则来选出一个 Validator（每个 Validator 都有一定的 Voting Power），由这个 Validator 打包一个新的 Block， 并向所有节点发出 Proposal，剩余的 Validator 节点对该 Proposal 进行投票，最终达成共识。</p><p>以下，分阶段来阐述各个阶段:</p><h5 id="1-NewHeight"><a href="#1-NewHeight" class="headerlink" title="1. NewHeight"></a>1. NewHeight</h5><p>当上一轮 Commit 结束，就会出现新高度，这是就需要进入下一轮共识了，也就是说，这就是新一轮共识过程的开始，这时候需要选出一个 Proposer。选择算法是 Round Robin，基于他们的 Voting Power（上一轮的选中的 Validator 节点会把其 Voting Power 值减去 Total Voting Power，也就是说上一轮的 Validator 在这一轮，其 Voting Power 会变成负数）。</p><h5 id="2-Propose"><a href="#2-Propose" class="headerlink" title="2. Propose"></a>2. Propose</h5><p>在 Propose 节点开始的时候，该轮指定的 proposer 需要通过 gossip 广播一条 proposal 到所有的 peers。如果此时这个 proposer 被锁在上一轮的某个 block 上，那么它就直接 propose 那个 block，同时包含一条 proof of lock 的信息。</p><h5 id="3-Prevote"><a href="#3-Prevote" class="headerlink" title="3. Prevote"></a>3. Prevote</h5><p>Validator 节点收到 propose 信息之后就进入 Prevote 投票阶段。投票时，如果 Validator 被锁在之前一个 block 上，那么还是给之前那个 block 投 prevote 票，否则就投当前的 block。同时，它会继续收集对这个 block 的 prevote 投票，等轮到他 propose 的时候打包进 PoLC。</p><p>注意：<br>如果自己有 Lock-Block，这时又收到一个新的针对另外一个块的 PoLC，并且满足LastLockRound &lt; PoLC-Round &lt; 当前 Round，则解锁 Lock-Block。</p><p>如果 timeout 期间没收到 proposal，或则收到的 proposal 是无效的，那么就投 nil 票。<br>在 Prevote 阶段不会锁住任何 block。</p><h5 id="4-Precommit"><a href="#4-Precommit" class="headerlink" title="4. Precommit"></a>4. Precommit</h5><p>Prevote 超时或则收到的 Prevote 或 nil 票超过 2/3 时，就进入 Precommit 阶段。<br>如果此时收到了 +2/3 的 prevote 投票，就广播一条 precommit 投票，同时，<strong>把自己锁在当前的 block 上（把之前的都释放掉）</strong>。一个节点一次只能锁在一个块上。<br>如果收到 +2/3 的 nil 投票，那么就释放锁。</p><p><strong>当一个节点锁在一个 block 上的时候（有 PoLC）</strong>，它会将 <strong>LastLockRound</strong> 置为当前 Round，并对这个块投 Precommit 票。</p><p>如果有针对 nil 票的 PoLC，则解锁并且对 nil 投 Precommit 票；否则的话保持 Lock-Block 不变，并投 nil 。</p><p>如果在 timeout 期间内，没有收到对某个块的足够的 +2/3 投票（prevote 或者 nil 都行），那么就什么也不干。</p><p>最终，如果一个节点收到了 +2/3 的 precommit 投票，就进入 Commit 阶段。否则，继续进入下一轮的 Propose 阶段。</p><h5 id="5-Commit"><a href="#5-Commit" class="headerlink" title="5. Commit"></a>5. Commit</h5><p>Commit 阶段是一个特殊阶段，有两个并行的条件必须满足：</p><ol><li>节点必须收到该 block</li><li>节点必须等待，直到收到 2/3 的 节点 commit 信息。</li></ol><p>At any time during the consensus process if a node receives more than 2/3 of commits for a particular block, it immediately enters the Commit step if it hadn’t already. Thus there are two ways to enter the Commit step. A commit-vote for a block at round R counts as prevotes and precommits for all rounds R0 where R &lt; R0 . Commit-votes are gossipped to neighboring peers in the background re-gardless of the current round or step。</p><p>At any time during the consensus process if a node is locked on a block from round R but receives a proof-of-lock for a round R0 where R &lt; R0 , the node unlocks.</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><h4 id="1-安全性证明"><a href="#1-安全性证明" class="headerlink" title="1. 安全性证明"></a>1. 安全性证明</h4><p>Tendermint 的安全性就是说，在对高度为 H 的块达成共识之后，不可能会出现新的高度为 H 的块，也就是说 Tendermint 保证不会分叉，保证不会分叉的主要角色就是 Lock-Block。</p><p>先看下wiki对于安全性证明的描述：</p><p>Assume that at most -1/3 of the voting power of validators is byzantine. If a validator commits block B at<br>round R, it’s because it saw +2/3 of precommits at round R. This implies that 1/3+ of honest nodes are still<br>locked at round R’ &gt; R. These locked validators will remain locked until they see a PoLC at R’ &gt; R, but this<br>won’t happen because 1/3+ are locked and honest, so at most -2/3 are available to vote for anything other<br>than B.</p><p>翻译：</p><p>假定有最多小于总结点 1/3 的拜占庭节点。如果一个节点在第 R 轮提交一个块，则表明此节点在第 R 轮收到大于 2/3 的针对此块的 Precommit 投票。这也就意味有<br>大于1/3 的诚实节点在第 R’ (R’ &gt; R)轮仍然锁定在这个块上(因为大于 2/3 的 Precommit 投票必定包含大于 1/3 诚实节点的 Precommit 投票)。只有当遇到针对另一个<br>块的 PoLC 时才会解锁，但是在 R’ 轮是不可能有针对某个块的 PoLC，因为已经有大于 1/3 的诚实节点已经锁定在这个块上，所以就不可能有对另外一个块大于 2/3<br>的 Prevote 投票。</p><p>下面给出较为详细的证明过程，假设高度为 H 的块 b 在第 R 轮达成共识。给出如下条件：</p><ul><li>x 表示在第 R 轮已经 Commit 的节点，均为诚实节点，x &lt; 1/3。</li><li>y 表示拜占庭节点，可以做任意事情，y &lt; 1/3。</li><li>z 表示剩余节点，z &gt; 1/3，因为已经有 x 个节点 Commit，则肯定有 z0 个节点对 b 投了 precommit 票，z0 &lt; z。</li></ul><p>需要证明，<strong>当 x 个节点 commit 之后，剩余(也就是 y + z)的没有 Commit 块 b 的节点不会对另外一个块达成共识。</strong></p><p>也就是说需要证明：y + z - z0 &lt; 2/3，假设所有的拜占庭节点都对 b 投了 Precommit，则满足：x + y + z0 &gt; 2/3。</p><p>简而言之，要从 x + y + z0 &gt; 2/3 证明 y + z - z0 &lt; 2/3。</p><p>我们通过反证法来证明：<br>假设 y + z - z0 &gt; 2/3，也就是在第 r 轮之后有可能造成分叉，则：<br>x + y + z - z0 &gt; 2/3 + x  =&gt;  1 - z0 &gt; 2/3 + x =&gt; x + z0 &lt; 1/3。</p><p>而上面我们提到了，因为x节点已经 Commit 块 b，则 x + y + z0 &gt; 2/3，且 y &lt; 1/3，则说明 x + z0 必须大于1/3。由此证明，y + z - z0 &lt; 1/3 成立，在第 R 轮之后无法对另一个块达成共识，也就不可能出现分叉。</p><h4 id="活性证明"><a href="#活性证明" class="headerlink" title="活性证明"></a>活性证明</h4><p>活性证明相对来说就要简单一些，假设多于 1/3 的节点分别 Lock 在不同的块上，则在 Prevote 阶段的条件保证最终 round 较小的会 unlock，而且 proposal 的超时时间会随着轮数的提高而提高。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>在证明安全性的过程中提到，有可能会有部分节点由于没有收到足够的 Precommit 投票导致无法 commit，这个时候可以通过同步来使各个节点的状态尽量保持一致，在wiki中提到一个 JSet 和 VSet 的概念，当节点已经 commit 时，就可以广播一条消息携带 VSet 给其他节点，其他节点验证对于块的 commit 是否有效。这一点其实和 bft-raft （另外一个拜占庭容错算法，Raft 算法的变种）的做法类似。</p><br>全文完！<br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 和 C++ 程序通过 protobuf 来进行数据交互</title>
      <link href="/Programming/go-go-cpp-protobuf/"/>
      <url>/Programming/go-go-cpp-protobuf/</url>
      
        <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>这篇文章主要介绍如何使用 Protobuf 来在 Go 语言程序和 C++ 程序之间进行数据交互。<br>这里使用 Go 编写服务端，而用 C++ 编写客户端。</p><h4 id="编写-proto-协议文件"><a href="#编写-proto-协议文件" class="headerlink" title="编写 proto 协议文件"></a>编写 proto 协议文件</h4><p>在开始写客户端和服务端之前，首先需要生成 Go 和 C++ 的 proto 协议文件，只编写一个 proto 文件即可。<br>新建一个名为 <code>msg.proto</code> 的文件，输入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line">package msg;</span><br><span class="line"></span><br><span class="line">message Msg &#123;</span><br><span class="line">    int64 MsgId = 1;</span><br><span class="line">    string MsgInfo = 2;</span><br><span class="line">    string MsgFrom = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译-proto-文件"><a href="#编译-proto-文件" class="headerlink" title="编译 proto 文件"></a>编译 proto 文件</h4><p>执行下列命令分别生成 Go 语言和 C++ 对应的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protoc --cpp_out=. msg.proto</span><br><span class="line">protoc --go_out=. msg.proto</span><br></pre></td></tr></table></figure><h4 id="编写-Go-服务端程序"><a href="#编写-Go-服务端程序" class="headerlink" title="编写 Go 服务端程序"></a>编写 Go 服务端程序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"test/msg"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/google/protobuf/proto"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>)</span><br><span class="line">    n, err := conn.Read(buff)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"read data failed..."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"read len: %d\n"</span>, ReadLen)</span><br><span class="line">    fmt.Println(buff)</span><br><span class="line"></span><br><span class="line">    msgBuf := buf[<span class="number">0</span> : n]</span><br><span class="line">    reciveMsg := &amp;msg.Msg &#123;&#125;</span><br><span class="line"></span><br><span class="line">    err = proto.Unmarshal(msgBuf, reciveMsg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"unmarshaling error: "</span>, reciveMsg)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"msg id: %d\n"</span>, reciveMsg.GetMsgId())</span><br><span class="line">    fmt.Printf(<span class="string">"msg info: %s\n"</span>, reciveMsg.GetMsgInfo())</span><br><span class="line">    fmt.Printf(<span class="string">"msg from id: %s\n"</span>, reciveMsg.GetMsgFrom())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tcpAddr, err := net.ResolveTCPAddr(<span class="string">"tcp4"</span>, <span class="string">":2121"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"get tcp addr failed..."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    listener, err := net.ListenTCP(<span class="string">"tcp"</span>, tcpAddr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"listen tcp failed..."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> handleConn(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写-C-客户端程序"><a href="#编写-C-客户端程序" class="headerlink" title="编写 C++ 客户端程序"></a>编写 C++ 客户端程序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"msg.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sk = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = htons(<span class="number">2121</span>); <span class="comment">// 固定端口port</span></span><br><span class="line">    server.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>); <span class="comment">// 固定ip</span></span><br><span class="line"></span><br><span class="line">    connect(sk, (struct sockaddr*)&amp;server, <span class="keyword">sizeof</span>(server));</span><br><span class="line"></span><br><span class="line">    msg::Msg sendMsg;</span><br><span class="line">    sendMsg.set_msgid(<span class="number">0</span>);</span><br><span class="line">    sendMsg.set_msginfo(<span class="string">"hello protobuf"</span>);</span><br><span class="line">    sendMsg.set_msgfrom(<span class="string">"alex"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> sendData;</span><br><span class="line">    sendMsg.SerializeToString(&amp;sendData);</span><br><span class="line">    <span class="keyword">int</span> len = sendData.length();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"string len:"</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buff = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(buff, sendData.c_str(), len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"buff len:"</span> &lt;&lt; <span class="built_in">strlen</span>(buff) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//向服务段发送数据</span></span><br><span class="line">    <span class="comment">//在发送数据时一定要指明数据长度 防止中间有\0截断c风格字符串</span></span><br><span class="line">    send(sk, buff, len, <span class="number">0</span>);</span><br><span class="line">    close(sk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>先后启动服务端和客户端程序</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>grpc 的安装和使用</title>
      <link href="/Tools-and-Build/tool-and-build-grpc-installation/"/>
      <url>/Tools-and-Build/tool-and-build-grpc-installation/</url>
      
        <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>grpc 是 Google 在 2015 年 2 月底时发布的一款开源 RPC 框架，其源码是由 C 语言编写的。<br>按照 Google 的说法，grpc 是：<strong>A high performance, open source, general RPC framework that puts mobile and HTTP/2 first.</strong><br>简单来说，它是一个高性能，开源，将移动和 HTTP/2 放在首位的通用的 RPC 框架.</p><p>由于它构建于 HTTP/2 标准，因此它有很多优秀的特点，主要如下：</p><ul><li>bidirectional streaming</li><li>flow control</li><li>header compression</li><li>multiplexing requests over a single TCP connection</li></ul><p>这些特性在移动设备上节约电池使用时间和数据使用，加速服务和运行在云上的web应用。</p><h4 id="源码编译及安装"><a href="#源码编译及安装" class="headerlink" title="源码编译及安装"></a>源码编译及安装</h4><p>源码地址：<a href="https://github.com/grpc/grpc" target="_blank" rel="noopener">https://github.com/grpc/grpc</a></p><ol><li>安装依赖</li></ol><ul><li>配置工具：build-essential, autoconf, libtool</li><li>测试支持：libgflags-dev</li><li>编译工具：clang, libc++-dev</li></ul><p>Tip: when building, you may want to explicitly set the LIBTOOL and LIBTOOLIZE environment variables when running make to ensure the version installed by brew is being used:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ LIBTOOL=glibtool LIBTOOLIZE=glibtoolize make</span><br></pre></td></tr></table></figure><p><strong>protoc</strong><br>GRPC 默认使用 protobuf 作为消息格式，为 protoc 是 protobuf 协议的编译器，因此，在构建 GRPC 之前确保 protoc 已经安装。</p><p><strong>注：</strong>gRpc 源码中的 Makefile 文件中会自动检测当前系统是否已经安装了 protoc，如果没有安装，那么就会自动从其项目中的第三方库源码目录中进行安装。</p><ol start="2"><li>编译</li></ol><p>执行下列命令进行编译构建和安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b $(curl -L https://grpc.io/release) https://github.com/grpc/grpc</span><br><span class="line"><span class="built_in">cd</span> grpc</span><br><span class="line">git submodule update --init</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>注意到第一行命令是安装 release 分支中的版本，如果想安装最新的 master HEAD 上的版本，那么直接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/grpc/grpc</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>编译过程中可能会遇到 <code>openssl1.1.0</code> 与 老版本 <code>openssl1.0.1</code>不兼容的问题（grpc 使用的老版本 openssl1.0.1），也就是说，如果本机环境使用的是 openssl1.1.0，那么编译 grpc 时会出现报错，可以去 Google 中搜索解决方案。</p><ol start="3"><li>编译完成后生成的文件</li></ol><p>构建完成之后，想要知道生成了哪些文件，我们可以通过查看 <code>.gitignore</code> 文件来获知。</p><p>打开 <code>.gitignore</code> 文件，可以看到如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> C/C++ build outputs</span></span><br><span class="line">.build/</span><br><span class="line">bins</span><br><span class="line">gens</span><br><span class="line">libs</span><br><span class="line">objs</span><br></pre></td></tr></table></figure><p>根据注释含义可知，编译成功后会在根目录下新建上述目录，不同的目录包含了不同的文件，这里主要来看 libs， bins 这两个目录，<br>bins 目录中包含了所有编译构建后生成二进制程序文件。<br>查看 <code>bins/opt/</code> 会发现，生成了下列二进制程序，它们都是 grpc 对各个语言默认插件的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grpc_cpp_plugin</span><br><span class="line">grpc_csharp_plugin</span><br><span class="line">grpc_node_plugin</span><br><span class="line">grpc_objective_c_plugin</span><br><span class="line">grpc_php_plugin</span><br><span class="line">grpc_python_plugin</span><br><span class="line">grpc_ruby_plugin</span><br></pre></td></tr></table></figure><p>libs 目录中则包含了动态库，静态库等文件。查看 `libs/opt/`` 可以看到以 libgrpc, libgrpc++ 等为前缀的许多静态和动态库文件，这里不一一列举：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">libgpr.a</span><br><span class="line">libgpr.so.4.0.0-dev</span><br><span class="line">libgrpc.a</span><br><span class="line">libgrpc++.a</span><br><span class="line">libgrpc++.so.1.5.0-dev</span><br><span class="line">libgrpc.so.4 -&gt; libgrpc.so.4.0.0-dev</span><br><span class="line">libgrpc.so.4.0.0-dev</span><br><span class="line">pkgconfig/</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="4"><li>安装</li></ol><p>执行 <code>make install</code> 就会自动安装上述编译所生成的库及二进制程序。这一步非常简单，其实质只是把相应的文件拷贝的系统目录而已。<br>想要知道具体会安装哪些文件，查看 Makefile 即可。<br>安装内容相当的复杂，实际上，我们没有必要去了解每个细节，只要知道哪些主要文件会被安装，以及他们会被安装在哪个目录就可以了。</p><p>我在这里对整个安装过程做了一个总结，如下：</p><p>（1）要安装的文件<br>按照文件类型，我把要安装或者说拷贝到系统目录的文件主要有以下几个部分：</p><ul><li><ol><li>grcp 的相关头文件</li></ol></li><li><ol start="2"><li>静态库，动态库</li></ol></li><li><ol start="3"><li>可执行文件 （也即以 _plugin 结尾的各语言的 grpc 插件）</li></ol></li></ul><p>（2） 安装至的目录 （默认 <code>/usr/local</code>）</p><p>如果没有指定安装目录的 prefix，那么默认的 prefix 是 /usr/local。如果想使用其他 prefix 比如 /usr，那么可以编辑 Makefile 文件修改 prefix 变量。<br>或者 make install DISTDIR=/usr/local 。</p><p>It depends on the package. If the Makefile is generated by GNU autotools (./configure) you can usually set the target location like so:<br>./configure –prefix=/usr/local<br>If the Makefile is not generated by autotools, but distributed along with the software, simply open it up in an editor and change it. The install target directory is probably defined in a variable somewhere.</p><p>从上文可知，如果源码包没有提供 configure 配文件，最可靠的办法就是编辑 Makefile 文件来指定 prefix。</p><p>按照不同的类型区别，它们分别将安装在如下目录</p><p>（1）头文件<br>$prefix/include<br>注：源码文件通常会在 $prefix/src 中，但通常没有必要安装源码。</p><p>（2）静态库及动态库 （.a 文件，.so，.so.x.x 文件）<br>对不同语言的支持，会有不同的静态库及动态库文件。<br>$prefix/lib</p><p>（3） plugins，也就是二进制文件<br>$prefix/bin</p><p>（4） pkg-config 文件<br>$prefix/lib/pkg-config</p><p>（5）证书文件 certs<br>$prefix/share/grpc</p><p>比如，根证书文件为：<br>$prefix/share/grpc/roots.pem</p><h4 id="GRPC-实例"><a href="#GRPC-实例" class="headerlink" title="GRPC 实例"></a>GRPC 实例</h4><p>这里编写一个 C++ 使用 GRPC 的实例来试验 GRPC 的使用。</p><p>官方的 grpc 源码中提供了示例，进入 <code>examples/cpp/helloworld</code> 目录，执行 make 来编译所提供的 cpp 例子（<code>greeter_server.cc</code>, <code>greeter_client.cc</code>, etc）：</p><p>可能会出现如下错误提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ g++ helloworld.pb.o helloworld.grpc.pb.o greeter_client.o -L/usr/<span class="built_in">local</span>/lib `pkg-config --libs protobuf grpc++ grpc` -Wl,--no-as-needed -lgrpc++_reflection -Wl,--as-needed -ldl -o greeter_client</span><br><span class="line">Package grpc++ was not found <span class="keyword">in</span> the pkg-config search path.</span><br><span class="line">Perhaps you should add the directory containing `grpc++.pc<span class="string">'</span></span><br><span class="line"><span class="string">to the PKG_CONFIG_PATH environment variable</span></span><br><span class="line"><span class="string">No package '</span>grpc++<span class="string">' found</span></span><br><span class="line"><span class="string">Package grpc was not found in the pkg-config search path.</span></span><br><span class="line"><span class="string">Perhaps you should add the directory containing `grpc.pc'</span></span><br><span class="line">to the PKG_CONFIG_PATH environment variable</span><br><span class="line">No package <span class="string">'grpc'</span> found</span><br><span class="line">/usr/bin/ld: helloworld.pb.o: undefined reference to symbol <span class="string">'_ZN6google8protobuf8internal16RegisterAllTypesEPKNS0_8MetadataEi'</span></span><br><span class="line">/usr/lib/libprotobuf.so.13: error adding symbols: DSO missing from <span class="built_in">command</span> line</span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br><span class="line">make: *** [Makefile:42: greeter_client] Error 1</span><br></pre></td></tr></table></figure><p>根据提示可知，执行 <strong><code>pkg-config --libs protobuf grpc++ grpc</code></strong> 出错了，因为 <code>PKG_CONFIG_PATH</code> 没有设置。</p><p>解决办法很简单，只需按如下设置该变量即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PKG_CONFIG_PATH=<span class="variable">$PKG_CONFIG_PATH</span>:/usr/<span class="built_in">local</span>/lib/pkgconfig</span><br></pre></td></tr></table></figure><p>设置完成之后，执行 <strong><code>pkg-config --libs protobuf grpc++ grpc</code></strong> 就会显示如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-L/usr/local/lib -lprotobuf -pthread -lpthread -lgrpc++ -lgrpc</span><br></pre></td></tr></table></figure><p>现在，在 <code>examples/cpp/helloworld</code> 目录执行 make 就成功了，执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ protoc -I ../../protos --cpp_out=. ../../protos/helloworld.proto</span><br><span class="line">$ g++ -std=c++11 `pkg-config --cflags protobuf grpc`  -c -o helloworld.pb.o helloworld.pb.cc</span><br><span class="line">$ protoc -I ../../protos --grpc_out=. --plugin=protoc-gen-grpc=`<span class="built_in">which</span> grpc_cpp_plugin` ../../protos/helloworld.proto</span><br><span class="line">$ g++ -std=c++11 `pkg-config --cflags protobuf grpc`  -c -o helloworld.grpc.pb.o helloworld.grpc.pb.cc</span><br><span class="line">$ g++ -std=c++11 `pkg-config --cflags protobuf grpc`  -c -o greeter_client.o greeter_client.cc</span><br><span class="line">$ g++ helloworld.pb.o helloworld.grpc.pb.o greeter_client.o -L/usr/<span class="built_in">local</span>/lib `pkg-config --libs protobuf grpc++ grpc` -Wl,--no-as-needed -lgrpc++_reflection -Wl,--as-needed -ldl -o greeter_client</span><br><span class="line">$ g++ -std=c++11 `pkg-config --cflags protobuf grpc`  -c -o greeter_server.o greeter_server.cc</span><br><span class="line">$ g++ helloworld.pb.o helloworld.grpc.pb.o greeter_server.o -L/usr/<span class="built_in">local</span>/lib `pkg-config --libs protobuf grpc++ grpc` -Wl,--no-as-needed -lgrpc++_reflection -Wl,--as-needed -ldl -o greeter_server</span><br></pre></td></tr></table></figure><p>Makefile 中指定了，先执行 protoc 生成 <code>--cpp_out</code> 和 <code>--grpc_out</code> 两类文件，均是 cpp 头文件，它们是：<code>helloworld.pb.h</code> 和 <code>helloworld.grpc.pb.h</code><br>实际上，helloworld.pb.h 是定义 protobuf Message 类型相关的代码，而 <code>helloworld.grpc.pb.h</code> 头文件是定义 grpc Service 相关的代码</p><p><strong>需要注意的是：</strong>在 cpp 中，这两部分内容是分开放在两个头文件中的，而用 grpc-go 生成的 Message 和 Service 代码则是在同一个 go 文件中。</p><p>编译好 <code>greeter_client</code>, <code>greeter_server</code> 等可执行程序之后，执行 <code>./greeter_client</code>，会出现如下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./greeter_client</span><br><span class="line">./greeter_client: error <span class="keyword">while</span> loading shared libraries: libgrpc++.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">./greeter_client: error <span class="keyword">while</span> loading shared libraries: libgrpc++_reflection.so.1: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p><code>libgrpc++.so</code> 是一个运行时库，上述错误显示，<code>greeter_client</code> 动态连接该库时没找到这个库，这个库的搜索目录是在 <code>LD_LIBRARY_PATH</code>环境变量中定义里的，因此如果没在这个目录中，那么就会找不到，如果已经在这个目录中，可以执行 <code>sudo ldconfig -v</code> 来更新 /<code>etc/ld.so.conf</code> 的 cache（也即 <code>/etc/ld.so.cache</code> 文件）。</p><p>由于安装时，所有的 libgrpc 相关的静态库和动态库都会安装在 <code>/usr/local/lib</code> 目录中，而这个目录已经加入 <code>LD_LIBRARY_PATH</code> 环境变量，经过查看发现，<code>/usr/local/lib</code> 目录中确实没有 <code>libgrpc++.so.1</code>，原因是什么呢？</p><p>原来，在 grpc 源码目录的构建生成的 <code>libs/opt</code> 目录下， <code>libgrpc++.so.1</code> 这个文件确实是存在的（它是一个 symlink 文件，真正指向的是 <code>libgrpc++.so.1.5.0-dev</code>）。<br>但是执行 <code>make install</code> 安装的时候，却变成了 <code>libgrpc++.so.4</code>，那就扯淡了。那么，最简单的解决办法就是把构建目录中的 <code>libgrpc++.so.1</code> 拷贝到 <code>/usr/local/lib</code> 中去。或者把 <code>libgrpc++.so.4</code> 改成 <code>libgrpc++.so.1</code>。</p><p>最后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 `pkg-config --cflags protobuf grpc`  -c -o route_guide.grpc.pb.o route_guide.grpc.pb.cc</span><br><span class="line">g++ -std=c++11 `pkg-config --cflags protobuf grpc`  -c -o route_guide_client.o route_guide_client.cc</span><br></pre></td></tr></table></figure><p>全文完!</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在 Go 语言中使用 Protobuf</title>
      <link href="/Programming/go-go-use-protobuf/"/>
      <url>/Programming/go-go-use-protobuf/</url>
      
        <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><a href="https://github.com/google/protobuf" target="_blank" rel="noopener">Protobuf</a> 源码中默认实现了对 C++, Java, C#, Python 等语言的生成器插件，但是没有 Go 语言的生成器插件。Go 语言的生成器插件是在另一个叫 <a href="https://github.com/golang/protobuf" target="_blank" rel="noopener">golang/protobuf</a> 的项目中提供的，也叫 goprotobuf，这篇文章主要就是介绍如何在 Go 语言中使用 Protobuf。</p><h4 id="安装-golang-protobuf"><a href="#安装-golang-protobuf" class="headerlink" title="安装 golang/protobuf"></a>安装 golang/protobuf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure><p>执行上述命令之后，<strong>protoc-gen-go</strong> 二进制程序默认会安装在 <code>$GOBIN</code> 目录中。</p><p>注：<br><code>golang/protobuf</code> 中包含了 <code>github.com/golang/protobuf/proto</code> 库，这个库定义了 <code>.proto</code> 文件中声明的类型和方法所对应的 Go 语言表示的类型和方法，也就是由 <strong>protoc-gen-go</strong> 所生成的 Go 源码文件中所有需要引用到的类型和方法。</p><p>比如 <code>proto/lib.go</code> 中包含大量常用的类型及方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">proto.String()</span><br><span class="line">proto.Int64()</span><br><span class="line">proto.Uint64()</span><br><span class="line">proto.Bool()</span><br><span class="line">proto.Marshal()</span><br><span class="line">proto.Unmarshal()</span><br><span class="line">proto.Message</span><br></pre></td></tr></table></figure><h4 id="编译-proto-文件"><a href="#编译-proto-文件" class="headerlink" title="编译 .proto 文件"></a>编译 .proto 文件</h4><p>执行 <strong>protoc</strong>，并使用 <code>--go_out</code> 选项指定输出目录，即可生成 Go 源码文件。因为安装了 <strong>protoc-gen-go</strong> 之后，<code>--go_out</code> 选项会自动搜索 <strong>protoc-gen-go</strong>，只要其在 PATH 目录中可以找到即可。</p><p><strong><code>--go_out</code></strong> 支持以下参数</p><ul><li><code>plugins=plugin1+plugin2</code> 指定插件，目前只支持 grpc，即：plugins=grpc</li><li><code>M 参数</code> 指定导入的.proto文件路径编译后对应的golang包名(不指定本参数默认就是.proto文件中import语句的路径)</li><li><code>import_prefix=xxx</code> 为所有 import 路径添加前缀，主要用于编译子目录内的多个 proto 文件，这个参数按理说很有用，尤其适用替代一些情况时的 M 参数。</li><li><code>import_path=foo/bar</code> 用于指定未声明 package 或 go_package 的文件的包名，最右面的斜线前的字符会被忽略</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>（1）编写一个 <code>msg.proto</code> IDL 文件，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax=&quot;proto3&quot;;</span><br><span class="line">package example;</span><br><span class="line"></span><br><span class="line">message Msg &#123;</span><br><span class="line">    int32 msgType  = 1;</span><br><span class="line">    string MsgInfo = 2;</span><br><span class="line">    string MsgFrom = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h6><ul><li>在最新版的 Protobuf 中，强制要求 proto 文件必须指定版本，否则编译报错</li><li>这里定义的所有字段（无论大小写），在生成的 Go 语言中的结构体中都是导出字段，也就是都会变成大写。</li></ul><p>（2）编译 <code>.proto</code> 文件，生成 Go 语言文件</p><p>执行 <code>protoc --go_out=. msg.proto</code> 生成对应的 <code>msg.pb.go</code> 文件<br>进入 <code>msg.pb.go</code> 所在目录，执行 <code>go install</code> 生成相应的包。</p><p>（3）在 Go 程序中使用 protobuf</p><p>创建 <code>main.go</code>，并输入如下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/google/protobuf/proto"</span></span><br><span class="line">    <span class="string">"example"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    msg_test := &amp;example.Msg&#123;</span><br><span class="line">        MsgType: proto.Int32(<span class="number">1</span>),</span><br><span class="line">        MsgInfo: proto.String(<span class="string">"I am hahaya."</span>),</span><br><span class="line">        MsgFrom: proto.String(<span class="string">"127.0.0.1"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    in_data, err := proto.Marshal(msg_test)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Marshaling error: "</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    msg_encoding := &amp;example.Msg&#123;&#125;</span><br><span class="line">    err = proto.Unmarshal(in_data, msg_encoding)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Unmarshaling error: "</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"msg type: %d\n"</span>, msg_encoding.GetMsgType())</span><br><span class="line">    fmt.Printf(<span class="string">"msg info: %s\n"</span>, msg_encoding.MsgInfo)</span><br><span class="line">    fmt.Printf(<span class="string">"msg from: %s\n"</span>, msg_encoding.MsgFrom)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h4><p>除了 Google 官方提供的这款 <code>golang/protobuf</code> 插件，还有一款非常优秀的开源第三方库 <strong><code>gogo/protobuf</code></strong>，其作为官方的 fork，做了非常多的性能上的优化，能提供更加快速的编解码实现。</p><p><code>gogo/protobuf</code> 的源码地址：<a href="https://github.com/gogo/protobuf" target="_blank" rel="noopener">https://github.com/gogo/protobuf</a></p><p>根据其官方介绍，它提供了许多不同优化级别的实现，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proto-gen-gofast</span><br><span class="line">proto-gen-gogo</span><br><span class="line">proto-gen-gogofast</span><br><span class="line">proto-gen-gogofaster</span><br><span class="line">proto-gen-gogoslick</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h6 id="gogo-protobuf-的安装和使用"><a href="#gogo-protobuf-的安装和使用" class="headerlink" title="gogo/protobuf 的安装和使用"></a>gogo/protobuf 的安装和使用</h6><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gogo/protobuf/protoc-gen-gofast</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --gofast_out=. test.proto</span><br></pre></td></tr></table></figure><p>全文完!</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Protobuf 安装及使用</title>
      <link href="/Tools-and-Build/tool-and-build-protobuf-usage/"/>
      <url>/Tools-and-Build/tool-and-build-protobuf-usage/</url>
      
        <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Protocol Buffers （简称 Protobuf）是 Google 开源的一款跨语言，跨平台，扩展性好的序列化工具，相比于 XML 和 JSON 等流行的编码格式，Protobuf 的性能非常高。因此，Protobuf 的编码格式（文件后缀为 <code>.proto</code>）在网络开发中得到了广泛的应用，<strong>protoc</strong> 作为 Protobuf 的编译器，可以根据 Protobuf 的定义文件 <code>.proto</code> 生成多种语言（如：C++, Java, Go, Python 等）的类型定义文件及编解码操作代码，</p><p>这篇文章主要介绍 <strong>protoc</strong> 的安装和使用方法。</p><h4 id="源码编译安装"><a href="#源码编译安装" class="headerlink" title="源码编译安装"></a>源码编译安装</h4><p>官方源码：<a href="https://github.com/google/protobuf" target="_blank" rel="noopener">https://github.com/google/protobuf</a></p><p>（1） 安装依赖<br>如官网所列，protoc 有如下依赖：<br>autoconf, automake, libtool, curl, make, g++, unzip, gmock<br>其中 gmock 依赖于 libtool </p><p>（2）编译安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/google/protobuf</span><br><span class="line">./autogen.sh  <span class="comment"># 生成 configure 文件</span></span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>注：<br>安装完成之后，会在 /usr/lib 目录下生成前缀为 libprotobuf, libprotobuf-lite, libprotoc 这三类静态和动态库文件。<br>然后，我们需要执行 ldconfig 来更新 lib 路径。<br>如果上述步骤完成之后，执行 <strong>protoc</strong> 时仍发生错误的话，我们可以按如下方式手动链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/lib/libprotobuf.so.10.0.0 /usr/lib/libprotobuf.so</span><br></pre></td></tr></table></figure><h4 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h4><p>如果不想编译安装，也可以直接下载二进制包来进行安装，我们可以从 <a href="https://github.com/google/protobuf/releases" target="_blank" rel="noopener">这里</a> 直接获取编译好的 protoc 二进制文件。 </p><p>比如，下载如下两个包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protoc-3.3.0-win32.zip</span><br><span class="line">protoc-3.3.0-linux-x86_64.zip</span><br></pre></td></tr></table></figure><p>解压到 PATH 路径下即可完成安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo unzip protoc-3.0.0-beta-3-linux-x86_64.zip</span><br><span class="line">sudo chmod a+x protoc</span><br></pre></td></tr></table></figure><p>查看使用帮助</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">官方文档</a></p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>安装好 protoc 之后，我们可以安装官方手册上的例子来试验一下用法</p><p>1）编写 <code>.proto</code> 定义文件</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;</span><br><span class="line">package tutorial;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">    string name = 1;</span><br><span class="line">    int32 id = 2;</span><br><span class="line">    string email = 3;</span><br><span class="line"></span><br><span class="line">    enum PhoneType &#123;</span><br><span class="line">        MOBILE = 0;</span><br><span class="line">        HOME = 1;</span><br><span class="line">        WORK = 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    message PhoneNumber &#123;</span><br><span class="line">        string number = 1;</span><br><span class="line">        PhoneType type = 2 [default = HOME];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repeated PhoneNumber phone = 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddressBook &#123;</span><br><span class="line">    repeated Person person = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2) 编译 <code>.proto</code> 文件，生成想要的语言的定义及操作文件</p><p>比如，我们这里想要生成 C++ 的源码，那么执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --cpp_out=. addressbook.proto</span><br></pre></td></tr></table></figure><p>生成的文件：addressbook.pb.h, addressbook.pb.cc</p><p>3) 把上述生成的 <code>.pb.cc</code> 文件和我们应用程序 C++ 文件进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ addressbook.pb.cc readinput.cpp -lprotobuf</span><br></pre></td></tr></table></figure><h4 id="protoc-用法及选项"><a href="#protoc-用法及选项" class="headerlink" title="protoc 用法及选项"></a>protoc 用法及选项</h4><p>通过 <code>protoc --help</code> 可以查看使用方法</p><p>protoc 的用法格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc [OPTION] PROTO_FILES</span><br></pre></td></tr></table></figure><h5 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-IPATH, --proto_path=PATH   Specify the directory in which to search for imports. </span><br><span class="line">                            May be specified multiple times;</span><br><span class="line">                            If not given, the current working directory is used.</span><br><span class="line">--plugin=EXECUTABLE         Specifies a plugin executable to use.</span><br><span class="line">                              Normally, protoc searches the PATH for</span><br><span class="line">                              plugins, but you may specify additional</span><br><span class="line">                              executables not in the path using this flag.</span><br><span class="line">                              Additionally, EXECUTABLE may be of the form</span><br><span class="line">                              NAME=PATH, in which case the given plugin name</span><br><span class="line">                              is mapped to the given executable even if</span><br><span class="line">                              the executable&apos;s own name differs.</span><br><span class="line">--cpp_out=OUT_DIR           Generate C++ header and source.</span><br><span class="line">--csharp_out=OUT_DIR        Generate C# source file.</span><br><span class="line">--java_out=OUT_DIR          Generate Java source file.</span><br><span class="line">--javanano_out=OUT_DIR      Generate Java Nano source file.</span><br><span class="line">--js_out=OUT_DIR            Generate JavaScript source.</span><br><span class="line">--objc_out=OUT_DIR          Generate Objective C header and source.</span><br><span class="line">--php_out=OUT_DIR           Generate PHP source file.</span><br><span class="line">--python_out=OUT_DIR        Generate Python source file.</span><br><span class="line">--ruby_out=OUT_DIR          Generate Ruby source file.</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protoc -I ../../protos --grpc_out=. --plugin=protoc-gen-grpc=`<span class="built_in">which</span> grpc_cpp_plugin` ../../protos/route_guide.proto</span><br><span class="line">protoc -I ../../protos --cpp_out=. ../../protos/route_guide.proto</span><br></pre></td></tr></table></figure><p>全文完</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 grpc-go 编写 Client/Server</title>
      <link href="/Programming/go-grpc-go-for-cs/"/>
      <url>/Programming/go-grpc-go-for-cs/</url>
      
        <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>这篇文章介绍使用 grpc-go 编写 Client/Server 程序</p><h4 id="一、proto-文件定义及-Go-代码生成"><a href="#一、proto-文件定义及-Go-代码生成" class="headerlink" title="一、proto 文件定义及 Go 代码生成"></a>一、proto 文件定义及 Go 代码生成</h4><p>gRpc 使用 protobuf 作为默认的 wire-format 传输，在 .proto 文件中，我们需要定义传输过程中需要使用的各种 Message 类型，同时我们还需要定义 service，并在 service 中提供远程调用的各种方法。</p><p>（1）传输过程中的数据格式</p><p>提供 service 的 <code>.proto</code> 文件中定义两个 message 类型，一个用于指定请求的参数类型 HelloRequest，一个用于返回值的类型 HelloReply</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message HelloRequest &#123;</span><br><span class="line">    string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloReply &#123;</span><br><span class="line">    string message = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）提供的服务 Service<br>除了定义消息类型，<code>.proto</code> 文件中还需要定义一个 service 用于供客户端远程调用， 在这个 service 中声明 RPC 服务所要提供的各种方法的函数签名。<br>注意：这里只是函数声明，其指明了需要接收的参数类型和返回的类型。函数的实现需要我们根据 proto 生成的 Go 语言文件，在 Server 端编写代码来自行实现。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// The request message containing the user&apos;s name.</span><br><span class="line">service Greeter &#123;</span><br><span class="line">  rpc SayHello (HelloRequest) returns(HelloReply)&#123;&#125;</span><br><span class="line">  rpc SayGoodby (GoodByRequest) returns(GoodByReplay) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以把上述（1）和（2）的内容放在两个单独的 .proto 文件中（当然，必须使用同一个包名）。也可以放在同一个 .proto 文件中。通常，为了方便，我们都会放在同一个 .proto 文件中。这里我们把上述内容放在 helloworld.proto 文件中。</p><p>现在，调用 protoc 来生成 go 代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protoc -I ghello/ ghello/ghello.proto --go_out=plugins=grpc:ghello</span><br><span class="line">protoc -I helloworld/helloworld/ helloworld/helloworld/helloworld.proto --go_out=plugins=grpc:helloworld</span><br></pre></td></tr></table></figure><p>执行上述语句，protoc 会生成一个叫 helloworld.pb.go 的文件，这里面就包含了 Go 语言表述的相关代码。</p><h4 id="二、生成的-helloworld-pb-go-代码解析"><a href="#二、生成的-helloworld-pb-go-代码解析" class="headerlink" title="二、生成的 helloworld.pb.go 代码解析"></a>二、生成的 helloworld.pb.go 代码解析</h4><p>理解 protoc 所生成的 <code>helloworld.pb.go</code> 代码有助于我们理解整个 gRpc 的调用过程。</p><p>（1）首先，按照 proto 文件中所申明的各种不同消息类型，会生成对应名称的 struct 结构体，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Message <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）为上述结构体生成一些默认的方法，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *HelloRequest)</span> <span class="title">Reset</span><span class="params">()</span></span>                    &#123; *m = HelloRequest&#123;&#125; &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *HelloRequest)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>            &#123; <span class="keyword">return</span> proto.CompactTextString(m) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*HelloRequest)</span> <span class="title">ProtoMessage</span><span class="params">()</span></span>               &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*HelloRequest)</span> <span class="title">Descriptor</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, []<span class="keyword">int</span>)</span></span> &#123; <span class="keyword">return</span> fileDescriptor0, []<span class="keyword">int</span>&#123;<span class="number">0</span>&#125; &#125;</span><br></pre></td></tr></table></figure><p>（3）为 Service 分别生成 Client 端和 Server 端的 interface 定义，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GreeterClient <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Sends a greeting</span></span><br><span class="line">    SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GreeterServer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Sends a greeting</span></span><br><span class="line">    SayHello(context.Context, *HelloRequest) (*HelloReply, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要特别注意，虽然两者都是 interface 类型，但是 Client 端的对象是由 protoc 自动生成的，其实现了 GreeterClient 接口，见（4）。而 Server 端的对象则需要我们自己去手动编写了。因为我们是服务提供方嘛，提供什么具体的服务当然是由我们决定的。</p><p>（4）生成默认的 Client 类型，以便 gRpc 的客户端可以使用它来连接及调用 gRpc 服务端提供的服务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> greeterClient <span class="keyword">struct</span> &#123;</span><br><span class="line">    cc *grpc.ClientConn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGreeterClient</span><span class="params">(cc *grpc.ClientConn)</span> <span class="title">GreeterClient</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;greeterClient&#123;cc&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *greeterClient)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption)</span> <span class="params">(*HelloReply, error)</span></span> &#123;</span><br><span class="line">    out := <span class="built_in">new</span>(HelloReply)</span><br><span class="line">    err := grpc.Invoke(ctx, <span class="string">"/helloworld.Greeter/SayHello"</span>, in, out, c.cc, opts...)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到上述 Client 默认实现的 SayHello 函数，这个叫做 Client Stub，其实就是相当于本地实现了一个 SayHello 函数，当 grpc 的客户端调用 SayHello 函数的时候，其调用的就是这个本地的 SayHello 函数，这个函数在内部通过 grpc.Invoke() 的方式实现了远程调用。</p><p>（5）注册服务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterGreeterServer</span><span class="params">(s *grpc.Server, srv GreeterServer)</span></span> &#123;</span><br><span class="line">    s.RegisterService(&amp;_Greeter_serviceDesc, srv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑很简单，我们需要在我们的服务端，自己去定义一个 struct 对象，实现 .pb.go 中所声明的 GreeterServer 接口，然后把那个 struct 注册到 grpc 服务上。</p><h4 id="三、启动-gRpc-服务端和客户端"><a href="#三、启动-gRpc-服务端和客户端" class="headerlink" title="三、启动 gRpc 服务端和客户端"></a>三、启动 gRpc 服务端和客户端</h4><p>理解了上述所生成的 pb.go 的代码内容，现在我们就需要来编写 gRpc 的 <strong>Server 端代码</strong>了。先来看 Server 端代码怎么写才能提供 gRpc 服务。</p><p>为了简单，我分成了如下如下步骤：</p><ul><li>（1） 指定需要提供服务的端口，本地未被使用的任意端口都可以，比如 50051。</li><li>（2） 监听端口，调用net.Listen(“tcp”, port)</li><li><strong>（3） 定义一个 server struct 来实现 proto 文件中 service 部分所声明的所有 RPC 方法。 这步最关键！</strong></li><li>（4） 调用 grpc.NewServer() 来创建一个 Server</li><li>（5） 把上述 struct 的实例注册到 gprc 上</li><li>（6）调用 s.Serve(lis) 提供 gRpc 服务</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"golang.org/x/net/context"</span></span><br><span class="line">    <span class="string">"google.golang.org/grpc"</span></span><br><span class="line">    pb <span class="string">"google.golang.org/grpc/examples/helloworld/helloworld"</span></span><br><span class="line">    <span class="string">"google.golang.org/grpc/reflection"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    port = <span class="string">":50051"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server is used to implement helloworld.GreeterServer.</span></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello implements helloworld.GreeterServer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloReply, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: <span class="string">"Hello "</span> + in.Name&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    lis, err := net.Listen(<span class="string">"tcp"</span>, port)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    s := grpc.NewServer()</span><br><span class="line">    pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line">    <span class="comment">// Register reflection service on gRPC server.</span></span><br><span class="line">    reflection.Register(s)</span><br><span class="line">    <span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"failed to serve: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了服务端提供服务，我们就要想办法访问它了，这就需要我们编写 gRpc 的客户端了，来看看<strong>客户端代码</strong>怎么写。<br>我也详细分成了如下步骤：</p><ul><li>（1）连接服务端， 调用 <code>conn = grpc.Dial(&quot;localhost:50051&quot;, grpc.WithInsecure())</code></li><li>（2）创建 <code>GreeterClient(conn)</code>，把连接成功后返回的 conn 传入</li><li>（3）调用具体的方法 <code>SayHello()</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"golang.org/x/net/context"</span></span><br><span class="line">    <span class="string">"google.golang.org/grpc"</span></span><br><span class="line">    pb <span class="string">"google.golang.org/grpc/examples/helloworld/helloworld"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    address     = <span class="string">"localhost:50051"</span></span><br><span class="line">    defaultName = <span class="string">"world"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Set up a connection to the server.</span></span><br><span class="line">    conn, err := grpc.Dial(address, grpc.WithInsecure())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"did not connect: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    c := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Contact the server and print out its response.</span></span><br><span class="line">    name := defaultName</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">        name = os.Args[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    r, err := c.SayHello(context.Background(), &amp;pb.HelloRequest&#123;Name: name&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"could not greet: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Greeting: %s"</span>, r.Message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，只需要把正确类型的参数传给 c.SayHello() 就能完成 grpc 调用了。如：<code>&amp;pb.HelloRequest{Name: name}</code></p><p>注：要连接 gRpc 的服务端，使用上述 Go 语言版本的 gRpc client 可以完成，使用其他任何 grpc 支持的语言的 client 都可以完成。比如，我们使用 cpp 版本的 client</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grpc++/grpc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> BAZEL_BUILD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"examples/protos/helloworld.grpc.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"helloworld.grpc.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> grpc::Channel;</span><br><span class="line"><span class="keyword">using</span> grpc::ClientContext;</span><br><span class="line"><span class="keyword">using</span> grpc::Status;</span><br><span class="line"><span class="keyword">using</span> helloworld::HelloRequest;</span><br><span class="line"><span class="keyword">using</span> helloworld::HelloReply;</span><br><span class="line"><span class="keyword">using</span> helloworld::Greeter;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreeterClient</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  GreeterClient(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Channel&gt; channel)</span><br><span class="line">      : stub_(Greeter::NewStub(channel)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assembles the client's payload, sends it and presents the response back</span></span><br><span class="line">  <span class="comment">// from the server.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">SayHello</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Data we are sending to the server.</span></span><br><span class="line">    HelloRequest request;</span><br><span class="line">    request.set_name(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Container for the data we expect from the server.</span></span><br><span class="line">    HelloReply reply;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Context for the client. It could be used to convey extra information to</span></span><br><span class="line">    <span class="comment">// the server and/or tweak certain RPC behaviors.</span></span><br><span class="line">    ClientContext context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The actual RPC.</span></span><br><span class="line">    Status status = stub_-&gt;SayHello(&amp;context, request, &amp;reply);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Act upon its status.</span></span><br><span class="line">    <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">      <span class="keyword">return</span> reply.message();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; status.error_code() &lt;&lt; <span class="string">": "</span> &lt;&lt; status.error_message()</span><br><span class="line">                &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"RPC failed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Greeter::Stub&gt; stub_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Instantiate the client. It requires a channel, out of which the actual RPCs</span></span><br><span class="line">  <span class="comment">// are created. This channel models a connection to an endpoint (in this case,</span></span><br><span class="line">  <span class="comment">// localhost at port 50051). We indicate that the channel isn't authenticated</span></span><br><span class="line">  <span class="comment">// (use of InsecureChannelCredentials()).</span></span><br><span class="line">  GreeterClient greeter(grpc::CreateChannel("localhost:50051", grpc::InsecureChannelCredentials()));</span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">user</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> reply = greeter.SayHello(user);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Greeter received: "</span> &lt;&lt; reply &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务端，查询 db，并且赋值给 HelloReply 中的 fields。 然后把 HelloReply message 返回给客户端。</p><p>全文完</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>grpc-go 的安装和使用</title>
      <link href="/Tools-and-Build/tool-and-build-grpc-go-installation/"/>
      <url>/Tools-and-Build/tool-and-build-grpc-go-installation/</url>
      
        <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Google 原生的 <a href="https://github.com/grpc/grpc" target="_blank" rel="noopener">grpc 框架</a> 是用 C 语言实现的，其默认包含了多种语言（cpp, ruby, python, c# 等）的实现，因而可以支持多种语言的 grpc 调用。但是默认没有提供 Go 和 Java 两种语言的 GRPC 实现。虽然如此，Google 官方在另外的单独的仓库中提供了 Go 语言版本的 GRPC 实现，也即 <a href="https://github.com/grpc/grpc" target="_blank" rel="noopener">grpc-go</a>（注：java 版的在 <a href="https://github.com/grpc/grpc-java" target="_blank" rel="noopener">grpc-java</a> 中），它们都在独立的 Repository 中。</p><p>这篇文章就来介绍下如何安装和使用 grpc-go，并构建基于 grpc-go 的程序。</p><h4 id="grpc-go-安装"><a href="#grpc-go-安装" class="headerlink" title="grpc-go 安装"></a>grpc-go 安装</h4><p>官方 repo 地址：<a href="https://github.com/grpc/grpc" target="_blank" rel="noopener">https://github.com/grpc/grpc-go</a></p><p>（1） 依赖<br>需要至少 go 1.7+，以及 gRPC</p><p>（2）安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u google.golang.org/grpc</span><br></pre></td></tr></table></figure><p>需要注意的是：这里安装的 <strong>grpc-go</strong> 只是一个第三方库，提供的是库函数接口，而不是二进制程序。因此，grpc-go 安装之后提供的是第三方包的作用。</p><p>在用户程序中，通常是通过下列方式来使用 grpc 包</p><p>（1）编写 <code>.proto</code> 文件 </p><p>helloworld.proto</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option java_multiple_files = true;</span><br><span class="line">option java_package = &quot;io.grpc.examples.helloworld&quot;;</span><br><span class="line">option java_outer_classname = &quot;HelloWorldProto&quot;;</span><br><span class="line"></span><br><span class="line">package helloworld;</span><br><span class="line"></span><br><span class="line">// The greeting service definition.</span><br><span class="line">service Greeter &#123;</span><br><span class="line">  // Sends a greeting</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// The request message containing the user&apos;s name.</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// The response message containing the greetings</span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  string message = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）编译 .proto 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=plugin=grpc:. *.proto</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --gofast_out=plugins=grpc:. *.proto</span><br></pre></td></tr></table></figure><p>（3）编写 client 端代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"golang.org/x/net/context"</span></span><br><span class="line">    <span class="string">"google.golang.org/grpc"</span></span><br><span class="line">    pb <span class="string">"google.golang.org/grpc/examples/helloworld/helloworld"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    address     = <span class="string">"localhost:50051"</span></span><br><span class="line">    defaultName = <span class="string">"world"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Set up a connection to the server.</span></span><br><span class="line">    conn, err := grpc.Dial(address, grpc.WithInsecure())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"did not connect: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    c := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Contact the server and print out its response.</span></span><br><span class="line">    name := defaultName</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">        name = os.Args[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    r, err := c.SayHello(context.Background(), &amp;pb.HelloRequest&#123;Name: name&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"could not greet: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Greeting: %s"</span>, r.Message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：以上内容来自 grpc-go 源码目录中的 examples/helloworld/greeter_client/main.go</p><p>（4）编写 server 端代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"golang.org/x/net/context"</span></span><br><span class="line">    <span class="string">"google.golang.org/grpc"</span></span><br><span class="line">    pb <span class="string">"google.golang.org/grpc/examples/helloworld/helloworld"</span></span><br><span class="line">    <span class="string">"google.golang.org/grpc/reflection"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    port = <span class="string">":50051"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server is used to implement helloworld.GreeterServer.</span></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello implements helloworld.GreeterServer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">SayHello</span><span class="params">(ctx context.Context, in *pb.HelloRequest)</span> <span class="params">(*pb.HelloReply, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: <span class="string">"Hello "</span> + in.Name&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    lis, err := net.Listen(<span class="string">"tcp"</span>, port)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"failed to listen: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    s := grpc.NewServer()</span><br><span class="line">    pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line">    <span class="comment">// Register reflection service on gRPC server.</span></span><br><span class="line">    reflection.Register(s)</span><br><span class="line">    <span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"failed to serve: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：以上内容来自 grpc-go 源码目录中的 <code>examples/helloworld/greeter_server/main.go</code></p><p>全文完!</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go 和 C++ 程序通过 protobuf 来进行数据交互</title>
      <link href="/Tools-and-Build/tool-and-build-protobuf-go-cpp/"/>
      <url>/Tools-and-Build/tool-and-build-protobuf-go-cpp/</url>
      
        <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>这篇文章主要介绍如何使用 Protobuf 来在 Go 语言程序和 C++ 程序之间进行数据交互。</p><p>这里使用 Go 编写服务端，而用 C++ 编写客户端。</p><h4 id="编写-proto-协议文件"><a href="#编写-proto-协议文件" class="headerlink" title="编写 proto 协议文件"></a>编写 proto 协议文件</h4><p>在开始写客户端和服务端之前，首先需要生成 Go 和 C++ 的 proto 协议文件，只写了一个 proto 文件即可<br>新建一个名为 msg 的 proto 文件，输入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line">package msg;</span><br><span class="line"></span><br><span class="line">message Msg &#123;</span><br><span class="line">    int64 MsgId = 1;</span><br><span class="line">    string MsgInfo = 2;</span><br><span class="line">    string MsgFrom = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译-proto-文件"><a href="#编译-proto-文件" class="headerlink" title="编译 proto 文件"></a>编译 proto 文件</h4><p>执行下列命令分别生成 Go 语言和 C++ 对应的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protoc --cpp_out=. msg.proto</span><br><span class="line">protoc --go_out=. msg.proto</span><br></pre></td></tr></table></figure><h4 id="编写-Go-服务端程序"><a href="#编写-Go-服务端程序" class="headerlink" title="编写 Go 服务端程序"></a>编写 Go 服务端程序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">"test/msg"</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">"github.com/google/protobuf/proto"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>)</span><br><span class="line">    n, err := conn.Read(buff)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"read data failed..."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"read len: %d\n"</span>, ReadLen)</span><br><span class="line">    fmt.Println(buff)</span><br><span class="line">    </span><br><span class="line">    msgBuf := buf[<span class="number">0</span> : n]</span><br><span class="line">    reciveMsg := &amp;msg.Msg &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    err = proto.Unmarshal(msgBuf, reciveMsg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"unmarshaling error: "</span>, reciveMsg)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"msg id: %d\n"</span>, reciveMsg.GetMsgId())</span><br><span class="line">    fmt.Printf(<span class="string">"msg info: %s\n"</span>, reciveMsg.GetMsgInfo())</span><br><span class="line">    fmt.Printf(<span class="string">"msg from id: %s\n"</span>, reciveMsg.GetMsgFrom())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tcpAddr, err := net.ResolveTCPAddr(<span class="string">"tcp4"</span>, <span class="string">":2121"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"get tcp addr failed..."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    listener, err := net.ListenTCP(<span class="string">"tcp"</span>, tcpAddr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"listen tcp failed..."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> handleConn(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写-C-客户端程序"><a href="#编写-C-客户端程序" class="headerlink" title="编写 C++ 客户端程序"></a>编写 C++ 客户端程序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"msg.pb.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sk = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = htons(<span class="number">2121</span>); <span class="comment">// 固定端口port</span></span><br><span class="line">    server.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>); <span class="comment">// 固定ip</span></span><br><span class="line">    </span><br><span class="line">    connect(sk, (struct sockaddr*)&amp;server, <span class="keyword">sizeof</span>(server));</span><br><span class="line">    </span><br><span class="line">    msg::Msg sendMsg;</span><br><span class="line">    sendMsg.set_msgid(<span class="number">0</span>);</span><br><span class="line">    sendMsg.set_msginfo(<span class="string">"hello protobuf"</span>);</span><br><span class="line">    sendMsg.set_msgfrom(<span class="string">"alex"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> sendData;</span><br><span class="line">    sendMsg.SerializeToString(&amp;sendData);</span><br><span class="line">    <span class="keyword">int</span> len = sendData.length();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"string len:"</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *buff = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(buff, sendData.c_str(), len);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"buff len:"</span> &lt;&lt; <span class="built_in">strlen</span>(buff) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//向服务段发送数据</span></span><br><span class="line">    <span class="comment">//在发送数据时一定要指明数据长度 防止中间有\0截断c风格字符串</span></span><br><span class="line">    send(sk, buff, len, <span class="number">0</span>);</span><br><span class="line">    close(sk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>先后启动服务端和客户端程序</p>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>protoc2 与 protoc3 区别</title>
      <link href="/Tools-and-Build/tool-and-build-protoc23diff/"/>
      <url>/Tools-and-Build/tool-and-build-protoc23diff/</url>
      
        <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>在新版的 Protobuf 中，强制要求 proto 文件必须指定版本（语法是：<code>syntax=&quot;proto3&quot;;</code>），这篇文章主要介绍 Protobuf 的 protoc2 与 protoc3 之间的区别。</p><p><a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">官方文档</a></p><p>总体来说，proto3 比 proto2 支持更多语言但 更简洁。去掉了一些复杂的语法和特性，更强调约定而弱化语法。如果是首次使用 Protobuf ，建议使用 proto3 。</p><ol><li>在第一行非空白非注释行，必须指定版本，如下：</li></ol><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>字段规则<strong>移除了 “required”</strong>，并把 “optional” 改名为 “singular”<br>在 proto2 中 required 也是不推荐使用的。proto3 直接从语法层面上移除了 required 规则。<br>个人认为，还可以做的更彻底，把所有字段规则描述都撤销，原来的 repeated 改为在类型或字段名后加一对中括号，这样可能会更简洁。</p></li><li><p>“repeated” 字段默认采用 <code>packed</code> 编码<br>在 proto2 中，需要明确使用 <code>[packed=true]</code> 来为字段指定比较紧凑的 <code>packed</code> 编码方式。</p></li><li><p>语言增加 Go、Ruby、JavaNano 支持</p></li><li><p>移除了 default 选项<br>在 proto2 中，可以使用 default 选项为某一字段指定默认值。在 proto3 中，字段的默认值只能根据字段类型由系统决定。也就是说，默认值全部是约定好的，而不再提供指定默认值的语法。<br>在字段被设置为默认值的时候，该字段不会被序列化。这样可以节省空间，提高效率。<br>但这样就无法区分某字段是根本没赋值，还是赋值了默认值。这在 proto3 中问题不大，但在 proto2 中会有问题。<br>比如，在更新协议的时候使用 default 选项为某个字段指定了一个与原来不同的默认值，旧代码获取到的该字段的值会与新代码不一样。<br>另一个重约定而弱语法的例子是 Go 语言里的公共/私有对象。Go 语言约定，首字母大写的为公共对象，否则为私有对象。所以在 Go 语言中是没有 public、private 这样的语法的。</p></li><li><p>枚举类型的第一个字段必须为 0</p></li><li><p>移除了对分组的支持<br>分组的功能完全可以用消息嵌套的方式来实现，并且更清晰。在 proto2 中已经把分组语法标注为『过期』了。这次也算清理垃圾了。</p></li><li><p>在 proto3 中，旧代码在解析新增字段时，会把不认识的字段丢弃，再序列化后新增的字段就没了；<br>而在 proto2 中，旧代码虽然会忽视不认识的新增字段，但并不会将其丢弃，再序列化的时候那些字段会被原样保留。<br>个人认为，proto2 的处理方式更好一些。能尽量保持兼容性和扩展能力，或许实现起来也更简单。proto3 现在的处理方式，没有带来明显的好处，但丢掉了部分兼容性和灵活性。<br>[2017-06-15 更新]：经过漫长的讨论，官方终于同意在 proto3 中恢复 proto2 的处理方式了。 可以通过这个文档了解前因后果及时间线。</p></li><li><p>移除了对扩展的支持，新增了 Any 类型<br>Any 类型是用来替代 proto2 中的扩展的。目前还在开发中。<br>proto2 中的扩展特性很像 Swift 语言中的扩展。理解起来有点困难，使用起来更是会带来不少混乱。<br>相比之下，proto3 中新增的 Any 类型有点像 C/C++ 中的 void* ，好理解，使用起来逻辑也更清晰。</p></li><li><p>增加了 JSON 映射特性<br>语言的活力来自于与时俱进。当前，JSON 的流行有其充分的理由。很多『现代化』的语言都内置了对 JSON 的支持，比如 Go、PHP 等。而 C++ 这种看似保罗万象的学院派语言，因循守旧、故步自封，以致于现出了式微的苗头。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Protobuf For Golang</title>
      <link href="/Tools-and-Build/tool-and-build-protoc-go/"/>
      <url>/Tools-and-Build/tool-and-build-protoc-go/</url>
      
        <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><a href="https://github.com/google/protobuf" target="_blank" rel="noopener">Protobuf</a> 源码中默认实现了对 C++, Java, C#, Python 等语言的生成器插件，但是没有 Go 语言的生成器插件。Go 语言的生成器插件是在另一个叫 <a href="https://github.com/golang/protobuf" target="_blank" rel="noopener">golang/protobuf</a> 的项目中提供的，也叫 goprotobuf，这篇文章主要就是介绍如何在 Go 语言中使用 Protobuf。</p><h4 id="安装-golang-protobuf"><a href="#安装-golang-protobuf" class="headerlink" title="安装 golang/protobuf"></a>安装 golang/protobuf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure><p>执行上述命令之后，<strong>protoc-gen-go</strong> 二进制程序默认会安装在 <code>$GOBIN</code> 目录中。</p><p>注：<br><code>golang/protobuf</code> 中包含了 <code>github.com/golang/protobuf/proto</code> 库，这个库定义了 <code>.proto</code> 文件中声明的类型和方法所对应的 Go 语言表示的类型和方法，也就是由 <strong>protoc-gen-go</strong> 所生成的 Go 源码文件中所有需要引用到的类型和方法。</p><p>比如 <code>proto/lib.go</code> 中包含大量常用的类型及方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">proto.String()</span><br><span class="line">proto.Int64()</span><br><span class="line">proto.Uint64()</span><br><span class="line">proto.Bool()</span><br><span class="line">proto.Marshal()</span><br><span class="line">proto.Unmarshal()</span><br><span class="line">proto.Message</span><br></pre></td></tr></table></figure><h4 id="编译生成-Go-源码"><a href="#编译生成-Go-源码" class="headerlink" title="编译生成 Go 源码"></a>编译生成 Go 源码</h4><p>执行 <strong>protoc</strong>，并使用 <code>--go_out</code> 选项指定输出目录，即可生成 Go 源码文件。因为安装了 <strong>protoc-gen-go</strong> 之后，<code>--go_out</code> 选项会自动搜索 <strong>protoc-gen-go</strong>，只要其在 PATH 目录中可以找到即可。</p><p><strong><code>--go_out</code></strong> 支持以下参数</p><ul><li><code>plugins=plugin1+plugin2</code> 指定插件，目前只支持 grpc，即：plugins=grpc</li><li><code>M 参数</code> 指定导入的.proto文件路径编译后对应的golang包名(不指定本参数默认就是.proto文件中import语句的路径)</li><li><code>import_prefix=xxx</code> 为所有 import 路径添加前缀，主要用于编译子目录内的多个 proto 文件，这个参数按理说很有用，尤其适用替代一些情况时的 M 参数。</li><li><code>import_path=foo/bar</code> 用于指定未声明 package 或 go_package 的文件的包名，最右面的斜线前的字符会被忽略</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>1) 编写一个 <code>msg.proto</code> IDL 文件，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax=&quot;proto3&quot;;</span><br><span class="line">package example;</span><br><span class="line"></span><br><span class="line">message Msg &#123;</span><br><span class="line">    int32 msgType  = 1;</span><br><span class="line">    string MsgInfo = 2;</span><br><span class="line">    string MsgFrom = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h6><ul><li>在最新版的 Protobuf 中，强制要求 proto 文件必须指定版本，否则编译报错</li><li>这里定义的所有字段（无论大小写），在生成的 Go 语言中的结构体中都是导出字段，也就是都会变成大写。</li></ul><p>2) 编译 <code>.proto</code> 文件，生成 Go 语言文件</p><p>执行 <code>protoc --go_out=. msg.proto</code> 生成对应的 <code>msg.pb.go</code> 文件<br>进入 <code>msg.pb.go</code> 所在目录，执行 <code>go install</code> 生成相应的包。</p><p>3) 在 Go 程序中使用 protobuf</p><p>创建 <code>main.go</code>，并输入如下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/google/protobuf/proto"</span></span><br><span class="line">    <span class="string">"example"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    msg_test := &amp;example.Msg&#123;</span><br><span class="line">        MsgType: proto.Int32(<span class="number">1</span>),</span><br><span class="line">        MsgInfo: proto.String(<span class="string">"I am hahaya."</span>),</span><br><span class="line">        MsgFrom: proto.String(<span class="string">"127.0.0.1"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    in_data, err := proto.Marshal(msg_test)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Marshaling error: "</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    msg_encoding := &amp;example.Msg&#123;&#125;</span><br><span class="line">    err = proto.Unmarshal(in_data, msg_encoding)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Unmarshaling error: "</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"msg type: %d\n"</span>, msg_encoding.GetMsgType())</span><br><span class="line">    fmt.Printf(<span class="string">"msg info: %s\n"</span>, msg_encoding.MsgInfo)</span><br><span class="line">    fmt.Printf(<span class="string">"msg from: %s\n"</span>, msg_encoding.MsgFrom)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h4><p>除了 Google 官方提供的这款 <code>golang/protobuf</code> 插件，还有一款非常优秀的开源第三方库 <strong><code>gogo/protobuf</code></strong>，其作为官方的 fork，做了非常多的性能上的优化，能提供更加快速的编解码实现。</p><p><code>gogo/protobuf</code> 的源码地址：<a href="https://github.com/gogo/protobuf" target="_blank" rel="noopener">https://github.com/gogo/protobuf</a></p><p>根据其官方介绍，它提供了许多不同优化级别的实现，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proto-gen-gofast</span><br><span class="line">proto-gen-gogo</span><br><span class="line">proto-gen-gogofast</span><br><span class="line">proto-gen-gogofaster</span><br><span class="line">proto-gen-gogoslick</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h6 id="gogo-protobuf-的安装和使用"><a href="#gogo-protobuf-的安装和使用" class="headerlink" title="gogo/protobuf 的安装和使用"></a>gogo/protobuf 的安装和使用</h6><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gogo/protobuf/protoc-gen-gofast</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --gofast_out=. test.proto</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Protobuf 安装及使用</title>
      <link href="/Tools-and-Build/tool-and-build-protoc-install/"/>
      <url>/Tools-and-Build/tool-and-build-protoc-install/</url>
      
        <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Protocol Buffers （简称 Protobuf）是 Google 开源的一款跨语言，跨平台，扩展性好的序列化工具，相比于 XML 和 JSON 等流行的编码格式，Protobuf 的性能非常高。因此，Protobuf 的编码格式（文件后缀为 <code>.proto</code>）在网络开发中得到了广泛的应用，<strong>protoc</strong> 作为 Protobuf 的编译器，可以根据 Protobuf 的定义文件 <code>.proto</code> 生成多种语言（如：C++, Java, Go, Python 等）的类型定义文件及编解码操作代码，</p><p>这篇文章主要介绍 <strong>protoc</strong> 的安装和使用方法。</p><h4 id="编译及安装"><a href="#编译及安装" class="headerlink" title="编译及安装"></a>编译及安装</h4><p>官方源码：<a href="https://github.com/google/protobuf" target="_blank" rel="noopener">https://github.com/google/protobuf</a></p><p>1) 安装依赖<br>如官网所列，protoc 有如下依赖：</p><p>autoconf, automake, libtool, curl, make, g++, unzip, gmock<br>其中 gmock 依赖于 libtool</p><p>2）编译安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/google/protobuf</span><br><span class="line">./autogen.sh  <span class="comment"># 生成 configure 文件</span></span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>注：<br>安装完成之后，会在 /usr/lib 目录下生成前缀为 libprotobuf, libprotobuf-lite, libprotoc 这三类静态和动态库文件。<br>然后，我们需要执行 ldconfig 来更新 lib 路径。<br>如果上述步骤完成之后，执行 <strong>protoc</strong> 时仍发生错误的话，我们可以按如下方式手动链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/lib/libprotobuf.so.10.0.0 /usr/lib/libprotobuf.so</span><br></pre></td></tr></table></figure><h4 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h4><p>如果不想编译安装，也可以直接下载二进制包来进行安装，我们可以从 <a href="https://github.com/google/protobuf/releases" target="_blank" rel="noopener">这里</a> 直接获取编译好的 protoc 二进制文件。</p><p>比如，下载如下两个包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protoc-3.3.0-win32.zip</span><br><span class="line">protoc-3.3.0-linux-x86_64.zip</span><br></pre></td></tr></table></figure><p>解压到 PATH 路径下即可完成安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo unzip protoc-3.0.0-beta-3-linux-x86_64.zip</span><br><span class="line">sudo chmod a+x protoc</span><br></pre></td></tr></table></figure><p>查看使用帮助</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">官方文档</a></p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>安装好 protoc 之后，我们可以安装官方手册上的例子来试验一下用法</p><p>1）编写 <code>.proto</code> 定义文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;</span><br><span class="line">package tutorial;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">    string name = 1;</span><br><span class="line">    int32 id = 2;</span><br><span class="line">    string email = 3;</span><br><span class="line"></span><br><span class="line">    enum PhoneType &#123;</span><br><span class="line">        MOBILE = 0;</span><br><span class="line">        HOME = 1;</span><br><span class="line">        WORK = 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    message PhoneNumber &#123;</span><br><span class="line">        string number = 1;</span><br><span class="line">        PhoneType type = 2 [default = HOME];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    repeated PhoneNumber phone = 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddressBook &#123;</span><br><span class="line">    repeated Person person = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2) 编译 <code>.proto</code> 文件，生成想要的语言的定义及操作文件</p><p>比如，我们这里想要生成 C++ 的源码，那么执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --cpp_out=. addressbook.proto</span><br></pre></td></tr></table></figure><p>生成的文件：addressbook.pb.h, addressbook.pb.cc</p><p>3) 把上述生成的 <code>.pb.cc</code> 文件和我们应用程序 C++ 文件进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ addressbook.pb.cc readinput.cpp -lprotobuf</span><br></pre></td></tr></table></figure><h4 id="protoc-用法及选项"><a href="#protoc-用法及选项" class="headerlink" title="protoc 用法及选项"></a>protoc 用法及选项</h4><p>通过 <code>protoc --help</code> 可以查看使用方法</p><p>protoc 的用法格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc [OPTION] PROTO_FILES</span><br></pre></td></tr></table></figure><h5 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-IPATH, --proto_path=PATH   Specify the directory in which to search for imports.</span><br><span class="line">                            May be specified multiple times;</span><br><span class="line">                            If not given, the current working directory is used.</span><br><span class="line">--plugin=EXECUTABLE         Specifies a plugin executable to use.</span><br><span class="line">                              Normally, protoc searches the PATH for</span><br><span class="line">                              plugins, but you may specify additional</span><br><span class="line">                              executables not in the path using this flag.</span><br><span class="line">                              Additionally, EXECUTABLE may be of the form</span><br><span class="line">                              NAME=PATH, in which case the given plugin name</span><br><span class="line">                              is mapped to the given executable even if</span><br><span class="line">                              the executable&apos;s own name differs.</span><br><span class="line">--cpp_out=OUT_DIR           Generate C++ header and source.</span><br><span class="line">--csharp_out=OUT_DIR        Generate C# source file.</span><br><span class="line">--java_out=OUT_DIR          Generate Java source file.</span><br><span class="line">--javanano_out=OUT_DIR      Generate Java Nano source file.</span><br><span class="line">--js_out=OUT_DIR            Generate JavaScript source.</span><br><span class="line">--objc_out=OUT_DIR          Generate Objective C header and source.</span><br><span class="line">--php_out=OUT_DIR           Generate PHP source file.</span><br><span class="line">--python_out=OUT_DIR        Generate Python source file.</span><br><span class="line">--ruby_out=OUT_DIR          Generate Ruby source file.</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protoc -I ../../protos --grpc_out=. --plugin=protoc-gen-grpc=`<span class="built_in">which</span> grpc_cpp_plugin` ../../protos/route_guide.proto</span><br><span class="line">protoc -I ../../protos --cpp_out=. ../../protos/route_guide.proto</span><br></pre></td></tr></table></figure><p>全文完</p>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言 big.Int</title>
      <link href="/Programming/go-go-bigint/"/>
      <url>/Programming/go-go-bigint/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>math/big 作为 Go 语言提供的进行大数操作的官方库，在以太坊 Ethereum 项目中作为 currency 的类型表示得到了广泛的使用，这篇文章主要介绍该库的使用。</p><h3 id="官方包解析"><a href="#官方包解析" class="headerlink" title="官方包解析"></a>官方包解析</h3><p>在官方的 math/big 包中，Int 类型定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An Int represents a signed multi-precision integer.</span></span><br><span class="line"><span class="comment">// The zero value for an Int represents the value 0.</span></span><br><span class="line"><span class="keyword">type</span> Int <span class="keyword">struct</span> &#123;</span><br><span class="line">    neg <span class="keyword">bool</span> <span class="comment">// sign</span></span><br><span class="line">    abs nat  <span class="comment">// absolute value of the integer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成 Int 类型的方法为 <code>NewInt()</code>，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewInt allocates and returns a new Int set to x.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInt</span><span class="params">(x <span class="keyword">int64</span>)</span> *<span class="title">Int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new</span>(Int).SetInt64(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，NewInt() 函数只对 int64 有效，其他类型必须先转成 int64 才行。</p><p>但是，官方还提供了许多 Set 函数，可以方便的把其他类型的整形存入 Int ，因此，我们可以先 new(int) 然后再调用 Set 函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetInt64 sets z to x and returns z.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *Int)</span> <span class="title">SetInt64</span><span class="params">(x <span class="keyword">int64</span>)</span> *<span class="title">Int</span></span> &#123;</span><br><span class="line">    neg := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        neg = <span class="literal">true</span></span><br><span class="line">        x = -x</span><br><span class="line">    &#125;</span><br><span class="line">    z.abs = z.abs.setUint64(<span class="keyword">uint64</span>(x))</span><br><span class="line">    z.neg = neg</span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// SetUint64 sets z to x and returns z.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *Int)</span> <span class="title">SetUint64</span><span class="params">(x <span class="keyword">uint64</span>)</span> *<span class="title">Int</span></span> &#123;</span><br><span class="line">    z.abs = z.abs.setUint64(x)</span><br><span class="line">    z.neg = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// Set sets z to x and returns z.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *Int)</span> <span class="title">Set</span><span class="params">(x *Int)</span> *<span class="title">Int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> z != x &#123;</span><br><span class="line">        z.abs = z.abs.set(x.abs)</span><br><span class="line">        z.neg = x.neg</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>用法示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    big1 := <span class="built_in">new</span>(big.Int).SetUint64(<span class="keyword">uint64</span>(<span class="number">1000</span>))</span><br><span class="line">    fmt.Println(<span class="string">"big1 is: "</span>, big1)</span><br><span class="line">    </span><br><span class="line">    big2 := big1.Uint64()</span><br><span class="line">    fmt.Println(<span class="string">"big2 is: "</span>, big2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上述的 Set 函数，big 库还提供了一个 <code>SetString()</code> 函数，可以指定进制数，比如二进制、十进制或者十六进制等！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetString sets z to the value of s, interpreted in the given base,</span></span><br><span class="line"><span class="comment">// and returns z and a boolean indicating success. The entire string</span></span><br><span class="line"><span class="comment">// (not just a prefix) must be valid for success. If SetString fails,</span></span><br><span class="line"><span class="comment">// the value of z is undefined but the returned value is nil.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The base argument must be 0 or a value between 2 and MaxBase. If the base</span></span><br><span class="line"><span class="comment">// is 0, the string prefix determines the actual conversion base. A prefix of</span></span><br><span class="line"><span class="comment">// ``0x'' or ``0X'' selects base 16; the ``0'' prefix selects base 8, and a</span></span><br><span class="line"><span class="comment">// ``0b'' or ``0B'' prefix selects base 2. Otherwise the selected base is 10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *Int)</span> <span class="title">SetString</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>)</span> <span class="params">(*Int, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    r := strings.NewReader(s)</span><br><span class="line">    <span class="keyword">if</span> _, _, err := z.scan(r, base); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// entire string must have been consumed</span></span><br><span class="line">    <span class="keyword">if</span> _, err := r.ReadByte(); err != io.EOF &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z, <span class="literal">true</span> <span class="comment">// err == io.EOF =&gt; scan consumed all of s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    big1 := <span class="built_in">new</span>(big.Int).SetString(<span class="string">"1000"</span>, <span class="number">10</span>)</span><br><span class="line">    fmt.Println(<span class="string">"big1 is: "</span>, big1)</span><br><span class="line">    </span><br><span class="line">    big2 := big1.Uint64()</span><br><span class="line">    fmt.Println(<span class="string">"big2 is: "</span>, big2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>uint64, int64 等普通类型与 big.Int 类型的转换<br>如上，直接调用 big 库提供的 Int64(), Uint64() 等函数就可以进行转换。</p><p>Int 对象上的运算函数<br>Mul(im, in)<br>Add(ip, im)<br>Div(ip, io)</p><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a href="https://golang.org/pkg/math/big/" target="_blank" rel="noopener">https://golang.org/pkg/math/big/</a></p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入解析 multipart/form-data</title>
      <link href="/Programming/web-multipart-formdata/"/>
      <url>/Programming/web-multipart-formdata/</url>
      
        <content type="html"><![CDATA[<h4 id="一个-HTML-表单中的-enctype-有三种类型"><a href="#一个-HTML-表单中的-enctype-有三种类型" class="headerlink" title="一个 HTML 表单中的 enctype 有三种类型"></a>一个 HTML 表单中的 enctype 有三种类型</h4><ul><li>application/x-www-urlencoded</li><li>multipart/form-data</li><li>text-plain</li></ul><p>默认情况下是 <code>application/x-www-urlencoded</code>，当表单使用 POST 请求时，数据会被以 x-www-urlencoded 方式编码到 Body 中来传送，<br>而如果 GET 请求，则是附在 url 链接后面来发送。</p><p>GET 请求只支持 ASCII 字符集，因此，如果我们要发送更大字符集的内容，我们应使用 POST 请求。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果要发送大量的二进制数据（non-ASCII），<code>&quot;application/x-www-form-urlencoded&quot;</code> 显然是低效的，因为它需要用 3 个字符来表示一个 non-ASCII 的字符。因此，这种情况下，应该使用 <code>&quot;multipart/form-data&quot;</code> 格式。</p><p>The content type “application/x-www-form-urlencoded” is inefficient for sending large quantities of binary data or text containing non-ASCII characters. The content type “multipart/form-data” should be used for submitting forms that contain files, non-ASCII data, and binary data.</p><h4 id="application-x-www-urlencoded"><a href="#application-x-www-urlencoded" class="headerlink" title="application/x-www-urlencoded"></a>application/x-www-urlencoded</h4><p>我们在通过 HTTP 向服务器发送 POST 请求提交数据，都是通过 form 表单形式提交的，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FORM</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"http://w.sohu.com"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"txt1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"txt2"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">FORM</span>&gt;</span></span><br></pre></td></tr></table></figure><p>提交时会向服务器端发出这样的数据（已经去除部分不相关的头信息），数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Host: w.sohu.com</span><br><span class="line">Content-Length: 21</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line"> </span><br><span class="line">txt1=hello&amp;txt2=world</span><br></pre></td></tr></table></figure><p>对于普通的 HTML Form POST请求，它会在头信息里使用 <code>Content-Length</code> 注明内容长度。<br>请求头信息每行一条，空行之后便是 Body，即“内容”（entity）。内容的格式是在头信息中的 Content-Type 指定的，如上是 <code>application/x-www-form-urlencoded</code>，这意味着消息内容会经过 URL 格式编码，就像在 GET请 求时 URL 里的 QueryString 那样。<code>txt1=hello&amp;txt2=world</code></p><h4 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h4><p><code>multipart/form-data</code> 定义在 <a href="https://tools.ietf.org/html/rfc2388" target="_blank" rel="noopener">rfc2388</a> 中，最早的 HTTP POST 是不支持文件上传的，给编程开发带来很多问题。但是在1995年，ietf 出台了 rfc1867，也就是《RFC 1867 -Form-based File Upload in HTML》，用以支持文件上传。所以 Content-Type 的类型扩充了multipart/form-data 用以支持向服务器发送二进制数据。因此，发送 POST 请求时候，表单 <form> 属性 enctype 共有二个值可选，这个属性管理的是表单的 MIME 编码：</form></p><p>① application/x-www-form-urlencoded (默认值)<br>② multipart/form-data</p><p>注：form 表单中 enctype 的默认值是 <code>enctype=&quot;application/x- www-form-urlencoded&quot;</code>.</p><p>通过 form 表单提交文件操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;FORM method="POST" action="http://w.sohu.com/t2/upload.do" enctype="multipart/form-data"&gt;</span><br><span class="line">    &lt;INPUT type="text" name="city" value="Santa colo"&gt;</span><br><span class="line">    &lt;INPUT type="text" name="desc"&gt;</span><br><span class="line">    &lt;INPUT type="file" name="pic"&gt;</span><br><span class="line"> &lt;/FORM&gt;</span><br></pre></td></tr></table></figure><p>浏览器将会发送以下数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">POST /t2/upload.do HTTP/1.1</span><br><span class="line">User-Agent: SOHUWapRebot</span><br><span class="line">Accept-Language: zh-cn,zh;q=0.5</span><br><span class="line">Accept-Charset: GBK,utf-8;q=0.7,*;q=0.7</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 60408</span><br><span class="line">Content-Type:multipart/form-data; boundary=ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC</span><br><span class="line">Host: w.sohu.com</span><br><span class="line"></span><br><span class="line">--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC</span><br><span class="line">Content-Disposition: form-data; name=&quot;city&quot;</span><br><span class="line"></span><br><span class="line">Santa colo</span><br><span class="line">--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC</span><br><span class="line">Content-Disposition: form-data;name=&quot;desc&quot;</span><br><span class="line">Content-Type: text/plain; charset=UTF-8</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line">--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC</span><br><span class="line">Content-Disposition: form-data;name=&quot;pic&quot;; filename=&quot;photo.jpg&quot;</span><br><span class="line">Content-Type: application/octet-stream</span><br><span class="line">Content-Transfer-Encoding: binary</span><br><span class="line"> </span><br><span class="line">... binary data of the jpg ...</span><br><span class="line">--ZnGpDtePMx0KrHh_G0X99Yef9r8JZsRJSXC--</span><br></pre></td></tr></table></figure><p>从上面的 <code>multipart/form-data</code> 格式发送的请求的样式来看，它包含了多个 <strong>Parts</strong>，每个 <strong>Part</strong> 都包含头信息部分，<br><strong>Part</strong> 头信息中必须包含一个 <code>Content-Disposition</code> 头，其他的头信息则为可选项， 比如 <code>Content-Type</code> 等。</p><p><strong><code>Content-Disposition</code></strong> 包含了 type 和 一个名字为 name 的 parameter，type 是 form-data，name 参数的值则为表单控件（也即 field）的名字，如果是文件，那么还有一个 filename 参数，值就是文件名。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;user&quot;; filename=&quot;hello.txt&quot;</span><br></pre></td></tr></table></figure><p>上面的 “user” 就是表单中的控件的名字，后面的参数 filename 则是点选的文件名。<br>对于可选的 Content-Type（如果没有的话），默认就是 <code>text/plain</code>。</p><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>如果文件内容是通过填充表单来获得，那么上传的时候，Content-Type 会被自动设置（识别）成相应的格式，如果没法识别，那么就会被设置成 <code>&quot;application/octet-stream&quot;</code><br>如果多个文件被填充成单个表单项，那么它们的请求格式则会是 multipart/mixed。</p><p>如果 Part 的内容跟默认的 encoding 方式不同，那么会有一个 <code>&quot;content-transfer-encoding&quot;</code> 头信息来指定。</p><p>下面，我们填充两个文件到一个表单项中，行程的请求信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=AaB03x</span><br><span class="line"></span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name=&quot;submit-name&quot;</span><br><span class="line"></span><br><span class="line">Larry</span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name=&quot;files&quot;</span><br><span class="line">Content-Type: multipart/mixed; boundary=BbC04y</span><br><span class="line"></span><br><span class="line">--BbC04y</span><br><span class="line">Content-Disposition: file; filename=&quot;file1.txt&quot;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">... contents of file1.txt ...</span><br><span class="line">--BbC04y</span><br><span class="line">Content-Disposition: file; filename=&quot;file2.gif&quot;</span><br><span class="line">Content-Type: image/gif</span><br><span class="line">Content-Transfer-Encoding: binary</span><br><span class="line"></span><br><span class="line">...contents of file2.gif...</span><br><span class="line">--BbC04y--</span><br><span class="line">--AaB03x--</span><br></pre></td></tr></table></figure><h4 id="Boundary-分隔符"><a href="#Boundary-分隔符" class="headerlink" title="Boundary 分隔符"></a>Boundary 分隔符</h4><p>每个部分使用 <code>--boundary</code> 分割开来，最后一行使用 <code>--boundary--</code> 结尾。</p><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>To see exactly what is happening, use nc -l and an user agent like a browser or cURL.</p><p>Save the form to an .html file:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FORM</span> <span class="attr">action</span>=<span class="string">"http://localhost:8000"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"text default"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">INPUT</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">BUTTON</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">BUTTON</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FORM</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Create files to upload:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 'Content of a.txt.' &gt; a.txt</span><br><span class="line">echo '&lt;!DOCTYPE html&gt;&lt;title&gt;Content of a.html.&lt;/title&gt;' &gt; a.html</span><br></pre></td></tr></table></figure><p>Run:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l localhost 8000</span><br></pre></td></tr></table></figure><p>Open the HTML on your browser, select the files and click on submit and check the terminal.</p><p>nc prints the request received. Firefox sent:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: localhost:8000</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:29.0) Gecko/20100101 Firefox/29.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Cookie: __atuvc=34%7C7; permanent=0; _gitlab_session=226ad8a0be43681acf38c2fab9497240; __profilin=p%3Dt; request_method=GET</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: multipart/form-data; boundary=---------------------------9051914041544843365972754266</span><br><span class="line">Content-Length: 554</span><br><span class="line"></span><br><span class="line">-----------------------------9051914041544843365972754266</span><br><span class="line">Content-Disposition: form-data; name=&quot;text&quot;</span><br><span class="line"></span><br><span class="line">text default</span><br><span class="line">-----------------------------9051914041544843365972754266</span><br><span class="line">Content-Disposition: form-data; name=&quot;file1&quot;; filename=&quot;a.txt&quot;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">Content of a.txt.</span><br><span class="line"></span><br><span class="line">-----------------------------9051914041544843365972754266</span><br><span class="line">Content-Disposition: form-data; name=&quot;file2&quot;; filename=&quot;a.html&quot;</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;&lt;title&gt;Content of a.html.&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">-----------------------------9051914041544843365972754266--</span><br></pre></td></tr></table></figure><p>Aternativelly, cURL should send the same POST request as your a browser form:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -l localhost 8000</span><br><span class="line">curl -F "text=default" -F "file1=@a.html" -F "file1=@a.txt" localhost:8000</span><br></pre></td></tr></table></figure><p>You can do multiple tests with:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while true; do printf '' | nc -l localhost 8000; done</span><br></pre></td></tr></table></figure><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a href="https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4" target="_blank" rel="noopener">https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4</a><br><a href="https://stackoverflow.com/questions/4526273/what-does-enctype-multipart-form-data-mean/28380690#28380690" target="_blank" rel="noopener">https://stackoverflow.com/questions/4526273/what-does-enctype-multipart-form-data-mean/28380690#28380690</a><br><a href="https://tools.ietf.org/html/rfc2388" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2388</a><br><a href="https://stackoverflow.com/questions/913626/what-should-a-multipart-http-request-with-multiple-files-look-like" target="_blank" rel="noopener">https://stackoverflow.com/questions/913626/what-should-a-multipart-http-request-with-multiple-files-look-like</a>  </p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言 multipart 库解析</title>
      <link href="/Programming/go-go-multipart/"/>
      <url>/Programming/go-go-multipart/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这篇文章作为上一篇文章的实践篇，在掌握了基本的 HTTP 中的 <code>multipart/form-data</code> 这种格式的请求之后，现在通过 Go 语言的官方 multipart 库来深入理解如何发送和处理 <code>multipart/form-data</code> 格式的请求</p><p>先来看一段客户端请求的代码和一段服务端处理请求的代码</p><h3 id="1-客户端请求"><a href="#1-客户端请求" class="headerlink" title="1. 客户端请求"></a>1. 客户端请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"mime/multipart"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    destURL = <span class="string">"localhost:8080"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> bufReader bytes.Buffer</span><br><span class="line">    mpWriter := multipart.NewWriter(&amp;bufReader)</span><br><span class="line">    fw, err := mpWriter.CreateFormFile(<span class="string">"upload_file"</span>, <span class="string">"a.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Create form file error: "</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    f, _ := os.Open(<span class="string">"a.txt"</span>)</span><br><span class="line">    _, err = io.Copy(fw, f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"copying f %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mpWriter.Write([]<span class="keyword">byte</span>(<span class="string">"this is test file"</span>))</span><br><span class="line">    mpWriter.WriteField(<span class="string">"name"</span>, <span class="string">"Trump"</span>)</span><br><span class="line">    mpWriter.Close()</span><br><span class="line"></span><br><span class="line">    client := &amp;http.Client&#123;</span><br><span class="line">        Timeout: <span class="number">10</span> * time.Second</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// resp, err := http.Post(destURL, writer.FormDataContentType(), bufReader)</span></span><br><span class="line">    </span><br><span class="line">    req, _ := http.NewRequest(<span class="string">"POST"</span>, destURL, bufReader)</span><br><span class="line">    req.Header.Set(<span class="string">"Content-Type"</span>, writer.FormDataContentType())</span><br><span class="line">    req.Header.Set(<span class="string">"Accept"</span> , <span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>)</span><br><span class="line">    req.Header.Set(<span class="string">"Accept-Charset"</span> , <span class="string">"GBK,utf-8;q=0.7,*;q=0.3"</span>)</span><br><span class="line">    req.Header.Set(<span class="string">"Accept-Encoding"</span> , <span class="string">"gzip,deflate,sdch"</span>)</span><br><span class="line">    response,_ := client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> response.StatusCode == <span class="number">200</span> &#123;</span><br><span class="line">        body, _ := ioutil.ReadAll(response.Body)</span><br><span class="line">        bodystr := <span class="keyword">string</span>(body)</span><br><span class="line">        fmt.Println(bodystr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>在 Go 语言中，想要发送一个 <code>multipart/form-data</code> 格式的请求体，可以使用官方提供的 <code>mime/multipart</code> 库的 <strong>Writer</strong>。</p><p>这个 Writer 的如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Writer generates multipart messages.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">struct</span> &#123;</span><br><span class="line">    w        io.Writer</span><br><span class="line">    boundary <span class="keyword">string</span></span><br><span class="line">    lastpart *part</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Writer 结构体的三个成员清晰而简单，对应着 multipart/form-data 格式的 body 的样式。<br>其中 w 是一个我们用来往其中填充 request body 的 buffer writer，boundary 通常是随机生成的 random string，lastpart 就是结尾符 <code>--boundary--</code>，</p><h5 id="创建-multipart-form-data-格式的请求体分为-4-个步骤："><a href="#创建-multipart-form-data-格式的请求体分为-4-个步骤：" class="headerlink" title="创建 multipart/form-data 格式的请求体分为 4 个步骤："></a>创建 <code>multipart/form-data</code> 格式的请求体分为 4 个步骤：</h5><ul><li>(1) 创建 Writer</li><li>(2) 往 Writer 中写入定制化的 Header</li><li>(3) 往 Writer 中写入 body 内容（body 内容可以是文件，也可以是字段列表等内容）</li><li>(4) 写入结尾符 boundary（调用 Writer.Close() 即可）</li></ul><h5 id="1-创建-Writer"><a href="#1-创建-Writer" class="headerlink" title="(1) 创建 Writer"></a>(1) 创建 Writer</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewWriter returns a new multipart Writer with a random boundary,</span></span><br><span class="line"><span class="comment">// writing to w.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(w io.Writer)</span> *<span class="title">Writer</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Writer&#123;</span><br><span class="line">        w:        w,</span><br><span class="line">        boundary: randomBoundary(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-往-Writer-中写入每个-Part-部分的头信息"><a href="#2-往-Writer-中写入每个-Part-部分的头信息" class="headerlink" title="(2) 往 Writer 中写入每个 Part 部分的头信息"></a>(2) 往 Writer 中写入每个 Part 部分的头信息</h5><p>通过调用 <code>w.CreatePart(mimeHeader)</code> 来创建 Part 的头部分</p><p>一个典型的 Part 头部分包含了 boundary 和 Header 部分，其样式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------9051914041544843365972754266</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;a.txt&quot;</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure><p><code>w.CreatePart()</code> 函数就是用来创建上面的内容的，其接受的参数是 MIMEHeader，返回的也是一个 Writer，可以继续往这个 Writer 中写入 body 部分的内容。</p><p>调用 <code>w.CreatePart()</code> 的步骤如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h := <span class="built_in">make</span>(textproto.MIMEHeader)</span><br><span class="line">h.Set(<span class="string">"Content-Disposition"</span>, fmt.Sprintf(<span class="string">`form-data; name="%s"; filename="%s"`</span>, escapeQuotes(fieldname), escapeQuotes(filename)))</span><br><span class="line">h.Set(<span class="string">"Content-Type"</span>, <span class="string">"application/octet-stream"</span>)</span><br><span class="line">w.CreatePart(h)</span><br></pre></td></tr></table></figure><h5 id="3-往-Writer-中写入每个-Part-部分的-Body-内容"><a href="#3-往-Writer-中写入每个-Part-部分的-Body-内容" class="headerlink" title="(3) 往 Writer 中写入每个 Part 部分的 Body 内容"></a>(3) 往 Writer 中写入每个 Part 部分的 Body 内容</h5><p>现在，调用 <code>w.CreatePart()</code> 成功的创建了一个 Part 的头部分，我们还需要往其中写入该 Part 的 Body 部分的内容。根据内容的不同，我们分为两部分：</p><p><strong>&lt;1&gt; Body 内容是文件</strong><br>对于文件，我们可以直接调用 io.Copy(w, f) 往刚才 w.CreatePart() 返回的 Writer 中写入文件内容<br>对于文件流 fileReader，直接调用 <code>io.Copy()</code> 拷贝到 w 中，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(filename)</span><br><span class="line">_, err = io.Copy(w, f)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"copying file to w error: %v"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong><br>本质上，表单都是 key - value 的形式，key 就是控件（field）名，而 value 就是具体的值了，在 Part 的头部信息中我们写入了 key 为 filename，而 value 就是我们要写入的文件内容了。</p><p><strong>提示：</strong><br>对于文件类型的 Part 头部，Go 语言的 <code>multipart.Writer</code> 提供了 <code>CreateFormFile()</code> 函数，其封装了创建该 Part 头部的过程，我们直接调用 w.CreateFromFile() 就可以创建该 Part 的头部内容，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreateFormFile is a convenience wrapper around CreatePart. It creates</span></span><br><span class="line"><span class="comment">// a new form-data header with the provided field name and file name.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Writer)</span> <span class="title">CreateFormFile</span><span class="params">(fieldname, filename <span class="keyword">string</span>)</span> <span class="params">(io.Writer, error)</span></span>&#123;</span><br><span class="line">    h := <span class="built_in">make</span>(textproto.MIMEHeader)</span><br><span class="line">    h.Set(<span class="string">"Content-Disposition"</span>, fmt.Sprintf(<span class="string">`form-data; name="%s"; filename="%s"`</span>, escapeQuotes(fieldname), escapeQuotes(filename)))</span><br><span class="line">    h.Set(<span class="string">"Content-Type"</span>, <span class="string">"application/octet-stream"</span>)</span><br><span class="line">    <span class="keyword">return</span> w.CreatePart(h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&lt;2&gt; Body 内容是 Field 字段</strong><br>对于字段类型，其方法类似文件的处理，先创建 Part 头部，再创建相应的 Body 内容。 <code>multipart.Writer</code> 提供了 <code>CreateFormField()</code> 函数来创建该 Part 头部，其内部也调用了 CreatePart()，最终也是返回一个 Writer，我们可以继续往这个 Writer 中填充 body 内容。</p><p>当然，如果已经有一个 multipart.Writer 的话，可以直接调用其 <strong><code>WriteField()</code></strong> 函数来往里面写入字段， 因为 WriteField() 内部封装了上述的 CreateFormField() 函数，示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    writer := multipart.NewWriter(body)</span><br><span class="line">    </span><br><span class="line">    fields := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">"filename"</span>: filename,</span><br><span class="line">        <span class="string">"age"</span>:      <span class="string">"88"</span>,</span><br><span class="line">        <span class="string">"ip"</span>:       <span class="string">"198.162.5.1"</span>,</span><br><span class="line">        <span class="string">"city"</span>:     <span class="string">"New York"</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> fields &#123;</span><br><span class="line">        _ = writer.WriteField(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>由 multipart 创建的 field 字段，每个 Part 只能有一个 &lt;Key,Value&gt; 对，也就是说，一个部分只能对应一个 field。</p><p>生成的请求样式如下：<br><img src="http://upload-images.jianshu.io/upload_images/1452123-28c9adcb6c048928.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="4-写入结尾符-–boudary–"><a href="#4-写入结尾符-–boudary–" class="headerlink" title="(4) 写入结尾符 –boudary–"></a>(4) 写入结尾符 –boudary–</h5><p>这一步非常重要，如果不写入结尾符，那么服务端收到请求后只能解析第一个 Part。<br>直接调用 multipart.Writer 的 Close() 方法即可写入结尾符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close finishes the multipart message and writes the trailing</span></span><br><span class="line"><span class="comment">// boundary end line to the output.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Writer)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> w.lastpart != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := w.lastpart.<span class="built_in">close</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        w.lastpart = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    _, err := fmt.Fprintf(w.w, <span class="string">"\r\n--%s--\r\n"</span>, w.boundary)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-服务端处理"><a href="#2-服务端处理" class="headerlink" title="2. 服务端处理"></a>2. 服务端处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SimpleHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    contentType := r.Header.Get(<span class="string">"Content-Type"</span>)</span><br><span class="line">    mediatype, _, _ := mime.ParseMediaType(contentType)</span><br><span class="line">    </span><br><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span>)</span><br><span class="line">    <span class="comment">// w.WriteHeader(http.StatusOK)</span></span><br><span class="line">    w.WriteString(<span class="string">"Hello world!"</span>)</span><br><span class="line">    <span class="comment">// w.Write([]byte("This is an example.\n"))</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, IndexHandler)</span><br><span class="line">    http.ListenAndServe(<span class="string">"127.0.0.0:8000"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们拿到 Request 之后可以根据请求头中的 <code>&quot;Content-Type&quot;</code> 来决定如何处理相应的数据。</p><p>比如，有一个请求的 Header 头信息如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /t2/upload.do HTTP/1.1</span><br><span class="line">User-Agent: SOHUWapRebot</span><br><span class="line">Accept-Language: zh-cn,zh;q=0.5</span><br><span class="line">Accept-Charset: GBK,utf-8;q=0.7,*;q=0.7</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 10780</span><br><span class="line">Content-Type:multipart/form-data; boundary=---------------------------9051914041544843365972754266</span><br><span class="line">Host: w.sohu.com</span><br></pre></td></tr></table></figure><p>我们如下解析头部 “Content-Type” 字段，如果是 “multipart/form-data” 则根据 Request 的 body 创建一个 <strong><code>multipart.Reader</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReceiveHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span></span><br><span class="line">    contentType := r.Header.Get("Content-Type")</span><br><span class="line">    mediatype, param, err := mime.ParseMediaType(contentType)</span><br><span class="line">    <span class="keyword">if</span> mediatype == <span class="string">"multipart/form-data"</span> &#123;</span><br><span class="line">        boundary, _ := params[<span class="string">"boundary"</span>]</span><br><span class="line">        reader := multipart.NewReader(r.Body, boundary)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码我们最终通过 NewReader() 函数创建了一个 <strong><code>multipart.Reader</code></strong> 类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewReader creates a new multipart Reader reading from r using the given MIME boundary.</span></span><br><span class="line"><span class="comment">// The boundary is usually obtained from the "boundary" parameter of the message's "Content-Type" header. </span></span><br><span class="line"><span class="comment">// Use mime.ParseMediaType to parse such headers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(r io.Reader, boundary <span class="keyword">string</span>)</span> *<span class="title">Reader</span></span> &#123;</span><br><span class="line">    b := []<span class="keyword">byte</span>(<span class="string">"\r\n--"</span> + boundary + <span class="string">"--"</span>)</span><br><span class="line">    <span class="keyword">return</span> &amp;Reader&#123;</span><br><span class="line">        bufReader:        bufio.NewReaderSize(&amp;stickyErrorReader&#123;r: r&#125;, peekBufferSize),</span><br><span class="line">        nl:               b[:<span class="number">2</span>],</span><br><span class="line">        nlDashBoundary:   b[:<span class="built_in">len</span>(b)<span class="number">-2</span>],</span><br><span class="line">        dashBoundaryDash: b[<span class="number">2</span>:],</span><br><span class="line">        dashBoundary:     b[<span class="number">2</span> : <span class="built_in">len</span>(b)<span class="number">-2</span>],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，Request 结构体提供了一个 <code>MultipartReader()</code> 来简化上述的步骤，其源码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">MultipartReader</span><span class="params">()</span> <span class="params">(*multipart.Reader, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.MultipartForm == multipartByReader &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"http: MultipartReader called twice"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> r.MultipartForm != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"http: multipart handled by ParseMultipartForm"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    r.MultipartForm = multipartByReader</span><br><span class="line">    <span class="keyword">return</span> r.multipartReader()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span> <span class="title">multipartReader</span><span class="params">()</span> <span class="params">(*multipart.Reader, error)</span></span> &#123;</span><br><span class="line">    v := r.Header.Get(<span class="string">"Content-Type"</span>)</span><br><span class="line">    <span class="keyword">if</span> v == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrNotMultipart</span><br><span class="line">    &#125;</span><br><span class="line">    d, params, err := mime.ParseMediaType(v)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || d != <span class="string">"multipart/form-data"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrNotMultipart</span><br><span class="line">    &#125;</span><br><span class="line">    boundary, ok := params[<span class="string">"boundary"</span>]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrMissingBoundary</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> multipart.NewReader(r.Body, boundary), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看 <strong>multipart.Reader</strong> 的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reader is an iterator over parts in a MIME multipart body.</span></span><br><span class="line"><span class="comment">// Reader's underlying parser consumes its input as needed. Seeking isn't supported.</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">    bufReader *bufio.Reader</span><br><span class="line"></span><br><span class="line">    currentPart *Part</span><br><span class="line">    partsRead   <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    nl               []<span class="keyword">byte</span> <span class="comment">// "\r\n" or "\n" (set after seeing first boundary line)</span></span><br><span class="line">    nlDashBoundary   []<span class="keyword">byte</span> <span class="comment">// nl + "--boundary"</span></span><br><span class="line">    dashBoundaryDash []<span class="keyword">byte</span> <span class="comment">// "--boundary--"</span></span><br><span class="line">    dashBoundary     []<span class="keyword">byte</span> <span class="comment">// "--boundary"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h5><p>通过 <strong>Reader</strong> 结构体的成员构成我们再一次来理解 <code>multipart/form-data</code> 格式的请求体。<br>其中，这个结构体主要包含了 bufReader，currentPart, 和 boundar 的定义。</p><ul><li>bufReader 就对应 Writer 结构体中的 w，从 w 中读取内容。</li><li>currentPart 是一个指向 Part 类型的指针，顾名思义，Part 类型代表了 multipart 中的每个 Part。</li><li>boudary 变量则定义了 Part 之间的边界标识符以及结束符。</li></ul><p>下面来看 Part 结构体的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Part represents a single part in a multipart body.</span></span><br><span class="line"><span class="keyword">type</span> Part <span class="keyword">struct</span> &#123;</span><br><span class="line">    Header textproto.MIMEHeader</span><br><span class="line"></span><br><span class="line">    mr *Reader</span><br><span class="line"></span><br><span class="line">    disposition       <span class="keyword">string</span></span><br><span class="line">    dispositionParams <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// r is either a reader directly reading from mr, or it's a</span></span><br><span class="line">    <span class="comment">// wrapper around such a reader, decoding the</span></span><br><span class="line">    <span class="comment">// Content-Transfer-Encoding</span></span><br><span class="line">    r io.Reader</span><br><span class="line"></span><br><span class="line">    n       <span class="keyword">int</span>   <span class="comment">// known data bytes waiting in mr.bufReader</span></span><br><span class="line">    total   <span class="keyword">int64</span> <span class="comment">// total data bytes read already</span></span><br><span class="line">    err     error <span class="comment">// error to return when n == 0</span></span><br><span class="line">    readErr error <span class="comment">// read error observed from mr.bufReader</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个如下请求体的 Part，从 <code>Content-Disposition</code> 我们可以看到它是一个文件类型的 Part，<br>文件内容的部分都是不可打印字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--49d03132746bfd98bffc0be04783d061e8acaeec7e0054b4bea84fc0ea2c</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;husky.jpg&quot;</span><br><span class="line">Content-Type: application/octet-stream</span><br><span class="line"></span><br><span class="line">JFIF    ( %!%)+...383,7(-.+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--++++--+-++++-+++--+------+--7---+77-+--+++7++++76!1AQa&quot;qB</span><br><span class="line">BHf[tTN4t&apos;(4&quot;?i\m=,52ʺ1Nf%* OCW6jWIlWZ.P3&lt;+7V9u᪖</span><br><span class="line">jeIp=z-v$_e\YZω4 CvXdY(՗8wHv%:hֽ`ԯ 1*6L+X3\9   i)z</span><br><span class="line">?K&#123;j</span><br><span class="line">K&#123;@)9&gt;$#r&apos;gE⺍-CA1V&#123;qZٰ,^SdIdWu;e\1KJJЭ</span><br><span class="line">-G(&apos;db&#125;HaHVKmU521XRjc|dFO1fY[ \WYpF9`&#125;e</span><br></pre></td></tr></table></figure><p>Part 结构体的 Header 成员就对应了 boundary 下面的 <code>Content-Disposition</code>，<code>Content-Type</code> 等属性，空过一个换行之后就是文件内容。</p><p>通过调用 Reader 的 <strong>NextPart()</strong> 函数，我们可以遍历一个 multipart 请求体中所有的 Part，其实现如下（已简化）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">NextPart</span><span class="params">()</span> <span class="params">(*Part, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r.currentPart != <span class="literal">nil</span> &#123;</span><br><span class="line">        r.currentPart.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        line, err := r.bufReader.ReadSlice(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> r.isBoundaryDelimiterLine(line) &#123;</span><br><span class="line">            r.partsRead++</span><br><span class="line">            bp, err := newPart(r)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">            r.currentPart = bp</span><br><span class="line">            <span class="keyword">return</span> bp, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> r.isFinalBoundary(line) &#123;</span><br><span class="line">            <span class="comment">// Expected EOF</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, io.EOF</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"multipart: unexpected line in Next(): %q"</span>, line)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全文完！</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NPM in deep</title>
      <link href="/Web/web-npm-in-deep/"/>
      <url>/Web/web-npm-in-deep/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文介绍 NPM 的工作流程及原理，这样以后遇到问题时就会游刃有余。本文主要内容来源于作者 rianma 于 2018 年 3 月写的<a href="https://myan.im/2018/03/24/you-dont-know-npm/" target="_blank" rel="noopener">一篇文章</a>，很有深度，非常具有实践意义，因此转载加工于此。</p><h4 id="1-npm-init"><a href="#1-npm-init" class="headerlink" title="1. npm init"></a>1. npm init</h4><p>我们都知道 package.json 文件是用来定义一个 package 的描述文件, </p><p>在项目根目录中执行 npm init 时，会创建 package.json 文件，这个文件指定了该项目的一些信息，包括依赖的第三方库。<br>注：如果想免去交互式创建过程，在命令后追加 –yes 参数即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init --yes</span><br></pre></td></tr></table></figure><p>npm init 命令的执行原理很简单，就是调用脚本（我们可以自定义这个脚本）并输出一个初始化的 package.json 文件。</p><p>所以，实现自定义很简单，在 Home 目录创建一个 .npm-init.js 即可，该文件的 module.exports 即为 package.json 文件中的配置内容。对于需要获取用户输入的选项，调用 prompt() 方法即可获取。</p><p>下面是一个样例 <em>~/.npm-init.js</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> desc = prompt(<span class="string">'description?'</span>, <span class="string">'A new package...'</span>)</span><br><span class="line"><span class="keyword">const</span> bar = prompt(<span class="string">'bar?'</span>, <span class="string">''</span>)</span><br><span class="line"><span class="keyword">const</span> count = prompt(<span class="string">'count?'</span>, <span class="string">'42'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  key: <span class="string">'value'</span>,</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: bar,</span><br><span class="line">    count: count</span><br><span class="line">  &#125;,</span><br><span class="line">  name: prompt(<span class="string">'name?'</span>, process.cwd().split(<span class="string">'/'</span>).pop()),</span><br><span class="line">  version: prompt(<span class="string">'version?'</span>, <span class="string">'0.1.0'</span>),</span><br><span class="line">  description: desc,</span><br><span class="line">  main: <span class="string">'index.js'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时在 <em>~/hello</em> 目录下执行 <code>npm init</code> 将会得到这样的 package.json:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"key"</span>: <span class="string">"value"</span>,</span><br><span class="line">  <span class="attr">"foo"</span>: &#123;</span><br><span class="line">    <span class="attr">"bar"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"count"</span>: <span class="string">"42"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hello"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"A new package..."</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制代码除了生成 package.json, 因为 .npm-init.js 是一个常规的模块，意味着我们可以执行随便什么 node 脚本可以执行的任务。例如通过 fs 创建 README, .eslintrc 等项目必需文件，实现项目脚手架的作用。</p><h4 id="2、依赖包安装"><a href="#2、依赖包安装" class="headerlink" title="2、依赖包安装"></a>2、依赖包安装</h4><p>依赖管理是 npm 的核心功能。通常，在执行项目时，需要先执行 npm install，它会把 package.json 中指定的依赖（ dependencies, devDependencies ）下载并安装到当前目录的 ./node_modules 目录中（如果没有该目录则会创建）。否则缺少依赖的话，项目会执行失败。</p><p>package.json 文件中有 Dependencies 和 devDependencies 两个项，默认是 Production 模式，也就是 Dependencies，开发模式（Development ）下则是 devDependencies，<br>注：如果 npm install 时指定了 –save-dev（或 -D）选项，那么会在当前项目的 package.json 文件中的 devDependencies {} 中添加该依赖。</p><p><strong>package定义</strong><br>我们都知道要手动安装一个包时，执行 <code>npm install &lt;package&gt;</code> 命令即可。这里的第三个参数 package 通常就是我们所要安装的包名，默认配置下 npm 会从默认的源 (Registry) 中查找该包名对应的包地址，并下载安装。但在 npm 的世界里，除了简单的指定包名, package 还可以是一个指向有效包名的 http, url/git, url/dir_path。<br>阅读 npm的文档， 我们会发现 package 准确的定义，只要符合以下 a) 到 g) 其中之一条件，就是一个 package:</p><p>a) 一个包含了程序和描述该程序的 package.json 文件的文件夹<br>例子：./local-module/</p><p>b) 一个包含了 (a) 的 gzip 压缩文件<br>例子：./module.tar.gz</p><p>c) 一个可以下载得到 (b) 资源的 url (通常是 http(s) url)<br><code>https://registry.npmjs.org/webpack/-/webpack-4.1.0.tgz</code></p><p>d) 一个格式为 <name>@<version> 的字符串，可指向 npm 源(通常是官方源 npmjs.org)上已发布的可访问 url，且该 url 满足条件 (c)<br>例子：<code>webpack@4.1.0</code></version></name></p><p>e) 一个格式为 <name>@<tag> 的字符串，在 npm 源上该<tag>指向某 <version> 得到 <name>@<version>，后者满足条件 (d)<br>例子：<code>webpack@latest</code></version></name></version></tag></tag></name></p><p>f) 一个格式为 <name> 的字符串，默认添加 latest 标签所得到的 <name>@latest 满足条件 (e)<br>例子：webpack</name></name></p><p>g) 一个 git url, 该 url 所指向的代码库满足条件 (a)<br>例子：<code>git@github.com:webpack/webpack.git</code></p><p><strong>安装本地包/远程 git 仓库包</strong><br>上面表格的定义意味着，我们在共享依赖包时，并不是非要将包发表到 npm 源上才可以提供给使用者来安装。这对于私有的不方便 publish 到远程源（即使是私有源），或者需要对某官方源进行改造，但依然需要把包共享出去的场景来说非常实用。</p><p><strong>场景1: 本地模块引用</strong><br>nodejs 应用开发中不可避免有模块间调用，例如在实践中经常会把需要被频繁引用的配置模块放到应用根目录；于是在创建了很多层级的目录、文件后，很可能会遇到这样的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../../../../config.js'</span>);</span><br></pre></td></tr></table></figure><p>上面的代码除了看上去很丑以外，这样的路径引用也不利于代码的重构。并且身为程序员的自我修养告诉我们，这样重复的代码多了也就意味着是时候把这个模块分离出来供应用内其他模块共享了。例如这个例子里的 config.js 非常适合封装为 package 放到 node_modules 目录下，共享给同应用内其他模块。</p><p>实际上，无需手动拷贝文件或者创建软链接到 node_modules 目录，npm 有更优雅的解决方案。</p><p><strong>解决方案</strong></p><p>1）创建 config 包<br>新增 config 文件夹; 重命名 config.js 为 config/index.js 文件; 创建 package.json 定义 config 包</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"config"</span>,</span><br><span class="line">    <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.1.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）在应用层 package.json 文件中新增依赖项，然后执行 <code>npm install</code>; 或直接执行第 3 步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;dependencies&quot;: &#123;</span><br><span class="line">        &quot;config&quot;: &quot;file:./config&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）直接在应用目录执行 <code>npm install file:./config</code>，这种方式等价于第 2 步。</p><p>此时，查看 node_modules 目录我们会发现多出来一个名为 config，指向上层 config/ 文件夹的软链接。这是因为 npm 识别 file: 协议的 url，得知这个包需要直接从文件系统中获取，会自动创建软链接到 node_modules 中，完成“安装”过程。<br>相比手动软链，我们既不需要关心 windows 和 linux 命令差异，又可以显式地将依赖信息固化到 dependencies 字段中，开发团队其他成员可以执行 <code>npm install</code> 后直接使用。</p><p><strong>场景2: 私有 git 共享 package</strong><br>有些时候，我们一个团队内会有一些代码或者公用库需要在团队内不同项目间共享，但可能由于包含了敏感内容，或者代码太烂拿不出手等原因，不方便发布到源。<br>这种情况下，我们可以简单地将被依赖的包托管在私有的 git 仓库中，然后将该 git url 保存到 dependencies 中. npm 会直接调用系统的 git 命令从 git 仓库拉取包的内容到 node_modules 中。</p><p>[npm 支持的 git url 格式][<a href="https://docs.npmjs.com/files/package.json#git-urls-as-dependencies]" target="_blank" rel="noopener">https://docs.npmjs.com/files/package.json#git-urls-as-dependencies]</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;protocol&gt;://[&lt;user&gt;[:&lt;password&gt;]@]&lt;hostname&gt;[:&lt;port&gt;][:][/]&lt;path&gt;[#&lt;commit-ish&gt; | #semver:&lt;semver&gt;]</span><br></pre></td></tr></table></figure><p>git 路径后可以使用 # 指定特定的 <code>git branch/commit/tag</code>, 也可以 #semver: 指定特定的 <code>semver range</code>.</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git+ssh://git@github.com:npm/npm.git#v1.0.27</span><br><span class="line">git+ssh://git@github.com:npm/npm#semver:^5.0</span><br><span class="line">git+https://isaacs@github.com/npm/npm.git</span><br><span class="line">git://github.com/npm/npm.git#v1.0.27</span><br></pre></td></tr></table></figure><p><strong>场景3: 开源 package 问题修复</strong><br>使用某个 npm 包时发现它有某个严重 bug，但也许最初作者已不再维护代码了，也许我们工作紧急，没有足够的时间提 issue 给作者再慢慢等作者发布新的修复版本到 npm 源。<br>此时我们可以手动进入 node_modules 目录下修改相应的包内容，也许修改了一行代码就修复了问题。</p><p>但是这种做法非常不明智！<br>首先 node_modules 本身不应该放进版本控制系统，对 node_modules 文件夹中内容的修改不会被记录进 git 提交记录；其次，就算我们非要反模式，把 node_modules 放进版本控制中，你的修改内容也很容易在下次 team 中某位成员执行 npm install 或 npm update 时被覆盖，而这样的一次提交很可能包含了几十几百个包的更新，你自己所做的修改很容易就被淹没在庞大的 diff 文件列表中了。</p><p><strong>解决方案</strong><br>最好的办法应当是 fork 原作者的 git 库，在自己所属的 repo 下修复问题后，将 dependencies 中相应的依赖项更改为自己修复后版本的 git url 即可解决问题。（Fork 代码库后，也便于向原作者提交 PR 修复问题。上游代码库修复问题后，再次更新我们的依赖配置也不迟。）</p><h4 id="3、node-modules-目录结构解析"><a href="#3、node-modules-目录结构解析" class="headerlink" title="3、node_modules 目录结构解析"></a>3、node_modules 目录结构解析</h4><p><code>npm install</code> 执行完毕后，我们可以在 node_modules 中看到所有依赖的包。虽然使用者无需关注这个目录里的文件夹结构细节，只管在业务代码中引用依赖包即可，但了解 node_modules 的内容可以帮我们更好理解 npm 如何工作，了解从 npm 2 到 npm 5 有哪些变化和改进。<br>为简单起见，我们假设应用目录为 app, 用两个流行的包 webpack, nconf 作为依赖包做示例说明。并且为了正常安装，使用了“上古” npm 2 时期的版本 webpack<i></i>@1.15.0, nconf<i></i>@0.8.5.</p><p><strong>npm 2</strong><br>npm 2 在安装依赖包时，采用简单的递归安装方法。执行 <code>npm install</code> 后，npm 2 依次递归安装 webpack 和 nconf 两个包到 node_modules 中。执行完毕后，我们会看到 ./node_modules 这层目录只含有这两个子目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node_modules/</span><br><span class="line">├── nconf/</span><br><span class="line">└── webpack/</span><br></pre></td></tr></table></figure><p>进入更深一层 nconf 或 webpack 目录，将看到这两个包各自的 node_modules 中，已经由 npm 递归地安装好自身的依赖包。包括 ./node_modules/webpack/node_modules/webpack-core , ./node_modules/conf/node_modules/async 等等。而每一个包都有自己的依赖包，每个包自己的依赖都安装在了自己的 node_modules 中。依赖关系层层递进，构成了一整个依赖树，这个依赖树与文件系统中的文件结构树刚好层层对应。<br>最方便的查看依赖树的方式是直接在 app 目录下执行 <code>npm ls</code> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">app@0.1.0</span><br><span class="line">├─┬ nconf@0.8.5</span><br><span class="line">│ ├── async@1.5.2</span><br><span class="line">│ ├── ini@1.3.5</span><br><span class="line">│ ├── secure-keys@1.0.0</span><br><span class="line">│ └── yargs@3.32.0</span><br><span class="line">└─┬ webpack@1.15.0</span><br><span class="line">  ├── acorn@3.3.0</span><br><span class="line">  ├── async@1.5.2</span><br><span class="line">  ├── clone@1.0.3</span><br><span class="line">  ├── ...</span><br><span class="line">  ├── optimist@0.6.1</span><br><span class="line">  ├── supports-color@3.2.3</span><br><span class="line">  ├── tapable@0.1.10</span><br><span class="line">  ├── uglify-js@2.7.5</span><br><span class="line">  ├── watchpack@0.2.9</span><br><span class="line">  └─┬ webpack-core@0.6.9</span><br><span class="line">    ├── source-list-map@0.1.8</span><br><span class="line">    └── source-map@0.4.4</span><br></pre></td></tr></table></figure><p>这样的目录结构优点在于层级结构明显，便于进行傻瓜式的管理:</p><p>例如新装一个依赖包，可以立即在第一层 node_modules 中看到子目录<br>在已知所需包名和版本号时，甚至可以从别的文件夹手动拷贝需要的包到 node_modules 文件夹中，再手动修改 package.json 中的依赖配置<br>要删除这个包，也可以简单地手动删除这个包的子目录，并删除 package.json 文件中相应的一行即可</p><p>实际上，很多人在 npm 2 时代也的确都这么实践过，的确也都可以安装和删除成功，并不会导致什么差错。<br>但这样的文件结构也有很明显的问题，那就是，</p><p>1）对于复杂的工程, node_modules 内目录结构可能会太深，导致深层的文件路径过长而触发 windows 文件系统中，文件路径不能超过 260 个字符长的错误。<br>2）部分被多个包所依赖的包，很可能在应用 node_modules 目录中的很多地方被重复安装。随着工程规模越来越大，依赖树越来越复杂，这样的包情况会越来越多，造成大量的冗余。</p><p>比如，在我们的示例中就有这个问题，webpack 和 nconf 都依赖 async 这个包，所以在文件系统中，webpack 和 nconf 的 node_modules 子目录中都安装了相同的 async 包，并且是相同的版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------------------+</span><br><span class="line">|                   app/                    |</span><br><span class="line">+----------+------------------------+-------+</span><br><span class="line">           |                        |</span><br><span class="line">           |                        |</span><br><span class="line">+----------v------+       +---------v-------+</span><br><span class="line">|                 |       |                 |</span><br><span class="line">|  webpack@1.15.0 |       |  nconf@0.8.5    |</span><br><span class="line">|                 |       |                 |</span><br><span class="line">+--------+--------+       +--------+--------+</span><br><span class="line">         |                         |</span><br><span class="line">   +-----v-----+             +-----v-----+</span><br><span class="line">   |async@1.5.2|             |async@1.5.2|</span><br><span class="line">   +-----------+             +-----------+</span><br></pre></td></tr></table></figure><p><strong>npm 3 - 扁平结构</strong><br>主要为了解决以上问题，npm 3 的 node_modules 目录改成了更加扁平状的层级结构。文件系统中 webpack, nconf, async 的层级关系变成了平级关系，处于同一级目录中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------+</span><br><span class="line">         |                   app/                    |</span><br><span class="line">         +-+---------------------------------------+-+</span><br><span class="line">           |                                       |</span><br><span class="line">           |                                       |</span><br><span class="line">+----------v------+    +-------------+   +---------v-------+</span><br><span class="line">|                 |    |             |   |                 |</span><br><span class="line">|  webpack@1.15.0 |    | async@1.5.2 |   |  nconf@0.8.5    |</span><br><span class="line">|                 |    |             |   |                 |</span><br><span class="line">+-----------------+    +-------------+   +-----------------+</span><br></pre></td></tr></table></figure><p>虽然这样一来 webpack/node_modules 和 nconf/node_modules 中都不再有 async 文件夹，但得益于 node 的模块加载机制，他们都可以在上一级 node_modules 目录中找到 async 库。所以 webpack 和 nconf 的库代码中 require(‘async’) 语句的执行都不会有任何问题。<br>这只是最简单的例子，实际的工程项目中，依赖树不可避免地会有很多层级，很多依赖包，其中会有很多同名但版本不同的包存在于不同的依赖层级，对这些复杂的情况, npm 3 都会在安装时遍历整个依赖树，计算出最合理的文件夹安装方式，使得所有被重复依赖的包都可以去重安装。</p><p>npm 文档提供了更直观的例子解释这种情况：</p><p>1）假如 package{dep} 写法代表包和包的依赖，那么  A{B,C}, B{C}, C{D} 的依赖结构在安装之后的 node_modules 是这样的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">+-- B</span><br><span class="line">+-- C</span><br><span class="line">+-- D</span><br></pre></td></tr></table></figure><p>注：这里之所以 D 也安装到了与 B C 同一级目录，是因为 npm 会默认会在无冲突的前提下，尽可能将包安装到较高的层级。</p><p>2）如果是 A{B,C}, B{C,D@1}, C{D@2} 的依赖关系，得到的安装后结构是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">+-- B</span><br><span class="line">+-- C</span><br><span class="line">   `-- D@2</span><br><span class="line">+-- D@1</span><br></pre></td></tr></table></figure><p>这里是因为，对于 npm 来说同名但不同版本的包是两个独立的包，而同层不能有两个同名子目录，所以其中的 D@2 放到了 C 的子目录而另一个 D@1 被放到了再上一层目录。<br>很明显在 npm 3 之后 npm 的依赖树结构不再与文件夹层级一一对应了。想要查看 app 的直接依赖项，要通过 npm ls 命令指定 –depth 参数来查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ls --depth 1</span><br></pre></td></tr></table></figure><p>注: 与本地依赖包不同，如果我们通过 <code>npm install --global</code> 全局安装包到全局目录时，得到的目录依然是“传统的”目录结构。而如果使用 npm 3 想要得到“传统”形式的本地 node_modules 目录，使用 <code>npm install --global-style</code> 命令即可。</p><p><strong>npm 5 - package-lock.json 文件</strong><br>npm 5 发布于 2017 年也是目前最新的 npm 版本，这一版本依然沿用 npm 3 之后扁平化的依赖包安装方式，此外最大的变化是增加了 package-lock.json 文件。</p><p>package-lock.json 的作用是锁定依赖安装结构，如果查看这个 json 的结构，会发现与 node_modules 目录的文件层级结构是一一对应的。<br>以依赖关系为: app{webpack} 的 ‘app’ 项目为例, 其 package-lock 文件包含了这样的片段。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>:  <span class="string">"app"</span>,</span><br><span class="line">    <span class="attr">"version"</span>:  <span class="string">"0.1.0"</span>,</span><br><span class="line">    <span class="attr">"lockfileVersion"</span>:  <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"requires"</span>:  <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">        // ... 其他依赖包</span><br><span class="line">        "webpack": &#123;</span><br><span class="line">            "version": "1.8.11",</span><br><span class="line">            "resolved": "https://registry.npmjs.org/webpack/-/webpack-1.8.11.tgz",</span><br><span class="line">            "integrity": "sha1-Yu0hnstBy/qcKuanu6laSYtgkcI=",</span><br><span class="line">            "requires": &#123;</span><br><span class="line">                "async": "0.9.2",</span><br><span class="line">                "clone": "0.1.19",</span><br><span class="line">                "enhanced-resolve": "0.8.6",</span><br><span class="line">                "esprima": "1.2.5",</span><br><span class="line">                "interpret": "0.5.2",</span><br><span class="line">                "memory-fs": "0.2.0",</span><br><span class="line">                "mkdirp": "0.5.1",</span><br><span class="line">                "node-libs-browser": "0.4.3",</span><br><span class="line">                "optimist": "0.6.1",</span><br><span class="line">                "supports-color": "1.3.1",</span><br><span class="line">                "tapable": "0.1.10",</span><br><span class="line">                "uglify-js": "2.4.24",</span><br><span class="line">                "watchpack": "0.2.9",</span><br><span class="line">                "webpack-core": "0.6.9"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        "webpack-core": &#123;</span><br><span class="line">            "version": "0.6.9",</span><br><span class="line">            "resolved": "https://registry.npmjs.org/webpack-core/-/webpack-core-0.6.9.tgz",</span><br><span class="line">            "integrity": "sha1-/FcViMhVjad76e+23r3Fo7FyvcI=",</span><br><span class="line">            "requires": &#123;</span><br><span class="line">                "source-list-map": "0.1.8",</span><br><span class="line">                "source-map": "0.4.4"</span><br><span class="line">            &#125;,</span><br><span class="line">            "dependencies": &#123;</span><br><span class="line">                "source-map": &#123;</span><br><span class="line">                    "version": "0.4.4",</span><br><span class="line">                    "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.4.4.tgz",</span><br><span class="line">                    "integrity": "sha1-66T12pwNyZneaAMti092FzZSA2s=",</span><br><span class="line">                    "requires": &#123;</span><br><span class="line">                        "amdefine": "1.0.1"</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        //... 其他依赖包</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看懂 package-lock 文件并不难，其结构是同样类型的几个字段嵌套起来的，主要是 version, resolved, integrity, requires, dependencies 这几个字段而已。</p><p>version, resolved, integrity 用来记录包的准确版本号、内容hash、安装源的，决定了要安装的包的准确“身份”信息<br>假设盖住其他字段，只关注文件中的 dependencies: {} 我们会发现，整个文件的 JSON 配置里的 dependencies 层次结构与文件系统中 node_modules 的文件夹层次结构是完全对照的<br>只关注 requires: {} 字段又会发现，除最外层的 requires 属性为 true 以外, 其他层的 requires 属性都对应着这个包的 package.json 里记录的自己的依赖项</p><p>因为这个文件记录了 node_modules 里所有包的结构、层级和版本号甚至安装源，它也就事实上提供了 “保存” node_modules 状态的能力。只要有这样一个 lock 文件，不管在那一台机器上执行 npm install 都会得到完全相同的 node_modules 结果。<br>这就是 package-lock 文件致力于优化的场景：在从前仅仅用 package.json 记录依赖，由于 semver range 的机制；一个月前由 A 生成的 package.json 文件，B 在一个月后根据它执行 npm install 所得到的 node_modules 结果很可能许多包都存在不同的差异，虽然 semver 机制的限制使得同一份 package.json 不会得到大版本不同的依赖包，但同一份代码在不同环境安装出不同的依赖包，依然是可能导致意外的潜在因素。<br>相同作用的文件在 npm 5 之前就有，称为 npm shrinkwrap 文件，二者作用完全相同，不同的是后者需要手动生成，而 npm 5 默认会在执行 npm install 后就生成 package-lock 文件，并且建议你提交到 git/svn 代码库中。<br>package-lock.json 文件在最初 npm 5.0 默认引入时也引起了相当大的争议。在 npm 5.0 中，如果已有 package-lock 文件存在，若手动在 package.json 文件新增一条依赖，再执行 npm install, 新增的依赖并不会被安装到 node_modules 中, package-lock.json 也不会做相应的更新。这样的表现与使用者的自然期望表现不符。在 npm 5.1 的首个 Release 版本中这个问题得以修复。这个事情告诉我们，要升级，不要使用 5.0。<br>——但依然有反对的声音认为 package-lock 太复杂，对此 npm 也提供了禁用配置：<br>npm config set package-lock false</p><h4 id="4、依赖包版本管理"><a href="#4、依赖包版本管理" class="headerlink" title="4、依赖包版本管理"></a>4、依赖包版本管理</h4><p>依赖包安装完并不意味着就万事大吉了，版本的维护和更新也很重要。这一章介绍依赖包升级管理相关知识，太长不看版本请直接跳到下面的[最佳实践]部分。</p><p><strong>semver</strong><br>npm 依赖管理的一个重要特性是采用了语义化版本 (semver) 规范，作为依赖版本管理方案。<br>semver 约定一个包的版本号必须包含3个数字，格式必须为 MAJOR.MINOR.PATCH, 意为 主版本号.小版本号.修订版本号.</p><p>MAJOR 对应大的版本号迭代，做了不兼容旧版的修改时要更新 MAJOR 版本号<br>MINOR 对应小版本迭代，发生兼容旧版API的修改或功能更新时，更新MINOR版本号<br>PATCH 对应修订版本号，一般针对修复 BUG 的版本号</p><p>对于包作者（发布者），npm 要求在 publish 之前，必须更新版本号。npm 提供了 npm version 工具，执行 npm version major|minor|patch 可以简单地将版本号中相应的数字加1.</p><blockquote></blockquote><p>如果包是一个 git 仓库，<code>npm version</code> 还会自动创建一条注释为更新后版本号的 <code>git commit</code> 和名为该版本号的 tag</p><p>对于包的引用者来说，我们需要在 dependencies 中使用 semver 约定的 semver range 指定所需依赖包的版本号或版本范围。npm 提供了网站 <a href="https://semver.npmjs.com" target="_blank" rel="noopener">https://semver.npmjs.com</a> 可方便地计算所输入的表达式的匹配范围。常用的规则示例如下表：</p><p>^2.2.1<br>指定的 MAJOR 版本号下, 所有更新的版本匹配 2.2.3, 2.3.0; 不匹配 1.0.3, 3.0.1</p><p>~2.2.1<br>指定 MAJOR.MINOR 版本号下，所有更新的版本 匹配 2.2.3, 2.2.9 ; 不匹配 2.3.0, 2.4.5</p><p>&gt;=2.1<br>版本号大于或等于 2.1.0 匹配 2.1.2, 3.1</p><p>&lt;=2.2<br>版本号小于或等于 2.2 匹配 1.0.0, 2.2.1, 2.2.11</p><p>1.0.0 - 2.0.0<br>版本号从 1.0.0 (含) 到 2.0.0 (含)<br>匹配 1.0.0, 1.3.4, 2.0.0</p><p><strong>版本规则解释</strong><br>任意两条规则，用空格连接起来，表示“与”逻辑，即两条规则的交集:<br>如 &gt;=2.3.1 &lt;=2.8.0 可以解读为: &gt;=2.3.1 且 &lt;=2.8.0</p><p>可以匹配 2.3.1, 2.4.5, 2.8.0<br>但不匹配 1.0.0, 2.3.0, 2.8.1, 3.0.0</p><p>任意两条规则，通过 || 连接起来，表示“或”逻辑，即两条规则的并集:<br>如 ^2 &gt;=2.3.1 || ^3 &gt;3.2</p><p>可以匹配  2.3.1, 2,8.1, 3.3.1<br>但不匹配 1.0.0, 2.2.0, 3.1.0, 4.0.0</p><p>PS: 除了这几种，还有如下更直观的表示版本号范围的写法:</p><ul><li>或 x 匹配所有主版本<br>1 或 1.x 匹配 主版本号为 1 的所有版本</li></ul><p>1.2 或 1.2.x 匹配 版本号为 1.2 开头的所有版本</p><p>PPS: 在常规仅包含数字的版本号之外，semver 还允许在 MAJOR.MINOR.PATCH 后追加 - 后跟点号分隔的标签，作为预发布版本标签 - Prerelese Tags，通常被视为不稳定、不建议生产使用的版本。例如：</p><p>1.0.0-alpha<br>1.0.0-beta.1<br>1.0.0-rc.3</p><p>上表中我们最常见的是 ^1.8.11 这种格式的 range, 因为我们在使用 npm install <package name=""> 安装包时，npm 默认安装当前最新版本，例如 1.8.11, 然后在所安装的版本号前加^号, 将 ^1.8.11 写入 package.json 依赖配置，意味着可以匹配 1.8.11 以上，2.0.0 以下的所有版本。</package></p><p><strong>依赖版本升级</strong><br>问题来了，在安装完一个依赖包之后有新版本发布了，如何使用 npm 进行版本升级呢？——答案是简单的 npm install 或 npm update，但在不同的 npm 版本，不同的 package.json, package-lock.json 文件，安装/升级的表现也不同。<br>我们不妨还以 webpack 举例，做如下的前提假设:</p><ul><li>我们的工程项目 app 依赖 webpack</li><li>项目最初初始化时，安装了当时最新的包 <a href="mailto:webpack@1.8.0" target="_blank" rel="noopener">webpack@1.8.0</a>，并且 package.json 中的依赖配置为: “webpack”: “^1.8.0”</li><li>当前（2018 年 3 月） webpack 最新版本为 4.2.0, webpack 1.x 最新子版本为 1.15.0</li></ul><p>如果我们使用的是 npm 3, 并且项目不含 package-lock.json, 那么根据 node_modules 是否为空，执行 install/update 的结果如下 (node 6.13.1, npm 3.10.10 环境下试验):</p><table><thead><tr><th>#</th><th>package.json(BEFORE)</th><th>node_modules(BEFORE)</th><th>command(npm 3)</th><th>package.json(AFTER)</th><th>node_modules(AFTER)</th></tr></thead><tbody><tr><td>a)</td><td>webpack: ^1.8.0</td><td><a href="mailto:webpack@1.8.0" target="_blank" rel="noopener">webpack@1.8.0</a></td><td>install</td><td>webpack: ^1.8.0</td><td><a href="mailto:webpack@1.8.0" target="_blank" rel="noopener">webpack@1.8.0</a></td></tr><tr><td>b)</td><td>webpack: ^1.8.0</td><td>空</td><td>install</td><td>webpack: ^1.8.0</td><td><a href="mailto:webpack@1.15.0" target="_blank" rel="noopener">webpack@1.15.0</a>.</td></tr><tr><td>c)</td><td>webpack: ^1.8.0</td><td><a href="mailto:webpack@1.8.0" target="_blank" rel="noopener">webpack@1.8.0</a></td><td>update</td><td>webpack: ^1.8.0</td><td><a href="mailto:webpack@1.15.0" target="_blank" rel="noopener">webpack@1.15.0</a>.</td></tr><tr><td>d)</td><td>webpack: ^1.8.0</td><td>空</td><td>update</td><td>webpack: ^1.8.0</td><td><a href="mailto:webpack@1.15.0" target="_blank" rel="noopener">webpack@1.15.0</a></td></tr></tbody></table><p>根据这个表我们可以对 npm 3 得出以下结论：</p><ul><li>如果本地 node_modules 已安装，再次执行 install 不会更新包版本, 执行 update 才会更新; 而如果本地 node_modules 为空时，执行 install/update 都会直接安装更新包;</li><li>npm update 总是会把包更新到符合 package.json 中指定的 semver 的最新版本号——本例中符合 ^1.8.0 的最新版本为 1.15.0</li><li>一旦给定 package.json, 无论后面执行 npm install 还是 update, package.json 中的 webpack 版本一直顽固地保持 一开始的 ^1.8.0 岿然不动</li></ul><p>这里不合理的地方在于，如果最开始团队中第一个人安装了 <a href="mailto:webpack@1.8.0" target="_blank" rel="noopener">webpack@1.8.0</a>, 而新加入项目的成员, checkout 工程代码后执行 npm install 会安装得到不太一样的 1.15.0 版本。虽然 semver 约定了小版本号应当保持向下兼容（相同大版本号下的小版本号）兼容，但万一有不熟悉不遵循此约定的包发布者，发布了不兼容的包，此时就可能出现因依赖环境不同导致的 bug。<br>下面由 npm 5 带着 package-lock.json 闪亮登场，执行 install/update 的效果是这样的 (node 9.8.0, npm 5.7.1 环境下试验):</p><p>下表为表述简单，省略了包名 webpack, install 简写 i, update 简写为 up</p><table><thead><tr><th>#</th><th>package.json (BEFORE)</th><th>node_modules (BEFORE)</th><th>package-lock (BEFORE)</th><th>command</th></tr></thead><tbody><tr><td>a)</td><td>^1.8.0</td><td>@1.8.0</td><td>@1.8.0</td><td>i</td></tr><tr><td>b)</td><td>^1.8.0</td><td>空</td><td>@1.8.0</td><td>i</td></tr><tr><td>c)</td><td>^1.8.0</td><td>@1.8.0</td><td>@1.8.0</td><td>up</td></tr><tr><td>d)</td><td>^1.8.0</td><td>空</td><td>@1.8.0</td><td>up</td></tr><tr><td>e)</td><td>^1.15.0</td><td>@1.8.0(旧)</td><td>@1.15.0</td><td>i</td></tr><tr><td>f)</td><td>^1.15.0</td><td>@1.8.0(旧)</td><td>@1.15.0</td><td>up</td></tr></tbody></table><p>与 npm 3 相比，在安装和更新依赖版本上主要的区别为：</p><ul><li>无论何时执行 install, npm 都会优先按照 package-lock 中指定的版本来安装 webpack; 避免了 npm 3 表中情形 b) 的状况;</li><li>无论何时完成安装/更新, package-lock 文件总会跟着 node_modules 更新 —— (因此可以视 package-lock 文件为 node_modules 的 JSON 表述)</li><li>已安装 node_modules 后若执行 npm update，package.json 中的版本号也会随之更改为 ^1.15.0</li></ul><p>由此可见 npm 5.1 使得 package.json 和 package-lock.json 中所保存的版本号更加统一，解决了 npm 之前的各种问题。只要遵循好的实践习惯，团队成员可以很方便地维护一套应用代码和 node_modules 依赖都一致的环境。<br>皆大欢喜。</p><p><strong>最佳实践</strong><br>总结起来，在 2018 年 (node 9.8.0, npm 5.7.1) 时代，我认为的依赖版本管理应当是:</p><ul><li><p>使用 npm: &gt;=5.1 版本, 保持 package-lock.json 文件默认开启配置</p></li><li><p>初始化：第一作者初始化项目时使用 npm install <package> 安装依赖包, 默认保存 ^X.Y.Z 依赖 range 到 package.json中; 提交 package.json, package-lock.json, 不要提交 node_modules 目录</package></p></li><li><p>初始化：项目成员首次 checkout/clone 项目代码后，执行一次 npm install 安装依赖包</p></li><li><p>不要手动修改 package-lock.json</p></li><li><p>升级依赖包:</p><ul><li>升级小版本: 本地执行 npm update 升级到新的小版本</li><li>升级大版本: 本地执行 npm install <package-name>@<version> 升级到新的大版本</version></package-name></li><li>也可手动修改 package.json 中版本号为要升级的版本(大于现有版本号)并指定所需的 semver, 然后执行 npm install</li><li>本地验证升级后新版本无问题后，提交新的 package.json, package-lock.json 文件</li></ul></li><li><p>降级依赖包:</p><ul><li>正确: npm install <package-name>@<old-version> 验证无问题后，提交 package.json 和 package-lock.json 文件</old-version></package-name></li><li>错误: 手动修改 package.json 中的版本号为更低版本的 semver, 这样修改并不会生效，因为再次执行 npm install 依然会安装 package-lock.json 中的锁定版本</li></ul></li><li><p>删除依赖包:</p><ul><li>Plan A: npm uninstall <package> 并提交 package.json 和 package-lock.json</package></li><li>Plan B: 把要卸载的包从 package.json 中 dependencies 字段删除, 然后执行 npm install 并提交 package.json 和 package-lock.json</li></ul></li><li><p>任何时候有人提交了 package.json, package-lock.json 更新后，团队其他成员应在 svn update/git pull 拉取更新后执行 npm install 脚本安装更新后的依赖包</p></li></ul><p><del>恭喜你终于可以跟 rm -rf node_modules &amp;&amp; npm install 这波操作说拜拜了（其实并不会）</del></p><h4 id="5、npm-scripts"><a href="#5、npm-scripts" class="headerlink" title="5、npm scripts"></a>5、npm scripts</h4><p><strong>基本使用</strong><br>npm scripts 是 npm 另一个很重要的特性。通过在 package.json 中 scripts 字段定义一个脚本，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">        <span class="attr">"echo"</span>: <span class="string">"echo HELLO WORLD"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就可以通过 <code>npm run echo</code> 命令来执行这段脚本，像在 shell 中执行该命令 echo HELLO WORLD 一样，看到终端输出 HELLO WORLD.<br>—— npm scripts 的基本使用就是这么简单，它提供了一个简单的接口用来调用工程相关的脚本。关于更详细的相关信息，可以参考阮一峰老师的文章 npm <a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2016%2F10%2Fnpm_scripts.html" target="_blank" rel="noopener">script 使用指南 (2016年10月)</a></p><p>下面简要总结一下阮老师的文章内容：</p><p>1）npm run 命令执行时，会把 <em>./node_modules/.bin/__ 目录添加到执行环境的 PATH 变量中，因此如果某个命令行包未全局安装，而只安装在了当前项目的 node_modules 中，通过 npm run 一样可以调用该命令。<br>2）执行 npm 脚本时要传入参数，需要在命令后加 – 标明, 如 `npm run test – –grep=”pattern”`` 可以将 _–grep=”pattern”</em> 参数传给 test 命令<br>3）npm 提供了 pre 和 post 两种钩子机制，可以定义某个脚本前后的执行脚本<br>4）运行时变量：在 <code>npm run</code> 的脚本执行环境内，可以通过环境变量的方式获取许多运行时相关信息。</p><p>比如，以下信息都可以通过 process.env 对象访问获得：</p><ul><li>npm_lifecycle_event - 正在运行的脚本名称</li><li>npm_package_<key> - 获取当前包 package.json 中某个字段的配置值：如 npm_package_name 获取包名</key></li><li>npm_package_<key>_<sub-key> - package.json 中嵌套字段属性：如 npm_pacakge_dependencies_webpack 可以获取到 package.json 中的 dependencies.webpack 字段的值，即 webpack 的版本号</sub-key></key></li></ul><p><strong>node_modules/.bin 目录</strong><br>上面所说的 node_modules/.bin 目录，保存了依赖目录中所安装的可供调用的命令行包。<br>何谓命令行包？例如 webpack 就属于一个命令行包。如果我们在安装 webpack 时添加 –global 参数，就可以在终端直接输入 webpack 进行调用。但如果不加 –global 参数，我们会在 node_modules/.bin 目录里看到名为 webpack 的文件，如果在终端直接输入 ./node_modules/.bin/webpack 命令，一样可以执行。<br>这是因为 webpack 在 package.json 文件中定义了 bin 字段为:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bin"</span>: &#123;</span><br><span class="line">        <span class="attr">"webpack"</span>: <span class="string">"./bin/webpack.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bin 字段的配置格式为: <command>: <file>, 即 命令名: 可执行文件. npm 执行 install 时，会分析每个依赖包的 package.json 中的 bin 字段，并将其包含的条目安装到 ./node_modules/.bin 目录中，文件名为 <command>。而如果是全局模式安装，则会在 npm 全局安装路径的 bin 目录下创建指向 <file> 名为 <command> 的软链。因此，./node_modules/.bin/webpack 文件在通过命令行调用时，实际上就是在执行 node ./node_modules/.bin/webpack.js 命令。<br>正如上一节所说，<code>npm run</code> 命令在执行时会把 ./node_modules/.bin 加入到 PATH 中，使我们可直接调用所有提供了命令行调用接口的依赖包。所以这里就引出了一个最佳实践：</file></file></p><p>将项目依赖的命令行工具安装到项目依赖文件夹中，然后通过 npm scripts 调用；而非全局安装</p><p>举例而言 webpack 作为前端工程标配的构建工具，虽然我们都习惯了全局安装并直接使用命令行调用，但不同的项目依赖的 webpack 版本可能不同，相应的 webpack.config.js 配置文件也可能只兼容了特定版本的 webpack. 如果我们仅全局安装了最新的 webpack 4.x 并使用 webpack 命令调用，在一个依赖 webpack 3.x 的工程中就会无法成功执行构建。<br>但如果这类工具总是本地安装，我们要调用一个命令，要手动添加 ./node_modules/.bin 这个长长的前缀，未免也太麻烦了，我们 nodejs 开发者都很懒的。于是 npm 从5.2 开始自带了一个新的工具 npx.</p><p><strong>npx</strong><br>npx 的使用很简单，就是执行 npx <command> 即可，这里的 <command> 默认就是 ./node_modules 目录中安装的可执行脚本名。例如上面本地安装好的 webpack 包，我们可以直接使用 npx webpack 执行即可。<br>除了这种最简单的场景, npm cli 团队开发者 Kat Marchán 还在这篇文章中介绍了其他几种 npx 的神奇用法: [Introducing npx: an npm package runner][<a href="https://link.juejin.im/?target=https%3A%2F%2Fbit.ly%2F2uzuIHv]" target="_blank" rel="noopener">https://link.juejin.im/?target=https%3A%2F%2Fbit.ly%2F2uzuIHv]</a>, 国内有位开发者 robin.law 将原文翻译为中文 [npx 是什么，为什么需要 npx?][<a href="https://link.juejin.im/?target=https%3A%2F%2Frobin-front.github.io%2F2017%2F07%2F14%2Fintroducing-npx-an-npm-package-runner%2F]" target="_blank" rel="noopener">https://link.juejin.im/?target=https%3A%2F%2Frobin-front.github.io%2F2017%2F07%2F14%2Fintroducing-npx-an-npm-package-runner%2F]</a></p><p>有兴趣的可以戳链接了解，懒得点链接的，看总结：</p><p><strong>场景a) 一键执行远程 npm 源的二进制包</strong><br>除了在 package 中执行 ./node_modules/.bin 中已安装的命令, 还可以直接指定未安装的二进制包名执行。例如我们在一个没有 package.json 也没有 node_modules 的目录下，执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx cowsay hello</span><br></pre></td></tr></table></figure><p>npx 将会从 npm 源下载 cowsay 这个包（但并不安装）并执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> _______ </span><br><span class="line">&lt; hello &gt;</span><br><span class="line"> ------- </span><br><span class="line">        \   ^__^</span><br><span class="line">         \  (oo)\_______</span><br><span class="line">            (__)\       )\/\</span><br><span class="line">                ||----w |</span><br><span class="line">                ||     ||</span><br></pre></td></tr></table></figure><p>这种用途非常适合：</p><ol><li>在本地简单测试或调试 npm 源上这些二进制包的功能；</li><li>调用 create-react-app 或 yeoman 这类往往每个项目只需要使用一次的脚手架工具</li></ol><p>PS: 此处有彩蛋，执行下面这条命令试试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx workin-hard</span><br></pre></td></tr></table></figure><p><strong>场景b) 一键执行 GitHub Gist</strong><br>还记得前面提到的 [2.1 package定义] 么，npm install <package> 可以是包含了有效 package.json 的 git url.<br>刚好 GitHub Gist 也是 git 仓库的一种，集合 npx 就可以方便地将简单的脚本共享给其他人，拥有该链接的人无需将脚本安装到本地工作目录即可执行。将 package.json 和 需执行的二进制脚本上传至 gist, 在运行 npx <gist url=""> 就可以方便地执行该 gist 定义的命令。<br>原文作者 Kat Marchán 提供了这个<a href="https://link.juejin.im/?target=https%3A%2F%2Fgist.github.com%2Fzkat%2F4bc19503fe9e9309e2bfaa2c58074d32" target="_blank" rel="noopener">示例 gist</a>, 执行：<br>npx <a href="https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32" target="_blank" rel="noopener">https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32</a><br>可得到一个来自 GitHubGist 的 hello world 问候。</gist></package></p><p><strong>场景c) 使用不同版本 node 执行命令</strong><br>将 npx 与 Aria Stewart 创建的 node 包 (<a href="https://www.npmjs.com/package/node" target="_blank" rel="noopener">https://www.npmjs.com/package/node</a>) 结合，可以实现在一行命令中使用指定版本的 node 执行命令。<br>例如先后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx node@4 -e "console.log(process.version)"</span><br><span class="line">npx node@6 -e "console.log(process.version)"</span><br></pre></td></tr></table></figure><p>将分别输出 v4.8.7 和 v6.13.0.<br>往常这种工作是由 nvm 这类 node 版本管理工具来做的，但 npx node@4 这种方式免去 nvm 手动切换配置的步骤，更加简洁简单。</p><h4 id="6、npm-配置"><a href="#6、npm-配置" class="headerlink" title="6、npm 配置"></a>6、npm 配置</h4><p><strong>npm config</strong><br>npm cli 提供了 npm config 命令进行 npm 相关配置，通过 npm config ls -l 可查看 npm 的所有配置，包括默认配置。npm 文档页为每个配置项提供了详细的说明 <a href="https://docs.npmjs.com/misc/config" target="_blank" rel="noopener">https://docs.npmjs.com/misc/config</a> .<br>修改配置的命令为 npm config set <key> <value>, 我们使用相关的常见重要配置:</value></key></p><p>proxy, https-proxy: 指定 npm 使用的代理<br>registry 指定 npm 下载安装包时的源，默认为 <a href="https://registry.npmjs.org/" target="_blank" rel="noopener">https://registry.npmjs.org/</a> 可以指定为私有 Registry 源<br>package-lock 指定是否默认生成 package-lock 文件，建议保持默认 true<br>save true/false 指定是否在 npm install 后保存包为 dependencies, npm 5 起默认为 true</p><p>删除指定的配置项命令为 npm config delete <key>.</key></p><p><strong>npmrc 文件</strong><br>除了使用 CLI 的 npm config 命令显示更改 npm 配置，还可以通过 npmrc 文件直接修改配置。<br>这样的 npmrc 文件优先级由高到低包括：</p><p>工程内配置文件: /path/to/my/project/.npmrc<br>用户级配置文件: ~/.npmrc<br>全局配置文件: $PREFIX/etc/npmrc (即npm config get globalconfig 输出的路径)<br>npm内置配置文件: /path/to/npm/npmrc</p><p>通过这个机制，我们可以方便地在工程跟目录创建一个 .npmrc 文件来共享需要在团队间共享的 npm 运行相关配置。比如如果我们在公司内网环境下需通过代理才可访问 registry.npmjs.org 源，或需访问内网的 registry, 就可以在工作项目下新增 .npmrc 文件并提交代码库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy = http://proxy.example.com/</span><br><span class="line">https-proxy = http://proxy.example.com/</span><br><span class="line">registry = http://registry.example.com/</span><br></pre></td></tr></table></figure><p>因为项目级 .npmrc 文件的作用域只在本项目下，所以在非本目录下，这些配置并不生效。对于使用笔记本工作的开发者，可以很好地隔离公司的工作项目、在家学习研究项目两种不同的环境。<br>将这个功能与 ~/.npm-init.js 配置相结合，可以将特定配置的 .npmrc 跟 .gitignore, README 之类文件一起做到 npm init 脚手架中，进一步减少手动配置。</p><p><strong>node 版本约束</strong><br>虽然一个项目的团队都共享了相同的代码，但每个人的开发机器可能安装了不同的 node 版本，此外服务器端的也可能与本地开发机不一致。<br>这又是一个可能带来不一致性的因素 —— 但也不是很难解决，声明式约束+脚本限制即可。<br>声明：通过 package.json 的 engines 属性声明应用运行所需的版本运行时要求。例如我们的项目中使用了 async, await 特性，查阅兼容性表格得知最低支持版本为 7.6.0，因此指定 engines 配置为:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"engines"</span>: &#123; <span class="attr">"node"</span>: <span class="string">"&gt;=7.6.0"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强约束(可选)：在 npm 中以上字段内容仅作为建议字段使用，若要在私有项目中添加强约束，需要自己写脚本钩子，读取并解析 engines 字段的 semver range 并与运行时环境做对比校验并适当提醒。</p><h4 id="7、小结-npm-最佳实践"><a href="#7、小结-npm-最佳实践" class="headerlink" title="7、小结 npm 最佳实践"></a>7、小结 npm 最佳实践</h4><ul><li>使用 npm-init 初始化新项目</li><li>统一项目配置: 需团队共享的 npm config 配置项，固化到 .npmrc 文件中</li><li>统一运行环境，统一 package.json，统一 package-lock 文件</li><li>合理使用多样化的源安装依赖包: npm install <git url="">|<local file=""></local></git></li><li>使用 npm: &gt;=5.2 版本</li><li>使用 npm scripts 与 npx (npm: &gt;=5.2) 脚本管理应用相关脚本</li></ul><h4 id="8、参考来源："><a href="#8、参考来源：" class="headerlink" title="8、参考来源："></a>8、参考来源：</h4><ul><li>本文来源：<a href="https://juejin.im/post/5ab3f77df265da2392364341" target="_blank" rel="noopener">https://juejin.im/post/5ab3f77df265da2392364341</a></li><li>下面这篇 2015 年的文章介绍了如何使用把本地模块打包到 node_modules 依赖中:<br><a href="https://link.juejin.im/?target=https%3A%2F%2Fbit.ly%2F2DLnaCd" target="_blank" rel="noopener">Build modular application with npm local modules</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ABS, Arch Build System</title>
      <link href="/Tools-and-Build/tool-and-build-abs-arch-build/"/>
      <url>/Tools-and-Build/tool-and-build-abs-arch-build/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这篇文章主要介绍在 Arch Linux 中的 ABS 系统，ABS 系统可以让我们通过源码编译的方式安装软件包。</p><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>通过 pacman 安装软件包时，我们安装的都是编译好的二进制包，Arch Linux 中的 pacman 包管理程序没有提供像其他 Linux 发行版下（比如 Ubuntu）那样的 -dev 之类的包。而是提供了一个 ABS 来帮助用户来定制化地安装软件包。</p><p>这是 Arch Linux 中的 The Arch Way 的一个特点，主要目的就是精简，缩小体积。<br>当我们需要手动编译安装包（定制安装选项）时，我们可以使用 Arch 提供的 ABS 系统。</p><h3 id="ABS-是什么？"><a href="#ABS-是什么？" class="headerlink" title="ABS 是什么？"></a>ABS 是什么？</h3><p>ABS 全称是 Arch Build System，是一个用于把源码进行编译和打包的 port-like system。<br>区别与 pacman 的是，pacman 是一个专门用于管理二进制包的工具（包括由 ABS 编译打包而成的二进制包），而 ABS 则包含了一组把源码打包成 .pkg.tar.xz 包的工具。</p><h3 id="什么是-port-like-系统？"><a href="#什么是-port-like-系统？" class="headerlink" title="什么是 port-like 系统？"></a>什么是 port-like 系统？</h3><p>port 就是一个小目录，它包含了源码文件，以及一些编译和安装软件的脚本配置，这就使得在 port 目录中，安装软件变得极其简单，只需要像执行一个 make 或 make install 命令一样简单。</p><h3 id="ABS-包中有哪些东西？"><a href="#ABS-包中有哪些东西？" class="headerlink" title="ABS 包中有哪些东西？"></a>ABS 包中有哪些东西？</h3><p>ABS 是由一个目录树来组成，可以通过 svn 或者 git 命令来 checkout。<br>注意，在这个目录树下面不包含任何 Arch 官方包，子目录中也不包含软件包的源码，而是包含了一个 PKGBUILD 文件，它实际上是一个 shell 脚本，其包含了如何构建软件的指令。通过在当前目录中执行 makepkg 命令，来进行构建。</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>ABS 目录中并不包含源码，而是在 PKGBUILD 中包含了一个 URL 链接，在执行 makepkg 命令的时候会去下载源码。</p><p>因此，在编译某个包的源码之前，我们需要在本地电脑 Checkout 这个包。</p><p>下面展示一下如何使用 svn 来 checkout acl 这个包。</p><p>1） 先创建一个名为 packages 的空目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn checkout --depth=empty svn://svn.archlinux.org/packages</span></span><br></pre></td></tr></table></figure><p>该命令会创建一个目录，里面是空的，并把该目录初始化为一个 ABS 目录，如下：<br><img src="http://upload-images.jianshu.io/upload_images/1452123-679b9926747f5941.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>2） Checkout 一个包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> svn update package-name</span></span><br></pre></td></tr></table></figure><p>执行这个命令后，指定的包就会被拉下来。注意，如果指定的包名不存在，那么 svn 不会提示，也不会创建任何目录，所以用户需要自己确认包名的正确，可以去<br>  <a href="https://www.archlinux.org/packages" target="_blank" rel="noopener">https://www.archlinux.org/packages</a>  查看包是否存在。</p><p><img src="http://upload-images.jianshu.io/upload_images/1452123-fcd70c6868ff541b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="使用-Git-来-Checkout"><a href="#使用-Git-来-Checkout" class="headerlink" title="使用 Git 来 Checkout"></a>使用 Git 来 Checkout</h4><p>需要先安装 asp 工具（<code>sudo pacman -Sy asp</code>）安装好 asp 之后，直接执行 <code>asp checkout openssl</code> 就可以把 openssl 的 ABS tree 拉下来了。</p><p><img src="http://upload-images.jianshu.io/upload_images/1452123-82727a5f5171ca84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>acl 中的 PKGBUILD 内容</p><p><img src="http://upload-images.jianshu.io/upload_images/1452123-ca70bb4f0530a7ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="包的编译"><a href="#包的编译" class="headerlink" title="包的编译"></a>包的编译</h3><p>编译之前，我们可能需要根据需要来修改 PKGBUILD 的配置，因此，先把我们要准备编译的包的目录拷贝到<br>其他地方，进行相应的修改，然后执行 makepkg 命令。</p><h3 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h3><p>在我们通过 makepkg 手动编译安装了某个包之后，如果不小心又执行了 pacman 命令来安装同一个包，那么我们手动安装的版本就会被覆盖。如果想要避免这种情况，那么可以采用下面的办法：</p><p>在 PKGBUILD 文件中添加下面一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groups=(&apos;modified&apos;)</span><br></pre></td></tr></table></figure><p>然后在 /etc/pacman.conf 中，把上述的 group 也即 modified 添加到 IgnoreGroup 中去，如下：<br><img src="http://upload-images.jianshu.io/upload_images/1452123-9f00a0797b637890.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">执行 </p><h4 id="makepkg"><a href="#makepkg" class="headerlink" title="makepkg"></a>makepkg</h4><p>执行 makepkg 时会下载源码包，同时进行签名校验，这个时候可能会出现一个验签失败错误</p><p><img src="http://upload-images.jianshu.io/upload_images/1452123-d377ab9857aab6bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>执行 gpg –recv-key <keyid> 获取 key 即可<br>原因是 makepkg 不使用 pacman 的 keyring，而是使用当前用户目录下 <code>~/.gnugpg</code> 中的 keyring。</keyid></p><p>执行 makepkg 命令成功后，显示如下：<br><img src="http://upload-images.jianshu.io/upload_images/1452123-a4fe1b4d18492778.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>源码这时候也就编译成功了，会生成一个 pkg 的目录，其中包含了所有编译后的结果，如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1452123-f7cddb7341ae314a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这时候，执行 下面的命令来安装刚才编译好的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacmane -U openssl-1.1.0.g-1-x86_64.pkg.tar.xz</span><br></pre></td></tr></table></figure><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go upload file</title>
      <link href="/Programming/go-go-upload/"/>
      <url>/Programming/go-go-upload/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这篇文章主要介绍使用 Go 语言来实现客户端上传文件和服务端处理接收文件的功能。</p><p>1） Client 端上传文件：Uploading files<br>2） Server 端接收文件： Receving files 并且 Saving files</p><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>作为 Client 端，读取本地文件，并上传到服务器，通常需要调用 Server 端提供的接口，向其发出 POST 请求。</p><p>Client 端的上传方式主要有两种：<br>一是 Request Body 就是整个文件内容，通过请求头（即 Header ）中的 Content-Type 字段来指定文件类型。<br>二是用 multipart 表单方式来上传</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>作为 Server 端，需要处理接收 Client 端上传过来的文件，并保存在服务器的某个目录中。<br>Server 通常需要提供一个接口供 Client 端访问，当接收到 Client 的调用请求，则需要解析这个请求，并把请求中上传过来的文件读取并保存到磁盘。</p><p>相应的，Server 端在处理 Client 端请求时也要区分两种方式</p><ul><li>如果 Client 端上传的是纯二进制流数据，那么直接读取 body 写入到本地文件中即可</li><li>如果 Client 端是用 multipart 表单上传的文件，那么就解析表单，再把文件写入本地。</li></ul><p>（1）第一种，Client 把文件内容放在整个 body 中来传送</p><p>client </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="comment">// "time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Url = <span class="string">"http://localhost:8080/upload"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// body is file content</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doUpload</span><span class="params">(filepath <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    file, err := os.Open(filepath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    res, err := http.Post(Url, <span class="string">"binary/octet-stream"</span>, file) <span class="comment">// 第二个参数用来指定 "Content-Type"</span></span><br><span class="line">    <span class="comment">// resp, err := http.Post(Url, "image/jpeg", file)</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> filename <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        filename = <span class="string">"/home/winkee/abc.txt"</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        filename = os.Args[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    doUpload(filename)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UploadHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Println(r.Header[<span class="string">"Content-Type"</span>])</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// create a temporary file to hold the content</span></span><br><span class="line">    f, err := os.OpenFile(<span class="string">"received.tmp"</span>, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    n, err := io.Copy(f, r.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">        log.Printf(<span class="string">"%d bytes are recieved.\n"</span>, n)</span><br><span class="line">    <span class="comment">// w.Write([]byte(fmt.Sprintf("%d bytes are recieved.\n", n)))</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/upload"</span>, UploadHandler)</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）第二种，Client-通过-multipart-表单上传文件"><a href="#（2）第二种，Client-通过-multipart-表单上传文件" class="headerlink" title="（2）第二种，Client 通过 multipart 表单上传文件"></a>（2）第二种，Client 通过 multipart 表单上传文件</h4><p>Client 通过 multipart.Writer 的 CreateFormFile() 函数把本地文件写入 Form 中。并设置请求头的 Content-Type 为 <code>writer.FormDataContentType()</code>，然后发送请求。<br>需要注意的是：发送请求之前需要把 Writer 关闭。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"mime/multipart"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitIfErr</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">multipartUpload</span><span class="params">(destURL <span class="keyword">string</span>, f io.Reader, fields <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> <span class="params">(*http.Response, error)</span></span> &#123;</span><br><span class="line">    body := &amp;bytes.Buffer&#123;&#125;</span><br><span class="line">    writer := multipart.NewWriter(body)</span><br><span class="line">    fw, err := writer.CreateFormFile(<span class="string">"file"</span>, fields[<span class="string">"filename"</span>])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"CreateFormFile %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _, err = io.Copy(fw, f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"copying fileWriter %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> fields &#123;</span><br><span class="line">        _ = writer.WriteField(k, v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = writer.Close() <span class="comment">// close writer before POST request</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"writerClose: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    resp, err := http.Post(destURL, writer.FormDataContentType(), body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// req, err := http.NewRequest("POST", destURL, body)</span></span><br><span class="line">    <span class="comment">// if err != nil &#123;</span></span><br><span class="line">    <span class="comment">//  return nil, err</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// req.Header.Set("Content-Type", writer.FormDataContentType())</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if req.Close &amp;&amp; req.Body != nil &#123;</span></span><br><span class="line">    <span class="comment">//  defer req.Body.Close()</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// return http.DefaultClient.Do(req)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> filename <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        filename = <span class="string">"/home/winkee/abc.txt"</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        filename = os.Args[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line">    exitIfErr(err)</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    fields := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">"filename"</span>: filename,</span><br><span class="line">    &#125;</span><br><span class="line">    res, err := multipartUpload(<span class="string">"http://localhost:8080/uploadform"</span>, f, fields)</span><br><span class="line">    exitIfErr(err)</span><br><span class="line">    fmt.Println(<span class="string">"res: "</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CreateFormFile() 函数原型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreateFormFile is a convenience wrapper around CreatePart. It creates</span></span><br><span class="line"><span class="comment">// a new form-data header with the provided field name and file name.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Writer)</span> <span class="title">CreateFormFile</span><span class="params">(fieldname, filename <span class="keyword">string</span>)</span> <span class="params">(io.Writer, error)</span></span> &#123;</span><br><span class="line">    h := <span class="built_in">make</span>(textproto.MIMEHeader)</span><br><span class="line">    h.Set(<span class="string">"Content-Disposition"</span>, fmt.Sprintf(<span class="string">`form-data; name="%s"; filename="%s"`</span>, escapeQuotes(fieldname), escapeQuotes(filename)))</span><br><span class="line">    h.Set(<span class="string">"Content-Type"</span>, <span class="string">"application/octet-stream"</span>)</span><br><span class="line">    <span class="keyword">return</span> w.CreatePart(h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个参数，实际上是时需要带上来的 filename 域所需的值（也就是文件名），<br>比如，客户端发送 POST 请求进行上传时，在 Body 中就会把 filename=FieldValue 写上，<br>而在发送 GET 请求进行下载时，则是在 url 中把 filename 拼上。</p><p>如果想要再上传文件的时候，同时传递一些其他的参数，那么就应该使用 writer.WriteField() 函数，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> fields &#123;</span><br><span class="line">    _ = writer.WriteField(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，形成的 request body 内容如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1452123-e36de91f9527c346.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>注意：<br>如果要指定上传的每个部分的Content-Type，则需要重写multipart.Writer的CreateFormField和CreateFormFile方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateFormFile</span><span class="params">(fieldname, filename, contentType <span class="keyword">string</span>, w *multipart.Writer)</span> <span class="params">(io.Writer, error)</span></span> &#123;</span><br><span class="line">    h := <span class="built_in">make</span>(textproto.MIMEHeader)</span><br><span class="line">    h.Set(<span class="string">"Content-Disposition"</span>,</span><br><span class="line">        fmt.Sprintf(<span class="string">`form-data; name="%s"; filename="%s"`</span>,</span><br><span class="line">            escapeQuotes(fieldname), escapeQuotes(filename)))</span><br><span class="line">    h.Set(<span class="string">"Content-Type"</span>, contentType)</span><br><span class="line">    <span class="keyword">return</span> w.CreatePart(h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"path/filepath"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    DefaultUploadDir = <span class="string">"/home/winkee"</span>   </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReceiveFormFile</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// if err = req.ParseMultipartForm(2 &lt;&lt; 10); err != nil &#123;  </span></span><br><span class="line">    <span class="comment">//    status = http.StatusInternalServerError  </span></span><br><span class="line">    <span class="comment">//    return  </span></span><br><span class="line">    <span class="comment">// &#125;  </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// r.Method should be "POST"</span></span><br><span class="line">    file, header, err := r.FormFile(<span class="string">"file"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    nameParts := strings.Split(header.Filename, <span class="string">"."</span>)</span><br><span class="line">    filename := nameParts[<span class="number">1</span>]</span><br><span class="line">    savedPath := filepath.Join(DefaultUploadDir, filename)</span><br><span class="line">    f, err := os.OpenFile(savedPath, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    _, err = io.Copy(f, file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/uploadform"</span>, ReceiveFormFile)</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 header.Filename 需要注意，客户端上传时指定的 filename 可能是 ../../../../../test/hello.txt 这种格式，如果不做 sanitize 的话，保存的时候直接用这个 filename 显然会出问题。</p><p>server 的另外一种处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReceiveFormFile</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> _24K = (<span class="number">1</span> &lt;&lt; <span class="number">10</span>) * <span class="number">24</span>  <span class="comment">// 24 MB</span></span><br><span class="line">    <span class="keyword">if</span> err = req.ParseMultipartForm(_24K); <span class="literal">nil</span> != err &#123;  </span><br><span class="line">        status = http.StatusInternalServerError  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> _, fheaders := <span class="keyword">range</span> req.MultipartForm.File &#123;  </span><br><span class="line">        <span class="keyword">for</span> _, hdr := <span class="keyword">range</span> fheaders &#123;  </span><br><span class="line">            <span class="comment">// open uploaded  </span></span><br><span class="line">            <span class="keyword">var</span> infile multipart.File  </span><br><span class="line">            <span class="keyword">if</span> infile, err = hdr.Open(); <span class="literal">nil</span> != err &#123;  </span><br><span class="line">                status = http.StatusInternalServerError  </span><br><span class="line">                <span class="keyword">return</span>  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// open destination  </span></span><br><span class="line">            <span class="keyword">var</span> outfile *os.File  </span><br><span class="line">            <span class="keyword">if</span> outfile, err = os.Create(<span class="string">"./uploaded/"</span> + hdr.Filename); <span class="literal">nil</span> != err &#123;  </span><br><span class="line">                status = http.StatusInternalServerError  </span><br><span class="line">                <span class="keyword">return</span>  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 32K buffer copy  </span></span><br><span class="line">            <span class="keyword">var</span> written <span class="keyword">int64</span>  </span><br><span class="line">            <span class="keyword">if</span> written, err = io.Copy(outfile, infile); <span class="literal">nil</span> != err &#123;  </span><br><span class="line">                status = http.StatusInternalServerError  </span><br><span class="line">                <span class="keyword">return</span>  </span><br><span class="line">            &#125;  </span><br><span class="line">            res.Write([]<span class="keyword">byte</span>(<span class="string">"uploaded file:"</span> + hdr.Filename + <span class="string">";length:"</span> + strconv.Itoa(<span class="keyword">int</span>(written))))  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>http 包中的 Request 结构体提供了 ParseForm() 和 ParseMultipartForm() 两个函数。<br>在理解它们之间的区别之前，先来看一下 Request 结构体的定义，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;   </span><br><span class="line">    <span class="comment">// Form contains the parsed form data, including both the URL</span></span><br><span class="line">    <span class="comment">// field's query parameters and the POST or PUT form data.</span></span><br><span class="line">    <span class="comment">// This field is only available after ParseForm is called.</span></span><br><span class="line">    <span class="comment">// The HTTP client ignores Form and uses Body instead.</span></span><br><span class="line">    Form url.Values</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PostForm contains the parsed form data from POST, PATCH,</span></span><br><span class="line">    <span class="comment">// or PUT body parameters.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This field is only available after ParseForm is called.</span></span><br><span class="line">    <span class="comment">// The HTTP client ignores PostForm and uses Body instead.</span></span><br><span class="line">    PostForm url.Values</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MultipartForm is the parsed multipart form, including file uploads.</span></span><br><span class="line">    <span class="comment">// This field is only available after ParseMultipartForm is called.</span></span><br><span class="line">    <span class="comment">// The HTTP client ignores MultipartForm and uses Body instead.</span></span><br><span class="line">    MultipartForm *multipart.Form</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，Request 结构体中，定义了 3 个不同类型的 Form 相关的数据<br>Form 是一个通用的数据类型 url.Values，原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Values map[string][]string</span><br></pre></td></tr></table></figure><p>1） 对于 Form 和 PostForm 来说，一个是 GET url raw 请求中带的参数，另一个是在 POST body 中带的参数，格式都一样，比如 ?name=xxx&amp;age=18 等。服务端在接收到请求时，通过调用 <code>r.ParseForm()</code>来获得客户端传上来的请求参数。<br>2） 对于这个 MultipartForm，是用户客户端上传文件时使用的，服务端收到客户端的请求时，通过调用 <code>r.ParseMultipartForm()</code> 函数来获得相应的文件内容。<code>r.ParseMultipartForm() 在内部会调用 r.ParseForm()</code> 来进行部分解析。</p><p>multipart.Form 则是在 url.Values 的基础上，再添加了一个包含了文件信息的数据类型，原型如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Form is a parsed multipart form.</span></span><br><span class="line"><span class="comment">// Its File parts are stored either in memory or on disk,</span></span><br><span class="line"><span class="comment">// and are accessible via the *FileHeader's Open method.</span></span><br><span class="line"><span class="comment">// Its Value parts are stored as strings.</span></span><br><span class="line"><span class="comment">// Both are keyed by field name.</span></span><br><span class="line"><span class="keyword">type</span> Form <span class="keyword">struct</span> &#123;</span><br><span class="line">    Value <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br><span class="line">    File  <span class="keyword">map</span>[<span class="keyword">string</span>][]*FileHeader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常，服务端在收到客户端上传的文件请求时，先调用 r.ParseMultipartForm(maxMemorySize) ，然后调用 r.FormFile(“uploadfile”) 来获得其中的对应控件名的文件（注：multipartForm 可以包含多个文件）。<br>实际上, r.FormFile(“) 内部也会调用 r.ParseMultipartForm()，因此，即使不先调用 r.ParseMultipartForm()， 而直接调用 r.FormFile(“”)  也是可以的。<br>但是，如果文件太大的话，可能会出错，因此最好还是先调用  r.ParseMultipartForm() 控制读入内存的大小。</p><p>默认的最大是 10 M，也就是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxFormSize = <span class="keyword">int64</span>(<span class="number">10</span> &lt;&lt; <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>全文完！</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NPM in simple</title>
      <link href="/Web/web-npm-in-simple/"/>
      <url>/Web/web-npm-in-simple/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>NPM 是 Javascript 社区最强大的包管理工具，本文介绍 NPM 的最基本用法。</p><h4 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h4><p>使用 npm 安装第三方包的语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;package_name&gt; [--save|--save-dev|--save-optional]</span><br></pre></td></tr></table></figure><p>参数解释：</p><p>–save: Package will appear in your depedencies.<br>–save-dev: Package will appear in your devDependencies.<br>–save-optional: Package will appear in your optionalDependencies.<br>–global: Package will be installed globally (if you want to use it as a command line tool for example)</p><p>如果不加任何参数，而是执行 <code>npm install lodash</code> 这种的话，那么就会安装在当前目录的 <code>node_modules/</code> 目录中，并且会在 <code>package.json</code> 中的 _dependencies {}_ 中添加当前安装的库。</p><p><strong>指定安装源</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p><strong>安装最新版</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;package_name&gt;@latest</span><br></pre></td></tr></table></figure><p><strong>同时安装多个包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express momemt lodash mongoose body-parser webpack</span><br></pre></td></tr></table></figure><p><strong>查看全局的 node_modules 所在目录</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm root -g</span><br></pre></td></tr></table></figure><p>如果直接执行 <code>npm root</code>，则会列出当前项目的 <code>node_modules</code> 的绝对路径。<br>还可以用 <code>npm bin</code> 列出当前项目的 <code>node_modules/.bin</code> 目录。</p><h4 id="2、删除"><a href="#2、删除" class="headerlink" title="2、删除"></a>2、删除</h4><p>删除 project range 的包和删除 global range 的包语法不同，而且还可以决定是否把 <em>package.json</em> 中的依赖信息也删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall &lt;package_name&gt; removes the module from node_modules, but not package.json</span><br><span class="line">npm uninstall &lt;package_name&gt; --save also removes it from dependencies in package.json</span><br><span class="line">npm uninstall &lt;package_name&gt; --save-dev also removes it from devDependencies in package.json</span><br><span class="line">npm -g uninstall &lt;package_name&gt; --save also removes it globally</span><br></pre></td></tr></table></figure><h3 id="3、更新"><a href="#3、更新" class="headerlink" title="3、更新"></a>3、更新</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update underscore</span><br></pre></td></tr></table></figure><p>可以用 <code>npm outdated</code> 命令来查看当前项目中的第三方包是否有更新：</p><p><img src="/image/web/whichnode.png" alt=""></p><h4 id="4、自更新"><a href="#4、自更新" class="headerlink" title="4、自更新"></a>4、自更新</h4><p>在执行 npm 命令时通常会提示是否需要更新，如果需要手动更新，可以执行下列命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm update npm -g</span><br><span class="line">npm install npm@latest -g</span><br></pre></td></tr></table></figure><h4 id="5、搜索包"><a href="#5、搜索包" class="headerlink" title="5、搜索包"></a>5、搜索包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm search mkdir</span><br></pre></td></tr></table></figure><h4 id="6、缓存管理"><a href="#6、缓存管理" class="headerlink" title="6、缓存管理"></a>6、缓存管理</h4><p>当指定 <em>npm install</em> 安装一个第三方包的时候，npm 会在本地缓存目录保存这个包的一个拷贝，这样，在下次我们执行安装的时候，如果本地缓存已经有这个包，就无需从网络获取了。<br>这个缓存目录通常是 <code>~/.npm</code>，所有我们安装过的第三方包都会在这里保存一个拷贝。</p><p>如果我们不清楚缓存是哪个目录，还可以用下面这个命令来查询：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get cache</span><br></pre></td></tr></table></figure><p>随着我们不断的安装新的包，这个缓存目录会不断变得臃肿（get clutterd with old packages），所以我们有必要在一定的时候清理它。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></table></figure><h4 id="7、Aliases"><a href="#7、Aliases" class="headerlink" title="7、Aliases"></a>7、Aliases</h4><p>npm 的命令有时候看起来比较长，尤其是我们经常使用的时候，这个时候，我们可以使用命令的简写形式，它们也叫 NPM Command Aliases。</p><p>下面列举常见的一些命令别名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm i &lt;package&gt; – install local package</span><br><span class="line">npm i -g &lt;/package&gt;&lt;package&gt; – install global package</span><br><span class="line">npm un &lt;/package&gt;&lt;package&gt; – uninstall local package</span><br><span class="line">npm up – npm update packages</span><br><span class="line">npm t – run tests</span><br><span class="line">npm ls – list installed modules</span><br><span class="line">npm ll or npm la – print additional package information while listing modules</span><br></pre></td></tr></table></figure><h4 id="8、其他"><a href="#8、其他" class="headerlink" title="8、其他"></a>8、其他</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm config set editor &quot;sublime&quot;</span><br><span class="line">npm ls</span><br><span class="line">npm list --global</span><br><span class="line">npm list -g --depth=0</span><br><span class="line"></span><br><span class="line">npm config list</span><br><span class="line">npm config get prefix</span><br><span class="line">npm config set prefix=$HOME/.node_modules_global</span><br></pre></td></tr></table></figure><p>我们可以用 npm 来执行 <em>package.json</em> 文件中指定的（命令行）命令。</p><p>先在 <em>package.json</em> 文件中的 scripts 项中添加相应的命令，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot; : &#123;</span><br><span class="line">    &quot;test&quot; : &quot;node testfile.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行 <code>npm run &lt;command&gt;</code>，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run test</span><br></pre></td></tr></table></figure><p>全文完！</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Install Nodejs and Use NVM to Manage Nodejs Versions</title>
      <link href="/Web/web-nodejs-install/"/>
      <url>/Web/web-nodejs-install/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这篇文章主要介绍在 Mac OS 下安装 Nodejs 并使用 nvm 来管理不同版本的 Nodejs。<br>This article introduces how to install Nodejs on Mac OS and how to use nvm to manage different versions of Nodejs.</p><h3 id="第一部分：Nodejs"><a href="#第一部分：Nodejs" class="headerlink" title="第一部分：Nodejs"></a>第一部分：Nodejs</h3><h4 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h4><p>在安装之前，我们可以使用 brew 来查看系统正在使用的 Node 的信息，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">brew list node</span><br><span class="line">/usr/local/Cellar/node/12.1.0/bin/node</span><br><span class="line">/usr/local/Cellar/node/12.1.0/etc/bash_completion.d/npm</span><br><span class="line">/usr/local/Cellar/node/12.1.0/include/node/ (445 files)</span><br><span class="line">/usr/local/Cellar/node/12.1.0/lib/dtrace/node.d</span><br><span class="line">/usr/local/Cellar/node/12.1.0/libexec/bin/ (2 files)</span><br><span class="line">/usr/local/Cellar/node/12.1.0/libexec/lib/ (4045 files)</span><br><span class="line">/usr/local/Cellar/node/12.1.0/share/doc/ (2 files)</span><br><span class="line">/usr/local/Cellar/node/12.1.0/share/man/man1/node.1</span><br><span class="line">/usr/local/Cellar/node/12.1.0/share/systemtap/tapset/node.stp</span><br></pre></td></tr></table></figure><p>执行上述 list 命令时，brew 会在 node 目录下搜寻可用的 node 版本。如果该目录想有多个版本，那么只会列举最新的那个。<br>执行 <code>brew link node</code> 命令时，会在 <code>/usr/local/bin/`` 目录下创建一个软链，指向</code>/usr/local/Cellar/node/12.1.0/bin` 目录下的可执行文件 node。</p><h4 id="2、-安装-Nodejs"><a href="#2、-安装-Nodejs" class="headerlink" title="2、 安装 Nodejs"></a>2、 安装 Nodejs</h4><p>在 Mac OS 中，安装 Nodejs 最简单的方式就是使用 brew 命令。</p><p>安装前，先查看官方库提供了哪些最新的发布版：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew search node</span><br></pre></td></tr></table></figure><p><img src="/image/web/brew_search.png" alt=""></p><p>可以看到，brew 只列出了部分主版本，并没有列出 Node 所有的发行版，比如奇数版本以及各个小版本。<br>如果我们需要安装 Node 某个具体版本，就需要通过 nvm 版本管理其来实现。</p><p>现在先通过 brew 安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>安装之后，我们可以通过 <code>brew --prefix node</code> 来查看 Node 可执行文件路径，使用 <code>brew info node</code> 来查看详细信息。</p><h2 id="第二部分：NVM"><a href="#第二部分：NVM" class="headerlink" title="第二部分：NVM"></a>第二部分：NVM</h2><p>NVM 的全称就是 “Node Version Manager”，使用它之前，我们先安装。</p><h4 id="1、安装-nvm"><a href="#1、安装-nvm" class="headerlink" title="1、安装 nvm"></a>1、安装 nvm</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nvm</span><br></pre></td></tr></table></figure><p>成功之后，我们把它添加到环境变量中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source $(brew --prefix nvm)/nvm.sh</span><br></pre></td></tr></table></figure><p>在 <code>~/.bashrc</code> 中添加如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export NVM_DIR="$HOME/.nvm"</span><br><span class="line">[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh" # This loads nvm</span><br><span class="line">[ -s "$NVM_DIR/bash_completion" ] &amp;&amp; \. "$NVM_DIR/bash_completion" # This loads nvm bash_completion</span><br></pre></td></tr></table></figure><p>现在，我们就可以通过 nvm 来安装和卸载各个版本的 Node 了。</p><h4 id="2、nvm-使用"><a href="#2、nvm-使用" class="headerlink" title="2、nvm 使用"></a>2、nvm 使用</h4><p>通过 nvm 来安装 Node 很简单，命令格式与 brew 类似，通过 @ 来指定具体版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install node@11.15.0</span><br></pre></td></tr></table></figure><p>由于我们可能在本地安装多个版本的 Node，所以，安装之后，我们要先启用才能使用新安装的 Node。<br>使用 <strong>use</strong> 命令来启用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use 11</span><br></pre></td></tr></table></figure><p>为了更好的管理通过 nvm 安装的 Node，我们需要了解 nvm 帮我们做了什么事，其中最关键的就是知道 nvm 把 Node 安装在哪个目录。</p><p>在 Mac OS 中，nvm 安装的 Node 二进制文件是在如下目录中：</p><p><img src="/image/web/nvm_nodedir.png" alt=""></p><p>具体的二进制文件则是在对应版本子目录的 <code>bin/</code> 中，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/alex/.nvm/versions/node/v11.15.0/bin</span><br></pre></td></tr></table></figure><p>我们知道，NPM 是会随着 Node 一起被安装的，它会被安装在如下目录中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/alex/.nvm/versions/node/v11.15.0/lib/node_modules/npm/bin/npm-cli.js</span><br></pre></td></tr></table></figure><p><img src="/image/web/whichnode.png" alt=""></p><p>注意：上述的 <code>which node</code> 命令显示的 <code>/Users/alex/.nvm/versions/node/v11.15.0/bin/npm</code> 实际上是一个软链，其链接到 lib/node_modules/npm/bin/ 目录下真正的 npm-cli.js 文件。</p><p>###备注：<br>注意到 nvm 实际上是一个 shell 脚本，所以，如果我们使用的是 fish shell，那么默认的 nvm.sh 就不可用。github 社区有人写了一个叫 <code>fish-nvm</code> 的工具，我试用了一下，功能非常简单，跟 nvm 正规用法和命令都不相同，不建议使用。</p><p>全文完！</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang Hook</title>
      <link href="/Programming/go-go-hook/"/>
      <url>/Programming/go-go-hook/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这篇文章主要是通过官方提供的 <a href="https://blog.golang.org/http-tracing" target="_blank" rel="noopener">HTTP 追踪</a>来学习使用 Hook 的编程思想。</p><p>简单来说 Hook 的编程思想跟事件驱动是类似的，通过预先保存一些要执行函数或方法，在满足某些条件的时候自动执行。<br>在了解使用 Go 语言编写 Hook 之前，最好先掌握 Context 的用法，关于 Context 的用法，请详见[另外一篇文章][]。</p><p>官方提供的 <code>net/http/httptrace</code>主要是用于追踪客户端的  Request 请求过程中发生的各种事件及行为，在标准库 <code>net/http/httptrace/trace.go</code> 中定义了一个叫 ClientTrace 的结构体，它包含了一系列的钩子函数 hooks 作为成员变量，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientTrace is a set of hooks to run at various stages of an outgoing HTTP request. </span></span><br><span class="line"><span class="keyword">type</span> ClientTrace <span class="keyword">struct</span> &#123;</span><br><span class="line">    GetConn <span class="function"><span class="keyword">func</span><span class="params">(hostPort <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">GotConn</span> <span class="title">func</span><span class="params">(GotConnInfo)</span></span></span><br><span class="line"><span class="function">    <span class="title">PutIdleConn</span> <span class="title">func</span><span class="params">(err error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">GotFirstResponseByte</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">Got100Continue</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">DNSStart</span> <span class="title">func</span><span class="params">(DNSStartInfo)</span></span></span><br><span class="line"><span class="function">    <span class="title">DNSDone</span> <span class="title">func</span><span class="params">(DNSDoneInfo)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">ConnectStart</span> <span class="title">func</span><span class="params">(network, addr <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">ConnectDone</span> <span class="title">func</span><span class="params">(network, addr <span class="keyword">string</span>, err error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">TLSHandshakeStart</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">TLSHandshakeDone</span> <span class="title">func</span><span class="params">(tls.ConnectionState, error)</span></span></span><br><span class="line"><span class="function">    <span class="title">WroteHeaders</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">Wait100Continue</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">WroteRequest</span> <span class="title">func</span><span class="params">(WroteRequestInfo)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>trace.go 还提供了一个 WithClientTrace() 包函数，用来把 ClientTrace 结构体中的钩子都保存（注册）到 Context 中去（因为 Context 提供 key/value 存储嘛），<br>key 就是一个叫 clientEventContextKey 的空结构体，value 是 nettrace 包中的 Trace 结构体，这个结构体作用跟 ClientTrace 一样，都是包含了一堆 hook 函数作为成员，<br>在这里它的目的只是封装下 ClientTrace 中的 hook 函数。最终， WithClientTrace() 会返回一个 context，它保存了上述的 hook 函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> clientEventContextKey <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithClientTrace</span><span class="params">(ctx context.Context, trace *ClientTrace)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> trace == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"nil trace"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    old := ContextClientTrace(ctx)</span><br><span class="line">    trace.compose(old)</span><br><span class="line"></span><br><span class="line">    ctx = context.WithValue(ctx, clientEventContextKey&#123;&#125;, trace)</span><br><span class="line">    <span class="keyword">if</span> trace.hasNetHooks() &#123;</span><br><span class="line">        nt := &amp;nettrace.Trace&#123;</span><br><span class="line">            ConnectStart: trace.ConnectStart,</span><br><span class="line">            ConnectDone:  trace.ConnectDone,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> trace.DNSStart != <span class="literal">nil</span> &#123;</span><br><span class="line">            nt.DNSStart = <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">                trace.DNSStart(DNSStartInfo&#123;Host: name&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> trace.DNSDone != <span class="literal">nil</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ctx = context.WithValue(ctx, nettrace.TraceKey&#123;&#125;, nt)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 ContextClientTrace() 的函数，可以把 ClientTrace 从 Context 中取出来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ContextClientTrace returns the ClientTrace associated with the</span></span><br><span class="line"><span class="comment">// provided context. If none, it returns nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContextClientTrace</span><span class="params">(ctx context.Context)</span> *<span class="title">ClientTrace</span></span> &#123;</span><br><span class="line">    trace, _ := ctx.Value(clientEventContextKey&#123;&#125;).(*ClientTrace)</span><br><span class="line">    <span class="keyword">return</span> trace</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们知道，有了 WithClientTrace()，我们就可以把钩子函数保存在 Context 中了，现在，我们要把这些钩子函数挂到 Request 中去，该怎么弄？<br>很简单，通过 Request.WithContext() 把刚才赋值好的 Context 保存到 Request 中就可以了。</p><p>现在 Request 有了这些钩子函数，那么什么时候会被调用呢？ 当然会 <strong>http.Client.Do(req)</strong> 的时候啦。</p><p>接下来我们通过一段实际的代码看看整个流程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/http/httptrace"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// transport is an http.RoundTripper that keeps track of the in-flight</span></span><br><span class="line"><span class="comment">// request and implements hooks to report HTTP tracing events.</span></span><br><span class="line"><span class="keyword">type</span> transport <span class="keyword">struct</span> &#123;</span><br><span class="line">    current *http.Request</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RoundTrip wraps http.DefaultTransport.RoundTrip to keep track</span></span><br><span class="line"><span class="comment">// of the current request.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *transport)</span> <span class="title">RoundTrip</span><span class="params">(req *http.Request)</span> <span class="params">(*http.Response, error)</span></span> &#123;</span><br><span class="line">    t.current = req</span><br><span class="line">    <span class="keyword">return</span> http.DefaultTransport.RoundTrip(req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GotConn prints whether the connection has been used previously</span></span><br><span class="line"><span class="comment">// for the current request.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *transport)</span> <span class="title">GotConn</span><span class="params">(info httptrace.GotConnInfo)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Connection reused for %v? %v\n"</span>, t.current.URL, info.Reused)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := &amp;transport&#123;&#125;</span><br><span class="line"></span><br><span class="line">    req, _ := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"https://google.com"</span>, <span class="literal">nil</span>)</span><br><span class="line">    trace := &amp;httptrace.ClientTrace&#123;</span><br><span class="line">        GotConn: t.GotConn,</span><br><span class="line">    &#125;</span><br><span class="line">    req = req.WithContext(httptrace.WithClientTrace(req.Context(), trace))</span><br><span class="line"></span><br><span class="line">    client := &amp;http.Client&#123;Transport: t&#125;</span><br><span class="line">    <span class="keyword">if</span> _, err := client.Do(req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的钩子的调用，最终都会在 <code>client.Do(req)</code> 里面执行，我们看看是怎么执行的。</p><p>注意到这里的 transport 结构体，它其实是 RoundTripper 接口类型（在 client.go 中声明）的一个 implementer，这个 RoundTripper 实际只有一个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RoundTripper is an interface representing the ability to execute a</span></span><br><span class="line"><span class="comment">// single HTTP transaction, obtaining the Response for a given Request.</span></span><br><span class="line"><span class="keyword">type</span> RoundTripper <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// RoundTrip executes a single HTTP transaction, returning</span></span><br><span class="line">    <span class="comment">// a Response for the provided Request.</span></span><br><span class="line">    RoundTrip(*Request) (*Response, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 client.Do() 中，会调用 client.send()，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp, didTimeout, err = c.send(req, deadline)</span><br></pre></td></tr></table></figure><p>c.send() 内部：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// didTimeout is non-nil only if err != nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">send</span><span class="params">(req *Request, deadline time.Time)</span> <span class="params">(resp *Response, didTimeout <span class="keyword">func</span>()</span> <span class="title">bool</span>, <span class="title">err</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    resp, didTimeout, err = send(req, c.transport(), deadline)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>send() 内部：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span> <span class="params">(resp *Response, didTimeout <span class="keyword">func</span>()</span> <span class="title">bool</span>, <span class="title">err</span> <span class="title">error</span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    resp, err = rt.RoundTrip(req)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，最终调用了 rt.RoundTrip() 函数。也就是上述 main.go 中 transport 实现的 RoundTrip() 函数。</p><p>在 rt.RoundTrip() 里面，把 req 赋给了 DefaultTransport.RoundTrip(req)，<br>这个 DefaultTransport 是包提供的一个 RoundTripper 的默认实现，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">    Proxy: ProxyFromEnvironment,</span><br><span class="line">    DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">        Timeout:   <span class="number">30</span> * time.Second,</span><br><span class="line">        KeepAlive: <span class="number">30</span> * time.Second,</span><br><span class="line">        DualStack: <span class="literal">true</span>,</span><br><span class="line">    &#125;).DialContext,</span><br><span class="line">    MaxIdleConns:          <span class="number">100</span>,</span><br><span class="line">    IdleConnTimeout:       <span class="number">90</span> * time.Second,</span><br><span class="line">    TLSHandshakeTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">    ExpectContinueTimeout: <span class="number">1</span> * time.Second,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在它的 RoundTrip() 函数里面最终会调用上述的钩子函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RoundTrip implements the RoundTripper interface.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For higher-level HTTP client support (such as handling of cookies</span></span><br><span class="line"><span class="comment">// and redirects), see Get, Post, and the Client type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">RoundTrip</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span> &#123;</span><br><span class="line">    t.nextProtoOnce.Do(t.onceSetNextProtoDefaults)</span><br><span class="line">    ctx := req.Context()</span><br><span class="line">    trace := httptrace.ContextClientTrace(ctx)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        treq := &amp;transportRequest&#123;Request: req, trace: trace&#125;</span><br><span class="line">        cm, err := t.connectMethodForRequest(treq)</span><br><span class="line">        ...</span><br><span class="line">        pconn, err := t.getConn(treq, cm)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>通过调用 httptrace.ContextClientTrace(ctx) 把 context 中的钩子函数都取出来，再在 t.getConn() 中调用钩子函数，如下：</p><p><img src="/image/programming/go_hook.png" alt=""></p><p>全文完！</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ethereum 命令行 geth 使用</title>
      <link href="/Distributed-System/blockchain-ethereum-geth-usage/"/>
      <url>/Distributed-System/blockchain-ethereum-geth-usage/</url>
      
        <content type="html"><![CDATA[<h3 id="进入Geth-命令行模式"><a href="#进入Geth-命令行模式" class="headerlink" title="进入Geth 命令行模式"></a>进入Geth 命令行模式</h3><p>在上一篇文章中，我们说到，我们可以用下面命令，建立一个新的私有链</p><pre><code>geth --datadir &quot;./&quot; --nodiscover console 2&gt;&gt;geth.log</code></pre><p>进入命令行模式，其中参数</p><ul><li>–datadir 代表文件夹地址，</li><li>–nodiscover 代表该链条不希望被其他节点发现，</li><li>console &gt;&gt; geth.log 代表将控制台输出到文件geth.log中去</li><li>输入 exit, 即可退出命令行模式</li></ul><h3 id="Geth命令行中的-Eth-accounts"><a href="#Geth命令行中的-Eth-accounts" class="headerlink" title="Geth命令行中的 Eth.accounts"></a>Geth命令行中的 Eth.accounts</h3><p>我们在命令行输入 eth.accounts 可以看到当前该区块链中共有几个账号，以及每个账号的公钥地址。</p><p><img src="/image/p2p/eth_account.png" alt=""></p><p>这里就要说到以太坊的账户体系了，</p><p>在以太坊系统中，状态是由被称为“账户”（每个账户由一个20字节的地址）的对象和在两个账户之间转移价值和信息的状态转换构成的。以太坊的账户包含四个部分：</p><ul><li>随机数，用于确定每笔交易只能被处理一次的计数器</li><li>账户目前的以太币余额</li><li>账户的合约代码，如果有的话</li><li>账户的存储（默认为空）</li><li>简单地说，每一个以太坊账户都有一对公钥和私钥组成。</li></ul><p>公钥我们可以理解为就是账户地址，任何其他账户都可以访问该地址<br>私钥可以理解为一段加密过的密码，这一对公钥和私钥共同组成一个唯一标示的以太坊账户。<br>例如在上节我们建立的第一个以太坊账户 <code>eth.accounts[0]</code> 中，地址 <code>0xbcf5b841303bc08026ce2d3b8f83498ffe42c12f</code> 就是公钥，而对密码加密而成的，就是私钥。</p><h3 id="如何新增账户"><a href="#如何新增账户" class="headerlink" title="如何新增账户"></a>如何新增账户</h3><p>我们可以输入命令 <code>personal.newAccount(&quot;123&quot;)</code> 来新建一个账户，（注意123可以修改为任何别的密码）</p><p><img src="/image/p2p/eth_account1.png" alt=""></p><p>这个时候我们可以看到除了第一个账户<code>0xbcf5b841303bc08026ce2d3b8f83498ffe42c12f</code> 之外，还新增了另一个账户 <code>0xb8b12a801b610176935a15321f77b48dd5c0c448</code>, 此时输入<code>eth.accounts</code>, 就可以很轻松的看到有两个账户的公钥地址。</p><h2 id="如何获取账户的以太币余额"><a href="#如何获取账户的以太币余额" class="headerlink" title="如何获取账户的以太币余额"></a>如何获取账户的以太币余额</h2><p>在上一章中我们说过，当以太坊的私链在挖矿时候，所挖到的以太币都会存入第一个以太坊账户中，即eth.accounts[0] 中，而eth.accounts[1]默认是不会有以太币的。这个时候我们可以用下面的命令来查看eth.accounts[0] 中的以太币余额。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eth.getBalance(&quot;0xbcf5b841303bc08026ce2d3b8f83498ffe42c12f&quot;)</span><br><span class="line">eth.getBalance(&quot;0xb8b12a801b610176935a15321f77b48dd5c0c448&quot;)</span><br></pre></td></tr></table></figure><ul><li>其中 <code>0xbcf5b841303bc08026ce2d3b8f83498ffe42c12f</code> 是第一个账户的地址，</li><li><code>0xb8b12a801b610176935a15321f77b48dd5c0c448</code> 是第二个账户的地址 结果如下： </li><li><img src="/image/p2p/eth_getbalance.png" alt=""></li></ul><p>从上我们可以看得很清楚，挖矿得来的以太币都进了第一个账户，同时每个账户的公钥是该账户的核心。通过公钥我么可以对该账户的以太币进行增删改查各种操作</p><h3 id="如何在两个账户之间进行以太币转换"><a href="#如何在两个账户之间进行以太币转换" class="headerlink" title="如何在两个账户之间进行以太币转换"></a>如何在两个账户之间进行以太币转换</h3><p>前面说过每个账户的公钥（地址）是一切以太坊账户操作的核心，但地址字符串太长，我们用 acc0/acc1 分别代表 accounts[0] 和 accounts[1]，另外设置要转移 0.01 个以太币</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; acc0 = eth.accounts[0]</span><br><span class="line">&quot;0xbcf5b841303bc08026ce2d3b8f83498ffe42c12f&quot;</span><br><span class="line">&gt; acc1 = eth.accounts[1]</span><br><span class="line">&quot;0xb8b12a801b610176935a15321f77b48dd5c0c448&quot;</span><br><span class="line">&gt; amount = web3.toWei(0.01)</span><br><span class="line">&quot;10000000000000000&quot;</span><br></pre></td></tr></table></figure><p>这个时候我们可以使用 eth.sendTransaction 来将 0.01 个以太币从 acc0 转移到 acc1 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.sendTransaction(&#123;from: acc0, to: acc1, value: amount&#125;)</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/image/p2p/eth_sendtransaction.png" alt=""></p><p>这个是以太坊的一个保护机制，每隔一段时间账户就会自动锁定，这个时候任何以太币在账户之间的转换都会被拒绝，除非把该账户解锁.</p><p>这个时候我们就需要执行 <code>personal.unlockAccount(acc0)</code> 并输入密码来解锁 acc0 才可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.unlockAccount(acc0)</span><br><span class="line">Unlock account 0xbcf5b841303bc08026ce2d3b8f83498ffe42c12f</span><br><span class="line">Passphrase: </span><br><span class="line">true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>这个时候我们重新执行命令 <code>eth.sendTransaction({from: acc0, to: acc1, value: amount})</code> , 结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.sendTransaction(&#123;from: acc0, to: acc1, value: amount&#125;)</span><br><span class="line">&quot;0xeea74dd5ff3f1287614d52ebb674edb93e8c5e51e4296835044d3d858d3d9f10&quot;</span><br><span class="line">&gt; eth.getBalance(acc1)</span><br><span class="line">10000000000000000</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>我们可以看到这个时候 acc1 有了数值 10000000000000000, 而不再是之前的 0 了。但我们明明要给 0.01 ether 币的，为何数值会如此大呢？ 其实是对的，我们只要输入命令 <code>web3.fromWei(10000000000000000, &quot;ether&quot;)</code> 就可以知道了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; web3.fromWei(10000000000000000,&quot;ether&quot;)</span><br><span class="line">&quot;0.01&quot;</span><br></pre></td></tr></table></figure><p>为什么呢，这个就涉及到以太坊的基本单位了，我们下章讲解.</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ether 币的基本单位</title>
      <link href="/Distributed-System/blockchain-ethereum-ether/"/>
      <url>/Distributed-System/blockchain-ethereum-ether/</url>
      
        <content type="html"><![CDATA[<h3 id="Ether币的基本单位"><a href="#Ether币的基本单位" class="headerlink" title="Ether币的基本单位"></a>Ether币的基本单位</h3><p>Ether币最小的单位是Wei，也是命令行默认的单位, 然后每 1000 进一个单位，依次是</p><p>kwei (1000 Wei)<br>mwei (1000 KWei)<br>gwei (1000 mwei)<br>szabo (1000 gwei)<br>finney (1000 szabo)<br>ether (1000 finney)</p><p>简单地说就是就是 <code>1 eth = 1000 * 1000 * 1000* 1000 * 1000* 1000 Wei = 1000 ^ 6 Wei</code> （这就是在使用 geth 命令行转账时，我们转移 0.01 个以太币，结果却显示很长的原因）<br>如何进行 ether 和 Wei 之间的转换</p><pre><code>Ether–&gt; Wei：web3.toWei</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; web3.toWei(1)</span><br><span class="line">&quot;1000000000000000000&quot;</span><br><span class="line">&gt; web3.toWei(1.3423423)</span><br><span class="line">&quot;1342342300000000000&quot;</span><br><span class="line">&gt; web3.toWei(0.00034)</span><br><span class="line">&quot;340000000000000&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>Wei –&gt; Ether: web3.fromWei</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; web3.fromWei(10000000000000000)</span><br><span class="line">&quot;0.01&quot;</span><br><span class="line">&gt; web3.fromWei(1000000000000000000)</span><br><span class="line">&quot;1&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h3 id="一个以太币各单位之间的转换工具"><a href="#一个以太币各单位之间的转换工具" class="headerlink" title="一个以太币各单位之间的转换工具"></a>一个以太币各单位之间的转换工具</h3><p><a href="http://ether.fund/tool/converter" target="_blank" rel="noopener">http://ether.fund/tool/converter</a><br>使用很简单，输入各种单位，就可以自动得到各种转换结果，例如输入0.01ether 可以得到多少Wei, 多少finney等。<br><img src="http://upload-images.jianshu.io/upload_images/1452123-5e9b419cf28edf47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="开始挖矿-amp-停止挖矿"><a href="#开始挖矿-amp-停止挖矿" class="headerlink" title="开始挖矿 &amp; 停止挖矿"></a>开始挖矿 &amp; 停止挖矿</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; miner.start()   //开始挖矿</span><br><span class="line">true</span><br><span class="line">&gt; miner.stop()   //停止挖矿</span><br><span class="line">true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h3 id="部署合约"><a href="#部署合约" class="headerlink" title="部署合约"></a>部署合约</h3><p>注意合约部署的时候，以太坊的私有链必须处在挖矿进行的状态，否则合约部署将不会生效</p><p>在命令行中，首先 <code>unlock(eth.accounts[0])</code>，因为部署合约需要消耗gas，也就是以太币。而之前说过由于保护机制，不解锁账户，是不会允许任何以太币流出的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.unlockAccount(acc0)</span><br><span class="line">Unlock account 0xbcf5b841303bc08026ce2d3b8f83498ffe42c12f</span><br><span class="line">Passphrase: </span><br><span class="line">true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>然后我们复制黏贴下面代码到 geth 命令行中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a_demotypesContract = web3.eth.contract([&#123;&quot;constant&quot;:false,&quot;inputs&quot;:[&#123;&quot;name&quot;:&quot;a&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;name&quot;:&quot;f&quot;,&quot;outputs&quot;:[&#123;&quot;name&quot;:&quot;b&quot;,&quot;type&quot;:&quot;uint256&quot;&#125;],&quot;payable&quot;:false,&quot;type&quot;:&quot;function&quot;&#125;]);</span><br><span class="line">var a_demotypes = a_demotypesContract.new(</span><br><span class="line">   &#123;</span><br><span class="line">     from: web3.eth.accounts[0], </span><br><span class="line">     data: &apos;0x6060604052341561000c57fe5b5b60ab8061001b6000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063b3de648b14603a575bfe5b3415604157fe5b60556004808035906020019091905050606b565b6040518082815260200191505060405180910390f35b600060006008830290508091505b509190505600a165627a7a7230582010decdc0b0a43b565814fe904eae2544665457d6353c7d906fc2c43c81c867e40029&apos;, </span><br><span class="line">     gas: &apos;4700000&apos;</span><br><span class="line">   &#125;, function (e, contract)&#123;</span><br><span class="line">    console.log(e, contract);</span><br><span class="line">    if (typeof contract.address !== &apos;undefined&apos;) &#123;</span><br><span class="line">         console.log(&apos;Contract mined! address: &apos; + contract.address + &apos; transactionHash: &apos; + contract.transactionHash);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>结果如下图：<br><img src="http://upload-images.jianshu.io/upload_images/1452123-18f53aac2b408920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>等待片刻，会发现合约被部署到挖矿挖出来的区块中了, 按下回车代表成功</p><p><img src="http://upload-images.jianshu.io/upload_images/1452123-c83b59902637102a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>此时输入合约部署的实例 a_demotypes, 可以看到a_demotypes的详情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; a_demotypes</span><br><span class="line">&#123;</span><br><span class="line">  abi: [&#123;</span><br><span class="line">      constant: false,</span><br><span class="line">      inputs: [&#123;...&#125;],</span><br><span class="line">      name: &quot;f&quot;,</span><br><span class="line">      outputs: [&#123;...&#125;],</span><br><span class="line">      payable: false,</span><br><span class="line">      type: &quot;function&quot;</span><br><span class="line">  &#125;],</span><br><span class="line">  address: &quot;0x54ed7a5f5a63ddada3bfe83b3e632adabaa5fc2f&quot;,</span><br><span class="line">  transactionHash: &quot;0x69cde62bcd6458e14f40497f4840f422911d63f5dea2b3a9833e6810db64a1c9&quot;,</span><br><span class="line">  allEvents: function(),</span><br><span class="line">  f: function()</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>也可以调用 a_demotypes 的方法 f , 输入任何数字，会返回 8*n，如输入100，返回800，输入125，返回1000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; a_demotypes.f.call(100)</span><br><span class="line">800</span><br><span class="line">&gt; a_demotypes.f.call(125)</span><br><span class="line">1000</span><br></pre></td></tr></table></figure><p>参考：<br><a href="http://www.tk4479.net/ethchinese/article/details/62220921" target="_blank" rel="noopener">http://www.tk4479.net/ethchinese/article/details/62220921</a></p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>json-rpc 介绍</title>
      <link href="/Tools-and-Build/tool-and-build-json-rpc/"/>
      <url>/Tools-and-Build/tool-and-build-json-rpc/</url>
      
        <content type="html"><![CDATA[<p>json-rpc 是 rpc 通信过程中定义的一套 json 格式标准，最早是 <a href="http://json-rpc.org/wiki/specification" target="_blank" rel="noopener">json-rpc1.0</a>，最新是 json-rpc2.0。</p><p>使用 json 格式来通信，通信的双方 client，server 必须约定好统一的字段，以便彼此能互相解析，这就是 json-rpc 标准的来由。</p><p>根据 <strong>json-rpc 1.0</strong> 约定，Request 和 Response 的格式必须符合如下要求：</p><p>######（1）Request</p><ul><li><strong>method</strong> A String containing the name of the method to be invoked.</li><li><strong>params</strong> An Array of objects to pass as arguments to the method.</li><li><strong>id</strong> The request id. This can be of any type. It is used to match the response with the request that it is replying to.</li></ul><p>######（2）Response</p><ul><li><strong>result</strong> The Object that was returned by the invoked method. This must be null in - - case there was an error invoking the method.</li><li><strong>error</strong> An Error object if there was an error invoking the method. It must be null if there was no error.</li><li><strong>id</strong> This must be the same id as the request it is responding to.</li></ul><p>例子：<br>request：data sent to service</p><pre><code>{ &quot;method&quot;: &quot;echo&quot;, &quot;params&quot;: [&quot;Hello JSON-RPC&quot;], &quot;id&quot;: 1}</code></pre><p>response：data coming from service</p><pre><code>{ &quot;result&quot;: &quot;Hello JSON-RPC&quot;, &quot;error&quot;: null, &quot;id&quot;: 1}</code></pre><p>####json-rpc2.0</p><p>######（1）Request</p><ul><li><strong>jsonrpc</strong> - A String specifying the version of the JSON-RPC protocol. MUST be exactly “2.0”.</li><li><strong>method</strong> - A String containing the name of the method to be invoked.</li><li><strong>params</strong> - An Array of objects to pass as arguments to the method.</li><li><strong>id</strong> - The request id. This can be of any type. It is used to match the response with the request that it is replying to.</li></ul><p>######（2）Response</p><ul><li><strong>jsonrpc</strong> - A String specifying the version of the JSON-RPC protocol. MUST be exactly “2.0”.</li><li><strong>result</strong> - The Object that was returned by the invoked method. This must be null in case there was an error invoking the method.</li><li><strong>error</strong> - An Error object if there was an error invoking the method. It must be null if there was no error.</li><li><strong>id</strong> - This must be the same id as the request it is responding to.</li></ul><h6 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h6><p><strong>A Notification is a Request object without an “id” member.</strong> A Request object that is a Notification signifies the Client’s lack of interest in the corresponding Response object, and as such no Response object needs to be returned to the client.<br>The Server MUST NOT reply to a Notification, including those that are within a batch request.</p><p>例子：<br>request：data sent to service</p><pre><code>{&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;subtract&quot;, &quot;params&quot;: [42, 23], &quot;id&quot;: 1}</code></pre><p>response：data coming from service</p><pre><code>{&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: 19, &quot;id&quot;: 1}</code></pre><p>a notification request</p><pre><code>{&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;update&quot;, &quot;params&quot;: [1,2,3,4,5]}</code></pre><p>a notification response</p><pre><code>{&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;foobar&quot;}</code></pre><h4 id="json-rpc1-0-VS-json-rpc2-0"><a href="#json-rpc1-0-VS-json-rpc2-0" class="headerlink" title="json-rpc1.0  VS  json-rpc2.0"></a><strong>json-rpc1.0</strong>  VS  <strong>json-rpc2.0</strong></h4><ul><li><strong>“jsonrpc” field added added a version-field to the Request (and also to the Response) to resolve compatibility issues with JSON-RPC 1.0.</strong></li><li><strong>client-server instead of peer-to-peer</strong>:JSON-RPC 2.0 uses a client-server-architecture.<br>V1.0 used a peer-to-peer-architecture where every peer was both server and client.</li><li><strong>Transport independence</strong>:JSON-RPC 2.0 doesn’t define any transport-specific issues, since transport and RPC are independent.<br>V1.0 defined that exceptions must be raised if the connection is closed, and that invalid requests/responses must close the connection (and raise exceptions).</li><li><strong>Named parameters added</strong> (see <a href="http://www.simple-is-better.org/rpc/#example" target="_blank" rel="noopener">Example</a> below)</li><li><strong>Reduced fields</strong>:<ul><li>Request: params may be omitted</li><li>Notification: doesn’t contain an id anymore</li><li>Response: contains only <code>result</code> OR <code>error</code>  (but not both)</li></ul></li><li><strong>Optional parameters</strong>: defined that unspecified optional parameters SHOULD use a default-value.</li><li><strong>Error-definitions added</strong></li></ul><p>Go官方库实现了<a href="http://json-rpc.org/wiki/specification" target="_blank" rel="noopener">JSON-RPC 1.0</a>。JSON-RPC是一个通过JSON格式进行消息传输的RPC规范，因此可以进行跨语言的调用。</p><p>源文件：<code>rpc/jsonrpc/client.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> clientRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    Method <span class="keyword">string</span>         <span class="string">`json:"method"`</span></span><br><span class="line">    Params [<span class="number">1</span>]<span class="keyword">interface</span>&#123;&#125; <span class="string">`json:"params"`</span></span><br><span class="line">    Id     <span class="keyword">uint64</span>         <span class="string">`json:"id"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *clientCodec)</span> <span class="title">WriteRequest</span><span class="params">(r *rpc.Request, param <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    c.mutex.Lock()</span><br><span class="line">    c.pending[r.Seq] = r.ServiceMethod</span><br><span class="line">    c.mutex.Unlock()</span><br><span class="line">    c.req.Method = r.ServiceMethod</span><br><span class="line">    c.req.Params[<span class="number">0</span>] = param</span><br><span class="line">    c.req.Id = r.Seq</span><br><span class="line">    <span class="keyword">return</span> c.enc.Encode(&amp;c.req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 enc 就是 <code>json.Encoder()</code>，可见 <code>WriteRequest()</code> 函数最终把请求 encode 成 json 格式发送了。</p><p>调用流程分析：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallRpcService</span><span class="params">(c *rpc.Client)</span></span> &#123;</span><br><span class="line">    args := &amp;server.Args&#123;<span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> reply <span class="keyword">int</span></span><br><span class="line">    err := c.Call(<span class="string">"Arith.Mult"</span>, args, &amp;reply)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"Arith error: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Arith: %d*%d= %d\n"</span>, args.A, args.B, reply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是调用的 <code>c.Call(&quot;Arith.Mult&quot;, args, &amp;reply&quot;)</code> 来实现发送 json-rpc request 到服务器的。<br>Call() 函数内部的调用过程如下：<br>源文件：<code>rpc/client.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span> <span class="title">Call</span><span class="params">(serviceMethod <span class="keyword">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    call := &lt;-client.Go(serviceMethod, args, reply, <span class="built_in">make</span>(<span class="keyword">chan</span> *Call, <span class="number">1</span>)).Done</span><br><span class="line">    <span class="keyword">return</span> call.Error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span> <span class="title">Go</span><span class="params">(serviceMethod <span class="keyword">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;, done <span class="keyword">chan</span> *Call)</span> *<span class="title">Call</span></span> &#123;</span><br><span class="line">    call := <span class="built_in">new</span>(Call)</span><br><span class="line">    call.ServiceMethod = serviceMethod</span><br><span class="line">    call.Args = args</span><br><span class="line">    call.Reply = reply</span><br><span class="line">    ...</span><br><span class="line">    client.send(call)</span><br><span class="line">    <span class="keyword">return</span> call</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(client *Client)</span> <span class="title">send</span><span class="params">(call *Call)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Encode and send the request.</span></span><br><span class="line">    client.request.Seq = seq</span><br><span class="line">    client.request.ServiceMethod = call.ServiceMethod</span><br><span class="line">    err := client.codec.WriteRequest(&amp;client.request, call.Args)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源文件：<code>rpc/jsonrpc/client.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (4)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *clientCodec)</span> <span class="title">WriteRequest</span><span class="params">(r *rpc.Request, param <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    c.mutex.Lock()</span><br><span class="line">    c.pending[r.Seq] = r.ServiceMethod</span><br><span class="line">    c.mutex.Unlock()</span><br><span class="line">    c.req.Method = r.ServiceMethod</span><br><span class="line">    c.req.Params[<span class="number">0</span>] = param</span><br><span class="line">    c.req.Id = r.Seq</span><br><span class="line">    <span class="keyword">return</span> c.enc.Encode(&amp;c.req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 的 <code>net/rpc/jsonrpc</code> 库可以将 JSON-RPC 的请求转换成自己内部的格式，比如 request header 的处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *serverCodec)</span> <span class="title">ReadRequestHeader</span><span class="params">(r *rpc.Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    c.req.reset()</span><br><span class="line">    <span class="keyword">if</span> err := c.dec.Decode(&amp;c.req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    r.ServiceMethod = c.req.Method</span><br><span class="line">    c.mutex.Lock()</span><br><span class="line">    c.seq++</span><br><span class="line">    c.pending[c.seq] = c.req.Id</span><br><span class="line">    c.req.Id = <span class="literal">nil</span></span><br><span class="line">    r.Seq = c.seq</span><br><span class="line">    c.mutex.Unlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言官方库目前不支持 JSON-RPC 2.0 ，但是有第三方开发者提供了实现，比如:<br><a href="https://github.com/powerman/rpc-codec" target="_blank" rel="noopener">https://github.com/powerman/rpc-codec</a><br><a href="https://github.com/dwlnetnl/generpc" target="_blank" rel="noopener">https://github.com/dwlnetnl/generpc</a></p><p>一些其它的 codec 如 <a href="https://godoc.org/github.com/skynetservices/skynet/rpc/bsonrpc" target="_blank" rel="noopener">bsonrpc</a>、<a href="https://godoc.org/github.com/hashicorp/net-rpc-msgpackrpc" target="_blank" rel="noopener">messagepack</a>、<a href="https://github.com/mars9/codec" target="_blank" rel="noopener">protobuf</a> 等。<br>如果你使用其它特定的序列化框架，你可以参照这些实现来写一个你自己的 rpc codec。<br>关于 Go 序列化库的性能的比较可以参考 <a href="https://github.com/smallnest/gosercomp" target="_blank" rel="noopener">gosercomp</a>。</p><p><strong>注意：</strong><br>Go 语言提供的 jsonrpc 包不支持 json-rpc over HTTP，因此我们不能通过 curl 命令来给 Server 发送请求来测试。如果我们真的需要用 http 请求来测试的话，那么我们就应该提供一个 HTTP Hanlder 来处理 HTTP request/response，然后把他适配到 ServerCodec 函数中去，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">    <span class="string">"net/rpc/jsonrpc"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addr = <span class="string">"localhost:8080"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HttpConn <span class="keyword">struct</span> &#123;</span><br><span class="line">    in  io.Reader</span><br><span class="line">    out io.Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *HttpConn)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span>  &#123; <span class="keyword">return</span> c.in.Read(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *HttpConn)</span> <span class="title">Write</span><span class="params">(d []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123; <span class="keyword">return</span> c.out.Write(d) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *HttpConn)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span>                      &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC Api structure</span></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Greet method arguments</span></span><br><span class="line"><span class="keyword">type</span> GreetArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Grret message accept object with single param Name</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(test *Test)</span> <span class="title">Greet</span><span class="params">(args *GreetArgs, result *<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    *result = <span class="string">"Hello "</span> + args.Name</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start server with Test instance as a service</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test := <span class="built_in">new</span>(Test)</span><br><span class="line"></span><br><span class="line">    server := rpc.NewServer()</span><br><span class="line">    server.Register(test)</span><br><span class="line"></span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"listen error:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> listener.Close()</span><br><span class="line">    </span><br><span class="line">    http.Serve(listener, http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r.URL.Path == <span class="string">"/test"</span> &#123;</span><br><span class="line">            serverCodec := jsonrpc.NewServerCodec(&amp;HttpConn&#123;in: r.Body, out: w&#125;)</span><br><span class="line">            w.Header().Set(<span class="string">"Content-type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">            w.WriteHeader(<span class="number">200</span>)</span><br><span class="line">            err := server.ServeRequest(serverCodec)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Printf(<span class="string">"Error while serving JSON request: %v"</span>, err)</span><br><span class="line">                http.Error(w, <span class="string">"Error while serving JSON request, details have been logged."</span>, <span class="number">500</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    startServer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们就可以用 curl 命令来测试了，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d &apos;&#123;&quot;id&quot;: 1, &quot;method&quot;: &quot;Test.Greet&quot;, &quot;params&quot;: [&#123;&quot;name&quot;:&quot;world&quot;&#125;]&#125;&apos; http://localhost:8080/test</span><br></pre></td></tr></table></figure><p>网上也有 json-rpc over http 的第三方开源库，比如 <a href="https://github.com/gorilla/rpc/tree/master/json" target="_blank" rel="noopener">gorilla/rpc</a></p><p>使用 gorrlla/rpc 的实例：<br><a href="https://haisum.github.io/2015/10/13/rpc-jsonrpc-gorilla-example-in-golang/" target="_blank" rel="noopener">https://haisum.github.io/2015/10/13/rpc-jsonrpc-gorilla-example-in-golang/</a>  </p><p>参考:<br><a href="http://www.simple-is-better.org/rpc/#differences-between-1-0-and-2-0" target="_blank" rel="noopener">http://www.simple-is-better.org/rpc/#differences-between-1-0-and-2-0</a>  </p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang io.Reader 解析</title>
      <link href="/Programming/go-go-ioreader/"/>
      <url>/Programming/go-go-ioreader/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>io.Reader 是一个 Interface 类型，功能非常强大，在任何需要读的地方我们都尽量使用它。先来看下它的原型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">  Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，任何实现了 Read() 函数的对象都可以作为 Reader 来使用。</p><h3 id="Reader-类型"><a href="#Reader-类型" class="headerlink" title="Reader 类型"></a>Reader 类型</h3><p>标准库中有许多不同的 Reader 类型，最常见的就是 bytes, strings 等几个库。我们或多或少都用过它们。下面来看几个最常见的例子：</p><p>（1） 文件操作<br>当我们调用 <code>os.Open()</code>打开一个文件，它会返回一个 <code>os.File</code> 对象，而这个对象其实就是一个 Reader 类型（因为它实现了 Read 函数）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">r, err = os.Open(<span class="string">"file.txt"</span>)</span><br></pre></td></tr></table></figure><p>（2）字符串<br>我们还可以从一个普通的字符串 string 来创建一个 Reader，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">r = strings.NewReader(<span class="string">"Read will return these bytes"</span>)</span><br></pre></td></tr></table></figure><p>（3）网络 net</p><p>&lt;1&gt; net.Conn 是一个 Reader/Writer<br>原型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Conn <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(b []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">    Write(b []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">    Close() error</span><br><span class="line">    LocalAddr() Addr</span><br><span class="line">    RemoteAddr() Addr</span><br><span class="line">    SetDeadline(t time.Time) error</span><br><span class="line">    SetReadDeadline(t time.Time) error</span><br><span class="line">    SetWriteDeadline(t time.Time) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，提供的一个私有类型 conn 是一个 struct，其实现了上述 interface。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> conn <span class="keyword">struct</span> &#123;</span><br><span class="line">    fd *netFD</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Write implements the Conn Write method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"google.com:80"</span>)</span><br><span class="line">tmp := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">256</span>)     <span class="comment">// using small tmo buffer for demonstrating</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := conn.Read(tmp)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">                fmt.Println(<span class="string">"read error:"</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="built_in">append</span>(buf, tmp[:n]...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"google.com:80"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"dial error:"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    fmt.Fprintf(conn, <span class="string">"GET / HTTP/1.0\r\n\r\n"</span>)</span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    io.Copy(&amp;buf, conn)</span><br><span class="line">    fmt.Println(<span class="string">"total size:"</span>, buf.Len())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">whois</span><span class="params">(domain, server <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, server+<span class="string">":43"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    fmt.Fprintf(conn, <span class="string">"%s\r\n"</span>, domain)</span><br><span class="line">    <span class="keyword">return</span> ioutil.ReadAll(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&lt;2&gt; <code>http.Request</code> 中的 body 数据就是一个 Reader</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">    Method <span class="keyword">string</span></span><br><span class="line">    URL *url.URL</span><br><span class="line">    Header Header</span><br><span class="line">    <span class="comment">// Body is the request's body.</span></span><br><span class="line">    Body io.ReadCloser</span><br><span class="line">    Host <span class="keyword">string</span></span><br><span class="line">    Form url.Values</span><br><span class="line">    PostForm url.Values</span><br><span class="line">    MultipartForm *multipart.Form</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以这样使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">r = request.Body</span><br></pre></td></tr></table></figure><p>&lt;3&gt; <code>http.Post()</code> 请求<br>原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (c *Client) Post(url string, contentType string, body io.Reader) (resp *Response, err error)</span><br></pre></td></tr></table></figure><p>用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">requestBytes, _ := json.Marshal(request)</span><br><span class="line">requestBuf := bytes.NewBuffer(requestBytes)</span><br><span class="line">httpResponse, _ := c.client.Post(c.address, &quot;text/json&quot;, requestBuf)</span><br><span class="line">responseBytes, _ := ioutil.ReadAll(httpResponse.Body)</span><br><span class="line">response := &amp;types.RPCResponse&#123;&#125;</span><br><span class="line">err = json.Unmarshal(responseBytes, response)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Post(<span class="string">"www.example.com/accept.php"</span>, <span class="string">"application/x-www-form-urlencoded"</span>, strings.NewReader(<span class="string">"name=alex"</span>))</span><br></pre></td></tr></table></figure><p>（4） <code>bytes.Buffer</code><br>是 struct 类型，但同时也是一个 Reader/Writer，因为它实现了 Read() /Writer() 等函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Buffer <span class="keyword">struct</span> &#123;</span><br><span class="line">    buf       []<span class="keyword">byte</span>   <span class="comment">// contents are the bytes buf[off : len(buf)]</span></span><br><span class="line">    off       <span class="keyword">int</span>      <span class="comment">// read at &amp;buf[off], write at &amp;buf[len(buf)]</span></span><br><span class="line">    bootstrap [<span class="number">64</span>]<span class="keyword">byte</span> <span class="comment">// memory to hold first slice; helps small buffers avoid allocation.</span></span><br><span class="line">    lastRead  readOp   <span class="comment">// last read operation, so that Unread* can work correctly.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    b.lastRead = opInvalid</span><br><span class="line">    <span class="keyword">if</span> b.off &gt;= <span class="built_in">len</span>(b.buf) &#123;</span><br><span class="line">        <span class="comment">// Buffer is empty, reset to recover space.</span></span><br><span class="line">        b.Truncate(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, io.EOF</span><br><span class="line">    &#125;</span><br><span class="line">    n = <span class="built_in">copy</span>(p, b.buf[b.off:])</span><br><span class="line">    b.off += n</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        b.lastRead = opRead</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为 []byte 创建一个 Reader<br>有时候，我们有一个字节序列，但是需要调用的函数只接收 Reader，那么我们可以通过 bytes.NewReader() 来创建一个 Reader 来传入其中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bs, err := json.Marshal(data)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> io.Copy(os.Stdout, bytes.NewReader(bs))</span><br></pre></td></tr></table></figure><p>（5） <code>bufio</code><br>标准库 <code>bufio</code> 提供了对 io.Reader 和 io.Writer 等 I/O 对象的封装，实现了缓冲的功能。<br>比如 :</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span> *<span class="title">Reader</span> </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">NewWriterSize</span><span class="params">(w io.Writer, size <span class="keyword">int</span>)</span> *<span class="title">Writer</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">NewReadWriter</span><span class="params">(r *Reader, w *Writer)</span> *<span class="title">ReadWrite</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">NewScanner</span><span class="params">(r io.Reader)</span> *<span class="title">Scanner</span></span></span><br></pre></td></tr></table></figure><p>例子：<br>从标准输入读取内容到 buffer 中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reader := bufio.NewReader(os.Stdin)</span><br></pre></td></tr></table></figure><p>或者初始化一个 <code>bytes.Buffer</code> 对象，然后据此生成一个 <code>bufio.Reader</code> 对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readbuffer := bytes.NewBuffer([]<span class="keyword">byte</span>(<span class="string">"input string to be read into new buffer"</span>))</span><br><span class="line">reader := bufio.NewReader(readbuffer)</span><br></pre></td></tr></table></figure><p>由于 net.Conn 也是一个 Reader，因此还可以为它来创建一个 bufio.Reader，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">listener, err:= net.Listen(<span class="string">"tcp"</span>, <span class="string">":8888"</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    conn, _ := listener.Accept()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">reader := bufio.NewReader(conn)</span><br></pre></td></tr></table></figure><p>(6) 编解码 Decoder</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">  dec := json.NewDecoder(conn)</span><br><span class="line">  msg := <span class="built_in">new</span>(Message)</span><br><span class="line">  err := dec.Decode(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func NewDecoder(r io.Reader) *Decoder &#123;</span><br><span class="line">    return &amp;Decoder&#123;r: r&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注： 由于 conn 是一个 interface，声明了 Read() , Write() 等方法,  因此这里很方便的就可以作为 Reader 使用了。</p><p>除此之外，GO 语言标准库中还有很多 Reader 类型，我们应该在一切能使用它们的场景下都尽量使用它们。</p><h3 id="使用-Reader"><a href="#使用-Reader" class="headerlink" title="使用 Reader"></a>使用 Reader</h3><p>上面我们看了一些不同的 Reader 类型，现在我们看一下如何使用它们</p><p>（1）直接调用该 Reader 对象的 Read() 函数来读取数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">256</span>)</span><br><span class="line">n, err := r.Read(p)</span><br></pre></td></tr></table></figure><p>（2）使用 <code>ioutil.ReadAll</code> 从一个 Reader 中读取数据，返回 raw []byte</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b, err := ioutil.ReadAll(r)</span><br></pre></td></tr></table></figure><p>（3）使用 <code>io.Copy()</code> 从一个 Reader 中读取数据，并写入一个 Writer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n, err := io.Copy(w, r)</span><br></pre></td></tr></table></figure><p>（4）使用 JSON Decoder 从一个 Reader 中直接 decode 数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := json.NewDecoder(r).Decode(v)</span><br></pre></td></tr></table></figure><p>（5）从一个已经 gzipped 了的 []byte 数据的 Reader 中创建一个 gzip.Reader</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = gzip.NewReader(r)</span><br></pre></td></tr></table></figure><p>这样的话，从这个新创建的 reader 中读取数据的话就是已经自动 unzipped 的数据了。</p><h3 id="设计-Reader-接口"><a href="#设计-Reader-接口" class="headerlink" title="设计 Reader 接口"></a>设计 Reader 接口</h3><p>在编写应用程序接口的时候，如果我们需要接受 []byte 或者 string 等类型的数据，我们可以把参数设置成接受 Reader 类型而不是 []byte 或 string，这样的话，我们的接口就能变得更加通用，适用的场景也会更多。<br>如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br></pre></td></tr></table></figure><p>可以变成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(r io.Reader)</span> <span class="title">io</span>.<span class="title">Reader</span></span></span><br></pre></td></tr></table></figure><p>这样改变之后，如果别人想要传入一个 string，那么它可以这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = Reverse(strings.NewReader(<span class="string">"Make me backwards"</span>))</span><br></pre></td></tr></table></figure><p>如果别人想要传入一个文件对象，可以这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">"file.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">r = Reverse(f)</span><br></pre></td></tr></table></figure><p>或者，还可以传入一个 http.Request.Body</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  rev := Reverse(r.Body)</span><br><span class="line">  <span class="comment">// etc...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后建议：<br>在任何需要处理数据流的地方，都应该尽可能使用 Reader/Writer。</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang io.Writer 解析</title>
      <link href="/Programming/go-go-iowriter/"/>
      <url>/Programming/go-go-iowriter/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>io.Writer 跟 io.Reader 一样，都是 Interface 类型，功能非常强大，在任何需要写入数据，处理数据流的地方，我们都应该尽可能使用这两个类型的对象。</p><p>io.Writer 的原型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟 io.Reader 类似，一个对象只要实现了 Write() 函数，这个对象就自动成为 Writer 类型。</p><p>常见 Writer 类型</p><p>（1）文件操作<br>使用  <code>os.Create()</code> 创建文件时，会返回一个 <code>os.File</code> 对象，它是一个 struct，但是由于它实现了 Read() ，Write()，Closer() 等函数，因此它同时也是 Reader, Writer, Closer 等类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">    *file <span class="comment">// os specific</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := f.checkValid(<span class="string">"write"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    n, e := f.write(b)</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n != <span class="built_in">len</span>(b) &#123;</span><br><span class="line">        err = io.ErrShortWrite</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    epipecheck(f, e)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        err = &amp;PathError&#123;<span class="string">"write"</span>, f.name, e&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）<code>bytes.Buffer</code><br>在 Go 语言中，string 类型是 immutable 的，因此它没有对应的 Writer，也就是说不存在 strings.NewWriter(s) 这种函数。最好的替代方式就是使用 <code>bytes.Buffer</code>，因为它既是一个 Reader 也是一个 Writer，我们既可以往里面写也可以往外读。我们可以通过 <code>buf.String()</code> 得到 string 类型的数据，也可以通过 <code>buf.Bytes()</code> 拿到 []byte 类型的数据。</p><p>下面的例子展示了我们通过 bytes.NewBufferString(s) 函数，先在 buffer 中初始化一段 string，然后往里面 append 另外一段 string。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"Hello"</span></span><br><span class="line">buf := bytes.NewBufferString(s)</span><br><span class="line">s2 := <span class="string">"to be appended"</span></span><br><span class="line">buf.WriteString(s2)   <span class="comment">// 或者 fmt.Fprint(buf, s2)</span></span><br><span class="line">fmt.Println(<span class="string">"Final string:"</span>, buf.String())</span><br></pre></td></tr></table></figure><p>（3）<code>http.ResponseWriter</code><br>在使用 Go 语言进行 Web 开发时，<code>http.ResponseWriter</code> 是最基本的类型之一，它本身是一个 Interface 类，原型如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Header() Header</span><br><span class="line">    Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">    WriteHeader(<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，它只申明了需要实现三个函数，由于其要求了 Writer() 函数，包含了 Writer 的要求，因此，任何是符合 ResponserWriter 的类型必然是 Writer 类型。</p><p>下面是一个<code>http.ResponseWriter</code> 最常见的使用场景和方法的：</p><p>一、直接调用 Write() 写入一串 []byte</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span>) </span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"Hello World"</span>))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, helloHandler)</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式跟创建文件时，直接往文件对象中写入 []byte 是一样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, _:= os.Create(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> _, err = f.Write([]<span class="keyword">byte</span>(<span class="string">"Hello world"</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    f.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、或者 使用 io.WriteStirng() 或者 fmt.Fprintf() 往 Writer 中写入 string</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    io.WriteString(w, <span class="string">"Hello world!"</span>)</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"Hello, World!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, helloHandler)</span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4) <code>hash.Hash</code><br>hash 包中申明了 Hash 这个 interface 接口，作为所有 hash 函数的公共接口。它也是一个 Writer，原型如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Hash <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Write (via the embedded io.Writer interface) adds more data to the running hash.</span></span><br><span class="line">    <span class="comment">// It never returns an error.</span></span><br><span class="line">    io.Writer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sum appends the current hash to b and returns the resulting slice.</span></span><br><span class="line">    <span class="comment">// It does not change the underlying hash state.</span></span><br><span class="line">    Sum(b []<span class="keyword">byte</span>) []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset resets the Hash to its initial state.</span></span><br><span class="line">    Reset()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Size returns the number of bytes Sum will return.</span></span><br><span class="line">    Size() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BlockSize returns the hash's underlying block size.</span></span><br><span class="line">    <span class="comment">// The Write method must be able to accept any amount</span></span><br><span class="line">    <span class="comment">// of data, but it may operate more efficiently if all writes</span></span><br><span class="line">    <span class="comment">// are a multiple of the block size.</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/sha1"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    passwordHash := sha1.New()</span><br><span class="line">    io.WriteString(passwordHash, combination) <span class="comment">// 或者直接 passwordHash.Write(combination)</span></span><br><span class="line">    fmt.Printf(<span class="string">"Password Hash : %x \n"</span>, passwordHash.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(5) <code>bufio</code><br>可以通过 <code>bufio.NewWriter(r)</code> 函数来把原 io.Writer 对象封装成一个 <code>bufio.Writer</code> 对象，从而进行 buffered 读写。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, _ := os.Create(<span class="string">"file.txt"</span>)</span><br><span class="line">    w := bufio.NewWriter(f) <span class="comment">// Create a new writer.</span></span><br><span class="line">    w.WriteString(<span class="string">"ABC"</span>)  <span class="comment">// Write a string to the file.</span></span><br><span class="line">    w.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(6) gzip 压缩</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"compress/gzip"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Open file on disk.</span></span><br><span class="line">    name := <span class="string">"file.txt"</span></span><br><span class="line">    f, _ := os.Open(<span class="string">"C:\\programs\\"</span> + name)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a Reader and use ReadAll to get all the bytes from the file.</span></span><br><span class="line">    reader := bufio.NewReader(f)</span><br><span class="line">    content, _ := ioutil.ReadAll(reader)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace txt extension with gz extension.</span></span><br><span class="line">    name = strings.Replace(name, <span class="string">".txt"</span>, <span class="string">".gz"</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    f, _ = os.Create(<span class="string">"C:\\programs\\"</span> + name)</span><br><span class="line"></span><br><span class="line">    w := gzip.NewWriter(f)</span><br><span class="line">    w.Write(content)</span><br><span class="line">    w.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Etcd 使用</title>
      <link href="/Tools-and-Build/tool-and-build-etcd-usage/"/>
      <url>/Tools-and-Build/tool-and-build-etcd-usage/</url>
      
        <content type="html"><![CDATA[<h2 id="Etcd-简介"><a href="#Etcd-简介" class="headerlink" title="Etcd 简介"></a>Etcd 简介</h2><p>etcd 是一个高可用的键值存储系统，主要用于共享配置和服务发现。etcd是由CoreOS开发并维护的，灵感来自于 ZooKeeper 和 Doozer，它使用Go语言编写，并通过Raft一致性算法处理日志复制以保证强一致性。Raft是一个来自Stanford的新的一致性算法，适用于分布式系统的日志复制，Raft通过选举的方式来实现一致性，在Raft中，任何一个节点都可能成为Leader。Google的容器集群管理系统Kubernetes、开源PaaS平台Cloud Foundry和CoreOS的Fleet都广泛使用了etcd。</p><p>etcd 集群的工作原理基于 raft 共识算法 (The Raft Consensus Algorithm)。<br>etcd 在 0.5.0 版本中重新实现了 raft 算法，而非像之前那样依赖于第三方库 go-raft 。<br>raft 共识算法的优点在于可以在高效的解决分布式系统中各个节点日志内容一致性问题的同时，也使得集群具备一定的容错能力。即使集群中出现部分节点故障、网络故障等问题，仍可保证其余大多数节点正确的步进。甚至当更多的节点（一般来说超过集群节点总数的一半）出现故障而导致集群不可用时，依然可以保证节点中的数据不会出现错误的结果。</p><h4 id="1-Getting-etcd"><a href="#1-Getting-etcd" class="headerlink" title="1. Getting etcd"></a>1. Getting etcd</h4><p>从 Release 页面（<a href="https://github.com/coreos/etcd/releases/" target="_blank" rel="noopener">https://github.com/coreos/etcd/releases/</a> ）下载二进制，或者拉最新 master 代码进行编译。</p><pre><code>$ git clone https://github.com/coreos/etcd.git$ cd etcd$ ./build</code></pre><p>还有一种办法，直接获取一个 vendor 编译好的 etcd，如下：</p><pre><code>$ go get github.com/coreos/etcd/cmd/etcd</code></pre><h4 id="2-Starting-etcd"><a href="#2-Starting-etcd" class="headerlink" title="2. Starting etcd"></a>2. Starting etcd</h4><p>直接执行</p><pre><code>$ etcd</code></pre><p>或者指定 data-dir</p><pre><code>$ etcd -data-dir=/var/edata</code></pre><p>更加详细的配置选项，请查看：<a href="https://coreos.com/etcd/docs/latest/op-guide/configuration.html" target="_blank" rel="noopener">https://coreos.com/etcd/docs/latest/op-guide/configuration.html</a> </p><p>一个简单例子 human readable：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> This config is meant to be consumed by the config transpiler, <span class="built_in">which</span> will</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> generate the corresponding Ignition config. Do not pass this config directly</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> to instances of Container Linux.</span></span><br><span class="line"></span><br><span class="line">etcd:</span><br><span class="line">  name:                        my-etcd-1</span><br><span class="line">  listen_client_urls:          https://10.240.0.1:2379</span><br><span class="line">  advertise_client_urls:       https://10.240.0.1:2379</span><br><span class="line">  listen_peer_urls:            https://10.240.0.1:2380</span><br><span class="line">  initial_advertise_peer_urls: https://10.240.0.1:2380</span><br><span class="line">  initial_cluster:             my-1=https://10.240.0.1:2380,my-2=https://10.240.0.2:2380,my-3=https://10.240.0.3:2380</span><br><span class="line">  initial_cluster_token:       my-etcd-token</span><br><span class="line">  initial_cluster_state:       new</span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://coreos.com/etcd/docs/latest/getting-started-with-etcd.html" target="_blank" rel="noopener">https://coreos.com/etcd/docs/latest/getting-started-with-etcd.html</a><br><a href="https://docs.portworx.com/run-etcd.html" target="_blank" rel="noopener">https://docs.portworx.com/run-etcd.html</a>  </p><h4 id="3-etcd-cluster"><a href="#3-etcd-cluster" class="headerlink" title="3. etcd cluster"></a>3. etcd cluster</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">etcd --name infra0 --initial-advertise-peer-urls http://10.0.1.10:2380 \</span><br><span class="line">  --listen-peer-urls http://10.0.1.10:2380 \</span><br><span class="line">  --listen-client-urls http://10.0.1.10:2379,http://127.0.0.1:2379 \</span><br><span class="line">  --advertise-client-urls http://10.0.1.10:2379 \</span><br><span class="line">  --initial-cluster-token etcd-cluster-1 \</span><br><span class="line">  --initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \</span><br><span class="line">  --initial-cluster-state new</span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://coreos.com/etcd/docs/latest/v2/docker_guide.html#running-etcd-in-standalone-mode" target="_blank" rel="noopener">https://coreos.com/etcd/docs/latest/v2/docker_guide.html#running-etcd-in-standalone-mode</a><br><a href="https://coreos.com/etcd/docs/latest/op-guide/clustering.html" target="_blank" rel="noopener">https://coreos.com/etcd/docs/latest/op-guide/clustering.html</a>  </p><h4 id="4-etcdctl-查看帮助"><a href="#4-etcdctl-查看帮助" class="headerlink" title="4. etcdctl 查看帮助"></a>4. etcdctl 查看帮助</h4><p>上述启动的 etcd 是服务器，官方还提供了一个 commandline 客户端，即 etcdctl，所有的命令都通过这个客户端去请求。<br>执行下列命令来查看帮助信息：</p><pre><code>$ ETCDCTL_API=3 etcdctl help</code></pre><p>想要查看某个具体 command 的帮助，比如查看 get 命令的帮助：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ETCDCTL_API=3 etcdctl <span class="built_in">help</span> get</span></span><br><span class="line"></span><br><span class="line">NAME:</span><br><span class="line">        get - Gets the key or a range of keys</span><br><span class="line">USAGE:</span><br><span class="line">        etcdctl get [options] &lt;key&gt; [range_end]</span><br><span class="line">OPTIONS:</span><br><span class="line">      --consistency="l"                 Linearizable(l) or Serializable(s)</span><br><span class="line">      --from-key[=false]                Get keys that are greater than or equal to the given key using byte compare</span><br><span class="line">      --keys-only[=false]               Get only the keys</span><br><span class="line">      --limit=0                         Maximum number of results</span><br><span class="line">      --order=""                        Order of results; ASCEND or DESCEND (ASCEND by default)</span><br><span class="line">      --prefix[=false]                  Get keys with matching prefix</span><br><span class="line">      --print-value-only[=false]        Only write values when using the "simple" output format</span><br><span class="line">      --rev=0                           Specify the kv revision</span><br><span class="line">      --sort-by=""                      Sort target; CREATE, KEY, MODIFY, VALUE, or VERSION</span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">      --cacert=""                               verify certificates of TLS-enabled secure servers using this CA bundle</span><br><span class="line">      --cert=""                                 identify secure client using this TLS certificate file</span><br><span class="line">      --command-timeout=5s                      timeout for short running command (excluding dial timeout)</span><br><span class="line">      --debug[=false]                           enable client-side debug logging</span><br><span class="line">      --dial-timeout=2s                         dial timeout for client connections</span><br><span class="line">      --endpoints=[127.0.0.1:2379]              gRPC endpoints</span><br><span class="line">      --hex[=false]                             print byte strings as hex encoded strings</span><br><span class="line">      --insecure-skip-tls-verify[=false]        skip server certificate verification</span><br><span class="line">      --insecure-transport[=true]               disable transport security for client connections</span><br><span class="line">      --key=""                                  identify secure client using this TLS key file</span><br><span class="line">      --user=""                                 username[:password] for authentication (prompt if password is not supplied)</span><br><span class="line">  -w, --write-out="simple"                      set the output format (fields, json, protobuf, simple, table)</span><br></pre></td></tr></table></figure><h4 id="5-Command-examples"><a href="#5-Command-examples" class="headerlink" title="5. Command examples"></a>5. Command examples</h4><p>假设已有如下 keys</p><pre><code>foo = barfoo1 = bar1foo2 = bar2foo3 = bar3</code></pre><p>默认 etcdctl 会key 和 value 都打印，想要只打印 value 的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ etcdctl get foo --print-value-only</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>获取所有 prefix 为 foo 的 key 所对应的 value</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ etcdctl get --prefix foo</span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">foo1</span><br><span class="line">bar1</span><br><span class="line">foo2</span><br><span class="line">bar2</span><br><span class="line">foo3</span><br><span class="line">bar3</span><br></pre></td></tr></table></figure><p>更多命令：<br><a href="https://coreos.com/etcd/docs/latest/dev-guide/interacting_v3.html" target="_blank" rel="noopener">https://coreos.com/etcd/docs/latest/dev-guide/interacting_v3.html</a></p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang 命令</title>
      <link href="/Programming/go-go-commands/"/>
      <url>/Programming/go-go-commands/</url>
      
        <content type="html"><![CDATA[<p>本文简单介绍 Golang 提供的命令。<br>我们执行 <code>go help [command]</code> 可以查看具体命令的帮助信息。<br>执行 <code>go help</code> 可以看到，Golang 提供的命令有下列所示：</p><pre><code>build       compile packages and dependenciesclean       remove object filesdoc         show documentation for package or symbolenv         print Go environment informationbug         start a bug reportfix         run go tool fix on packagesfmt         run gofmt on package sourcesgenerate    generate Go files by processing sourceget         download and install packages and dependenciesinstall     compile and install packages and dependencieslist        list packagesrun         compile and run Go programtest        test packagestool        run specified go toolversion     print Go versionvet         run go tool vet on packages</code></pre><p>下面逐一介绍</p><h4 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h4><p>命令样式：go build [-o output] [-i] [build flags] [packages]</p><p>这个命令用于编译指定的源码文件或代码包以及它们的依赖包。编译时，会自动忽略以 ‘_test.go’ 文件名结尾的文件。</p><p>-o<br>指定输出文件名，只支持在编译单个 package 时使用 。</p><p>-i<br>安装目标 package 所需的依赖</p><p>build, clean, get, install, list, run, test 这些命令共享以下的 flags，这些 flags 在不同的命令下语义不同</p><p>-a<br>强行对所有涉及到的代码包进行重新构建，即使它们已经是最新的了。</p><p>-n<br>打印编译期间所用到的其它命令，但是并不真正执行它们。</p><p>-p n<br>指定编译过程中执行各任务的并行数量（确切地说应该是并发数量）。在默认情况下，该数量等于CPU的逻辑核数。但是在darwin/arm平台（即iPhone和iPad所用的平台）下，该数量默认是1。<em>n为正整数</em></p><p>-race<br>开启竞态条件的检测。不过此标记目前仅在 <code>linux/amd64</code>、<code>freebsd/amd64</code>、<code>darwin/amd64</code> 和 <code>windows/amd64</code> 平台下受到支持。</p><p>-v<br>打印出那些被编译的代码包的名字。</p><p>-work<br> 打印出编译时生成的临时工作目录的路径，并在编译结束时保留它。在默认情况下，编译结束时会删除该目录。</p><p>-x<br>打印编译期间所用到的其它命令。注意它与 -n 标记的区别。</p><p>-asmflags ‘flag list’<br>此标记可以后跟另外一些标记，如 -D、-I、-S 等。这些后跟的标记用于控制 Go 语言编译器编译汇编语言文件时的行为。</p><p>-buildmode mode<br>此标记用于指定编译模式，使用方式如 -buildmode=default。此标记支持的编译模式目前有 6 种。借此，我们可以控制编译器在编译完成后生成静态链接库 .a 文件、动态链接库 .so 文件或可执行文件（如 Windows下的 .exe ）。</p><p>-compiler name<br>使用指定的 compiler，比如 runtime.Compiler 中的 gccgo 或 gc。</p><p>-gccgoflags ‘arg list’<br>指定 gccgo 执行时所需的参数</p><p>-gcflags ‘arg list’<br>指定需要传递给 <code>go tool compile</code> 命令的参数列表。<br>比如：</p><pre><code>go build -gcflags &quot;-N -l&quot; -o test test.go</code></pre><p>-ldflags ‘flag list’<br>指定需要传递给 <code>go tool link</code> 命令的参数列表</p><p>-linkshared<br>链接 -buildmode=shared 模式下指定的共享库</p><h4 id="go-clean"><a href="#go-clean" class="headerlink" title="go clean"></a>go clean</h4><p>执行 <code>go clean</code> 命令会删除掉执行其它命令时产生的一些文件和目录，包括：<br>使用 <code>go build</code> 命令时在当前代码包下生成的与包名同名或者与 Go 源码文件同名的可执行文件。<br>执行 <code>go test</code> 命令并加入-c 标记时在当前代码包下生成的以包名加“.test”后缀为名的文件。<br>还有一些目录和文件是在编译 Go 或 C 源码文件时留在相应目录中的。包括：“_obj” 和 “_test” 目录，名称为 “_testmain.go”、“test.out”、“build.out”或 “a.out” 的文件，名称以 “.5”、“.6”、“.8”、“.a”、“.o” 或 “.so” 为后缀的文件。这些目录和文件是在执行 <code>go build</code> 命令时生成在临时目录中的。<br>go clean [-i] [-r] [-n] [-x] [build flags] [packages]</p><p>-r<br>删除由 <code>go install</code> 命令所安装的可执行目标文件及其所有依赖的文件。</p><p>-i<br>删除由 <code>go install</code> 命令所安装的可执行目标文件</p><h4 id="go-doc"><a href="#go-doc" class="headerlink" title="go doc"></a>go doc</h4><p>打印附于 Go 语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。<br>go doc [-u] [-c] [package|[package.]symbol[.method]]</p><p>-c<br>加入此标记后会使go doc命令区分参数中字母的大小写。</p><p>-cmd<br>打印出main包中的可导出的程序实体（其名称的首字母大写）的文档。</p><p>-u<br>打印出不可导出的程序实体（其名称的首字母小写）的文档。</p><h4 id="go-env"><a href="#go-env" class="headerlink" title="go env"></a>go env</h4><p>打印 Go 语言的环境信息。<br>命令格式：go env [var …]</p><p>$ go env GOARCH=”amd64”  # 程序构建环境的目标计算架构。<br>GOBIN=””         # 存放可执行文件的目录的绝对路径。<br>GOCHAR=””     # 程序构建环境的目标计算架构的单字符标识。1.5以后的版本没有了GOEXE=””        # 可执行文件的后缀。<br>GOHOSTARCH=”amd64”  # 程序运行环境的目标计算架构。<br>GOHOSTOS=”linux”          # 程序运行环境的目标操作系统。<br>GOOS=”linux”                    # 程序构建环境的目标操作系统。GOPATH=”/home/lbb/workspace/go #工作区目录的绝对路径。<br>GORACE=”” #用于数据竞争检测的相关选项。<br>GOROOT=”/usr/local/go” # Go语言的安装目录的绝对路径。GOTOOLDIR=”/usr/local/go/pkg/tool/linux_amd64” # Go工具目录的绝对路径。GO15VENDOREXPERIMENT=”1”<br>CC=”gcc”<br>GOGCCFLAGS=”-fPIC -m64 -pthread -fmessage-length=0”CXX=”g++”CGO_ENABLED=”1” # 指明cgo工具是否可用的标识。</p><h4 id="go-fix"><a href="#go-fix" class="headerlink" title="go fix"></a>go fix</h4><p>用来修复以前老版本的代码到新版本。它其实是命令 <code>go tool fix</code> 的简单封装。这甚至比 <code>go fmt</code> 命令对 <code>gofmt</code> 命令的封装更简单。像其它的 Go 命令一样，<code>go fix</code> 命令会先对作为参数的代码包导入路径进行验证，以确保它是正确有效的。</p><p>-diff<br>不将修正后的内容写入文件，而只打印修正前后的内容的对比信息到标准输出。</p><p>-r<br>只对目标源码文件做有限的修正操作。该标记的值即为允许的修正操作的名称。多个名称之间用英文半角逗号分隔。</p><p>-force<br>使用此标记后，即使源码文件中的代码已经与Go语言的最新版本相匹配了，也会强行执行指定的修正操作。该标记的值就是需要强行执行的修正操作的名称，多个名称之间用英文半角逗号分隔。</p><h4 id="go-fmt"><a href="#go-fmt" class="headerlink" title="go fmt"></a>go fmt</h4><p>命令格式：go fmt [-n] [-x] [packages]<br>该命令用于对 .go 源文件进行格式化。</p><p>-n<br>打印编译期间所用到的其它命令，但是并不真正执行它们。</p><p>-x<br>可以看到go get命令执行过程中所使用的所有命令。</p><h4 id="go-generate"><a href="#go-generate" class="headerlink" title="go generate"></a>go generate</h4><p>是一个你可以用来自动自成 Go 代码的命令，你可以结合例如 jsonenums (一个用于为枚举类型自动生成 JSON 编组样板代码的类库)这样的元编程来使用 <code>go generate</code> 快速自动实现重复乏味代码的编写。在 Go 标准类库里面已经有大量可以用于解析 AST 的接口，而 AST 使得编写元编程工具更简单，更容易。</p><h4 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h4><p>下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。<br>go get [-d] [-f] [-fix] [-insecure] [-t] [-u] [build flags] [packages]</p><p>-d<br>让命令程序只执行下载动作，而不执行安装动作。</p><p>-f<br>仅在使用 -u 标记时才有效。该标记会让命令程序忽略掉对已下载代码包的导入路径的检查。如果下载并安装的代码包所属的项目是你从别人那里 Fork 过来的，那么这样做就尤为重要了。</p><p>-fix<br>让命令程序在下载代码包后先执行修正动作，而后再进行编译和安装。之前解决相关性或建设中的代码。</p><p>-insecure<br>允许命令程序使用非安全的scheme（如HTTP）去下载指定的代码包。如果你用的代码仓库（如公司内部的 Gitlab）没有HTTPS支持，可以添加此标记。请在确定安全的情况下使用它。</p><p>-t<br>让命令程序同时下载并安装指定的代码包中的测试源码文件中依赖的代码包。</p><p>-u<br>让命令利用网络来更新已有代码包及其依赖包。默认情况下，该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包。</p><p>-x<br>可以看到 <code>go get</code> 命令执行过程中所使用的所有命令<br><code>go get</code> 还有一个很值得称道的功能。在使用它检出或更新代码包之后，它会寻找与本地已安装 Go 语言的版本号相对应的标签（tag）或分支（branch）。比如，本机安装 Go 语言的版本是 1.x，那么 <code>go get</code> 命令会在该代码包的远程仓库中寻找名为 “go1” 的标签或者分支。如果找到指定的标签或者分支，则将本地代码包的版本切换到此标签或者分支。如果没有找到指定的标签或者分支，则将本地代码包的版本切换到主干的最新版本。<br>扩展显示下载进度条修改 <code>git clone</code> 命令, 添加 <code>--progress</code> 选项, 使其输出进度修改cmd.Run() 执行的地方, 使其将输出定位到标准输出流上</p><h4 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h4><p>编译并安装指定的代码包及它们的依赖包。实际上，<code>go install</code> 命令只比 <code>go build</code> 命令多做了一件事，即：安装编译后的结果文件到指定目录。<br>go install [build flags] [packages]</p><h4 id="go-list"><a href="#go-list" class="headerlink" title="go list"></a>go list</h4><p>命令的作用是列出指定的代码包的信息。与其他命令相同，我们需要以代码包导入路径的方式给定代码包。被给定的代码包可以有多个。这些代码包对应的目录中必须直接保存有Go语言源码文件，其子目录中的文件不算在内。否则，代码包将被看做是不完整的。go list [-e] [-f format] [-json] [build flags] [packages]</p><h4 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h4><p>命令可以编译并运行命令源码文件。由于它其中包含了编译动作，因此它也可以接受所有可用于 go build 命令的标记。除了标记之外，go run 命令只接受 Go 源码文件作为参数，而不接受代码包。与 go build 命令和 go install 命令一样，go run 命令也不允许多个命令源码文件作为参数，即使它们在同一个代码包中也是如此。而原因也是一致的，多个命令源码文件会都有 main 函数声明。<br>go run [build flags] [-exec xprog] gofiles… [arguments…]<br>如果命令源码文件可以接受参数，那么在使用 go run 命令运行它的时候就可以把它的参数放在它的文件名后面，像这样：go run main.go -p ~/golang/gotest<br>。</p><h4 id="go-test"><a href="#go-test" class="headerlink" title="go test"></a>go test</h4><p>-c<br>生成用于运行测试的可执行文件，但不执行它。这个可执行文件会被命名为“pkg.test”，其中的“pkg”即为被测试代码包的导入路径的最后一个元素的名称。</p><p>-i<br>安装/重新安装运行测试所需的依赖包，但不编译和运行测试代码。</p><p>-o<br>指定用于运行测试的可执行文件的名称。追加该标记不会影响测试代码的运行，除非同时追加了标记-c或-i。</p><p>go tool<br>go tool [-n] command [args…]</p><p><code>go tool pprof</code> 命令可以用来交互式的访问概要文件的内容。命令将会分析指定的概要文件，并会根据我们的要求为我们提供高可读性的输出信息。</p><p><code>go tool cgo</code>这个工具可以使我们创建能够调用 C 语言代码的 Go 语言源码文件。这使得我们可以使用 Go 语言代码去封装一些 C 语言的代码库，并提供给 Go 语言代码或项目使用。</p><p>go version<br>查看 Go 版本</p><p>go vet<br>是一个用于检查 Go 语言源码中静态错误的简单工具<br>go vet [-n] [-x] [build flags] [packages]</p><p><code>go vet</code> 是 <code>go tool vet</code> 命令的简单封装。它会首先载入和分析指定的代码包，并把指定代码包中的所有 Go 语言源码文件和以 “.s” 结尾的文件的相对路径作为参数传递给 <code>go tool vet</code>命令。</p><p>-n<br>会让命令在执行过程中打印用到的系统命令，但不会真正执行它们。</p><p>-x<br>既打印命令又执行命令。</p><p>-r<br>包括当前代码包的所有依赖包的上述目录和文件。</p><p><a href="http://www.jianshu.com/nb/4804356" target="_blank" rel="noopener">Golang</a></p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安装 Arch Linux</title>
      <link href="/Tools-and-Build/tool-and-build-archlinux-install/"/>
      <url>/Tools-and-Build/tool-and-build-archlinux-install/</url>
      
        <content type="html"><![CDATA[<h1 id="Arch-Linux-介绍"><a href="#Arch-Linux-介绍" class="headerlink" title="Arch Linux 介绍"></a>Arch Linux 介绍</h1><p>Arch Linux 是 Linux 的一种发行版，它遵循 Arch之道（The Arch Way），核心理念就是 KISS 原则（Keep It Simple, Stupid）。</p><p>基于这个原则，Arch Linux 系统在安装时只会安装最基础的软件包，用户可以根据自己的需要在系统安装完成之后自行安装其他软件包，这样就把系统做到尽可能的精简。</p><p>Arch Linux 提供了一个非常好用的软件管理工具 pacman，所有的软件都可以通过 pacman 来进行管理（下载，安装，升级，卸载等）。而且， Arch Linux 一个很大的特点就是软件包非常新，Arch Linux 总是第一时间尝试新的软件，比如最新的内核等。另外，Arch 的 AUR 仓库包含大量软件包，只需一个 makepkg 命令即可构建，非常方便。</p><p>Arch 采用滚动更新的方式，不像其他系统那样有发行的版本（比如 Windows 7, Windows 10, Ubuntu 12.04, Ubuntu 16.04等等），系统一旦安装，就不再需要重装，因为一旦系统中的某个库或者核心包有了更新， Arch Linux 的软件厂库就会把它加入升级，通过 pacman 系统可以随时得到最新的升级，而无需重装一个新的系统。</p><h4 id="下载安装-Arch-ISO"><a href="#下载安装-Arch-ISO" class="headerlink" title="下载安装 Arch ISO"></a>下载安装 Arch ISO</h4><p><a href="https://archlinux.org/download/" target="_blank" rel="noopener">https://archlinux.org/download/</a></p><p>1、引导安装介质<br>进入 BIOS 进行修改引导顺序，将安装介质调至第一引导顺序，保存设置并重启。<br>进入BIOS的方式已知的有：开机时按下 [Delete]、[F1]、[F2]、[F11] 或 [F12] 键。<br>使用引导菜单引导安装介质。引导菜单调出方式已知的有：开机时按下[Esc]、[F8]、[F9] 键或 [F12] 键。</p><p>2、出现引导界面，选择 Boot Arch Linux 并回车。</p><p>3、进入系统之后，检查是否开启 UEFI 模式<br>主板是否支持UEFI以及UEFI模式是否开启会影响安装方式。</p><pre><code># mount -t efivarfs efivarfs /sys/firmware/efi/efivars # 若已挂载则无视# efivar -l</code></pre><p>若 Arch Linux 是以 UEFI 模式启动的， 则 efivar 会正确地列出UEFI变量</p><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><p>1、查看硬盘，lsblk<br>这个命令可以列出机器上所有的硬盘和分区情况。</p><p><img src="/image/linux/lsblk.png" alt=""></p><p>如果本机只有一块硬盘，那么就是 /dev/sda， 如果有第二块、第三块硬盘，那么就是 /dev/sdb, /dev/sdc， 以此类推。<br>每块硬盘的不同分区用数字标示，比如 sda1, sda2, sda3 依次递增。</p><p>2、确定使用何种分区格式（MBR 还是 GPT），还需要确定需要几个分区。<br>分区的要求是至少要有一个分区。通常，我们会划分3个，分别为 /boot, / , /home。<br>通常， /boot 通常只需要大概 100 MB 大小就足够了，/home 分区会存储所有用户的数据，需要足够大！然后把剩余的容量划分到 根目录 / 分区。<br>另外，若安装目标内存 ≤ 2GB，建议添加一个swap分区， swap分区的大小一般建议为内存的2倍。如果内存超过2G，则可以不必使用swap分区。如果内存大于8G的话，可以不设置 swap 分区。</p><p>简单来说，如何安排分区，取决于每个人如何规划。现在假设硬盘120 G，可以大致参考下面的方案：</p><pre><code>/dev/sda1  100 MB  /boot  物理分区/dev/sda2  40G     /      物理分区/dev/sda3  60G     /home  物理分区/dev/sda4  8G      swap   物理分区</code></pre><p>3、确定好分区方案之后，使用 cfdisk 或者 parted 进行分区（cfdisk 是可视化的，更加方便一些），下面是常用的几个分区工具的比较：<br><strong>(1). cfdisk</strong><br>cfdisk是一个漂亮的程序，它只接受最严谨的分区表， 而且它能生成高质量的分区表。如果可能，你最好使用这个程序。最大的亮点就是使用方便，字符界面下的交互界面很好。<br><strong>(2). fdisk</strong><br>这个是很多人一开始都会使用的工具，据说是一个有很多bug的分区工具软件（我用了很久，也没有发现过 bug，或许现在已经完善了）。 它所做的操作是模糊不清的，通常在碰巧的情况下它才会正常的运行（据说）。 它唯一值得使用的地方是它对 BSD 的磁盘标签和非 DOS 的分区表有所支持， 尽量少用这个程序（据说，我没有任何证据正名它是不行的）。<br><strong>(3). sfdisk</strong><br>是一个专为黑客提供的程序，它的用户界面很不友善，但它更精确，也比 fdisk 和 cfdisk更有效。另外，它只能以非交互的方式运行。我基本上只用在使用它看分区表。</p><p>直接执行 cfdisk 或者 cfdisk /dev/sda 来进行硬盘分区，会出现如下所示界面，选择 dos， 然后根据提示操作即可。</p><p><img src="/image/linux/cfdisk.png" alt=""></p><p>按照上述规划， sda1 作为 /boot 分区， sda2 作为 / 分区， sda3 作为 /home 分区， sda4 作为 swap 分区</p><p>4、分区完成之后，就需要对分区进行格式化来创建文件系统、同时，创建并激活 swap 分区(mkswap,swapon)<br>ArchLinux 支持许多文件系统，比如 FAT, ext4, btrfs 等等。如果对文件系统没有概念，那么推荐使用 ext4，这个是 archlinux 下最常见的文件系统。 btrfs 据说对 SSD 有优化。</p><p>Arch Linux 自带了不同的格式化工具，他们均在 /usr/bin 目录下</p><pre><code># ls -1 /usr/bin/ | grep -E &apos;mkfs|mkswap&apos;...mkfs.ext4*    # ext4 格式化工具...mkfs.fat*     # fat 格式化工具...mkswap*       # swap 格式化工具</code></pre><p>下面对所有分区进行格式化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkfs.exr4 /dev/sda1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkfs.ext4 /dev/sda2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkfs.ext4 /dev/sda3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkswap    /dev/sda4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> swapon    /dev/sda4</span></span><br></pre></td></tr></table></figure><p>注意：对 swap 分区的创建是使用 mkswap 命令，而且创建完成之后还需要执行 swapon 命令进行激活。这样的目的是为了让 genfstab 能生成 fstab 时包含swap分区</p><h3 id="四、进行系统安装-Installation"><a href="#四、进行系统安装-Installation" class="headerlink" title="四、进行系统安装 Installation"></a>四、进行系统安装 Installation</h3><p>1、挂载新分区<br>分区格式化完成之后，文件系统就已经建立完毕。这时候就需要把分区挂载到系统中。<br>执行 mount 命令进行挂载，命令格式是： mount &lt;设备名&gt; &lt;挂载点&gt;。需要注意挂载顺序，根目录 / 需要最先挂载。<br>根目录挂载完之后，需要创建其他挂载点（也即根目录下的子目录，比如 /home，/boot 等），然后依次挂载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda2 /mnt</span><br><span class="line">mkdir /mnt/&#123;boot,home&#125;</span><br><span class="line">mount /dev/sda1 /mnt/boot</span><br><span class="line">mount /dev/sda3 /mnt/home</span><br></pre></td></tr></table></figure><p>swap 分区无需进行挂载， 其不属于文件系统。</p><p>2、选择更新源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -i "s/^\b/#/g" /etc/pacman.d/mirrorlist</span><br><span class="line">nano /etc/pacman.d/mirrorlist</span><br><span class="line">pacman -Syy</span><br></pre></td></tr></table></figure><p>3、安装基础系统<br>选项 -i 是用来选择确认，也可以去掉，直接一步完成。</p><pre><code># pacstrap -i /mnt base base-devel</code></pre><p>4、生成 fstab 并检查  fstab 是否正确<br>选项 -U 是用来指定 uuid 格式。</p><pre><code># genfstab -U -p /mnt &gt;&gt; /mnt/etc/fstab# cat /mnt/etc/fstab</code></pre><p>参考检查项：<br>对于每一行的最后一部分 <pass> ，/ 分区应该为 1，其他分区为 2。<br>btrfs 分区（无论是否为 / 分区）及 swap 分区的应该为 0。<br>若发现错误，直接对 fstab 进行修正，勿再次执行 genfstab。</pass></p><p>注意：这里使用的是UUID，如果不加-U，那么在 fstab中记录的就是 /dev/sdX 之类的地址了，UUID 的方式更加好，为什么呢？请自行wiki。</p><p>fstab 大致内容如下：</p><pre><code>[root@arch ~]# cat /etc/fstab# # /etc/fstab: static file system information## &lt;file system&gt; &lt;dir&gt;   &lt;type&gt;  &lt;options&gt;   &lt;dump&gt;  &lt;pass&gt;/dev/sda1   UUID=8084711b-2eab-4da8-aef2-0c9e8f4cbf70 /boot ext4 rw,relatime,data=ordered    0 2/dev/sda2   UUID=66456dcc-5f5f-49a6-96a6-536f736eccb6   /   ext4 rw,relatime,data=ordered    0 2/dev/sda3   UUID=d6fb3286-aeff-4c72-b91c-14ca22e1db08 /home ext4 rw,relatime,data=ordered    0 2/dev/sda4   UUID=06f7e8e8-6323-4eff-918f-2fb6c004322d  none swap defaults 0 0</code></pre><h3 id="五、配置基础系统"><a href="#五、配置基础系统" class="headerlink" title="五、配置基础系统"></a>五、配置基础系统</h3><p>1、进入新系统<br>首先使用 chroot 进入已经部署好的基本系统，关于 chroot 的知识，<a href="http://zh.wikipedia.org/wiki/Chroot" target="_blank" rel="noopener">点击进入</a>。</p><pre><code># arch-chroot /mnt/bin/bash# alias ls=&apos;ls --color&apos;</code></pre><p>2、Locale<br>Locale 决定了软件使用的语言、书写习惯和字符集</p><p>需要编辑两个文件：<code>locale.gen</code> 与 <code>locale.conf</code>。/etc/locale.gen 是一个仅包含注释文档的文本文件。指定您需要的本地化类型，只需移除对应行前面的注释符号（＃）即可，请选择帶 UTF-8的项，使用 vi 打开并编辑 /etc/locale.gen 文件，解开以下三项的注释：</p><pre><code>en_US.UTF-8 UTF-8  zh_CN.UTF-8 UTF-8  zh_TW.UTF-8 UTF-8</code></pre><p>实际操作中，除了上面三行内容外，其它内容都可以删除。然后执行<code>locale-gen</code> 以生成 locale 信息：</p><pre><code>$ locale-gen  </code></pre><p>创建 locale.conf 并提交我们的本地化选项：</p><pre><code>$ echo LANG=en_US.UTF-8 &gt; /etc/locale.conf </code></pre><p>简体中文用户可执行：</p><pre><code># sed -i &apos;/zh_CN.UTF-8/{s/#//}&apos; /etc/locale.gen# locale-gen# echo LANG=zh_CN.UTF-8  &gt; /etc/locale.conf</code></pre><p>如果不安装桌面环境，使用 en_US.UTF-8 即可。</p><p>2.设置console</p><p>编辑 <code>/etc/vconsole.conf</code>，然后输入如下内容：</p><pre><code>KEYMAP=usFONT=</code></pre><p>3、设置时区<br>可用的时区全集中在 /usr/share/Zone/SubZone 目录中，所以要查看可用时区，直接浏览 /usr/share/zhoninfo 即可。<br>将 /etc/localtime 软链接到 /usr/share/zoneinfo/Zone/SubZone，这里采用上海的时区：<br>中国大陆用户可执行：</p><pre><code># ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime# ln -s /usr/share/zoneinfo/&lt;时区&gt;/&lt;子时区&gt; /etc/localtime</code></pre><p>硬件时间<br>使用 utc 时间</p><pre><code># hwclock --systohc --utc</code></pre><p>自动校对时间</p><pre><code># pacman -S ntp# systemctl enable ntpd</code></pre><p>4、主机名<br>设置主机名</p><pre><code># echo &lt;主机名&gt; &gt; /etc/hostname</code></pre><p>5、创建ramdisk环境</p><pre><code># mkinitcpio -p linux</code></pre><p>6、为 root 设置密码</p><pre><code># passwd</code></pre><p>7、添加用户<br>添加一个用户并把它添加进 wheel 组，通常 wheel 组具有 sudo 权限。</p><pre><code># useradd -m -g users -G wheel -s /bin/bash alex# passwd alex</code></pre><p>8、配置 sudo</p><pre><code># pacman -S sudo# visudo</code></pre><p> 删去 wheel 组前面的注释，把其权限开放出来。</p><pre><code># %wheel ALL=(ALL) ALL</code></pre><p>9、配置网络 networkmanager</p><pre><code># papcman -S networkmanager# systemctl enable NetworkManager</code></pre><p>网络工具，有线和无线</p><pre><code>pacman -S dhcpcd wpa_supplicant dialog</code></pre><p>为了使开机就有网络，需设置dhcpcd开机自启动</p><pre><code>systemctl enable dhcpcd</code></pre><h3 id="六、安装引导器-bootloader"><a href="#六、安装引导器-bootloader" class="headerlink" title="六、安装引导器 bootloader"></a>六、安装引导器 bootloader</h3><p>（1）对于BIOS用户，这里推荐使用GRUB<br>BIOS + MBR：</p><pre><code># pacman -S grub (os-prober # 启动 win + linux 双系统)# grub-install --target=i386-pc --recheck /dev/sda</code></pre><p>生成默认配置文件</p><pre><code># grub-mkconfig –o /boot/grub/grub.cfg</code></pre><p>注意：这里不需要指明 sda1、2之类的，直接指定硬盘即可。</p><p>（2）使用UEFI的用户，现在的启动器是system-boot，是直接用systemd来启动系统。<br>UEFI：</p><p>只需要运行如下命令：</p><h1 id="bootctl-install"><a href="#bootctl-install" class="headerlink" title="bootctl install"></a>bootctl install</h1><p>虽然换成了system-boot，但是配置依旧少不了。<br>首先我们需要在/boot/loader/entries文件夹中创建名为arch.conf的配置文件，命令：</p><p> nano /boot/loader/entries/arch.conf<br>然后添加如下内容：</p><pre><code>title Arch Linuxlinux /vmlinuz-linuxinitrd /initramfs-linux.imgoptions root=/dev/sda2 rw</code></pre><p>注意：root部分可以填写UUID，执行blkid可查看分区的UUID。但是为了图方面，我就直接用路径代替了，sda3即为root分区，各位需要根据自己的分区情况自行决定。</p><p>接下来需要配置 /boot/loader/loader.conf，这个文件有默认的内容，只需要修改下即可。</p><pre><code>timeout 3default arch</code></pre><p>注：timeout 3指的是系统开机后的等待时间，按以上设置会出现一个开机启动菜单，3指的是等待3秒让我们选择，不过本人希望更快一点，故本人直接设置为0</p><pre><code># mount -t efivarfs efivarfs /sys/firmware/efi/efivars # 若已挂载则无视# pacman -S grub efibootmgr# grub-install --target=x86_64-efi --efi-directory=/boot/EFI --bootloader-id=arch_grub --reche</code></pre><p>生成配置文件：</p><pre><code># grub-mkconfig -o /boot/grub/grub.cfg</code></pre><h3 id="七、退出安装环境"><a href="#七、退出安装环境" class="headerlink" title="七、退出安装环境"></a>七、退出安装环境</h3><p>执行下列命令</p><pre><code>#exit#umount -R /mnt#reboot</code></pre><p>至此，这样一个完全可用的 Arch Linux 就安装完成了，如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/3473262-76880869ae2db3d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>当然安装好系统只是第一步，还有很多需要我们学习。</p><h3 id="八-声音管理"><a href="#八-声音管理" class="headerlink" title="八 声音管理"></a>八 声音管理</h3><p>某些桌面环境亦提供了声音控制功能。若此时跳过本节，亦可稍后进行设置。<br>Arch Linux默认开启了声音支持，默认静音。用户可通过下列命令取消静音：<br>1、安装 alsa-utils</p><pre><code># pacman -S alsa-utils</code></pre><p>2、配置</p><pre><code>#alsamixer</code></pre><p>方向键 选中 Master 和 PCM<br>[M] 取消静音</p><h3 id="九、配置图形用户界面"><a href="#九、配置图形用户界面" class="headerlink" title="九、配置图形用户界面"></a>九、配置图形用户界面</h3><p>1、安装显卡驱动<br>确定显卡型号：</p><pre><code>$ lspci | grep VGA</code></pre><p>对应驱动包：<br>Intel 显卡：xf86-video-intel<br>nVidia 显卡：<br>GeForce 7 以上：xf86-video-nouveau；nvidia<br>GeForce 6/7：xf86-video-nouveau；nvidia-304xx<br>AMD/ATI 显卡：<br>开源驱动：xf86-video-ati</p><p>2、安装驱动</p><pre><code># pacman -S 驱动</code></pre><p>如果是在 virtualbox 中安装 archlinux，需要把 kernel 模块加上。</p><pre><code># pacman -S linux-headers# pacman -S virtualbox-guest-utils</code></pre><p>添加进模块</p><pre><code># modprobe -a vboxguest vboxsf vboxvideo</code></pre><p>创建一个模块配置文件，比如取名为 <code>vbox.conf</code>，然后编辑该文件，添加下列三行，</p><pre><code>vboxguestvboxsfvboxvideo</code></pre><p>3、安装 X 窗口系统<br>3.1 安装 Xorg Server</p><pre><code>#pacman -S xorg-server xorg-server-utils xorg-xinit</code></pre><p>3.2 安装3D支持</p><pre><code>#pacman -S mesa</code></pre><p>3.3 添加触摸板支持</p><pre><code># pacman -S xf86-input-synaptics</code></pre><p>3.4 安装字体<br>Dejavu 和文泉驿-微米黑</p><pre><code># pacman -S ttf-dejavu wqy-microhei</code></pre><p>4、安装桌面环境<br>Arch Linux 有许多桌面环境可供选择：Cinnamon(gnome-terminal)、GNOME(gnome-extra)、KDE、LXDE、Xfce。<br><a href="https://wiki.archlinux.org/index.php/Desktop_environment" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Desktop_environment</a></p><pre><code># pacman -S cinnamon (gnome-terminal)</code></pre><p>或者</p><pre><code># pacman -S xfce4</code></pre><p>安装附加功能：</p><pre><code># pacman -S xfce4-goodies</code></pre><p>5、启动桌面环境（显示管理器）<br>安装 lightdm</p><pre><code>#pacman -S lightdm lightdm-gtk3-greeter或lightdm-gtk2-greeter(#安装cinnamon时，使用gtk3)#systemctl enable lightdm</code></pre><p>6、安装输入法（fcitx）<br>安装</p><pre><code>#pacman -S fcitx-im</code></pre><p>配置：</p><pre><code>export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot;</code></pre><p>KDM、GDM、LightDM 等显示管理器的用户，向 ~/.xprofile添加以上内容。<br>使用 startx 或 slim 的用户，向 ~/.xinitrc 添加以上内容。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://wiki.archlinux.org/index.php/Installation_guide_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Installation_guide_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安装 Fish</title>
      <link href="/Tools-and-Build/tool-and-build-fish/"/>
      <url>/Tools-and-Build/tool-and-build-fish/</url>
      
        <content type="html"><![CDATA[<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>Fish 是目前所有 shell （bash, zsh, tsh, etc）中我个人认为用得最顺手、最快捷的 shell 了，本文介绍 fish 的安装、配置以及使用。</p><h5 id="官方资源"><a href="#官方资源" class="headerlink" title="官方资源"></a>官方资源</h5><p>github: <a href="https://github.com/fish-shell/fish-shell" target="_blank" rel="noopener">https://github.com/fish-shell/fish-shell</a><br>official: <a href="http://fishshell.com/docs/current/index.html" target="_blank" rel="noopener">http://fishshell.com/docs/current/index.html</a><br>faq: <a href="https://fishshell.com/docs/current/faq.html" target="_blank" rel="noopener">https://fishshell.com/docs/current/faq.html</a></p><h3 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h3><h5 id="使用包管理器安装"><a href="#使用包管理器安装" class="headerlink" title="使用包管理器安装"></a>使用包管理器安装</h5><p>（1）Ubuntu<br>先添加源：执行<code>apt-add-repository ppa:fish-shell/release-2</code> 或者 <code>$ apt-add-repository ppa:fish-shell/nightly-master</code><br>安装</p><pre><code>$ apt-get update$ apt-get install fish</code></pre><p>（2）Arch Linux</p><pre><code>$ pacman -S fish</code></pre><p>（3） CentOS</p><pre><code>$ yum install fish</code></pre><h5 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h5><p>源码地址：<a href="https://github.com/fish-shell/fish-shell" target="_blank" rel="noopener">https://github.com/fish-shell/fish-shell</a><br>先使用 git clone 下载，然后安装下列依赖 dependencies:</p><pre><code>libncurses5, gettext, autoconf</code></pre><p>确保上述依赖已经安装之后，执行下列命令进行编译及安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> autoconf                                          <span class="comment"># if building from Git</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure --prefix=/usr</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make                                              <span class="comment"># use gmake on BSD</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo make install</span></span><br></pre></td></tr></table></figure><p>在 /etc/shells 中添加 fish</p><pre><code>$ echo /usr/bin/fish | sudo tee -a /etc/shells</code></pre><p>把 fish 设置为默认 shell</p><pre><code>$ chsh -s /usr/bin/fish</code></pre><p>禁用 fish shell 启动时的欢迎语</p><pre><code>$ set fish_greeting</code></pre><h3 id="三、配置-fish"><a href="#三、配置-fish" class="headerlink" title="三、配置 fish"></a>三、配置 fish</h3><p>默认情况下，所有 fish 相关的文件会被安装在 <code>/usr/local/share</code>,  <code>/usr/local/etc</code> 和 <code>/usr/local/fish</code> 目录中，fish 可执行程序本身则会被安装在 <code>/usr/local/bin</code> 中。</p><p>fish 提供了一个配置文件样例 <code>share/fish/config.fish</code>，用户的 fish 配置文件应该放在 <code>~/.config/fish/</code> 目录下，所以，在安装完 fish 之后，通常我们需要这样：</p><pre><code>$ cp share/fish/config.fish ~/.config/fish/config.fish</code></pre><p>然后，根据需要来个性化设置 config.fish。</p><p>fish 的 prompt, 在 functions 目录加入文件 fish_prompt.fish ，其内容为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 其中的 (hostname) (prompt_pwd) 为shell命令， $USER 为环境变量， __fish_prompt_hostname 为临时变量</span><br><span class="line">function fish_prompt</span><br><span class="line">      if not set -q __fish_prompt_hostname</span><br><span class="line">        set -g __fish_prompt_hostname (hostname)</span><br><span class="line">     end</span><br><span class="line">     set_color -o cyan</span><br><span class="line">     echo -n -s &quot;$USER&quot; @ &quot;$__fish_prompt_hostname&quot; &quot;: &quot;</span><br><span class="line">     set_color -o green</span><br><span class="line">     echo -n (prompt_pwd)</span><br><span class="line">     # 也可以用这个： echo -n &apos; $ &apos;</span><br><span class="line">     echo -n &quot; \$ &quot;</span><br><span class="line">     set_color normal</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="fish-配置文件简单样例："><a href="#fish-配置文件简单样例：" class="headerlink" title="fish 配置文件简单样例："></a>fish 配置文件简单样例：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">source $HOME/.fishmarks/marks.fish</span><br><span class="line">set -gx GOROOT &apos;/usr/local/go&apos;</span><br><span class="line">set -gx GOPATH &apos;/home/juniway/go&apos;</span><br><span class="line">set -g -x PATH &#123;$GOROOT&#125;/bin &#123;$GOPATH&#125;/bin $PATH</span><br><span class="line"></span><br><span class="line"># alias</span><br><span class="line">alias g11 &apos;g++ -std=c++14 -Wall -O0 -pedantic&apos;</span><br><span class="line">alias cl++ &apos;clang++ -std=c++11 -Wall -O0 -pedantic&apos;</span><br><span class="line">alias tmux &apos;tmux -2&apos;</span><br></pre></td></tr></table></figure><h3 id="四、使用-fish"><a href="#四、使用-fish" class="headerlink" title="四、使用 fish"></a>四、使用 fish</h3><p>fish 的使用非常简单，而且提供了一些快捷键加快命令的输入，跟使用 bash 一样，TAB 键用来做命令补全，但是跟 bash 下相比有改进，如果输入的不匹配任何补全字符串，那么会显示红色。另外，不断重复的按 TAB 会循环所有可能的补全。</p><p>在输入命令的参数时，TAB 还可以显示不同的选项，比如：<br>输入 <code>./configure --</code> 然后按 TAB，会显示所有 – 后面的选项</p><p><img src="http://upload-images.jianshu.io/upload_images/1452123-1975c4d7dc0cceb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在 fish 列出候选的补全命令之后，按 <strong>Ctrl + F</strong> 或者 <strong>右方向键</strong> 可以完成补全。</p><p>在 fish 下，ls 命令集成了 find 功能，是一个递归搜索神器。</p><p><img src="http://upload-images.jianshu.io/upload_images/1452123-81eaaae614525e09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="五、fish-与-bash-的差异"><a href="#五、fish-与-bash-的差异" class="headerlink" title="五、fish 与 bash 的差异"></a>五、fish 与 bash 的差异</h3><p>（1）fish 中，如果有一个软链指向的是一个目录， 那么需要 ls qa/ 这样才能列出目录中的内容。<br>（2）fish 不支持 bash 下的 !!, !, $?<br>（3）fish 不支持 ctrl + r 历史命令，但是只需要键入想搜索的历史命令中的某些字母，再按 ctrl + p 或者 ctrl + n 就能不断前后翻找历史命令。<br>（4）fish 不在支持命令之间用 &amp;&amp;, ||, ! 来连接，取而代之的是 and, or, not，<br>例如： </p><pre><code>$ mkdir ~/test; and echo &quot;OK&quot;; or echo &quot;Failed&quot;</code></pre><p>（5）fish 中通过 set 来代替 “=” 对变量赋值，如下</p><pre><code>$ set name Justin</code></pre><p>如果需要擦除变量，就执行 <code>set -e</code>。</p><p>（6）fish 中没有 export 命令，需要用 set -x 来代替。<br>（7）命令替换，比如用一个变量来保存某个命令的执行结果，只需把命令放在括号里即可，比如：</p><pre><code>$ set os (uname -a)</code></pre><p>fish 跟 bash 一样使用分号 <strong>;</strong> 来使多个命令顺序执行。</p><h4 id="六、fish-shell-可能会导致的问题"><a href="#六、fish-shell-可能会导致的问题" class="headerlink" title="六、fish shell 可能会导致的问题"></a>六、fish shell 可能会导致的问题</h4><p>（1） make 命令假死<br>传统的项目编译构建通常会使用 <code>configure</code> 以及 <code>make</code>，由于 <code>configure</code> 在检查系统的时候会生成 <code>Makefile</code>，默认的是使用 <code>/bin/sh</code> 作为 shell ，<br>因此如果在 fish shell 下面执行 <code>./configure</code>，其产生的临时文件 <code>conftest.make</code> 会导致 make 命令假死。</p><p>解决方案是把 shell 切换回 bash（执行 <code>chsh -s /bin/bash</code>），重新登录之后再执行 <code>./configure</code> 就没有问题了。</p><p>（2）fish 会使得 vim 的 plugin 安装失败<br>在 ~/.vimrc 中添加下面这行即可解决</p><pre><code>set shell=/bin/bash</code></pre><p>相关资源：<br><a href="https://github.com/jbucaran/fish-shell-cookbook" target="_blank" rel="noopener">https://github.com/jbucaran/fish-shell-cookbook</a></p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Use zookeeper to privide distributed service</title>
      <link href="/Programming/go-go-zk-server/"/>
      <url>/Programming/go-go-zk-server/</url>
      
        <content type="html"><![CDATA[<h3 id="Zookeeper-简介"><a href="#Zookeeper-简介" class="headerlink" title="Zookeeper 简介"></a>Zookeeper 简介</h3><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，是 Hadoop 和 Hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。<br>ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p><h3 id="分布式服务简介"><a href="#分布式服务简介" class="headerlink" title="分布式服务简介"></a>分布式服务简介</h3><p>对于一个分布式服务，最基本的一项功能就是服务的注册和发现，我们利用 zookeeper 的 EPHEMERAL 节点，就可以很方便的实现该功能。EPHEMERAL 节点是临时节点，其生命周期是和客户端会话绑定的，当会话连接断开时，节点也会被自动删除。</p><h3 id="服务的注册与发现原理"><a href="#服务的注册与发现原理" class="headerlink" title="服务的注册与发现原理"></a>服务的注册与发现原理</h3><p>当我们想要提供分布式服务时，我们可以把提供服务的服务器地址（IP:Port）注册到 zookeeper 上（创建临时节点），一旦服务停止，就把临时节点删除。在客户端方面，客户端通过连接到 zookeeper，获取注册了的服务器地址从而可以连接到相应的服务器，使用其提供的服务。</p><p>下边我们就来实现一个简单的分布式服务的设计</p><p>分布式服务通常由多个服务器节点提供服务，比如有三台机器 Server1, Server2, Server3。我们可以先在 zookeeper 中创建一个根节点，在三台服务器分别启动时，然后把其相应的机器IP地址挂在这个根节点下，而且，随后的增减机器都可以在这个根节点下动态的变化。</p><br>##### 服务端 Server创建 zookeeper 连接，创建一个根节点叫 GoServers。每当一个服务器程序启动时，在 GoServers 节点下创建一个新节点，节点名为"IP:PORT"，这样就完成了一个服务的注册。当服务结束时（服务器断开连接），创建的节点会被 zookeeper 自动删除（有延迟，心跳检测间隔），这样，Client 就不再看得到此节点，也就不会连到该节点了。<br>##### 客户端 Client先从 zookeeper 获取 GoServers 节点下所有子节点，这样就拿到了所有注册了的 Server。客户端获取所有注册了的 Server 之后，还应该对这些节点进行监听以便在其中某个节点失效后或者服务停止之后可以自动响应（也即不再像那个节点请求服务），监听的方式可以避免每次都轮询去获取服务列表。从 Servers 列表中选中一个节点（由于同一个根节点下的 Server 提供的都是相同的服务，随机选取一个即可，实际服务一般会提供多种策略），创建连接进行通信。<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>下面将实现一个简单的分布式服务，并展示如何进行服务的注册与发现，为了简单起见，每次 Client 连接 Server，在获取 Server 发送的时间后就断开。</p><p>主要代码如下：</p><p>utils.go: 封装了一些 zk 的常用操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zkutils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"path"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/samuel/go-zookeeper/zk"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    timeOut = <span class="number">20</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hosts []<span class="keyword">string</span> = []<span class="keyword">string</span>&#123;<span class="string">"101.199.97.62:2181"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Connect</span><span class="params">()</span> <span class="params">(conn *zk.Conn, err error)</span></span> &#123;</span><br><span class="line">    conn, _, err = zk.Connect(hosts, timeOut*time.Second)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegistServer</span><span class="params">(conn *zk.Conn, host <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    fullpath := <span class="string">"/go_servers/"</span> + host</span><br><span class="line">    tpath := <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> _, str := <span class="keyword">range</span> strings.Split(fullpath, <span class="string">"/"</span>)[<span class="number">1</span>:] &#123;</span><br><span class="line">        tpath = path.Join(tpath, <span class="string">"/"</span>, str)</span><br><span class="line">        fmt.Printf(<span class="string">"create zookeeper path: %s\n"</span>, tpath)</span><br><span class="line">        _, err := conn.Create(tpath, []<span class="keyword">byte</span>(<span class="string">""</span>), <span class="number">0</span>, zk.WorldACL(zk.PermAll))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err == zk.ErrNodeExists &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"zk.create(%s) exists\n"</span>, tpath)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"zk.create(%s) Errorf(%v)\n"</span>, tpath, err)</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetServerList</span><span class="params">(conn *zk.Conn)</span> <span class="params">(list []<span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">    list, _, err = conn.Children(<span class="string">"/go_servers"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server.go: 服务端程序，把自己注册到 zookeeper 上</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"coding.net/go/basic/zkutils"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startServer</span><span class="params">(host <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    tcpAddr, err := net.ResolveTCPAddr(<span class="string">"tcp4"</span>, host)</span><br><span class="line">    fmt.Println(tcpAddr)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    listener, err := net.ListenTCP(<span class="string">"tcp"</span>, tcpAddr)</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register zk node</span></span><br><span class="line">    conn, err := zkutils.Connect()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"connect zk error: %v\n"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    err = zkutils.RegistServer(conn, host)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"register node error: %v\n"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">"Error: %v\n"</span>, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> handleClient(conn, host)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleClient</span><span class="params">(conn net.Conn, host <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    daytime := time.Now().String()</span><br><span class="line">    conn.Write([]<span class="keyword">byte</span>(host + <span class="string">":"</span> + daytime))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"Fatal error: %s"</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> startServer(<span class="string">"127.0.0.1:8897"</span>)</span><br><span class="line">    <span class="keyword">go</span> startServer(<span class="string">"127.0.0.1:8898"</span>)</span><br><span class="line">    <span class="keyword">go</span> startServer(<span class="string">"127.0.0.1:8899"</span>)</span><br><span class="line"></span><br><span class="line">    a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">    &lt;-a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client.go: 客户端程序，连接 zookeeper 并获取所有已注册到 zookeeper 上的服务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"coding.net/go/basic/zkutils"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getServerHost</span><span class="params">()</span> <span class="params">(host <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">    conn, err := zkutils.Connect()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">" connect zk error: %s \n "</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    serverList, err := zkutils.GetServerList(conn)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">" get server list error: %s \n"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count := <span class="built_in">len</span>(serverList)</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">        err = errors.New(<span class="string">"server list is empty \n"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机选中一个返回</span></span><br><span class="line">    r := rand.New(rand.NewSource(time.Now().UnixNano()))</span><br><span class="line">    host = serverList[r.Intn(<span class="number">3</span>)]</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startClient</span><span class="params">()</span></span> &#123;</span><br><span class="line">    serverHost, err := getServerHost()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"get server host fail: %v \n"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"connect host: "</span> + serverHost)</span><br><span class="line">    tcpAddr, err := net.ResolveTCPAddr(<span class="string">"tcp4"</span>, serverHost)</span><br><span class="line">    checkError(err)</span><br><span class="line">    conn, err := net.DialTCP(<span class="string">"tcp"</span>, <span class="literal">nil</span>, tcpAddr)</span><br><span class="line">    checkError(err)</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    _, err = conn.Write([]<span class="keyword">byte</span>(<span class="string">"timestamp"</span>))</span><br><span class="line">    checkError(err)</span><br><span class="line"></span><br><span class="line">    result, err := ioutil.ReadAll(conn)</span><br><span class="line">    checkError(err)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(result))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"Fatal error: %s"</span>, err.Error())</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        startClient()</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>全文完!]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安装 GDB 7.12.1</title>
      <link href="/Tools-and-Build/tool-and-build-gdb-7-12/"/>
      <url>/Tools-and-Build/tool-and-build-gdb-7-12/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>GDB, the GNU Project debugger, allows you to see what is going on “inside” another program while it executes – or what another program was doing at the moment it crashed. Note that GDB is most effective when tracing programs and libraries that were built with debugging symbols and not stripped.</p><h2 id="Package-Information"><a href="#Package-Information" class="headerlink" title="Package Information"></a>Package Information</h2><p>Download (HTTP): <a href="https://ftp.gnu.org/gnu/gdb/gdb-7.12.1.tar.xz" target="_blank" rel="noopener">https://ftp.gnu.org/gnu/gdb/gdb-7.12.1.tar.xz</a><br>Download (FTP): <a href="ftp://ftp.gnu.org/gnu/gdb/gdb-7.12.1.tar.xz" target="_blank" rel="noopener">ftp://ftp.gnu.org/gnu/gdb/gdb-7.12.1.tar.xz</a><br>Download MD5 sum: 193453347ddced7acb6b1cd2ee8f2e4b<br>Download size: 18 MB<br>Estimated disk space required: 413 MB (add 158 MB for tests, add 665 MB for docs)<br>Estimated build time: 2.7 SBU (add 22 SBU for tests, add 0.7 for docs)</p><h2 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h2><p>Optional<br><a href="http://www.linuxfromscratch.org/blfs/view/cvs/general/dejagnu.html" target="_blank" rel="noopener">DejaGnu-1.6</a> (for tests), <a href="http://www.linuxfromscratch.org/blfs/view/cvs/general/doxygen.html" target="_blank" rel="noopener">Doxygen-1.8.13</a>, <a href="http://www.linuxfromscratch.org/blfs/view/cvs/general/guile.html" target="_blank" rel="noopener">Guile-2.0.13</a>, <a href="http://www.linuxfromscratch.org/blfs/view/cvs/general/python2.html" target="_blank" rel="noopener">Python-2.7.13</a>, <a href="http://www.linuxfromscratch.org/blfs/view/cvs/general/valgrind.html" target="_blank" rel="noopener">Valgrind-3.12.0</a>, and <a href="https://sourceware.org/systemtap/" target="_blank" rel="noopener">SystemTap</a> (run-time dependency, also used in a few tests)</p><p><strong>建议：</strong> 给特定用户安装 GDB 的 pretty-printer 打印出可读性更好的 stdc++ 的 STL 容器<br>在编译 GDB 之前，先安装 ncurses 库和 Python 库（用于在 GDB 中 开启 Python<br>支持，编译 GDB 时必须添加 –with-python 选项）。</p><p>（1）安装 ncurses 开发库头文件：</p><pre><code>sudo apt-get install libncurses-dev</code></pre><p>（2）GDB 依赖 libreadline，执行下列命令来安装：</p><pre><code>sudo apt-get install libreadline-dev</code></pre><p>（3）GDB 需要 makeinfo，这个是在 texinfo 包中</p><pre><code>sudo apt-get install texinfo</code></pre><p>（4）安装 python-dev， 开发库头文件</p><pre><code>sudo apt-get install python-dev</code></pre><p>把<code>[GCC源码目录]/libstdc++-v3/python</code> 复制到任意一个目录（比如 <code>~/.gdb</code> 目录下），<br>如果源码目录下没有上述 python 目录，也可以用如下方式从远程库拉取之后再放到 <code>~/.gdb</code> 目录下：</p><pre><code>svn co svn://gcc.gnu.org/svn/gcc/trunk/libstdc++-v3/python</code></pre><p>然后，编辑 <code>~/.gdbinit</code>，添加如下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">p = os.path.expanduser(<span class="string">'~/.gdb/python'</span>) </span><br><span class="line"><span class="keyword">print</span> p</span><br><span class="line"><span class="keyword">if</span> os.path.exists(p):</span><br><span class="line">    sys.path.insert(<span class="number">0</span>, p)</span><br><span class="line">    <span class="keyword">from</span> libstdcxx.v6.printers <span class="keyword">import</span> register_libstdcxx_printers</span><br><span class="line">    register_libstdcxx_printers(<span class="keyword">None</span>)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>注意： 上述脚本在 <code>os.path.expanduser(&#39;~/.gdb/python&#39;)</code> 中指定了 python 目录的位置。</p><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr --with-system-readline --with-python</span><br><span class="line">make</span><br><span class="line">make -C gdb install</span><br></pre></td></tr></table></figure><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><p><strong>Installed Programs:</strong><br>gcore, gdb and gdbserver<br><strong>Installed Library:</strong><br>libinproctrace.so<br>Installed Directories:<br>/usr/{include,share}/gdb and /usr/share/doc/gdb-7.12.1</p><h2 id="Short-Descriptions"><a href="#Short-Descriptions" class="headerlink" title="Short Descriptions"></a>Short Descriptions</h2><p><strong>gcore</strong></p><p>generates a core dump of a running program.</p><ul><li><strong>gdb</strong> the GNU Debugger.</li><li><strong>gdbserver</strong> a remote server for the GNU debugger (it allows programs to be debugged from a different machine).</li><li><strong>libinproctrace.so</strong> contains functions for the in-process tracing agent. The agent allows for installing fast tracepoints, listing static tracepoint markers, probing static tracepoints markers, and starting trace monitoring.</li></ul><h3 id="安装-cgdb"><a href="#安装-cgdb" class="headerlink" title="安装 cgdb"></a>安装 cgdb</h3><p>cgdb 是一个开源的 gdb 前端，可以提供实时的代码预览，极大的方便了调试。</p><h5 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h5><pre><code>$ git clone git://github.com/cgdb/cgdb.git</code></pre><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><p>flex( gettext )，autoconf, aclocal, automake, help2man</p><p>安装依赖<br>（1） flex</p><pre><code>$ sudo apt-get install flex</code></pre><p>（2） aclocal, automake, autoconf, autoheader<br>这些 utilities 都在 automake 包中，因此安装automake 就够了。</p><pre><code>$ sudo apt-get install automake$ sudo apt-get install autotools-dev</code></pre><p>(3) makeinfo，这个 utility 在 texinfo 包中</p><pre><code>$ sudo apt-get install texinfo</code></pre><p>（3）help2man</p><pre><code>$ sudo apt-get install help2man</code></pre><h5 id="编译和安装"><a href="#编译和安装" class="headerlink" title="编译和安装"></a>编译和安装</h5><pre><code>$ cd cgdb$ ./autogen.sh$ ./configure --prefix=/usr/local$ make$ sudo make install</code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://www.linuxfromscratch.org/blfs/view/cvs/general/gdb.html" target="_blank" rel="noopener">http://www.linuxfromscratch.org/blfs/view/cvs/general/gdb.html</a></p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安装 GCC 6.3.0</title>
      <link href="/Tools-and-Build/tool-and-build-gcc-6-3-0/"/>
      <url>/Tools-and-Build/tool-and-build-gcc-6-3-0/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>GCC 全称是 GNU Compiler Collection。 GCC 原本是指 C 语言的编译器，后来逐渐集成了许多其他语言的编译，因次其含义就改成了 GNU Compiler Collection，它能支持编译的语言有 C, C++, Fortran, Objective C, Objective C++, 以及 Go 语言。它甚至还能编译 Ada 和 Java，但是有特殊的要求，这里暂不详述。</p><p>本文介绍在 Ubuntu 系统中源码安装 GCC 最新的发布版 GCC 6.3.0，在其他 Linux 系统中的安装方法类似。<br>如果当前的机器是升级安装，最好不要覆盖原有的 GCC 版本，因为如果本地安装了第三方的 Kernel 组件的话，一旦覆盖安装，有可能导致这些组件无法工作，除非我们把这些安装的第三方库及组件也使用最新安装的 GCC 重新编译。 </p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="http://ftpmirror.gnu.org/gcc/gcc-6.3.0/gcc-6.3.0.tar.bz2" target="_blank" rel="noopener">http://ftpmirror.gnu.org/gcc/gcc-6.3.0/gcc-6.3.0.tar.bz2</a><br><a href="ftp://ftp.gnu.org/gnu/gcc/gcc-6.3.0/gcc-6.3.0.tar.bz2" target="_blank" rel="noopener">ftp://ftp.gnu.org/gnu/gcc/gcc-6.3.0/gcc-6.3.0.tar.bz2</a><br>MD5 sum: 677a7623c7ef6ab99881bc4e048debb6<br>size: 95 MB<br>Estimated disk space required: 7.7 GB (with tests)</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ul><li>GMP4.2+, MPFR 2.4.0+, and MPC 0.8.0+</li><li>flex</li><li>zlib</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> $(uname -m) <span class="keyword">in</span></span><br><span class="line">  x86_64)</span><br><span class="line">    sed -e <span class="string">'/m64=/s/lib64/lib/'</span> \</span><br><span class="line">        -i.orig gcc/config/i386/t-linux64</span><br><span class="line">  ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line">mkdir build                                          &amp;&amp;</span><br><span class="line"><span class="built_in">cd</span>    build                                          &amp;&amp;</span><br><span class="line"></span><br><span class="line">../configure                                         \</span><br><span class="line">    --prefix=/usr                                    \</span><br><span class="line">    --<span class="built_in">disable</span>-multilib                               \</span><br><span class="line">    --with-system-zlib                               \</span><br><span class="line">    --<span class="built_in">enable</span>-languages=c,c++,fortran,go,objc,obj-c++ &amp;&amp;</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>如果缺少依赖，那么可能会在执行 <code>./configure</code> 的过程中出现错误，也可能在执行 <code>make</code> 进行编译的过程中出现错误。</p><h6 id="1-GMP-4-2-MPFR-2-4-0-and-MPC-0-8-0"><a href="#1-GMP-4-2-MPFR-2-4-0-and-MPC-0-8-0" class="headerlink" title="(1) GMP 4.2+, MPFR 2.4.0+ and MPC 0.8.0+"></a>(1) GMP 4.2+, MPFR 2.4.0+ and MPC 0.8.0+</h6><p>configure: error: Building GCC requires GMP 4.2+, MPFR 2.4.0+ and MPC 0.8.0+.<br>Try the –with-gmp, –with-mpfr and/or –with-mpc options to specify their locations.</p><p>在 Ubuntu 中执行这个命令可以安装上述3个依赖包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libgmp-dev libmpfr-dev libmpc-dev</span><br></pre></td></tr></table></figure><p>如果想源码安装上述3个依赖包的最新版本，可以参考<a href="http://juniway.blogspot.com/2015/08/building-gcc-requires-gmp-42-mpfr-231.html" target="_blank" rel="noopener">这篇文章</a>：</p><h6 id="2-flex"><a href="#2-flex" class="headerlink" title="(2) flex"></a>(2) flex</h6><pre><code>sudo apt-get install flex</code></pre><p>如果需要源码编译安装，那么 flex 有如下依赖：</p><ul><li>compiler suite - flex is built with gcc</li><li>bash, or a good Bourne-style shell</li><li>m4 - m4 -p needs to work; GNU m4 and a few others are suitable</li><li>GNU bison; to generate parse.c from parse.y</li><li>autoconf; for handling the build system</li><li>automake; for Makefile generation</li><li>gettext; for i18n support</li><li>help2man; to generate the flex man page</li><li>tar, gzip, lzip, etc.; for packaging of the source distribution</li><li>GNU texinfo; </li></ul><h6 id="3-zlib"><a href="#3-zlib" class="headerlink" title="(3) zlib"></a>(3) zlib</h6><pre><code>sudo apt-get install zlib1g-dev</code></pre><p><strong>注意：</strong> 执行 <code>make</code> 进行编译后，这个过程会非常漫长，如果机器性能一般，可能长达好几个小时，请做好心理准备。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>一旦成功编译，安装过程就非常简单，因为这个步骤只是把编译好的文件（二进制，库，头文件，文档等）拷贝到系统目录。 执行下列命令进行安装（确保是 root 权限下操作）。</p><pre><code>make install</code></pre><h3 id="编译选项相关解释"><a href="#编译选项相关解释" class="headerlink" title="编译选项相关解释"></a>编译选项相关解释</h3><p>–disable-multilib: 这个选项只会生成当前系统的库，比如当前系统是64位，那么只会生成 64 位的库，而不会生成 32 位的库。<br>–with-system-zlib: 使用系统的 zlib 库，而不是源码中附带的 zlib。如果系统没有安装 zlib，那么可以执行<code>apt-get install zlib1g-dev</code> 来安装<br>–enable-languages=c,c++,fortran,go,objc,obj-c++: 指定生成哪些语言所需的编译器，如果不指定，那么默认会编译所有语言所需的编译器。<br>–with-default-libstdcxx-abi=gcc4-compatible: 如果是升级安装 GCC 并且原 GCC 版本地狱 5.1.0 的话，这个选项可以让你避免重编译原有的C++语言所编写的库<br>make -k check: 在跑测试的时候即使遇到 error 也不停下来，而是跑完所有 test。<br>../contrib/test_summary: 这个命令可以生成总的测试结果概述。<br>mv -v /usr/lib/*gdb.py …: 把一些 gdb 可能要用到的文件放到 /usr/lib 目录中。</p><h4 id="所有安装的程序及库"><a href="#所有安装的程序及库" class="headerlink" title="所有安装的程序及库"></a>所有安装的程序及库</h4><p><strong>Installed Programs:</strong> gccgo, go, gofmt and gfortran, hard-linked to architecture specific names<br><strong>Installed Libraries:</strong> libgfortran.{so,a}, libgo.{so,a}, libgobegin.a, libgolibbegin.a, libnetgo.a, libobjc.{so,a}, and numerous other run-time libraries and executables<br><strong>Installed Directories:</strong> /usr/lib/go/6.3.0</p><h4 id="二进制程序介绍"><a href="#二进制程序介绍" class="headerlink" title="二进制程序介绍"></a>二进制程序介绍</h4><p><strong>gccgo</strong>  一个基于 GCC 的 Go 语言编译器<br><strong>go</strong> 用于管理 Go 源码的工具<br><strong>gofmt</strong> 用于格式化 Go 源码<br><strong>gfortran</strong> 一个基于 GCC 的 Fortran 语言编译器</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://www.linuxfromscratch.org/blfs/view/cvs/general/gcc.html" target="_blank" rel="noopener">http://www.linuxfromscratch.org/blfs/view/cvs/general/gcc.html</a></p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Type embedding in Go</title>
      <link href="/Programming/go-type-embed/"/>
      <url>/Programming/go-type-embed/</url>
      
        <content type="html"><![CDATA[<p>通过在一个 struct 中内嵌另一个无名的变量，可以使得当前 struct 类型具有那个无名变量的公开成员（包括成员变量和成员函数）。也就是说当前对象可以直接访问内嵌无名变量的成员变量和成员方法。<br>Go 语言编译期是通过一种叫 “promotion” 的方式来达到这种效果的。</p><p>promotion 的原理就是，编译期会为当前 struct 生成一个与内嵌变量的成员函数一样的函数，并在这个函数里面调用内嵌变量的成员函数来达到效果。</p><h3 id="1、内嵌-struct-匿名成员"><a href="#1、内嵌-struct-匿名成员" class="headerlink" title="1、内嵌 struct 匿名成员"></a>1、内嵌 struct 匿名成员</h3><h4 id="1）内嵌单个匿名成员"><a href="#1）内嵌单个匿名成员" class="headerlink" title="1）内嵌单个匿名成员"></a>1）内嵌单个匿名成员</h4><p>比如，我们有一个作为基类使用的 struct，定义了一些通用的方法，然后我们在具体的子类中内嵌定义一个这个基类类型的匿名成员，这样，在子类中就可以使用基类的方法了。</p><p>如下：</p><p>作为基类类型的 Ball</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ball <span class="keyword">struct</span> &#123;</span><br><span class="line">    Radius   <span class="keyword">int</span></span><br><span class="line">    Material <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Ball)</span> <span class="title">Bounce</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"bounce!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类 Football 将 Ball 内嵌为匿名成员</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Football <span class="keyword">struct</span> &#123;</span><br><span class="line">    Ball</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把 Football 打印出来，看看其内部结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fb := Football&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">"fb = %+v\n"</span>, fb)</span><br></pre></td></tr></table></figure><blockquote><p>fb = {Ball:{Radius:0 Material:}}</p></blockquote><p>现在，子类可以直接调用基类的方法了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fb.Bounce()</span><br></pre></td></tr></table></figure><p>当然，也可以通过引用内嵌类型名来调用 <code>fb.Ball.Bounce()</code></p><p>上面，我们内嵌的无名成员，我们还可以内嵌无名成员变量的指针，如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Football <span class="keyword">struct</span> &#123;</span><br><span class="line">    *Ball</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，我们实例化 Football 的时候就需要同时初始化其成员指针。如果没有初始化 *ball 指针的话，那么直接调用其方法会 panic。</p><h4 id="2-内嵌多个匿名成员"><a href="#2-内嵌多个匿名成员" class="headerlink" title="2) 内嵌多个匿名成员"></a>2) 内嵌多个匿名成员</h4><p>如果内嵌多个匿名 struct 成员，而这些匿名成员如果定义了相同的函数的话，那么调用这些函数就会导致编译错误：”ambiguous selector fb.Bounce”。<br>此外，注意，只要函数名相同，就会导致上述错误，不论参数类型和个数怎么样。</p><p>如，以下就会导致 ambiguous</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Fan <span class="keyword">struct</span> &#123;</span><br><span class="line">    Size <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Fan)</span> <span class="title">Bounce</span><span class="params">(height <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Fan bounce! height: %v\n"</span>, height)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Football <span class="keyword">struct</span> &#123;</span><br><span class="line">    Ball</span><br><span class="line">    Fan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fb := Football&#123;&#125;</span><br><span class="line">    fb.Bounce(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要注意的是，只要没有调用 fb.Bounce()，那么是可以编译通过的，而且，如果 Fan 还定义了其他函数的话，只要没有直接调用二者相同的函数，一切都没问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Fan)</span> <span class="title">Rotate</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Fan rotate!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Football <span class="keyword">struct</span> &#123;</span><br><span class="line">    Ball</span><br><span class="line">    Fan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fb := Football&#123;&#125;</span><br><span class="line">    fb.Rotate()      <span class="comment">// ok!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、内嵌-interface"><a href="#2、内嵌-interface" class="headerlink" title="2、内嵌 interface"></a>2、内嵌 interface</h3><p>struct 可以内嵌匿名的 interface 接口类型。我们知道，通常 interface 接口类型会声明一些方法，这些方法由具体的 implementer struct 去实现。如果我们在一个 struct 中定义了匿名的 interface{} 接口类型，那么我们在实例化这个 struct 的时候，应该同时实例化那个内嵌的 interface{} 对象，否则 interface 就会是 nil 的，调用该 interface 所声明的方法就会导致 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bouncer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Bounce()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Football <span class="keyword">struct</span> &#123;</span><br><span class="line">    Bouncer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，Bouncer 作为一个匿名的 interface 成员，如果我们实例化 Football 的时候没初始化这个 Bouncer 为具体的 implementor 类型的话，那么就是 nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fb := Football&#123;&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, fb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><blockquote><p><code>{&lt;nil&gt;}</code></p></blockquote><p>因此，我们应该在实例化 Football 对象的时候，初始化它的 interface 成员。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ball <span class="keyword">struct</span> &#123;</span><br><span class="line">    Radius <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Ball)</span> <span class="title">Bounce</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"ball bounce!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fb := Football&#123;&amp;Ball&#123;<span class="number">10</span>&#125;&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, fb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><blockquote><p><code>{</code>{<code>10</code>}<code>}</code></p></blockquote><h5 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h5><p>如果当前 struct 定义了一个变量和一个内嵌的匿名变量，而该变量名字与其内嵌匿名变量的成员函数名字一样，虽然编译可以通过，但是调用时会出错。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Ball)</span> <span class="title">Bounce</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"ball bounce!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Football <span class="keyword">struct</span> &#123;</span><br><span class="line">    Ball</span><br><span class="line">    Bounce <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fb := Football&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"fb.Bounce is: "</span>, fb.Bounce)</span><br><span class="line">    fb.Bounce() <span class="comment">// runtime error: cannot call non-function bb.Bounce (type int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、继承类通过内嵌匿名成员的方式来变成接口的实现者"><a href="#3、继承类通过内嵌匿名成员的方式来变成接口的实现者" class="headerlink" title="3、继承类通过内嵌匿名成员的方式来变成接口的实现者"></a>3、继承类通过内嵌匿名成员的方式来变成接口的实现者</h3><p>如果一个基类 struct 已经实现了某接口，那么继承类可以通过把其内嵌为匿名成员，从而也变成一个 implementer。</p><p>比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vollyball <span class="keyword">struct</span> &#123;</span><br><span class="line">    Ball    <span class="comment">// an struct</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Basketball <span class="keyword">struct</span> &#123;</span><br><span class="line">    Bouncer <span class="comment">// an interface</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDuckType</span><span class="params">(bc Bouncer)</span></span> &#123;</span><br><span class="line">    bc.Bounce()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    vb := Vollyball&#123;&#125;      <span class="comment">// Vollyball becomes a Bouncer</span></span><br><span class="line">    TestDuckType(vb)</span><br><span class="line"></span><br><span class="line">    bb := Baskball&#123;Ball&#123;&#125;&#125; <span class="comment">// Basketball becomes a Bouncer</span></span><br><span class="line">    TestDuckType(pb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果，内嵌的两个匿名变量都实现了同一个接口，那么调用就会出现冲突，编译会失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Tennis <span class="keyword">struct</span> &#123;</span><br><span class="line">    Color <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tennis Tennis)</span> <span class="title">Bounce</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"tennis bounce!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Basketball <span class="keyword">struct</span> &#123;</span><br><span class="line">    Ball    <span class="comment">// an struct</span></span><br><span class="line">    Bouncer <span class="comment">// an interface</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDuckType</span><span class="params">(bc Bouncer)</span></span> &#123;</span><br><span class="line">    bc.Bounce()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    bb := Baskball&#123;Ball&#123;&#125;&#125; <span class="comment">// Basketball becomes a Bouncer</span></span><br><span class="line">    TestDuckType(pb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Basketball.Bounce is ambiguous</span><br><span class="line">cannot use bb (type Basketball) as type Bouncer in argument to TestDuckType: Basketball does not implement Bouncer (missing Bounce method)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安装 LLVM + Clang</title>
      <link href="/Tools-and-Build/tool-and-build-llvm-clang/"/>
      <url>/Tools-and-Build/tool-and-build-llvm-clang/</url>
      
        <content type="html"><![CDATA[<h3 id="LLVM-简介"><a href="#LLVM-简介" class="headerlink" title="LLVM 简介"></a>LLVM 简介</h3><p>LLVM 全称是 Low Level Virtual Machine，它是源自 the University of Illinois 的一个研究项目，该项目旨在提供一个现代化的编译机制，使得对任何编程语言既可以做到静态编译也可以动态编译，而且非常高效。后来 LLVM 项目逐渐发展，并孵化了许多子项目，比如 Clang，LLDB， OpenMP 等。</p><p>LLVM 核心库（core libraries）提供了一个源和目标相互独立的优化器，也即一个通用的编译优化和代码生成平台，还为对许多主流 CPU 提供了代码生成的支持。LLVM 定义了一个中间语言 LLVM IR，只要前端把代码编译成 LLVM IR，就可以使用 LLVM 丰富的优化模块和代码生成模块。换句话说，LLVM 让“创造一种计算机语言”变成了一个相对容易的事情，这件事情会有深远的影响。</p><p>Clang 作为 LLVM 原生的 “ C/C++/Objective-C 编译器前端，是作为编译 C/C++ 代码的除 GCC 工具链之外的另一种选择。其有许多优点（比如像 <a href="http://llvm.org/" target="_blank" rel="noopener">LLVM 主页</a> 所介绍的 Debug 模式下编译 Object C 速度比 GCC 快3倍，并且提供更加可读的编译过程中的出错信息等等），更多关于 Clang 的介绍可以去官网查看。</p><p>从代码上说，Clang 结构更简单。因为 Clang 只需要完成词法和语法分析，代码优化和机器代码的生成工作由 LLVM 完成。所以和全部由自己包下的 GCC 比起来，Clang 可以更专注地做好一件事。</p><p>而且，这种结构也使 Clang 可以被单独拿出来用在其他的程序里。比如 Vim 的 clang_complete 插件就是利用 Clang 进行语法分析后给出精确的自动补全和语法错误提示的。而 GCC 就没法很方便地做到这一点。</p><p>在实用性方面，除了有更快的编译速度更快和更友好的出错提示外，Clang 还内置有静态分析工具，可以对代码进行静态分析（clang –analyze）。这也是 GCC 做不到的。</p><p>另外，有关 Clang 和 GCC 的更多比较，还可以看<a href="https://www.zhihu.com/question/20235742" target="_blank" rel="noopener">知乎上这个帖子</a>。</p><p>简单来说，Clang 和 CompileRT 这两个子项目为 LLVM 提供了 C, C++, Objective C 和 Objective C++ 的前端及动态库支持，使得我们可以使用 Clang 来编译和构建项目。</p><p>由于 LLVM + Clang 项目得到了大财主 Apple 公司的大力赞助，最近这些年发展非常快，</p><p>本文介绍如何从源码编译安装 LLVM + Clang，截止本文所写日期最新版本是 Clang 3.9.1。</p><h4 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h4><p>要编译构建 Clang，必须先构建 LLVM 核心库。LLVM 核心库可以<a href="http://llvm.org/releases/3.9.1/llvm-3.9.1.src.tar.xz" target="_blank" rel="noopener">下载最新的发行包</a>。也可以从远程库拉取代码。<br>Clang 源码 ：<a href="http://llvm.org/releases/3.9.1/cfe-3.9.1.src.tar.xz" target="_blank" rel="noopener">http://llvm.org/releases/3.9.1/cfe-3.9.1.src.tar.xz</a><br>Compiler 源码 ：<a href="http://llvm.org/releases/3.9.1/compiler-rt-3.9.1.src.tar.xz" target="_blank" rel="noopener">http://llvm.org/releases/3.9.1/compiler-rt-3.9.1.src.tar.xz</a></p><p>最新的 LLVM 依赖 cmake 3.7.1，同时 还需要确保 libffi-3.2.1 和 Python-2.7.13 已经安装。</p><h6 id="获取远程库代码"><a href="#获取远程库代码" class="headerlink" title="获取远程库代码"></a>获取远程库代码</h6><p>LLVM core， Clang 和 Compiler-RT 3个项目的源码是在独立的远程库中的，因此我们需要分别把这3个项目都拉取下来，同时还需要按照一定的组织结构放置。我们在本地创建一个 tmp 文件夹作为顶层目录来放置这3个项目的源码，llvm core 放在 tmp 目录下，而 clang 则放在 llvm 目录的 tools/下， complier-rt 放在 llvm 目录的 projects/ 下。</p><p>三个项目的源码拉取完成之后，组织结构应该如下所示：</p><pre><code>llvm/    /tools/clang    /projects/compiler-rt</code></pre><p><strong>1.Checkout LLVM:</strong></p><pre><code>$ cd tmp$ svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm</code></pre><p><strong>2. Checkout Clang</strong></p><pre><code>$ cd llvm/tools$ svn co http://llvm.org/svn/llvm-project/cfe/trunk clang</code></pre><p><strong>3. Checkout Compiler-RT(Optional)</strong></p><pre><code>$ cd llvm/projects$ svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt</code></pre><h4 id="编译及安装"><a href="#编译及安装" class="headerlink" title="编译及安装"></a>编译及安装</h4><p>LLVM 禁止源码内编译（in-tree build is not supported），因此我们需要在源码目录外新建一个单独的目录来存放编译后的文件，比如，在与 llvm 的同级的目录中新建一个 build 目录。然后进入该 build 目录进行编译。</p><p>需要先执行 cmake 命令生成 Makefile 或者 build.ninja 文件，这一步会检查编译所需的各项依赖（也即编译所需的环境要求），这里，我使用 Ninja 作为编译器并生成对应的 build.ninja，并指定 llvm 的安装目录为 <code>/opt/llvm</code>。</p><pre><code>$ cd build$ cmake -G Ninja ../ \  -DCMAKE_INSTALL_PREFIX=/opt/llvm  \  -DCMAKE_BUILD_TYPE=Release \  -DLLVM_ENABLE_FFI=ON \  -DLLVM_BUILD_LLVM_DYLIB=ON \  -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \  -DLLVM_TARGETS_TO_BUILD=&quot;host;AMDGPU&quot;   -Wno-dev</code></pre><p>如果本地已经安装 libffi 库，但依然提示找不到 libffi  库，<br>可以通过 <code>-DFFI_INCLUDE_DIR=/usr/include</code> 和 <code>-DFFI_LIBRARY_DIR=/usr/lib64</code> 来手动指定。</p><p><strong>NOTE:</strong> 编译时最好指定下面两个选项:</p><ul><li><strong>–enable-optimized</strong>  打开优化，默认情况下是关闭的。这样会生成大量 debug 信息，以致于产生的文件可能高达 9.4 G 之多，这可能很快耗尽磁盘空间导致编译失败。</li><li><strong>–enable-targets=host-only</strong> 选择目标平台，默认情况下会生成所有平台的。这里设置成 host-only 只选择本机即可。</li></ul><p>成功检测并生成 <code>build.ninja</code> 文件之后，直接执行 <code>ninja</code> 命令进行编译构建。<br>由于 LLVM + Clang 比较庞大，编译这一步会比较漫长，ninja 会默认使用系统所有 CPU 进行并发编译，这样的好处是编译速度非常快，但是会导致链接过程占用非常庞大的内存空间，因此如果系统的内存不够的话，最好不要使用所有的核来编译你，最好手动指定并发核数（比如执行 <code>ninja -j4</code> 来指定并发数为 4）。这样可以避免由于内存不够而导致的编译出错。</p><p>编译成功之后执行 <code>ninja install</code> 来完成安装。</p><p>所有安装的二进制程序包括：</p><p>bugpoint, c-index-test, clang, clang++ (symlinks to clang-<version>), clang-<version>, clang-check, clang-cl, clang-format, git-clang-format, llc, lli, llvm-ar, llvm-as, llvm-bcanalyzer, llvm-config, llvm-cov, llvm-c-test, llvm-cxxdump, llvm-diff, llvm-dis, llvm-dsymutil, llvm-dwarfdump, llvm-dwp, llvm-extract, llvm-lib (symlink to llvm-ar), llvm-link, llvm-lto, llvm-mc, llvm-mcmarkup, llvm-nm, llvm-objdump, llvm-pdbdump, llvm-profdata, llvm-ranlib (symlink to llvm-ar), llvm-readobj, llvm-rtdyld, llvm-size, llvm-split, llvm-stress, llvm-symbolizer, llvm-tblgen, obj2yaml, opt, sancov, sanstats, scan-build, scan-view, verify-uselistorder, and yaml2obj</version></version></p><p>安装的库文件包括：<br>BugpointPasses.so, LLVMHello.so, libLLVM.so, libLLVM<em>.a (57 libraries), libLTO.so, libclang.so and libclang</em>.a (24 libraries)</p><h4 id="libc-介绍"><a href="#libc-介绍" class="headerlink" title="libc++ 介绍"></a>libc++ 介绍</h4><p><strong>libc++</strong> 是由 Apple 公司为其 Mac OS X 平台专门开发的一个 C++ 标准库，其是针对 Clang 而开发完成的，包含了对 C++11 的完整支持，可以作为 Clang 的“御用” C++ 库。libc++ 作为另一个 C++ 标准的实现（传统的是 <strong>libstdc++</strong>），其与 Clang 的关系就像 libstdc++ 和 GCC 之间的关系一样。但是由于 Apple 公司向来喜欢走不兼容的路线，它在最新版的 Max OS X 中没有提供最新版的 libstdc++ 库（支持 C++11），如果需要使用 libstdc++ 库的话我们必须手动编译安装。</p><p>需要注意的是，按照上述流程安装完 LLVM + Clang 之后，<strong>默认是没有安装 libc++ 的</strong>，但 Clang 也可以用 libstdc++，所以执行 <code>clang++ --std=c++11 main.cpp</code> 就可以编译 C++11 的源码。</p><h5 id="编译安装-libc"><a href="#编译安装-libc" class="headerlink" title="编译安装 libc++"></a>编译安装 libc++</h5><p><strong>1. Checkout libc++:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> llvm/projects</span><br><span class="line">svn co http://llvm.org/svn/llvm-project/libcxx/trunk libcxx</span><br></pre></td></tr></table></figure><p><strong>2. Checkout libc++abi:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> llvm/projects</span><br><span class="line">svn co http://llvm.org/svn/llvm-project/libcxxabi/trunk libcxxabi</span><br></pre></td></tr></table></figure><p><strong>3. Configure and build libc++ with libc++abi:</strong><br>注意:  LLVM 只支持使用 CMake 来构建编译配置<br>推荐使用 Clang 来编译构建 libc++。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -G  Makefile -DLLVM_PATH=path/to/llvm \</span><br><span class="line">        -DLIBCXX_CXX_ABI=libcxxabi \</span><br><span class="line">        -DLIBCXX_CXX_ABI_INCLUDE_PATHS=path/to/libcxxabi/include \</span><br><span class="line">        path/to/libcxx</span><br></pre></td></tr></table></figure><p>注意：如果本机已经有一个 libc++ 了，那么不要随意覆盖它，可能会导致由其编译而生成的库不再工作。可以使用 Cmake 的 <code>CMAKE_INSTALL_PREFIX</code> 选项去指定一个安全的安装位置。</p><p>配置完成之后，执行下列命令进行构建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make cxx                                   — will build libc++ and libc++abi.</span><br><span class="line">make check-cxx check-cxxabi                — will run the <span class="built_in">test</span> suites.</span><br></pre></td></tr></table></figure><p>编译完成之后执行下列命令安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><h5 id="下面是-LLVM-Clang-所安装的程序简介："><a href="#下面是-LLVM-Clang-所安装的程序简介：" class="headerlink" title="下面是 LLVM + Clang 所安装的程序简介："></a>下面是 LLVM + Clang 所安装的程序简介：</h5><p><strong>bugpoint</strong> 　　　　　the automatic test case reduction tool.<br><strong>clang</strong>　　　　　　　the Clang C, C++, and Objective-C compiler.<br><strong>clang-format</strong>　　　a tool to format C/C++/Java/JavaScript/Objective-C/Protobuf code.<br><strong>llc</strong>　　　　　　　　the LLVM static compiler.<br><strong>lli</strong>　　　　　　　　used to directly execute programs from LLVM bitcode.<br><strong>llvm-ar</strong>　　　　　　the LLVM archiver.<br><strong>llvm-as</strong>　　　　　　the LLVM assembler.<br><strong>llvm-bcanalyzer</strong>　　the LLVM bitcode analyzer.<br><strong>llvm-config</strong>　　　　Prints LLVM compilation options.<br><strong>llvm-cov</strong>　　　　　used to emit coverage information.<br><strong>llvm-c-test</strong>　　　　bytecode disassembler.<br><strong>llvm-cxxdump</strong>　　　used as a C++ ABI Data Dumper.<br><strong>llvm-diff</strong>　　　　　the LLVM structural ‘diff’.<br><strong>llvm-dis</strong>　　　　　the LLVM disassembler.<br><strong>llvm-dsymutil</strong>　　　a tool used to manipulate archived DWARF debug symbol files,<br>　　　　　　　　　　compatible with the Darwin command dsymutil.<br><strong>llvm-dwarfdump</strong> 　　prints the content of DWARF sections in object files.<br><strong>llvm-dwp</strong>　　　　　 merges split DWARF files.<br><strong>llvm-extract</strong>　　　　used to extract a function from an LLVM module.<br><strong>llvm-link</strong>　　　　　　the LLVM linker.<br><strong>llvm-lto</strong>　　　　　　the LLVM LTO (link time optimization) linker.<br><strong>llvm-mc</strong>　　　　　　a standalone machine code assembler/disassembler.<br><strong>llvm-nm</strong>　　　　　　used to list LLVM bitcode and object file’s symbol table.<br><strong>llvm-objdump</strong>　　　an LLVM object file dumper.<br><strong>llvm-pdbdump</strong>　　　used as PDB Dumper.<br><strong>llvm-profdata</strong>　　　a small tool to manipulate and print profile data files.<br><strong>llvm-ranlib</strong>　　　　used to generate an index for a LLVM archive.<br><strong>llvm-readobj</strong>　　　displays low-level format-specific information about object files.<br><strong>llvm-rtdyld</strong>　　　　the LLVM MC-JIT tool.<br><strong>llvm-size</strong>　　　　　the LLVM object size dumper.<br><strong>llvm-split</strong>　　　　　the LLVM module splitter.<br><strong>llvm-stress</strong>　　　　used to generate random .ll files.<br><strong>llvm-symbolizer</strong>　　converts adresses into source code locations.<br><strong>llvm-tblgen</strong>　　　　the LLVM Target Description To C++ Code Generator.<br><strong>obj2yaml</strong>　　　　　takes an object file,and produces a YAML representation of it.<br><strong>opt</strong>　　　　　　　　the LLVM optimizer.<br><strong>sancov</strong>　　　　　　the sanitizer coverage processing tool.<br><strong>sanstats</strong>　　　　　the sanitizer statistics processing tool.<br><strong>scan-build</strong>　　　　a Perl script that invokes the Clang static analyzer.<br><strong>scan-view</strong>　　　　　a viewer for Clang static analyzer results.<br><strong>verify-uselistorder</strong>　the LLVM tool to verify use-list order.<br><strong>yaml2obj</strong>　　　　　takes a YAML representation of an object file and converts it to an binary file.</p><h6 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h6><p><a href="http://clang.llvm.org/get_started.html" target="_blank" rel="noopener">http://clang.llvm.org/get_started.html</a><br><a href="https://libcxx.llvm.org/" target="_blank" rel="noopener">https://libcxx.llvm.org/</a><br><a href="http://libcxx.llvm.org/docs/BuildingLibcxx.html" target="_blank" rel="noopener">http://libcxx.llvm.org/docs/BuildingLibcxx.html</a><br><a href="https://github.com/maidsafe-archive/MaidSafe/wiki/Hacking-with-Clang-llvm-abi-and-llvm-libc" target="_blank" rel="noopener">https://github.com/maidsafe-archive/MaidSafe/wiki/Hacking-with-Clang-llvm-abi-and-llvm-libc</a></p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Use http.Hijacker to take over the http connection</title>
      <link href="/Programming/go-http-hijacker/"/>
      <url>/Programming/go-http-hijacker/</url>
      
        <content type="html"><![CDATA[<p>Go 的 http 包提供了一个 Hijacker 接口类型，如果我们不想使用 Go 的 http 连接默认行为，我们通过使用这个接口，“劫获” http 连接，并且把它转换成我们自己的管理方式。<br>一旦我们“劫获”了原来的http连接，我们可以自己操控这个连接，也需要自己来处理这个连接的关闭。通常，我们还可以把劫获的 http 转换成 websocket 或者 rpc 等方式，</p><p>下面看一个简单的例子来比较默认的 http 行为和使用 Hijacker “劫取”之后的行为：</p><p><strong>(1) Default http</strong></p><p>Request Handler function</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintSomething</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hello world!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Response:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Date: Wed, <span class="number">26</span> Nov <span class="number">2014</span> <span class="number">03</span>:<span class="number">37</span>:<span class="number">57</span> GMT</span><br><span class="line">Content-Length: <span class="number">16</span></span><br><span class="line">Content-Type: text/plain; charset=utf<span class="number">-8</span></span><br><span class="line"></span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure><p><strong>(2) After Hijacked</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hijack</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    hj, _ := w.(http.Hijacker)</span><br><span class="line">    _, buf, _ := hj.Hijack();</span><br><span class="line">    buf.WriteString(<span class="string">"Hello world!"</span>)</span><br><span class="line">    buf.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The message “Hello world!” will be write to the output directly without header part, like below.</p><p>Response:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello world!</span><br></pre></td></tr></table></figure><p>Notice that both of <code>http.ResponseWriter</code> and <code>http.Hijacker</code> are interfaces, this means <strong>w</strong> implements both interfaces.</p><p>Hijacker prototype</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Hijacker <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Hijack lets the caller take over the connection.</span></span><br><span class="line">    <span class="comment">// After a call to Hijack(), the HTTP server library will not do anything else with the connection.</span></span><br><span class="line">    Hijack() (net.Conn, *bufio.ReadWriter, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’s see an example to see how we can hijack a normal http request and convert it to <code>RPC</code> protocol.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP hijack the HTTP connection and switch to RPC.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Before hijacke any connection, make sure the pd is initialized.</span></span><br><span class="line">    <span class="keyword">if</span> s.isClosed() &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hj, ok := w.(http.Hijacker)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        log.Errorf(<span class="string">"server doesn't support hijacking: conn %v"</span>, w)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    conn, bufrw, err := hj.Hijack()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Error(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = conn.SetDeadline(time.Time&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Error(err)</span><br><span class="line">        conn.Close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c, err := newConn(s, conn, bufrw)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Error(err)</span><br><span class="line">        conn.Close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> c.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Notice that by executing <code>hj.Hijack()</code> we get the conn and buffer reader &amp; writer out of the http connection, we generate a new conn object, which is different from original one, from them by<br>doing newConn().</p><p>newConne is look like this:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newConn</span><span class="params">(s *Server, netConn net.Conn, bufrw *bufio.ReadWriter)</span> <span class="params">(*conn, error)</span></span> &#123;</span><br><span class="line">    s.connsLock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.connsLock.Unlock()</span><br><span class="line"></span><br><span class="line">    c := &amp;conn&#123;</span><br><span class="line">        s:    s,</span><br><span class="line">        rb:   bufrw.Reader,</span><br><span class="line">        wb:   bufrw.Writer,</span><br><span class="line">        conn: netConn,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.conns[c] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>After that we simply run this newly create conn.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        msg := &amp;pb.Message&#123;&#125;</span><br><span class="line">        msgID, err := util.ReadMessage(c.rb, msg)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Errorf(<span class="string">"read request message err %v"</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> msg.GetMsgType() != pb.MessageType_Req &#123;</span><br><span class="line">            log.Errorf(<span class="string">"invalid request message %v"</span>, msg)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        request := msg.GetReq()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> response *pb.Response</span><br><span class="line">        response, err = c.handleRequest(request)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Errorf(<span class="string">"handle request %s err %v"</span>, request, errors.ErrorStack(err))</span><br><span class="line">            response = newError(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> response == <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Warn(<span class="string">"empty response"</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        updateResponse(request, response)</span><br><span class="line"></span><br><span class="line">        msg = &amp;msgpb.Message&#123;</span><br><span class="line">            MsgType: pb.MessageType_Resp,</span><br><span class="line">            Resp:  response,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        util.WriteMessage(c.wb, msgID, msg)</span><br><span class="line">        c.wb.Flush()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the above code example (for simplicity, I removed some error checking blocks), a proto buffer response struct is constructed to for the client request, and therefore<br>the original http transport is switched to RPC communication. </p><br><h5 id="extention"><a href="#extention" class="headerlink" title="extention"></a>extention</h5><hr><p>http.Hijacker is also a good learning example on how to use interface in Go.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write() (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Hijacker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Hijack() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> wter <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(writer wter)</span> <span class="title">Write</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(writer wter)</span> <span class="title">Hijack</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"I am in Hijack()"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testHj</span><span class="params">(w ResponseWriter)</span></span> &#123;</span><br><span class="line">    hj, ok := w.(Hijacker)</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"wt is Hijacker!"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"wt is not Hijacker!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    hj.Hijack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wt := wter&#123;&#125;</span><br><span class="line">    testHj(wt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the above example, I emulate two interfaces like the <code>ResponseWriter</code> and <code>Hijacker</code> provided by the Go standard library <code>net/http</code>,then I define a wter struct to implement both of the interfaces, and pass it in as an argument in testHj function, the type assertion suceeds as expected.</p><p>Note: if we use <strong>type assertion</strong> on a declared type object, we have to store it in a interface variable,<br>otherwise we will receive errors saying <span class="red">“invalid type assertion: (non-interface type xxx on left)”</span></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> w <span class="keyword">interface</span>&#123;&#125; = wter&#123;&#125;   <span class="comment">// if we use w := wter&#123;&#125;, we will encounter compile error described as above</span></span><br><span class="line">    hj, ok := w.(Hijacker)</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"wt is Hijacker!"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"wt is not Hijacker!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    hj.Hijack()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><p><strong>Reference</strong><br><a href="http://stackoverflow.com/questions/27075478/when-to-use-hijack-in-golang" target="_blank" rel="noopener">http://stackoverflow.com/questions/27075478/when-to-use-hijack-in-golang</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Percolator</title>
      <link href="/Distributed-System/distributed-system-percolator/"/>
      <url>/Distributed-System/distributed-system-percolator/</url>
      
        <content type="html"><![CDATA[<br>### Background Introduction<p><a href="https://research.google.com/pubs/pub36726.html" target="_blank" rel="noopener">Percolator</a> is the websearch indexing system with a new architecture that was introduced by Google in 2010, it incrementally<br>processing updates to a large data set. The major reason that Google develop Percolator comes from the limitations of MapReduce, for example, if we use MapReduce to update the search index after recrawling some small portion of the web, it must process the entire repository, not just the new documents, also, the reason why BigTable is also insuffient is because it does not provide multirow transactions(it only supports atomic read-modify-write operations on individual rows but not multiple rows), which is required for incrementally updating Google’s index. Percolator fixes these limitations, it builds on top of Google File System (GFS) and updates the index incrementally thus avoid redoing work that has been done. Also, it provides transaction guaranteen. </p><p><strong>Trade offs:</strong> Percolator trades effient use of resources for scalability because it uses twice as many resources as the previous system to processing the same crawl rate and it consumes roughly 30 times more CPU per transactions than a standard DBMS.</p><h3 id="Notable-Feature-of-Percolator"><a href="#Notable-Feature-of-Percolator" class="headerlink" title="Notable Feature of Percolator"></a>Notable Feature of Percolator</h3><p><strong>ACID transactions</strong></p><ul><li>Cross-row and cross-table</li></ul><p><strong>Snapshot isolation</strong></p><ul><li>Reads are from one consistent snap shot and writes are performed at another</li><li>I note that while snapshot isolation is not perfect (write skew), it can achieve great performance</li></ul><h3 id="Architecture-Design"><a href="#Architecture-Design" class="headerlink" title="Architecture Design"></a>Architecture Design</h3><ul><li>Three Binaries - Run on every machine<ul><li>[Bigtable][] tablet server</li><li>[GFS][] chunkserver</li><li>Percolator worker</li><li>The computations, named <strong>observers</strong>, are linked into the worker</li><li>Worker scans for updates to the columns</li></ul></li><li>Timestamp Oracle<ul><li>Strictly increasing timestamps</li></ul></li><li>Lightweight Lock Service<ul><li>Just an optimization, not required</li></ul></li></ul><p><img src="/image/Diapositive3.png" alt=""></p><p>Degisn Notes:</p><p>(1) A table is indexed by row and column, since they use MVCC for snapshot isolation, each cell is actually a series of timestamped values (native support in BigTable)<br>(2) No central transaction manager<br>Thus no global deadlock detector, however, this has a drawback that it will increase latency in the case of conflicting transactions.</p><p>(3) Transacitons are implemented in C++<br>(4) Although blocking calls is used, a threadpoll is used for paralleism<br>The reason is that They found this to be simpler and allow for some clever batching<br>(5) Transactions allow engineers to create consistent secondary indexes</p><h4 id="Transaction-Isolation"><a href="#Transaction-Isolation" class="headerlink" title="Transaction Isolation"></a>Transaction Isolation</h4><p>Each column A is represented as a data column <code>A:data, it also has a column</code>A:lock<code>and a write column</code>A:write`.<br>A worker coordinates a 2PC protocol</p><ul><li><p><strong>Prewrite</strong>: lock the cell being written to</p><ul><li>If there is another lock at any timestamp the transaction aborts</li><li>If there is a write record after the current transactions start timestamp, abort the transaction (write-write conflict)</li><li>Write the lock and data to each cell at the start timestamp</li></ul></li><li><p><strong>Commit</strong></p><ul><li><p>Get a commit timestamp from the timestamp oracle</p></li><li><p>Release each lock and replace it with a write record</p></li><li><p>A write record, stored in <code>A:write</code>, really points to the timestamp of the prewrite from the first phase.</p></li><li><p>Bigtable supports atomic row operations</p></li><li><p>If the transaction fails to complete at this stage, it will be rolled forward by other workers lazily</p></li></ul></li><li><p><strong>Get</strong></p><ul><li>If there is a lock in [0, start_timestamp], wait until the lock is released</li><li>Otherwise return the data</li><li>Notice how no transaction (T1) could commit before T2’s start_timesamp without having a prewrite lock on the column. commit_timestamp is after the prewrite phase.</li></ul></li></ul><p><strong>Lazy Lock Cleanup</strong></p><ul><li>Each transaction has a primary lock, all other locks in the prewrite phase point to this primary lock</li><li>If T1 encounters a lock left by T2, it checks to see if the T2 has likely failed<ul><li>Workers have an ephemeral path in Chubby</li><li>There is also a timeout</li><li>The wall time in the lock can be updated periodically for long running transactions<br>-I’d like to see the implementation of this. My guess is the worker has a thread that periodically checks and refreshes all the locks held by the worker across all transactions</li></ul></li><li>If T1 feels T2 has failed, it attempts to cleanup the primary lock first (this is atomic), rolling back the transaction</li><li>If the crash was in the commit phase, the primary will have been converted to a write record. T1 is responsible for rolling the transaction forward</li></ul><p><strong>Timestamp Oracle</strong></p><ul><li>Creates a batch of timestamps and logs the highest timestamp to stable storage. Now the oracle can hand out timestamps from memory. If the orace crashes, it can just start skip to beyond the highest logged timestamp</li><li>It is not sharded, single machine (2 million timestamps/sec)</li><li>Workers batch calls to the timestamp server for several transactions</li></ul><p><strong>Notifications</strong></p><ul><li>Like a trigger, but does not run in the same transaction as the write<ul><li>This is not for data integrity but incremental processing</li></ul></li><li>At-most-one one observer’s transaction will commit for a given change</li><li>Multiple changes may be batched into one observer transaction, however<ul><li>The authors say batching allows them to deal with cells that change quite a lot</li></ul></li><li>Each foo:data has an additional foo:observer0 column for each observer<ul><li>Stores the timestamp of the latest start for the observer</li><li>If two transactions start for the same change, only one of them will commit because of a conflict on the ack column</li></ul></li><li>Tables may be trillions of cells but only have millions of updates<ul><li>During a write to a watched column, an additional column is written to for each dirty cell</li><li>These columns are in a separate locality group so that workers only need to scan the notify columns, not the actual data</li></ul></li><li>Each worker scans with many threads, picking a random tablet and then random start key<ul><li>Workers acquire locks in the the lightweight lock service prior to running observers on a row</li><li>The authors make it sound like a lock is acquired for each row scanned but I imagine it’s more a range of keys? Seeing as the authors are fans of batching calls across transactions, they probably batch requests for row level locks together.</li><li>It’s OK if the lock service goes down, it’s just an optimization</li></ul></li><li>The authors noted that threads tended to pile up at a slow section of the keyspace. Many threads reaching the same point compounded the problem<ul><li>If a thread notices it is scanning the same row as another thread it jumps to a randomly selected key</li></ul></li><li>Weak Notification<ul><li>Write only to notify column</li></ul></li></ul><p><strong>Batching</strong><br>A worker waits until it has collected several precommit operations at a time, e.g. they wait for several seconds to create a batch<br>Reads are also batched. For example, they offset this with prefetching columns in the same row<br>Made based on past read patterns</p><p><strong>Reference</strong><br><a href="http://blog.octo.com/en/my-reading-of-percolator-architecture-a-google-search-engine-component/" target="_blank" rel="noopener">http://blog.octo.com/en/my-reading-of-percolator-architecture-a-google-search-engine-component/</a></p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redirect http to https in Go</title>
      <link href="/Programming/go-redirect-http-to-https/"/>
      <url>/Programming/go-redirect-http-to-https/</url>
      
        <content type="html"><![CDATA[<p>There are cases that we need to run both http server and https server so that the client can still have access to the web service.<br>If we want to force a https connection while still provide http api we can redirect the http request to the https.<br>This article talks about how to redirect a http connection to a https connection.</p><br>#### Serve the same Content on both HTTP and HTTPS---<p>This is the simplest option and easily achievable:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hi there!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">    <span class="comment">// Start the HTTPS server in a goroutine</span></span><br><span class="line">    <span class="keyword">go</span> http.ListenAndServeTLS(<span class="string">":8081"</span>, <span class="string">"cert.pem"</span>, <span class="string">"key.pem"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// Start the HTTP server</span></span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>#### Redirect from HTTP to HTTPS---<p>This is the most sensible option if you want to encrypt all your connections. To achieve this, you’ll need a function to redirect from HTTP to HTTPS:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">redirectToHttps</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Redirect the incoming HTTP request. Note that "127.0.0.1:8081" will only work if you are accessing the server from your local machine.</span></span><br><span class="line">    http.Redirect(w, r, <span class="string">"https://127.0.0.1:8081"</span>+r.RequestURI, http.StatusMovedPermanently)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hi there!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">    <span class="comment">// Start the HTTPS server in a goroutine</span></span><br><span class="line">    <span class="keyword">go</span> http.ListenAndServeTLS(<span class="string">":8081"</span>, <span class="string">"cert.pem"</span>, <span class="string">"key.pem"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// Start the HTTP server and redirect all incoming connections to HTTPS</span></span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, http.HandlerFunc(redirectToHttps))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Or, we can use two separate ServeMux for the HTTP and HTTPS servers so that only specific paths (e.g. /admin/) will be  redirected to HTTPS:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">redirectToHttps</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Redirect the incoming HTTP request. Note that "127.0.0.1:8081" will only work if you are accessing the server from your local machine.</span></span><br><span class="line">    http.Redirect(w, r, <span class="string">"https://127.0.0.1:8081"</span>+r.RequestURI, http.StatusMovedPermanently)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">homeHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hi there!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adminHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hi admin!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Create a new ServeMux for HTTP connections</span></span><br><span class="line">    httpMux := http.NewServeMux()</span><br><span class="line">    <span class="comment">// Create a new ServeMux for HTTPS connections</span></span><br><span class="line">    httpsMux := http.NewServeMux()</span><br><span class="line">    <span class="comment">// Redirect /admin/ paths to HTTPS</span></span><br><span class="line">    httpMux.Handle(<span class="string">"/admin/"</span>, http.HandlerFunc(redirectToHttps))</span><br><span class="line">    <span class="comment">// Accept everything else</span></span><br><span class="line">    httpMux.Handle(<span class="string">"/"</span>, http.HandlerFunc(homeHandler))</span><br><span class="line">    <span class="comment">// Accept everything on HTTPS</span></span><br><span class="line">    httpsMux.Handle(<span class="string">"/"</span>, http.HandlerFunc(homeHandler))</span><br><span class="line">    httpsMux.Handle(<span class="string">"/admin/"</span>, http.HandlerFunc(adminHandler))</span><br><span class="line">    <span class="comment">// Start the HTTPS server in a goroutine</span></span><br><span class="line">    <span class="keyword">go</span> http.ListenAndServeTLS(<span class="string">":8081"</span>, <span class="string">"cert.pem"</span>, <span class="string">"key.pem"</span>, httpsMux)</span><br><span class="line">    <span class="comment">// Start the HTTP server and redirect all incoming connections to HTTPS</span></span><br><span class="line">    http.ListenAndServe(<span class="string">":8080"</span>, httpMux)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><p><strong>Reference</strong><br><a href="http://www.kaihag.com/https-and-go/" target="_blank" rel="noopener">http://www.kaihag.com/https-and-go/</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TLS Mutual Authentication in Go</title>
      <link href="/Programming/go-tls-mutual-auth/"/>
      <url>/Programming/go-tls-mutual-auth/</url>
      
        <content type="html"><![CDATA[<p>We need to generate “cert.pem” and “key.pem” so that we can build a TLS server, then we should load the certificate files in TLS client, so that the server and the client can mutually authenticate each other.</p><br>##### 1. TLS Server---<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"crypto/tls"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.SetFlags(log.Lshortfile)</span><br><span class="line"></span><br><span class="line">    cer, err := tls.LoadX509KeyPair(<span class="string">"server.crt"</span>, <span class="string">"server.key"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    config := &amp;tls.Config&#123;Certificates: []tls.Certificate&#123;cer&#125;&#125;</span><br><span class="line">    ln, err := tls.Listen(<span class="string">"tcp"</span>, <span class="string">":443"</span>, config) </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> ln.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := ln.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> handleConnection(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConnection</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    r := bufio.NewReader(conn)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        msg, err := r.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println</span>(msg)</span><br><span class="line"></span><br><span class="line">        n, err := conn.Write([]<span class="keyword">byte</span>(<span class="string">"world\n"</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(n, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>##### 2. TLS Client---<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"crypto/tls"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.SetFlags(log.Lshortfile)</span><br><span class="line"></span><br><span class="line">    conf := &amp;tls.Config&#123;</span><br><span class="line">         <span class="comment">//InsecureSkipVerify: true,</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    conn, err := tls.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:443"</span>, conf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    n, err := conn.Write([]<span class="keyword">byte</span>(<span class="string">"hello\n"</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(n, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</span><br><span class="line">    n, err = conn.Read(buf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(n, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="keyword">string</span>(buf[:n]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Https Server</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/tls"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">        w.Header().Add(<span class="string">"Strict-Transport-Security"</span>, <span class="string">"max-age=63072000; includeSubDomains"</span>)</span><br><span class="line">        w.Write([]<span class="keyword">byte</span>(<span class="string">"This is an example server.\n"</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    cfg := &amp;tls.Config&#123;</span><br><span class="line">        MinVersion:               tls.VersionTLS12,</span><br><span class="line">        CurvePreferences:         []tls.CurveID&#123;tls.CurveP521, tls.CurveP384, tls.CurveP256&#125;,</span><br><span class="line">        PreferServerCipherSuites: <span class="literal">true</span>,</span><br><span class="line">        CipherSuites: []<span class="keyword">uint16</span>&#123;</span><br><span class="line">            tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">            tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,</span><br><span class="line">            tls.TLS_RSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">            tls.TLS_RSA_WITH_AES_256_CBC_SHA,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    srv := &amp;http.Server&#123;</span><br><span class="line">        Addr:         <span class="string">":443"</span>,</span><br><span class="line">        Handler:      mux,</span><br><span class="line">        TLSConfig:    cfg,</span><br><span class="line">        TLSNextProto: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(*http.Server, *tls.Conn, http.Handler)</span>, 0),</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line">    log.Fatal(srv.ListenAndServeTLS("tls.crt", "tls.key"))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><p><strong>Reference</strong><br><a href="http://www.levigross.com/2015/11/21/mutual-tls-authentication-in-go/" target="_blank" rel="noopener">http://www.levigross.com/2015/11/21/mutual-tls-authentication-in-go/</a><br><a href="https://gist.github.com/denji/12b3a568f092ab951456" target="_blank" rel="noopener">https://gist.github.com/denji/12b3a568f092ab951456</a><br><a href="https://gist.github.com/spikebike/2232102" target="_blank" rel="noopener">https://gist.github.com/spikebike/2232102</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Generate CA and key pairs in Go</title>
      <link href="/Programming/go-gen-ca-key/"/>
      <url>/Programming/go-gen-ca-key/</url>
      
        <content type="html"><![CDATA[<p>Generating CA and key pairs are quite often required in setting up HTTPS connection when we developing web applications, before we go into details let’s review the steps on<br>the general steps to generate CA and key pairs:</p><ol><li>Generate a CA Certificate</li><li>Generate a Server key</li><li>Sign the Server key with the CA certificate</li><li>Add the CA Certificate to the client’s tls.Config RootCAs</li><li>Set up the server’s tls.Config with the Server key and signed certificate.</li></ol><p>There is a good <a href="https://jamielinux.com/docs/openssl-certificate-authority/index.html" target="_blank" rel="noopener">source</a>.</p><p>Although we can use openssl to generate certificates and key pair files, Go provides a <code>generate_cert.go</code> to facilitates the process.</p><p>The use of <code>generate_cert.go</code> to generate the cert files are extremely easy, we can simple follow the below process</p><pre><code>$ export GOBIN=$GOPATH/bin$ cd $GOROOT/src/crypto/tls$ go install generate_cert.go</code></pre><p>Now we should have an executable <strong>generate_cert</strong> in <code>$GOPATH/bin</code> path, since <code>$GOPATH</code> is already in system environment PATH, we can directy execute it to generate the files we need.</p><p><strong>Generate CA</strong></p><pre><code>$ generate_cert --host=&quot;localhost_vbox:10.0.2.15&quot; --ca=true</code></pre><p>This command should generate two files: <code>&quot;cert.pem&quot;</code> and <code>&quot;key.pem&quot;</code> in current directory, these files are called self-signed certificates, which means that you can use them to encrypt the traffic to and from your server, but a browser will not trust the connection out of the box.</p><p>We can also execute <code>$ go run generate_cert.go --host=&quot;localhost_vbox:10.0.2.15&quot; --ca=true</code> directly.</p><p>Be noticed that if these two files already existed, they will be overwritten.</p><p><strong>Cautions</strong><br>Use this library for testing purposes only, e.g. to experiment with the built-in Go HTTPS server. Do NOT use in production!</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hi there!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">    log.Fatal(http.ListenAndServeTLS(<span class="string">":8081"</span>, <span class="string">"cert.pem"</span>, <span class="string">"key.pem"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Besides, we can use <a href="https://github.com/deckarep/EasyCert" target="_blank" rel="noopener">EasyCert</a> to generate these files, it calls <code>openssl</code> internally and the files it generates should includes a CA root cer file, a Server cer file, a Server key file, etc.</p><p>Usage: EasyCert [options]<br>Options:<br>  -cn Certificate Authority Name (can be any name, but should reflect your company name.)<br>  -h  Hostname of TLS server to install the private cert/key</p><p>e.g. </p><pre><code>$ go get github.com/deckarep/EasyCert$ EasyCert -cn vbox_os -h localvb:10.0.2.152016/11/20 20:06:52 *** Operation Completed Succesfully ***2016/11/20 20:06:52 Private root certificate created:  myCA.cer2016/11/20 20:06:52 Web server certificate created:  mycert1.cer2016/11/20 20:06:52 Web server key created:  mycer1.key$ lsmyCA.cer  myCA.key  mycert1.cer  mycert1.key  mycert1.req  serial</code></pre><p>Essential the safest way to generate and sign the ca is using openssl, check <a href="http://pages.cs.wisc.edu/~zmiller/ca-howto/" target="_blank" rel="noopener">this</a> for details.</p><p>e.g.</p><pre><code>RSA recommendation key ≥ 2048-bit$ openssl req -x509 -nodes -days 3650 -newkey ec:secp384r1 -keyout server.ecdsa.key -out server.ecdsa.crtECDSA recommendation key ≥ secp384r1List ECDSA the supported curves (openssl ecparam -list_curves)$ openssl req -x509 -nodes -days 3650 -newkey rsa:2048 -keyout server.rsa.key -out server.rsa.crt</code></pre><p>On executing the above command, we’ll be asked to fill in some information. The most critical part is the Common Name (e.g. server FQDN or Our name) field.<br>If we’d like to access the server on the local machine with port 8081, we’ll have to put in the server address (e.g. myblog.com, or 127.0.0.1:8081).</p><p>Here is a bash <a href="https://gist.github.com/wmark/c758ce1c2b8222afd69d" target="_blank" rel="noopener">script</a> for generating all these files. </p><br><br><br><p><strong>Reference</strong><br><a href="http://stackoverflow.com/questions/22666163/golang-tls-with-selfsigned-certificate" target="_blank" rel="noopener">http://stackoverflow.com/questions/22666163/golang-tls-with-selfsigned-certificate</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Use go vendor to manage your project</title>
      <link href="/Programming/go-go-vendor/"/>
      <url>/Programming/go-go-vendor/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Go vendor 是 Go 1.5 官方引入管理包依赖的方式，需要把环境变量 GO15VENDOREXPERIMENT 设置为 1：</p><pre><code>GO15VENDOREXPERIMENT=1</code></pre><p>Go vendor 的项目管理方式在 Go 1.6 版本中得到正式引入，上述环境变量的值已经默认设置为 1 了（可以通过 <code>go env</code> 命令查看）。<br>另外，在此后的 <strong>Go 1.7</strong> 版本中，已经去除了该环境变量，从而默认开启 vendor 特性。</p><p>相比于传统的 go get 的方式来获取外部包（默认保存在 <code>$GOPATH/src</code> 中而不是项目自身目录中），使用 Go vendor 来管理外部依赖包（第三方库）的优势是显而易见的，因为它是通过将源码拷贝到当前工程的 <strong>vendor</strong> 目录下，这样，打包当前的工程代码到任意机器的 <code>$GOPATH/src</code> 下都可以通过编译，避免项目代码有外部依赖，迁移之后，还需要用 go get 去下载那些依赖包。</p><p>此外，传统的 go get 方式管理的包还有许多不可避免的缺陷，尤其是在当多个开发者之间在不同的机器上工作，有可能因为参与的时间不同，通过 go get 获取到的包的版本不同，甚至有可能某个 commit 之后发生了 API 的变更，导致在不同电脑上出现编译错误，从而造成原有的代码无法兼容的问题。下面列举一些依赖包可能出现的对原有项目造成影响的情况：</p><ul><li>引用的包已经被砍掉了？</li><li>引用的包原作者或是维护团队忽然決定大改 API?</li><li>引用的包忽然出現意外的错误(break code)? (当然有可能是底层 API 被 Google 改掉)</li><li>想要维护整个包的稳定性，比如通过 go get 重新拉去的外部依赖包的版本又可能和工程开发时使用的不一致，导致潜在的编译错误问题。</li></ul><p>虽然我们可以使用开源的工具 <a href="https://github.com/tools/godep" target="_blank" rel="noopener">godep</a> 去处理第三方依赖包的问题，但终归多了一个额外安装的过程，而 Go 在提供了默认的 vendor 模式之后就简化了这个过程。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>vendor 的使用非常简单，只需要在用户的工程项目目录中新建一个 vendor 目录，然后把依赖的第三方包放入这个目录中就可以了。vendor 模式开启的情况下，则对于工程源码中的 import 语句中引入的外部包，Go 会自动在 vendor 目录中搜索。<br>可以参考这个库 <a href="https://github.com/fatih/color" target="_blank" rel="noopener">https://github.com/fatih/color</a> 的源码结构来组织你的工程目录。</p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>虽然使用 vendor 的方式可以解决上述提出的问题，但是这种方式还有一些没有解决的问题，比如：</p><ul><li>无法精确的引用外部包进行版本控制，不能指定引用某个特定版本的外部包。由于 vendor 目录中的包只是简单的拷贝过来，一旦外部包升级，vendor下的代码不会跟着升级。</li><li>而且 vendor 下面并没有元文件记录引用包的版本信息，这个引用外部包升级产生很大的问题，无法评估升级带来的风险；</li></ul><br>### 开源解决方案 govendor<p>开源库 <a href="https://github.com/kardianos/govendor" target="_blank" rel="noopener">govendor</a> 提供了一些方法来解决上述 go vendor 未解决的问题</p><p>govendor 工具可以平滑的将现有非 vendor 项目转换为 vendor 项目</p><p>简单用法：</p><ol><li><p>执行 <code>govendor init</code> 就可以在当前项目目录生成 vendor 文件夹，vendor 文件家中有一个 vendor.json 文件记录了依赖包的信息。</p></li><li><p>执行 <code>govendor add packagename</code> 命令添加一个依赖包</p></li><li><p>如果需要更新或移除，可以参考一下工具的具体文档使用 update 或者 remove 命令</p></li><li><p>提供命令查看整个工程的依赖关系</p><p> $ goverdor –list<br> $ goverdor –list -v</p></li><li><p>vendor.json 示例</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat vendor.json</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"comment"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="string">"ignore"</span>: <span class="string">"test"</span>,</span><br><span class="line">    <span class="string">"package"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"path"</span>: <span class="string">"github.com/yeeuu/echoic"</span>,</span><br><span class="line">            <span class="string">"revision"</span>: <span class="string">"a7d6994f92e2dc60cff071ae38b204fbd4bd2a3f"</span>,</span><br><span class="line">            <span class="string">"revisionTime"</span>: <span class="string">"2015-12-18T11:14:29+08:00"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"path"</span>: <span class="string">"golang.org/x/net/context"</span>,</span><br><span class="line">            <span class="string">"revision"</span>: <span class="string">"1d9fd3b8333e891c0e7353e1adcfe8a612573033"</span>,</span><br><span class="line">            <span class="string">"revisionTime"</span>: <span class="string">"2015-11-13T15:40:13-08:00"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多命令详见：<br><a href="https://github.com/kardianos/govendor" target="_blank" rel="noopener">https://github.com/kardianos/govendor</a></p><br><br><br><p><strong>参考：</strong><br><a href="http://thinkerou.com/2016-04/go-vendor/" target="_blank" rel="noopener">http://thinkerou.com/2016-04/go-vendor/</a><br><a href="http://www.infoq.com/cn/articles/golang-package-management" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/golang-package-management</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Streaming Encoders and Decoders for json</title>
      <link href="/Programming/go-json-encoder/"/>
      <url>/Programming/go-json-encoder/</url>
      
        <content type="html"><![CDATA[<p>虽然 <code>encoding/json</code> 包提供了 Marshal 和 Unmarshal 两个函数用来处理 json 对象的编解码，但是对于批量的 json 文件编解码来说，这两个函数就会显得效率不高。 因此，json package 还提供了用于流式处理 JSON 数据的类型 Decoder 和 Encoder, 他们可以批量的编解码 json 文件。</p><p>NewEncoder() 和 NewDecoder() 两个函数可以用来生成这两种类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDecoder</span><span class="params">(r io.Reader)</span> *<span class="title">Decoder</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Decoder&#123;r: r&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEncoder</span><span class="params">(w io.Writer)</span> *<span class="title">Encoder</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Encoder&#123;w: w, escapeHTML: <span class="literal">true</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Decoder 和 Encoder 的原型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Decoder reads and decodes JSON values from an input stream.</span></span><br><span class="line"><span class="keyword">type</span> Decoder <span class="keyword">struct</span> &#123;</span><br><span class="line">    r     io.Reader</span><br><span class="line">    buf   []<span class="keyword">byte</span></span><br><span class="line">    d     decodeState</span><br><span class="line">    scanp <span class="keyword">int</span> <span class="comment">// start of unread data in buf</span></span><br><span class="line">    scan  scanner</span><br><span class="line">    err   error</span><br><span class="line"></span><br><span class="line">    tokenState <span class="keyword">int</span></span><br><span class="line">    tokenStack []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An Encoder writes JSON values to an output stream.</span></span><br><span class="line"><span class="keyword">type</span> Encoder <span class="keyword">struct</span> &#123;</span><br><span class="line">    w          io.Writer</span><br><span class="line">    err        error</span><br><span class="line">    escapeHTML <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    indentBuf    *bytes.Buffer</span><br><span class="line">    indentPrefix <span class="keyword">string</span></span><br><span class="line">    indentValue  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两个结构体有两个函数 <strong>Encode()</strong> 和 <strong>Decode()</strong> 用来进行编解码。</p><ul><li>Decode 从流中读取一个 json 数据， 解析后保存到 v 对象中</li><li>Encode 把本地的 v 对象转换成 json 数据后， 写到流中。<br>传入的参数是一个 io.Reader 类型， 很多类型都是 io.Reader 的 duck type， 比如 os.Stdin, bytes.Buffer 等。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Decode reads the next JSON-encoded value from its input and stores it in the value pointed to by v.</span></span><br><span class="line"><span class="comment">// acts like UnMarshal</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dec *Decoder)</span> <span class="title">Decode</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    err = dec.d.unmarshal(v)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Encode writes the JSON encoding of v to the stream, followed by a newline character.</span></span><br><span class="line"><span class="comment">// acts like Marshal</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(enc *Encoder)</span> <span class="title">Encode</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    e := newEncodeState()</span><br><span class="line">    err := e.marshal(v, encOpts&#123;escapeHTML: enc.escapeHTML&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：Decode 相当于 Unmarshal， Encode 相当于 Marshal。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">    Engine <span class="keyword">string</span></span><br><span class="line">    Count  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Decode</span></span><br><span class="line">    <span class="keyword">var</span> data = []<span class="keyword">byte</span>(<span class="string">`&#123;"Name":"jemy","Age":26&#125;&#123;"Engine":"Power","Count":4&#125;`</span>)</span><br><span class="line">    <span class="keyword">var</span> d Dog</span><br><span class="line">    <span class="keyword">var</span> c Car</span><br><span class="line"></span><br><span class="line">    decoder := json.NewDecoder(bytes.NewReader(data))</span><br><span class="line">    decoder.Decode(&amp;d)</span><br><span class="line">    decoder.Decode(&amp;c)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Encode</span></span><br><span class="line">    <span class="keyword">var</span> dog = Dog&#123;<span class="string">"jemy"</span>, <span class="number">26</span>,&#125;</span><br><span class="line">    <span class="keyword">var</span> car = Car&#123;<span class="string">"Power"</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">    buffer := bytes.NewBuffer(<span class="literal">nil</span>)</span><br><span class="line">    encoder := json.NewEncoder(buffer)</span><br><span class="line">    err := encoder.Encode(&amp;dog)</span><br><span class="line">    err := encoder.Encode(&amp;car)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><p>更多例子：<br><a href="http://golanghome.com/post/868" target="_blank" rel="noopener">http://golanghome.com/post/868</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Process json in Go</title>
      <link href="/Programming/go-go-json/"/>
      <url>/Programming/go-go-json/</url>
      
        <content type="html"><![CDATA[<br>##### 简介----JSON 作为一种网络传输格式非常广泛，各种语言几乎都有支持，Go 语言也一样，提供了一个标准库 `encoding/json` 用于处理这种格式的数据。<p>首先，我们必须明白，JSON 文本（或者称为 JSON 对象）本质上就是一串符合一定格式的字符串（在 Go 中是 []byte 来表示）。Go 的标准库 <code>encoding/json</code> 提供了 Marshal 和 Unmarshal 两个核心函数，<br>其中 Marshal 用于把 Go 语言中的一个对象（比如 struct 或者其他合法的 Go 数据类型）转换成 json 字符串（一串 []byte 数组），而 Unmarshal 则是用于把 json 字符串转换为 Go 语言中的对象。</p><p>在使用 Unmarshal 时，只有符合 json 格式的 json 数据才能被成功的识别为 json，否则会提示格式错误。 </p><br>##### Marshal----Marshal 函数只有在编码成功的时候才会返回数据，而且 JSON 只支持 string 作为 key。所以，如果要编码 Go 程序中的 map 类型的变量，那么该变量必须是 map[string]T 这种类型（T 是 Go 语言中任意的合法类型）<p><strong>除此之外，还需要注意以下例外情况:</strong></p><ul><li>channel, complex 和 function 是不能被编码成 JSON 的</li><li>嵌套的数据是不能编码的，不然会让 JSON 编码进入死循环</li><li>指针在编码的时候会输出指针指向的内容，而空指针则会输出 null</li></ul><p>在声明一个 struct 变量时，如果这个变量在以后的使用过程中需要进行 Marshal 操作的话，struct 的成员声明需要符合一定的规则，如下：</p><ul><li>必须大写，如果 field 没有定义为大写（导出）的话，<code>encoding/json</code> 包将无法访问该 struct 的私有成员，从而导致无法 Marshal。</li><li>由于 struct 成员大写，而 json 对象的 key 一般（非强制）是小写。所以，如果希望生成的 json 对象的 key 是小写，可以使用反引号（即 back-tik ``) 作为 tag 来装饰 struct 的成员 field。</li></ul><p>装饰方式见如下的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Page <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id       <span class="keyword">int64</span>       <span class="string">`json:"-"`</span></span><br><span class="line">    Title    <span class="keyword">string</span>      <span class="string">`json:"page,omitempty"`</span></span><br><span class="line">    Comments []<span class="keyword">string</span>    <span class="string">`json:"comments"`</span></span><br><span class="line">    Reads    <span class="keyword">int</span>         <span class="string">`json:"reads,string"`</span></span><br><span class="line">    Version  <span class="keyword">string</span>      <span class="string">`json:"version" toml:"version"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>相关语法解释:</strong></p><ul><li><code>json:&quot;-&quot;</code> 表示这个字段不输出到 JSON 中</li><li>其中 omitempty 的意思是，如果该成员变量的值是空的话，就不 Marshal 该变量，也即生成的 json 对象中没有该变量。</li><li>tag 中带有自定义名称，那么这个自定义名称会出现在 JSON 的字段名中，例如上面例子中</li><li>如果字段类型是 bool, string, int, int64 等，而 tag 中带有 “, string” 选项，那么这个字段在输出到 JSON 的时候会把该字段对应的值转换成 JSON 字符串</li><li>可以定义多个输出类型，比如同时定义 json 和 toml 格式的输出字段类型。</li></ul><p><strong>函数原型：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure><p><strong>Marshal 用法示例：</strong><br>1) array/slice</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">string</span>&#123;<span class="string">"apple"</span>, <span class="string">"peach"</span>, <span class="string">"pear"</span>&#125;</span><br><span class="line">js, _ := json.Marshal(slice)</span><br></pre></td></tr></table></figure><p>2) map</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := []</span><br><span class="line">mapD := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"apple"</span>: <span class="number">5</span>, <span class="string">"lettuce"</span>: <span class="number">7</span>&#125;</span><br><span class="line">js, _ := json.Marshal(mapD)</span><br></pre></td></tr></table></figure><p>3) struct</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resp := &amp;Response&#123;</span><br><span class="line">    Page:   <span class="number">1</span>,</span><br><span class="line">    Fruits: []<span class="keyword">string</span>&#123;<span class="string">"apple"</span>, <span class="string">"peach"</span>, <span class="string">"pear"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">js, _ := json.Marshal(resp)</span><br></pre></td></tr></table></figure><p><strong>如何打印 json 数据</strong><br>在 Go 中， json 对象是由一串 []byte 字节数组定义的，需要先把 js 转化成 string 再进行打印</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"result:"</span>, <span class="keyword">string</span>(js))</span><br></pre></td></tr></table></figure><p><strong>构造 json 数据</strong><br>如上所述，json 对象在 Go 中是一串 []byte 数组（string literal）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">js := []<span class="keyword">byte</span>(<span class="string">`&#123;"num":6.13,"strs":["a","b"]&#125;`</span>)   <span class="comment">// 此处构造了一个内部是 map 类型的 json 对象</span></span><br></pre></td></tr></table></figure><br>##### Unmarshal----<p><strong>函数原型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="keyword">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p><strong>Umarshal 时，用什么数据结构去接收解码后的js son对象</strong></p><p>Unmarshal 时可以用对应的具体数据类型去接收，也可以用 interface{} 去接收。<br>如果用 interface{} 去接收的话，那么 Unmarshal 出来的结果会是 map[string]interface{}。<br>而且要注意，如果 json 中的数据是 int 等数字类型的话，用 interface{} 接收时会 float 类型，这点要格外注意。</p><p><strong>Unmarshal 用法示例</strong></p><p>1) map</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dat <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(js, &amp;dat); err != <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(dat)</span><br></pre></td></tr></table></figure><p>2) struct</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">js := <span class="string">`&#123;"page": 1, "fruits": ["apple", "peach"]&#125;`</span></span><br><span class="line">res := Response&#123;&#125;</span><br><span class="line">json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;res)</span><br></pre></td></tr></table></figure><p>提示：如果 struct 定义的字段与 json 数据的字段不匹配，那么只有 struct 中定义了的字段会被附上值，其余的字段依然会是默认值。</p><p>3) interface{}</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b := []<span class="keyword">byte</span>(<span class="string">`&#123;"Name":"Wednesday","Age":6,"Parents":["Gomez","Morticia"]&#125;`</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err := json.Unmarshal(b, &amp;f)</span><br></pre></td></tr></table></figure><p>这里 Unmarshal 得到的 f 实际上是一个 map[string]interface{} 类型, 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">    <span class="string">"Name"</span>: <span class="string">"Wednesday"</span>,</span><br><span class="line">    <span class="string">"Age"</span>:  <span class="number">6</span>,</span><br><span class="line">    <span class="string">"Parents"</span>: []<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">"Gomez"</span>,</span><br><span class="line">        <span class="string">"Morticia"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m := f.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>得到这个 map 之后，我们通常需要遍历 map 来提取我们需要的具体内容：<br>官方提供了一个如下的一个方式（断言）来取出这个 map 中的各个 key value。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    <span class="keyword">switch</span> vv := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Println(k, <span class="string">"is string"</span>, vv)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Println(k, <span class="string">"is int"</span>, vv)</span><br><span class="line">    <span class="keyword">case</span> []<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line">        fmt.Println(k, <span class="string">"is an array:"</span>)</span><br><span class="line">        <span class="keyword">for</span> i, u := <span class="keyword">range</span> vv &#123;</span><br><span class="line">            fmt.Println(i, u)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(k, <span class="string">"is of a type I don't know how to handle"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上可见，这种操作方式非常不方便，尤其是对于较复杂的或者嵌套层次较多的对象来说，所幸的是，网上有许多开源的解决方案帮助我们更好的处理这种位置结构体的 JSON。</p><p>比如: bitly 公司开源 <a href="https://github.com/bitly/go-simplejson" target="_blank" rel="noopener">simplejson</a> 包, 还有 ffjson 等。</p><p>使用 simplejson 来解码 json 对象的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">js, err := NewJson([]<span class="keyword">byte</span>(<span class="string">`&#123;</span></span><br><span class="line"><span class="string">    "test": &#123;</span></span><br><span class="line"><span class="string">        "array": [1, "2", 3],</span></span><br><span class="line"><span class="string">        "int": 10,</span></span><br><span class="line"><span class="string">        "float": 5.150,</span></span><br><span class="line"><span class="string">        "bignum": 9223372036854775807,</span></span><br><span class="line"><span class="string">        "string": "simplejson",</span></span><br><span class="line"><span class="string">        "bool": true</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;`</span>))</span><br><span class="line"></span><br><span class="line">arr, _ := js.Get(<span class="string">"test"</span>).Get(<span class="string">"array"</span>).Array()</span><br><span class="line">i, _ := js.Get(<span class="string">"test"</span>).Get(<span class="string">"int"</span>).Int()</span><br><span class="line">ms := js.Get(<span class="string">"test"</span>).Get(<span class="string">"string"</span>).MustString()</span><br></pre></td></tr></table></figure><br><br><br><p><strong>参考：</strong><br><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/07.2.md" target="_blank" rel="noopener">https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/07.2.md</a><br><a href="https://kev.inburke.com/kevin/golang-json-http/" target="_blank" rel="noopener">https://kev.inburke.com/kevin/golang-json-http/</a> </p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Variable shadowing in Go</title>
      <link href="/Programming/go-var-scope/"/>
      <url>/Programming/go-var-scope/</url>
      
        <content type="html"><![CDATA[<p>在 Go 语言开发过程中，经常会遇到需要使用局部（或临时）变量隐藏（shadow）全局同名变量的情形（比如常见的语句：<code>val, err := somefunc()</code>）。<br>因此，本文总结介绍 Go 语言中最常用到的变量隐藏的知识。</p><br>##### 在相同作用域中同名变量的关系。<p>Go 语言中申明一个变量的方法有两种，一种直接申明变量的名字和类型（如：<code>var name string</code>），另一种是通过变量的值来推导变量类型（如：<code>name := &quot;Rob Pike&quot;</code>）。<br>如果已经使用第一种方式申明过变量类型，那么，在同一作用域中，就不能再使用第二种方式给变量赋值，而是应该直接用等号 <code>=</code> 来给变量赋值。</p><p>比如，下列语句将会编译报错：<span class="red">“no new variables on left side of :=”</span></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">name := <span class="string">"Rob Pike"</span></span><br></pre></td></tr></table></figure><p>但是，如果 <code>:=</code> 左边是多个变量，那么这种语句将是合法的。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test() (<span class="keyword">string</span>, <span class="keyword">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Obama"</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">name, ok := test()</span><br></pre></td></tr></table></figure><p><strong>需要注意的是：</strong></p><ul><li>由于 <code>:=</code> 左边的 name 与之前申明的 name 变量在<strong>同一作用域</strong>，上述 test() 函数返回的第一个返回值的类型也必须是 string 类型，<br>否则，将会报错: <span class="red">“cannot assign int to name (type string) in multiple assignment”</span></li><li>第二个返回值不能使用 <code>_</code> 来忽略，必须显示返回。 如果使用 <code>name, _ := test()</code>，同样会报错 <span class="red">“no new variables on left side of :=”</span></li></ul><p>还要注意，<code>:=</code> 左边必须至少要有一个是未使用第一种方式申明过类型的。也就是说，如果上述 name 和 ok 都声明过的话，使用 <code>name, ok := test()</code> 将会编译报错。</p><br>##### 在内部作用域中隐藏外部同名变量<p>在 Go 语言中，下列语法将指定一个局部作用域</p><ul><li>由 <code>{}</code> 包起来的代码块</li><li>由 <code>if</code>, <code>for</code>, <code>switch</code> 等控制语句定义的代码块。</li><li>由 <code>select</code> 包起来的代码块</li><li>由 <code>go func()</code> 协程包起来的代码块。 </li></ul><p>当然，在上述所述的情况中，都可以引用作用域外的变量，但是当内部申明的变量与外部的变量同名时，将会隐藏外部的变量。这种隐藏是无条件的，也就是说，即使内部申明的变量类型不一样，<br>只要与外部变量名字相同，也同样会隐藏外部变量。</p><p>来看几个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line">&#123;</span><br><span class="line">    name := <span class="number">19.99</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述语法完全正确，即使内部作用域中申明的 name 变量不是 string 类型。<br>由于 Go 语言中采用 error 返回值的方式来处理程序出错，在 if, for 等流程控制代码段中，需要注意返回的其他变量不要与作用域外申明的变量之间的关系，尤其是当遇到流程控制块需要修改外部变量时。<br>比如，下列这个例子展示了一个流程控制中修改全局变量但是修改失效的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetValue</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    idx := strings.Index(s, <span class="string">":"</span>)</span><br><span class="line">    <span class="keyword">if</span> idx &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s[idx:], <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenGroupId</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res, ok := GetValue(<span class="string">"id:1881"</span>); !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> res, errors.New(<span class="string">"Format error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"group-"</span> + res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述 if 流程块中，使用了一个与全局范围内同名的 res 变量，但是实际上 if 块中 res 变量是一个局部临时变量，隐藏了全局变量，对其的修改无法反映到全局范围中去，<br>因此 return 语句中的 res 依然是空的。对于这种在 if 控制块中需要修改全局变量情况，应该避免使用 <code>:=</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetValue</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    idx := strings.Index(s, <span class="string">":"</span>)</span><br><span class="line">    <span class="keyword">if</span> idx &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s[idx:], <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenGroupId</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(res <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">if</span> res, ok = GetValue(<span class="string">"id:1881"</span>); !ok &#123;</span><br><span class="line">        err = errors.New(<span class="string">"Format error"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"group-"</span> + res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>A concurrency-safe implementation of map in Go</title>
      <link href="/Programming/go-go-sync-map/"/>
      <url>/Programming/go-go-sync-map/</url>
      
        <content type="html"><![CDATA[<p>Golang 里面 map 不是并发安全的，这一点是众所周知的，而且官方文档也很早就给了解释：<a href="http://golang.org/doc/faq#atomic_maps" target="_blank" rel="noopener">Why are map operations not defined to be atomic?</a>. 也正如这个解释说的一样，要实现一个并发安全的 map 其实非常简单。</p><br>#### 并发安全---实际上，大多数情况下，对一个 map 的访问都是读操作多于写操作，而且读的时候，是可以共享的。所以这种场景下，用一个 `sync.RWMutex` 保护一下就是很好的选择：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> syncMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个结构体定义了一个并发安全的 string map，用一个 map 来保存数据，一个读写锁来保护安全。这个 map 可以被任意多的 goroutine 同时读，但是写的时候，会阻塞其他读写操作。添加上 Get，Set，Delete 等方法，这个设计是能够工作的，而且大多数时候能表现不错。<br>但是这种设计会有些性能隐患。主要是两个方面：</p><ul><li>读写锁的粒度太大了，保护了整个 map 的访问。写操作是阻塞的，此时其他任何读操作都无法进行。</li><li>如果内部的 map 存储了很多 key，GC 的时候就需要扫描很久。</li></ul><br>#### 「分表」---一种解决思路是“分表”存储，具体实现就是，基于上面的 syncMap 再包装一次，用多个 syncMap 来模拟实现一个 map：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SyncMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    shardCount <span class="keyword">uint8</span></span><br><span class="line">    shards     []*syncMap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种设计用了一个 <code>*syncMap</code> 的 slice 来保存数据，shardCount 提供了分表量的可定制性。实际上 shards 同样可以实现为 <code>map[string]*syncMap</code>。在这种设计下，数据（key:value）会被分散到不同的 syncMap，而每个 syncMap 又有自己底层的 map。数据分散了，锁也分散了，能够很大程度上提高随机访问性能。而且在数据量大、高并发、写操作频繁的场景下，这种提升会更加明显。<br>那么数据如何被分配到指定的分块呢？一种很通用也很简单的方法就是 hash. 字符串的哈希算法有很多，byvoid 大神实现和比较了多种字符串 hash 函数（<a href="https://www.byvoid.com/blog/string-hash-compare/" target="_blank" rel="noopener">各种字符串Hash函数比较</a>），得出结论是：“BKDRHash无论是在实际效果还是编码实现中，效果都是最突出的”。这里采用了 <strong>BKDRHash</strong> 来实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> seed <span class="keyword">uint32</span> = <span class="number">131</span> <span class="comment">// 31 131 1313 13131 131313 etc..</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bkdrHash</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> h <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> str &#123;</span><br><span class="line">        h = h*seed + <span class="keyword">uint32</span>(c)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find the specific shard with the given key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SyncMap)</span> <span class="title">locate</span><span class="params">(key <span class="keyword">string</span>)</span> *<span class="title">syncMap</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.shards[bkdrHash(key)&amp;<span class="keyword">uint32</span>((m.shardCount<span class="number">-1</span>))]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：locate 方法调用 bkdrHash 函数计算一个 key 的哈希值，然后用该值对分表量取模得到在 slice 的 index，之后就能定位到对应的 syncMap.<br>这种实现足够简单，而且也有不错的性能表现。除了基本的 Get、Set、Delete 等基本操作之外，迭代（range）功能也非常有用。</p><p>更多的功能和细节，可以在源码里找到答案：<a href="https://github.com/DeanThompson/syncmap" target="_blank" rel="noopener">https://github.com/DeanThompson/syncmap</a>.</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>两种高效的服务器设计模型：Reactor 和 Proactor 模型</title>
      <link href="/Programming/network-programming-reactor-proactor/"/>
      <url>/Programming/network-programming-reactor-proactor/</url>
      
        <content type="html"><![CDATA[<p>在编写服务端软件的时候，如何处理各种 I/O 事件是其中很重要的一部分。在 Unix Network Programming 一书中介绍了 5 种Unix/Linux下可用的 I/O 编程模型：</p><ul><li>1) 阻塞式 I/O</li><li>2) 非阻塞式 I/O</li><li>3) I/O 复用</li><li>4) 信号驱动式 I/O</li><li>5) 异步 I/O。</li></ul><p>这 5 种 I/O 模型都是基本的 I/O 编程模型，我们可以单独使用其中一种，也可以组合使用。其中，前四种都是同步模型，最后一种是异步模型。为了应对高并发量的情形，在经典 C10K Problem 一文中另外总结了 5 种高性能的 I/O 编程模型，它们是：</p><ul><li>1) 单线程非阻塞式水平触发 I/O (Serve many clients with each thread, and use nonblocking I/O and level-triggered readiness notification)</li><li>2) 单线程非阻塞式边沿触发 I/O (Serve many clients with each thread, and use nonblocking I/O and readiness change notification)</li><li>3) 多线程异步 I/O 模型 (Serve many clients with each server thread, and use asynchronous I/O)</li><li>4) 单个服务线程对应单个客户 (Serve one client with each server thread)</li><li>5) 将服务线程放到内核 (Build the server code into the kernel)。</li></ul><p>本文下面将要介绍的两种模型都是基于 I/O 多路复用的单线程处理模型。</p><h4 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h4><p>Reactor 模式是处理并发 I/O 比较常见的一种模式，用于同步 I/O，其核心思想是将所有要处理的 I/O 事件注册到一个中心 I/O 多路复用器上，同时主线程/进程阻塞在多路复用器上；一旦有 I/O 事件到来或是准备就绪(文件描述符或socket可读、写)，多路复用器返回并将事先注册的相应 I/O 事件分发到对应的处理器中。</p><p>Reactor是一种事件驱动机制，和普通函数调用的不同之处在于：应用程序不是主动的调用某个API完成处理，而是恰恰相反，Reactor 逆置了事件处理流程，应用程序需要事先提供相应的接口并注册到 Reactor 上，如果相应的事件发生，Reactor 将主动调用应用程序注册的接口，这些接口又称为“回调函数”。用“好莱坞原则”来形容Reactor再合适不过了：“不要打电话给我们，我们会打电话通知你。”</p><p>Reactor 模式有三个重要的组件：</p><ul><li>多路复用器：由操作系统提供，在 Linux 上一般是 select, poll, epoll 等系统调用。</li><li>事件分发器：将多路复用器中返回的就绪事件分到对应的处理函数中。</li><li>事件处理器：负责处理特定事件的处理函数。</li></ul><p>因为这种模型经常使用，所有不少人对简单的系统调用做了一层封装，形成跨平台的事件处理库，比较典型的有:<a href="http://libevent.org/" target="_blank" rel="noopener">libevent</a>，<a href="http://software.schmorp.de/pkg/libev.html" target="_blank" rel="noopener">libev</a>，<a href="http://www.boost.org/" target="_blank" rel="noopener">boost asio</a> 等。</p><p>Reactor 中文翻译成反应器模式或者反应堆模式，通常，可以直接叫 Reactor 模式。其实我觉着叫应答者模式更好理解一些。通过了解，这个模式更像一个侍卫，一直在等待你的召唤，或者叫召唤兽。</p><p>并发系统通常使用 Reactor 模式来代替常用的多线程的处理方式，节省系统的资源，提高系统的吞吐量。</p><p>Reactor 模式与 Observer 模式在某些方面极为相似：当一个主体发生改变时，所有依属体都得到通知。不过，观察者模式与单个事件源关联，而反应器模式则与多个事件源关联 。</p><p>在 Reactor 模式中，有5个关键的参与者：</p><ul><li>描述符（handle）：由操作系统提供的资源，用于识别每一个事件，如Socket描述符、文件描述符、信号的值等。在 Linux 中，它用一个整数来表示。事件可以来自外部，如来自客户端的连接请求、数据等。事件也可以来自内部，如信号、定时器事件。</li><li>同步事件多路分离器（event demultiplexer）：事件的到来是随机的、异步的，无法预知程序何时收到一个客户连接请求或收到一个信号。所以程序要循环等待并处理事件，这就是事件循环。在事件循环中，等待事件一般使用I/O复用技术实现。在linux系统上一般是select、poll、epol_waitl等系统调用，用来等待一个或多个事件的发生。I/O框架库一般将各种I/O复用系统调用封装成统一的接口，称为事件多路分离器。调用者会被阻塞，直到分离器分离的描述符集上有事件发生。</li><li>事件处理器（event handler）：I/O框架库提供的事件处理器通常是由一个或多个模板函数组成的接口。这些模板函数描述了和应用程序相关的对某个事件的操作，用户需要继承它来实现自己的事件处理器，即具体事件处理器。因此，事件处理器中的回调函数一般声明为虚函数，以支持用户拓展。</li><li>具体的事件处理器（concrete event handler）：是事件处理器接口的实现。它实现了应用程序提供的某个服务。每个具体的事件处理器总和一个描述符相关。它使用描述符来识别事件、识别应用程序提供的服务。</li><li>Reactor 管理器（reactor）：定义了一些接口，用于应用程序控制事件调度，以及应用程序注册、删除事件处理器和相关的描述符。它是事件处理器的调度核心。 Reactor管理器使用同步事件分离器来等待事件的发生。一旦事件发生，Reactor管理器先是分离每个事件，然后调度事件处理器，最后调用相关的模 板函数来处理这个事件。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1452123-35a5505c0d9928f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>可以看出，Reactor 管理器并不是应用程序负责等待事件、分离事件和调度事件。Reactor 并没有被具体的事件处理器调度，而是管理器调度具体的事件处理器，由事件处理器对发生的事件作出处理，这就是 Hollywood 原则。应用程序要做的仅仅是实现一个具体的事件处理器，然后把它注册到 Reactor 管理器中。接下来的工作由管理器来完成：如果有相应的事件发生，Reactor 会主动调用具体的事件处理器，由事件处理器对发生的事件作出处理。</p><p>应用场景<br>场景：长途客车在路途上，有人上车有人下车，但是乘客总是希望能够在客车上得到休息。传统做法：每隔一段时间（或每一个站），司机或售票员对每一个乘客询问是否下车。Reactor做法：汽车是乘客访问的主体（Reactor），乘客上车后，到售票员（acceptor）处登记，之后乘客便可以休息睡觉去了，当到达乘客所要到达的目的地时（指定的事件发生，乘客到了下车地点），售票员将其唤醒即可。</p><p>为什么使用 Reactor<br>网络编程为什么要用反应堆？有了 I/O 复用，有了 epoll 已经可以使服务器并发几十万连接的同时，维持高 TPS 了，难道这还不够吗？<br>答案是，技术层面足够了，但在软件工程层面却是不够的。</p><p>程序使用 IO 复用的难点在哪里呢？<br>1个请求可能由多次 IO 处理完成，但相比传统的单线程完整处理请求生命期的方法，IO复用在人的大脑思维中并不自然，因为，程序员编程中，处理请求A的时候，假定A请求必须经过多个IO操作A1-An（两次IO间可能间隔很长时间），每经过一次IO操作，再调用IO复用时，IO复用的调用返回里，非常可能不再有A，而是返回了请求B。即请求A会经常被请求B打断，处理请求B时，又被C打断。这种思维下，编程容易出错。</p><p>形象例子：<br>本部分和下部分内容来自：<a href="http://blog.csdn.net/russell_tao/article/details/17452997" target="_blank" rel="noopener">高性能网络编程6–reactor反应堆与定时器管理</a><br>**    传统编程方法<strong>就好像是到了银行营业厅里，每个窗口前排了长队，业务员们在窗口后一个个的解决客户们的请求。一个业务员可以尽情思考着客户A依次提出的问题，例如：<br>“我要买2万XX理财产品。“<br>“看清楚了，5万起售。”<br>“等等，查下我活期余额。”<br>“余额5万。”<br>“那就买 5万吧。”<br>业务员开始录入信息。<br>”对了，XX理财产品年利率8%？”<br>“是预期8%，最低无利息保本。“<br>”早不说，拜拜，我去买余额宝。“<br>业务员无表情的删着已经录入的信息进行事务回滚。<br>”下一个！“<br>    用了</strong>IO 复用<strong>则是大师业务员开始挑战极限，在超大营业厅里给客户们人手一个牌子，黑压压的客户们都在大厅中，有问题时举牌申请提问，大师目光敏锐点名指定某人提问，该客户迅速得到大师的答复后，要经过一段时间思考，查查自己的银袋子，咨询下LD，才能再次进行下一个提问，直到得到完整的满意答复退出大厅。例如：大师刚指导A填写转帐单的某一项，B又来申请兑换泰铢，给了B兑换单后，C又来办理定转活，然后D与F在争抢有限的圆珠笔时出现了不和谐现象，被大师叫停业务，暂时等待。<br>    这就是</strong>基于事件驱动的 IO 复用编程**比起传统1线程1请求的方式来，有难度的设计点了，客户们都是上帝，既不能出错，还不能厚此薄彼。当没有反应堆时，我们可能的设计方法是这样的：大师把每个客户的提问都记录下来，当客户 A 提问时，首先查阅 A 之前问过什么做过什么，这叫联系上下文，然后再根据上下文和当前提问查阅有关的银行规章制度，有针对性的回答 A，并把回答也记录下来。当圆满回答了A的所有问题后，删除 A 的所有记录。</p><p>在程序中：<br>    某一瞬间，服务器共有 10 万个并发连接，此时，一次 IO 复用接口的调用返回了 100 个活跃的连接等待处理。先根据这100个连接找出其对应的对象，这并不难，epoll 的返回连接数据结构里就有这样的指针可以用。接着，循环的处理每一个连接，找出这个对象此刻的上下文状态，再使用 read、write 这样的网络 IO 获取此次的操作内容，结合上下文状态查询此时应当选择哪个业务方法处理，调用相应方法完成操作后，若请求结束，则删除对象及其上下文。<br>    这样，我们就<strong>陷入了面向过程编程方法之中</strong>了，在面向应用、快速响应为王的移动互联网时代，这样做早晚得把自己玩死。<strong>我们的主程序需要关注各种不同类型的请求，在不同状态下，对于不同的请求命令选择不同的业务处理方法</strong>。这会导致随着请求类型的增加，请求状态的增加，请求命令的增加，主程序复杂度快速膨胀，导致维护越来越困难，苦逼的程序员再也不敢轻易接新需求、重构。</p><pre><code>**反应堆是解决上述软件工程问题的一种途径**，它也许并不优雅，开发效率上也不是最高的，但**其执行效率与面向过程的使用 IO 复用却几乎是等价的**，所以，无论是 nginx、memcached、redis 等等这些高性能组件的代名词，都义无反顾的一头扎进了反应堆的怀抱中。**反应堆模式**可以在软件工程层面，**将事件驱动框架分离出具体业务，将不同类型请求之间用 OO 的思想分离**。通常，**反应堆不仅使用 IO 复用处理网络事件驱动，还会实现定时器来处理时间事件的驱动（请求的超时处理或者定时任务的处理）**，就像下面的示意图：</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1452123-16bac3419936124b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这幅图有5点意思：<br>（1）处理应用时基于 OO 思想，<strong>不同的类型的请求处理间是分离的</strong>。例如，A 类型请求是用户注册请求，B 类型请求是查询用户头像，那么当我们把用户头像新增多种分辨率图片时，更改B类型请求的代码处理逻辑时，完全不涉及A类型请求代码的修改。</p><p>（2）<strong>应用处理请求的逻辑，与事件分发框架完全分离</strong>。什么意思呢？即写应用处理时，不用去管何时调用 IO 复用，不用去管什么调用 epoll_wait，去处理它返回的多个 socket 连接。应用代码中，只关心如何读取、发送 socket 上的数据，如何处理业务逻辑。事件分发框架有一个抽象的事件接口，所有的应用必须实现抽象的事件接口，通过这种抽象才把应用与框架进行分离。</p><p>（3）反应堆上提供注册、移除事件方法，供应用代码使用，而<strong>分发事件方法，通常是循环的调用而已</strong>，是否提供给应用代码调用，还是由框架简单粗暴的直接循环使用，这是框架的自由。</p><p>（4）IO 多路复用也是一个抽象，它可以是具体的 select，也可以是 epoll，它们只必须提供采集到某一瞬间所有待监控连接中活跃的连接。</p><p>（5）定时器也是由反应堆对象使用，它必须至少提供4个方法，包括添加、删除定时器事件，这该由应用代码调用。最近超时时间是需要的，这会被反应堆对象使用，用于确认 select 或者 epoll_wait 执行时的阻塞超时时间，防止 IO 的等待影响了定时事件的处理。遍历也是由反应堆框架使用，用于处理定时事件。</p><p>Reactor 的几种模式<br>参考资料：<a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener"><strong>Scalable IO in Java</strong></a><br>在web服务中，很多都涉及基本的操作：read request、decode request、process service、encod reply、send reply等。</p><p>1 单线程模式<br>      这是最简单的单 Reactor 单线程模型。Reactor 线程是个多面手，负责多路分离套接字，Accept 新连接，并分派请求到处理器链中。该模型适用于处理器链中业务处理组件能快速完成的场景。不过这种单线程模型不能充分利用多核资源，所以实际使用的不多。<img src="http://upload-images.jianshu.io/upload_images/1452123-bfb7ef28b21ba29e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>2 多线程模式（单 Reactor）<br>       该模型在事件处理器（Handler）链部分采用了多线程（线程池），也是后端程序常用的模型。<br><img src="http://upload-images.jianshu.io/upload_images/1452123-306883d5deec0b56?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>3 多线程模式（多个Reactor）<br>       比起第二种模型，它是将 Reactor 分成两部分，mainReactor 负责监听并 accept 新连接，然后将建立的 socket 通过多路复用器（Acceptor）分派给 subReactor。subReactor 负责多路分离已连接的 socket，读写网络数据；业务处理功能，其交给 worker 线程池完成。通常，subReactor 个数上可与 CPU 个数等同。<br><img src="http://upload-images.jianshu.io/upload_images/1452123-d5bb25d670d1285b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="Proacotr模型"><a href="#Proacotr模型" class="headerlink" title="Proacotr模型"></a>Proacotr模型</h4><p>Proactor 是和异步 I/O 相关的。<br>       在 Reactor 模式中，事件分离者等待某个事件或者可应用或个操作的状态发生（比如文件描述符可读写，或者是 socket 可读写），事件分离器就把这个事件传给事先注册的处理器（事件处理函数或者回调函数），由后者来做实际的读写操作。在 Proactor 模式中，事件处理者(或者代由事件分离者发起)直接发起一个异步读写操作(相当于请求)，而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区，读的数据大小，或者用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分离者得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理者或者回调。</p><p>可以看出两者的区别：<br>Reactor 是在事件发生时就通知事先注册的事件（读写由处理函数完成）；<br>Proactor 是在事件发生时进行异步I/O（读写由 OS 完成），待 IO 完成事件分离器才调度处理器来处理。</p><p>为了帮助理解 Reactor 与 Proactor 二者的差异，以读操作为例（其他操作类似）。<br><strong>在Reactor（同步）中实现读：</strong> </p><ul><li>注册读就绪事件和相应的事件处理器 </li><li>事件分离器等待事件 - 事件到来，激活分离器，分离器调用事件对应的处理器。</li><li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li></ul><p><strong>Proactor（异步）中的读：</strong> </p><ul><li>处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，<strong>它关注的是完成事件</strong>。 </li><li>事件分离器等待操作完成事件</li><li>在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成。 </li><li>事件分离器呼唤处理器。 </li><li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器。</li></ul><p>工业实现</p><h5 id="开源-C-框架：ACE"><a href="#开源-C-框架：ACE" class="headerlink" title="开源 C++ 框架：ACE"></a>开源 C++ 框架：ACE</h5><p>开源 C++ 开发框架 ACE 提供了大量平台独立的底层并发支持类(线程、互斥量等)。 同时在更高一层它也提供了独立的几组 C++ 类，用于实现 Reactor 及 Proactor 模式。 尽管它们都是平台独立的单元，但他们都提供了不同的接口。ACE Proactor 在 MS-Windows上无论是性能还在健壮性都更胜一筹，这主要是由于 Windows 提供了一系列高效的底层异步 API。(这段可能过时了点吧) 不幸的是，<strong>并不是所有操作系统都为底层异步提供健壮的支持</strong>。举例来说， 许多 Unix 系统就有麻烦。因此， <strong>ACE Reactor 可能是 Unix 系统上更合适的解决方案</strong>。 正因为系统底层的支持力度不一，为了在各系统上有更好的性能，开发者不得不维护独立的好几份代码: 为 Windows 准备的 ACE Proactor 以及为 Unix 系列提供的 ACE Reactor。真正的异步模式需要操作系统级别的支持。由于事件处理者及操作系统交互的差异，为 Reactor 和 Proactor 设计一种通用统一的外部接口是非常困难的。这也是设计通行开发框架的难点所在。</p><p>ACE 是一个大型的中间件产品，代码20万行左右，过于宏大，一堆的设计模式，架构了一层又一层，使用的时候，要根据情况，看从那一层来进行使用。支持跨平台。</p><p>设计模式 ：ACE 主要应用了 Reactor，Proactor 等；<br>层次架构 ：ACE 底层是 C 风格的 OS 适配层，上一层基于 C++ 的 wrap 类，再上一层是一些框架 （Accpetor, Connector, Reactor, Proactor等），最上一层是框架上服务；<br>可移植性 ：ACE 支持多种平台，可移植性不存在问题，据说 socket 编程在 Linux 下有不少 bugs；<br>事件分派处理 ：ACE主要是注册 handler 类，当事件分派时，调用其 handler 的虚挂勾函数。实现 ACE_Handler/ACE_Svc_Handler/ACE_Event_handler 等类的虚函数；<br>涉及范围 ：ACE 包含了日志，IPC,线程池，共享内存，配置服务，递归锁，定时器等；<br>线程调度 ：ACE 的 Reactor 是单线程调度，Proactor 支持多线程调度；<br>发布方式 ：ACE 是开源免费的，不依赖于第三方库，一般应用使用它时，以动态链接的方式发布动态库；<br>开发难度 ：基于 ACE 开发应用，对程序员要求比较高，要用好它，必须非常了解其框架。在其框架下开发，往往 new 出一个对象，不知在什么地方释放好。</p><h5 id="C-网络库：libevent"><a href="#C-网络库：libevent" class="headerlink" title="C 网络库：libevent"></a>C 网络库：libevent</h5><p>libevent 是一个 C 语言写的网络库，官方主要支持的是类 Linux 操作系统，最新的版本添加了对 windows 的IOCP 的支持。在跨平台方面主要通过 select 模型来进行支持。<br>设计模式 ：<strong>libevent 为 Reactor 模式</strong>； 层次架构：livevent 在不同的操作系统下，做了多路复用模型的抽象，可以选择使用不同的模型，通过事件函数提供服务；<br>可移植性 ：libevent 主要支持 Linux 平台，freebsd 平台，其他平台下通过 select 模型进行支持，效率不是太高；<br>事件分派处理：libevent <strong>基于注册的事件回调函数来实现事件分发</strong>；涉及范围 ：libevent 只提供了简单的网络 API 的封装，线程池，内存池，递归锁等均需要自己实现；<br>线程调度 ：libevent 的线程调度需要自己来注册不同的事件句柄；<br>发布方式 ：libevent 为开源免费的，一般编译为静态库进行使用；<br>开发难度 ：基于 libevent 开发应用，相对容易，具体可以参考 memcached 这个开源的应用，里面使用了 libevent 这个库。 </p><h5 id="改进方案：模拟异步"><a href="#改进方案：模拟异步" class="headerlink" title="改进方案：模拟异步"></a>改进方案：模拟异步</h5><p>在改进方案中，我们<strong>将 Reactor 原来位于事件处理器内的  read/write 操作移至分离器</strong>(不妨将这个思路称为“模拟异步”)，以此寻求将 Reactor 多路同步 IO 转化为模拟异步 IO。<br>以读操作为例子，<strong>改进过程如下</strong>：</p><ul><li>注册读就绪事件及其处理器，并为分离器提供数据缓冲区地址，需要读取数据量等信息。 </li><li>分离器等待事件（如在 select()上等待） </li><li>事件到来，激活分离器。分离器执行一个非阻塞读操作（它有完成这个操作所需的全部信息），最后调用对应处理器。</li><li>事件处理器处理用户自定义缓冲区的数据，注册新的事件（当然同样要给出数据缓冲区地址，需要读取的数据量等信息），最后将控制权返还分离器。</li></ul><p>如我们所见，通过对多路IO模式功能结构的改造，可将 Reactor 转化为 Proactor 模式。改造前后，模型实际完成的工作量没有增加，只不过参与者间对工作职责稍加调换。没有工作量的改变，自然不会造成性能的削弱。对如下各步骤的比较，可以证明工作量的恒定：</p><p><strong>标准/典型的 Reactor：</strong> </p><ul><li>步骤1：等待事件到来（Reactor 负责） </li><li>步骤2：将读就绪事件分发给用户定义的处理器（Reactor 负责） </li><li>步骤3：读数据（用户处理器负责） </li><li>步骤4：处理数据（用户处理器负责）****</li></ul><p><strong>改进实现的模拟Proactor：</strong> </p><ul><li>步骤1：等待事件到来（Proactor 负责） </li><li>步骤2：得到读就绪事件，执行读数据（现在由 Proactor 负责） </li><li>步骤3：将读完成事件分发给用户处理器（Proactor 负责） </li><li>步骤4：处理数据（用户处理器负责）  </li></ul><p>对于不提供异步 IO API 的操作系统来说，这种办法可以隐藏 socket API 的交互细节，从而对外暴露一个完整的异步接口。借此，我们就可以进一步构建完全可移植的，平台无关的，有通用对外接口的解决方案。上述方案已经由<a href="http://www.terabit.com.au/" target="_blank" rel="noopener">Terabit P/L</a>公司实现为 TProactor。它有两个版本：C++ 和 JAVA 的。C++ 版本采用 ACE 跨平台底层类开发，为所有平台提供了通用统一的主动式异步接口。</p><h5 id="Boost-Asio类库"><a href="#Boost-Asio类库" class="headerlink" title="Boost.Asio类库"></a>Boost.Asio类库</h5><p>Boost.Asio 类库，其就是<strong>以 Proactor 这种设计模式来实现</strong>，参见：Proactor（The Boost.Asio library is based on the Proactor pattern. This design note outlines the advantages and disadvantages of this approach.）<br>其设计文档链接：<a href="http://asio.sourceforge.net/boost_asio_0_3_7/libs/asio/doc/design/index.html" target="_blank" rel="noopener">http://asio.sourceforge.net/boost_asio_0_3_7/libs/asio/doc/design/index.html</a></p><p>本文来源：<br><a href="http://blog.csdn.net/u013074465/article/details/46276967" target="_blank" rel="noopener">http://blog.csdn.net/u013074465/article/details/46276967</a></p><p>参考资料<br>1、<a href="http://www.cnblogs.com/hzbook/archive/2012/07/19/2599698.html" target="_blank" rel="noopener">Reactor 构架模式及框架概述</a><br>2、<a href="http://blog.csdn.net/russell_tao/article/details/17452997" target="_blank" rel="noopener">高性能网络编程6–reactor反应堆与定时器管理</a><br>3、<a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">Scalable IO in Java</a><br>4、<a href="http://www.cs.wustl.edu/~schmidt/PDF/reactor-siemens.pdf" target="_blank" rel="noopener">Reactor - An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events </a><br>5、<a href="http://blog.jobbole.com/59676/" target="_blank" rel="noopener">两种高性能I/O设计模式(Reactor/Proactor)的比较</a><br>6、<a href="http://www.cnblogs.com/MikeZhang/archive/2012/08/16/ReactorPattern20120815.html" target="_blank" rel="noopener">Reactor模式及在DSS中的体现</a><br>7、<a href="http://blog.csdn.net/roger_77/article/details/1555170" target="_blank" rel="noopener">高性能 I/O 设计模式 Reactor 和 Proactor</a><br>8、<a href="http://www.artima.com/articles/io_design_patterns2.html" target="_blank" rel="noopener">Comparing Two High-Performance I/O Design Patterns</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Print struct and map in a human readable format</title>
      <link href="/Programming/go-print-struct-map/"/>
      <url>/Programming/go-print-struct-map/</url>
      
        <content type="html"><![CDATA[<p>在对 Go 语言编码程序进行调试的过程中，经常可能会需要打印 struct 或者 map 这种复合结构的变量的内容，本文总结了并提炼了一些方法来方便的查看这些复杂类型的内容。</p><br>##### 1. struct---<p>如果已知是某具体的 struct。可以把它先转成 json， 然后使用 json 包提供的 Indent() 或者 MarshalIndent() 方法来打印 pretty json</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mystruct := Person&#123;<span class="string">"alex"</span>, <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. MarshalIndent</span></span><br><span class="line">    b1, _ := json.MarshalIndent(mystruct, <span class="string">""</span>, <span class="string">"  "</span>)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(b1))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Indent</span></span><br><span class="line">    b, _ := json.Marshal(mystruct)</span><br><span class="line">    <span class="keyword">var</span> prettyJson bytes.Buffer</span><br><span class="line">    json.Indent(&amp;prettyJson, b, <span class="string">""</span>, <span class="string">"\t"</span>)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(prettyJson.Bytes()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>##### 2. map---如果已知具体 map，直接遍历打印即可。<br>##### 3. interface---<p><strong>1) struct</strong><br>函数参数是 interface{}， 传入的是 struct。<br>必须使用 reflect 来遍历输出。<br>注意： 如果 struct 有嵌套， 则嵌套的部分只会整体打印出来</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Addr <span class="keyword">struct</span> &#123;</span><br><span class="line">    road <span class="keyword">string</span></span><br><span class="line">    city <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printStructInfo</span><span class="params">(info <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Println(reflect.TypeOf(info))</span><br><span class="line">    t := reflect.TypeOf(info)</span><br><span class="line">    v := reflect.ValueOf(info)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> v.CanInterface() &#123;</span><br><span class="line">            s := v.Field(i).Interface()</span><br><span class="line">            fmt.Printf(<span class="string">"%s %s = %v\n"</span>, t.Field(i).Name, t.Field(i).Type, s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pers := Person&#123;<span class="string">"alex"</span>, <span class="number">19</span>， Addr&#123;<span class="string">"jiuxian"</span>, <span class="string">"beijing"</span>&#125;&#125;</span><br><span class="line">    printInfo(pers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>main.Person<br>Name string = alex<br>Age int = 19<br>Addr main.Addr = {jiuxian beijing}</p></blockquote><p>对于有<strong>嵌套定义</strong>的 struct， 那么如何能够递归打印全部的成员出来呢？<br>这个就必须用到 Kind() 了， 这个函数会返回底层的数据结构类型。</p><p>比如：<br>如果是 struct， 那么 Kind().String() 就会返回 struct。<br>而 TypeOf().String() 只会返回 main.Addr 这种类型。</p><p>注意： 嵌套的 struct 中成员必须已导出（大写开头），否则无法打印，抛出错误：<br>cannot return value obtained from unexported field or method</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Addr <span class="keyword">struct</span> &#123;</span><br><span class="line">    Road <span class="keyword">string</span></span><br><span class="line">    City <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age  <span class="keyword">int</span></span><br><span class="line">    Addr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printStructInfo</span><span class="params">(info <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Println(reflect.TypeOf(info))</span><br><span class="line">    t := reflect.TypeOf(info)</span><br><span class="line">    v := reflect.ValueOf(info)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> v.CanInterface() &#123;</span><br><span class="line">            s := v.Field(i).Interface()</span><br><span class="line">            <span class="keyword">if</span> reflect.TypeOf(s).Kind().String() == <span class="string">"struct"</span> &#123;</span><br><span class="line">                printInfo(v.Field(i).Interface())</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"%s %s = %v\n"</span>, t.Field(i).Name, t.Field(i).Type, s)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pers := Person&#123;<span class="string">"alex"</span>, <span class="number">19</span>, Addr&#123;<span class="string">"jiuxian"</span>, <span class="string">"beijing"</span>&#125;&#125;</span><br><span class="line">    printInfo(pers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>ain.Person<br>Name string = alex<br>Age int = 19<br>main.Addr<br>Road string = jiuxian<br>City string = beijing</p></blockquote><p>这样的话， 不管 struct 嵌套多少层， 都可以打印出来了。</p><p><strong>2) map</strong></p><p>map 跟  struct 有所不同， 遍历 map 时， 需要使用 range 关键字。<br>而 range 遍历的话需要知道 value 的具体类型，比如： map[string]interface{}，value 的类型是 interface{}，<br>如果不知道 interface{} 实际所存的具体类型，就没法遍历打印其内容。</p><p>隐刺，进行 range 遍历的时候，需要把 value 进行 type assertion 成已知的 map 类型。</p><p>注意：不能把 map[string]int 进行 type assert 成 map[string]interface{}。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMapInfo</span><span class="params">(leading <span class="keyword">string</span>, info <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    t := reflect.TypeOf(info)</span><br><span class="line">    <span class="comment">// v := reflect.ValueOf(info)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> t.Kind().String() == <span class="string">"map"</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> k, v := <span class="keyword">range</span> info.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">            tv := reflect.TypeOf(v)</span><br><span class="line">            <span class="keyword">if</span> tv.Kind().String() == <span class="string">"map"</span> &#123;</span><br><span class="line">                fmt.Println(k, <span class="string">":"</span>)</span><br><span class="line">                printInfo(<span class="string">"\t"</span>, v)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"%s%s : %v\n"</span>, leading, k, v)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    my := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"alex"</span>, </span><br><span class="line">        <span class="string">"age"</span>: <span class="number">18</span>, </span><br><span class="line">        <span class="string">"commodity"</span>: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">            <span class="string">"class"</span>: <span class="string">"friute"</span>, </span><br><span class="line">            <span class="string">"price"</span>: <span class="number">10.2</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    printMapInfo(<span class="string">""</span>, my)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>ommodity :<br>    class : friute<br>    price : 10.2<br>name : alex<br>age : 18</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go performance tips</title>
      <link href="/Programming/go-go-performance-tips/"/>
      <url>/Programming/go-go-performance-tips/</url>
      
        <content type="html"><![CDATA[<p>本文列举一些可以更好的提升 Go 程序性能的场景和方法。</p><br>#### string 与 []byte 相互转换<p>在写程序的过程中经常遇到string与[]byte的相互转换，但是这种转换是有代价的，string与[]byte并不共享底层内存空间，所以每次转换都伴随着内存的分配与底层字节的拷贝。<br>我们可以借助unsafe完成指针类型转换,避开内存分配与复制，从而提升性能。<strong>属于magic，尽量不要用。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//  struct string&#123;</span></span><br><span class="line"><span class="comment">//    uint8 *str;</span></span><br><span class="line"><span class="comment">//    int len;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//  struct []uint8&#123;</span></span><br><span class="line"><span class="comment">//    uint8 *array;</span></span><br><span class="line"><span class="comment">//    int len;</span></span><br><span class="line"><span class="comment">//    int cap;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//  uintptr 是 golang 的内置类型，是能存储指针的整型，uintptr 的底层类型是 int，它和 unsafe.Pointer 可相互转换。</span></span><br><span class="line"><span class="comment">//  但是转换后的 string 与 []byte 共享底层空间，如果修改了[]byte 那么 string 的值也会改变，就违背了string 应该是只读的规范了，可能会造成难以预期的影响。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">str2byte</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    x := (*[<span class="number">2</span>]<span class="keyword">uintptr</span>)unsafe.Pointer(&amp;s)</span><br><span class="line">    h := [<span class="number">3</span>]<span class="keyword">uintptr</span>&#123;x[<span class="number">0</span>],x[<span class="number">1</span>],x[<span class="number">1</span>]&#125;</span><br><span class="line">    <span class="keyword">return</span> *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;h))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">byte2str</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>##### map使用注意事项---<br>###### (1) 预设容量 map可以动态扩容，所以我们可以不关心map的大小，但是每次动态扩容时需要付出数据拷贝和重新哈希成本，如果我们能预先知道一个map最终的容量，那么最好在初始化时就指定。bigMap := make(map[int]int,100000) <br>###### (2) 直接存储小对象值而不是指针 对于小对象，直接将数据交由 map 保存，远比用指针高效。这不但减少了堆内存分配，关键还在于垃圾回收器不会扫描非指针类型 key/value 对象。//存储值对象 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>,<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span> ;i&lt;<span class="number">10000</span>;i++ &#123;</span><br><span class="line">    m[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 存储指针对象</span></span><br><span class="line"><span class="comment">// 如果value是个小对象,直接存储值会比较好</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*<span class="keyword">int</span>,<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span> ;i&lt;<span class="number">10000</span>;i++ &#123;</span><br><span class="line">    value := i </span><br><span class="line">    m[i]=&amp;value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>###### (3) 手动删除没有元素的map map 可以动态扩容，我们可以不断的往map中添加新元素,但是map并不会自动收缩空间，即使一个map中的所有元素都被删除，map依然会保留所有已分配的空间。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dict <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span> ;i&lt;<span class="number">100000</span>;i++ &#123;</span><br><span class="line">    dict[i] = i </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> dict &#123;</span><br><span class="line">    <span class="built_in">delete</span>(key)  <span class="comment">//即使删掉所有的元素，dict的容量仍然&gt;=100000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不再使用dict那么手动设置为nil </span></span><br><span class="line"><span class="comment">// dict=nil </span></span><br><span class="line"><span class="comment">//也可以把dict指向一个新创建的小map，原有的map所占用的内存空间会被回收</span></span><br><span class="line"><span class="comment">//dict = make(map[int]int)</span></span><br></pre></td></tr></table></figure><br>#### 正确使用 defer---defer 是提高可读性和避免资源未释放的非常有用的关键字，是使用 golang 写出可靠、稳定程序的利器。 defer 后面的表达式会被放入一个类似于栈(stack)的结构，在当前方法返回的时候，列表中的表达式会按照后进先出的顺序执行。 defer 本身会有一定的性能损失，但是和它带来的好处相比根本不值得一提,我们需要注意的关键点是defer表达式会在函数返回时被调用,意味着有些资源只能在函数结束时才被释放。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m.lock()</span><br><span class="line">    <span class="keyword">defer</span> m.unlock()</span><br><span class="line">    <span class="comment">//....业务处理逻辑</span></span><br><span class="line">    <span class="comment">//这是很常见的上锁方式，但是m.unlock()只会在函数返回时调用，如果业务处理逻辑耗时很长,那么会一直占用着锁，在高并发情况下严重影响性能。</span></span><br><span class="line">    <span class="comment">//解决办法是找到**最小临界区**，在处理完最小临界区后及时释放掉锁。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m.lock()</span><br><span class="line">    <span class="comment">//...最小临界区</span></span><br><span class="line">    m.unlock()</span><br><span class="line">    <span class="comment">//...继续处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>#### 字符串拼接---字符串的拼接大概有以下几种方式<ul><li>fmt.Sprintf(“%s%s%d%s%s”, “hello”, “world”, 2018, “come”, “on”)                     // 这种方式效率最低，但是代码最简单，最优雅</li><li>使用 “+” 拼接字符串 “hello” + “world” + strconv.FormatInt(2016,10) + “come” + “on”  // 比fmt.Sprintf()高效一些，但是代码很难看</li><li>使用 strings.Join() 将参数组装成 []string，然后再调用 strings.join 进行拼接         // 效率最高的一种方式，推荐使用</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strs := []<span class="keyword">string</span>&#123;<span class="string">"hello"</span>,<span class="string">"world"</span>,strconv.FormatInt(<span class="number">2016</span>,<span class="number">10</span>),<span class="string">"come"</span>,<span class="string">"on"</span>&#125;</span><br><span class="line">str = strings.Join(strs,<span class="string">""</span>)</span><br></pre></td></tr></table></figure><p>为什么使用string.Join效率最好呢，来看下 strings.Join 的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(a []<span class="keyword">string</span>, sep <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">//计算最终字符串的长度，根据最终长度创建[]byte,避免拼接过程中内存重新分配</span></span><br><span class="line">    n := <span class="built_in">len</span>(sep) * (<span class="built_in">len</span>(a) - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">        n += <span class="built_in">len</span>(a[i])</span><br><span class="line">    &#125;</span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line">    <span class="comment">//使用copy函数是最高效的</span></span><br><span class="line">    bp := <span class="built_in">copy</span>(b, a[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> a[<span class="number">1</span>:] &#123;</span><br><span class="line">        bp += <span class="built_in">copy</span>(b[bp:], sep)</span><br><span class="line">        bp += <span class="built_in">copy</span>(b[bp:], s)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有时候很难将参数拼接成[]string，这时我们可以使用 byte.Buffer</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">    buffer.WriteString(<span class="string">"a"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>#### reflect 对性能的影响---refelct 包作为 Go 语言对反射机制提供的支持，其虽然带来了极大的方便，但是同时也有一定的性能损失。性能要求极高的模块中应该注意反射所带来的性能损失。 JSON 是一种常用的数据交换格式，但 Go 的 encoding/json 库依赖于反射来对json进行序列化和反序列化。开源库 ffjson，可以通过使用代码生成的方式来避免反射的使用，相比使用原生库可以提升2~3倍的性能。<br>#### channel 并不是很高效---使用golang语言编程有一条很重要的思想是 Don't communicate by sharing memory, share memory by communicating.而 channel 则是不同 goroutine 之间 communicate 的通道。但是channel的底层实现也不是无锁的，往channel中读写数据都是需要加锁的，而且锁的力度还很大。 在一些情况下可以使用利用atomic实现无锁的结构(ring buffer)来替代channel以提高程序的性能。而在有些情况下使用sync.Mutex、atmoi不仅比使用channel效率更高代码还更简洁明了。Use whichever is most expressive and most simple<br><br><br><p><strong>来源：</strong><br><a href="http://shanks.leanote.com/post/Go%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7%E3%80%90%E8%BD%AC%E3%80%91" target="_blank" rel="noopener">http://shanks.leanote.com/post/Go%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7%E3%80%90%E8%BD%AC%E3%80%91</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Death edge</title>
      <link href="/Life/life-edge-of-life/"/>
      <url>/Life/life-edge-of-life/</url>
      
        <content type="html"><![CDATA[<p>写点东西，回忆一下我生命中经历过的生与死的边界。</p><p>印象中最早的一次事情发生在读小学时候，放学后跟同学去游泳，那时候农村的鱼塘很多，水质也不错，大夏天放学后去结伴去游泳是很常见的事情。 然而我不会游泳，我最多算凑热闹的。由于第一次去没有经验，本来只打算在浅水区打打水玩玩的不小心就溜下去了，突然踩不到水底的我一下子就慌乱了，头没(mò)在水里，手脚瞎挣扎，最后离岸边越来越远，人沉在水中也喝了不少水。这时候，幸运的是，有一个在鱼塘中央和远处游玩的同学正好打算游回岸边，他发现了挣扎着的我，迅速的把我从水中背起，拖回到岸边（其实离岸边咫尺而已，但对我这种不会游泳又突然踩不到水底的人而言已是天涯之距）。好在我只是喝了几口水并不多，上岸之后，很快就缓过来了，这是我第一次与死神插肩而过。</p><p>后来，很长一段时间我都不敢再去游泳了。无独有偶，后来有一次去姑爷家过暑假（在农村的夏天，人们通常都会去河边游泳解暑）。有了前车之鉴的我抱着在水边玩一玩陪个伴顺便看他们游泳的心态去的，结果我又不小心一脚没踩到地溜到河中央去了，所幸在还没喝几口水又被救了。这次没那么危险因为表哥就在身边不远。其实这还不是我唯二的两次跟水有关的“事故”。更小的时候，可能一岁不到，那时家里大院门前就是一口水塘，叔叔与父亲闹过一次矛盾，结果叔叔抱起我就扔到池塘里面去，我妈妈拼死把我救回来，晚1秒都可能立刻淹死。虽然由于太小在记忆中不太深刻，但那次才是我真正离死亡最近的一次。</p><p>这三次都是从死神手中逃出来，都是差点溺死，算是有惊无险。<br>但是，在我看来，这几件事还不算是最惊险的。因为后来发生的一件事对我来说，可能更恐怖，也更可怕。</p><p>这件事也是发生在小学时候，4年级时有过一次春游，全班同学步行去市区里的某个景点游玩，回来时就地解散各自回家。路过看到一个游戏厅，觉得很好玩，就记住地点了。后来周末的时候跟弟弟骑车去那里玩，由于人太多，1块钱买了10块游戏牌子站在玩的人后面边看边等。这时候突然有个人在背后用带着<code>手套</code>的手蒙住我眼睛，另一个手则捂住我鼻子（不是捂死不让你呼吸的那种）。我的第一反应是，这肯定是某个很熟悉的同学或朋友在搞恶作剧，就没挣扎，心里还在默想这是谁谁谁，结果，没过了一会儿他就放开手了，我回头一看发现是个<code>大人</code>，中年男子，完全不认识，他看我回头，对我笑一笑就立刻出门了。他出门之后我很快就感觉到了<strong>恶心</strong>和<strong>眩晕</strong>，感觉人快要站立不住了，全身乏力。我当时位置正好就在游戏厅靠近出口处的地方，然后我赶紧强打精神进去找弟弟，找到之后让告诉他我不舒服，让他赶紧去拿自行车带我回家。我先出了游戏厅的院子，在大院门口外等他拿自行车来载我回去。很惊奇的是，这一些列抉择在下意识间瞬间就完成了，弟弟顺利拿到自行车载我往回家的路上跑，我在后座不断催促他快点快点再快点，心里一万个恐惧。</p><p>现在想起来，很感叹自己当时的反应。因为当时并没有意识到为什么会感到危险并且迅速逃离现场，也没有多想没有走掉的后果是什么，可能就是一种感觉不对劲，一种莫名的危险感，这种感觉驱使着我去做着那一系列的现在看来绝对是救命的抉择。后来，在很长一段时间内，我也只是认为自己逃离了一次被拐卖的命运，但是有时仔细想想又觉得不太可能，因为我那时候已经不是幼儿，都小学4年级了，认得父母，拐卖我意义不大。直到很多年之后，看到社会上很多的残疾人乞讨，我才意识到这其中的可怕之处。看过社会报道的人应该知道，很多人街头乞讨的残疾人都是被丐头故意弄成残疾的。也是直到这时候，我才真正理解和意识到，我可能是逃过了多么恐怖的一劫。这件事情给我的印象及其深刻，即使这么多年过去了， 我依然能记忆起当时的每一个细节和场景，包括我逃离时坐在自行车后座那恐惧的心理和催促的语气。</p><p>现在，我还是经常会想起这段经历。或许是第六感帮我发现了危险让我作出了成功的应急响应，又或许是某种不可知晓的力量在暗中帮助了我，很难想像如果没有那样的应急，该是多么可怕的一件事，我可能不是现在的我，甚至我可能已经不复存在了。</p><p><img src="http://o8chcdh8l.bkt.clouddn.com/markdown/img/1474003956830.png" alt=""></p><p>全文完！</p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Convertion between int and string values</title>
      <link href="/Programming/go-convertion-int-string/"/>
      <url>/Programming/go-convertion-int-string/</url>
      
        <content type="html"><![CDATA[<p>There a lot of situiations that we need do convertions between int and string types of values in Go, here I list the most common convertion function and method that facilitates the operations.</p><h4 id="int2string"><a href="#int2string" class="headerlink" title="int2string"></a>int2string</h4><p>1、for <strong>int32</strong>, use <code>strconv.Itoa(i)</code><br>2、for <strong>int64</strong> or greater, <code>strconv.FormatInt(intValue, 10)</code></p><p>Note: With FormatInt, we must pass an int64 value.</p><p>e.g. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result := strconv.FormatInt(<span class="keyword">int64</span>(value), <span class="number">10</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="keyword">int64</span>, base <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>3、use <code>fmt.Sprintf()</code> for anything</p><p>Parsing Custom strings</p><p>There is also a handy fmt.Sscanf() which gives even greater flexibility as with the format string you can specify the number format (like width, base etc.) along with additional extra characters in the inputstring.</p><p>This is great for parsing custom strings holding a number. For example if your input is provided in a form of “id:00123” where you have a prefix “id:” and the number is fixed 5 digits, padded with zeros if shorter, this is very easily parsable like this:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"id:00123"</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> _, err := fmt.Sscanf(s, <span class="string">"id:%5d"</span>, &amp;i); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(i) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output: 123</p><h4 id="string2int"><a href="#string2int" class="headerlink" title="string2int"></a>string2int</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag.Parse()</span><br><span class="line">s := flag.Arg(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>(1) use strconv.Atoi()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i, err := strconv.Atoi(s); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"i=%d, type: %T\n"</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) use strconv.ParseInt()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i, err := strconv.ParseInt(s, <span class="number">10</span>, <span class="number">64</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"i=%d, type: %T\n"</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong><br>Argument 2 is the base of the string being parsed. Most numbers we use are base 10.<br>Argument 3 is the bit size of the resulting int. 0 means int, 6 means int16, with 16 bits.</p><p>e.g. 64 tells how many bits of precision to parse</p><p><strong>Prototype:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseUint</span><span class="params">(s <span class="keyword">string</span>, base <span class="keyword">int</span>, bitSize <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">uint64</span>, error)</span></span></span><br></pre></td></tr></table></figure><p><strong>also:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strconv.ParseFloat()</span><br></pre></td></tr></table></figure><p>(3) use fmt.Sscan()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> _, err := fmt.Sscan(s, &amp;i); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"i=%d, type: %T\n"</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Output:</strong><br>i=123, type: int<br>i=123, type: int64<br>i=123, type: int</p><p><strong>Reference</strong><br><a href="http://stackoverflow.com/questions/4278430/convert-string-to-integer-type-in-go" target="_blank" rel="noopener">http://stackoverflow.com/questions/4278430/convert-string-to-integer-type-in-go</a><br><a href="https://golang.org/pkg/strconv/#FormatInt" target="_blank" rel="noopener">https://golang.org/pkg/strconv/#FormatInt</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Use sizeof in Go</title>
      <link href="/Programming/go-go-sizeof/"/>
      <url>/Programming/go-go-sizeof/</url>
      
        <content type="html"><![CDATA[<p>Go 语言虽然作为一个编译型语言，但是它却没有提供类似 C/C++ 中那样的 sizeof 关键字来查看某个类型变量的所占内存空间的大小。不过，Go 标准库提供了一个 unsafe 包，这个包提供一个 Sizeof() 函数，我们可以使用这个函数来获得一个类型所占内存大小。unsafe 包中只有一个文件 unsafe.go，这个文件中只声明了 5 个函数，而这五个函数的实现都是用汇编代码实现的。</p><p><strong>提示：</strong> 如果要在实际项目中使用 unsafe 包，需要非常谨慎，因为使用 unsafe 包之后可能会导致代码失去平台兼容性。</p><p>unsafe.go 中的内容:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArbitraryType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Offsetof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Sizeof</span><span class="params">(x ArbitraryType)</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">ArbitraryType</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">Pointer</span></span></span><br></pre></td></tr></table></figure><p>写一个程序来测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">    B      []<span class="keyword">byte</span></span><br><span class="line">    Title  <span class="keyword">string</span></span><br><span class="line">    I32    <span class="keyword">int32</span></span><br><span class="line">    I64    <span class="keyword">int64</span></span><br><span class="line">    I      <span class="keyword">int</span></span><br><span class="line">    IsBool <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Entity <span class="keyword">interface</span> &#123;</span><br><span class="line">    Print()</span><br><span class="line">    Info() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ent Entity</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSize</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pst Post</span><br><span class="line">    fmt.Println(<span class="string">"sizeof struct: "</span>, unsafe.Sizeof(pst))</span><br><span class="line">    fmt.Println(<span class="string">"sizeof byte: "</span>, unsafe.Sizeof(pst.B))</span><br><span class="line">    fmt.Println(<span class="string">"sizeof string: "</span>, unsafe.Sizeof(pst.Title))</span><br><span class="line">    fmt.Println(<span class="string">"sizeof int32: "</span>, unsafe.Sizeof(pst.I32))</span><br><span class="line">    fmt.Println(<span class="string">"sizeof int64: "</span>, unsafe.Sizeof(pst.I64))</span><br><span class="line">    fmt.Println(<span class="string">"sizeof int: "</span>, unsafe.Sizeof(pst.I))</span><br><span class="line">    fmt.Println(<span class="string">"sizeof bool: "</span>, unsafe.Sizeof(pst.IsBool))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testEntity</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"sizeof entity: "</span>, unsafe.Sizeof(ent))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testInterface</span><span class="params">(in <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"sizeof interface&#123;&#125;: "</span>, unsafe.Sizeof(in))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">    fmt.Println(<span class="string">"sizeof map: "</span>, unsafe.Sizeof(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    testSize()</span><br><span class="line">    testMap()</span><br><span class="line">    testInterface(<span class="number">1</span>)</span><br><span class="line">    testInterface(<span class="keyword">int64</span>(<span class="number">1</span>))</span><br><span class="line">    testEntity()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>sizeof struct:  72<br>sizeof byte:  24<br>sizeof string:  16<br>sizeof int32:  4<br>sizeof int64:  8<br>sizeof int:  8<br>sizeof bool:  1<br>sizeof map:  8<br>sizeof interface{}:  16<br>sizeof interface{}:  16<br>sizeof entity:  16</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Type Alias in Go</title>
      <link href="/Programming/go-go-type-alias/"/>
      <url>/Programming/go-go-type-alias/</url>
      
        <content type="html"><![CDATA[<p>在 Go 语言中，可以为一个已有的类型指定一个别名，其语法格式是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myint <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>这样就把 myint 定义为了 int 类型的一个别名。需要注意的是，一旦定义了一个类型别名，它与原有的类型就是完全两个类型。<br>由于 Go 语言中禁止类型的自动隐式转换，因此，别名和原类型之间不能相互赋值比较等等操作，需要显示类型转换才可以使用。<br>比如，在做参数传递时，如果类型不匹配，将会提示编译错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myint <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a myint = <span class="number">9</span></span><br><span class="line">    test(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码在编译时报错，提示: <span class="red">cannot use a (type myint) as type int in argument to test</span></p><p>因此，需要显示类型转换，<code>test(int(a))</code>。</p><p>需要注意：如果是 map 类型的话，则不需要做显示转换。见下述例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> columnmap <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testmap</span><span class="params">(field_map <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"field_map: "</span>, field_map)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> myfs columnmap = columnmap&#123;</span><br><span class="line">        <span class="string">"user_message_t"</span>: []<span class="keyword">string</span>&#123;<span class="string">"name"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    testmap(myfs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>field_map:  map[user_message_t:[name]]</p></blockquote><p>可见，可以编译通过，并且运行正确。</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mastering Go interface</title>
      <link href="/Programming/go-interface-notes/"/>
      <url>/Programming/go-interface-notes/</url>
      
        <content type="html"><![CDATA[<p>interface 类型在 Go 语言中是一个核心类型，用途及其广泛，本文列举其中最主要的使用场景，详述其使用方式，从而掌握使用它的精髓。</p><br>#### 1. interface 接口类型做参数---<p>想要函数对任何类型都能处理，并且处理后返回，可以把参数设置成接收 duck type，然后通过参数返回。<br>传入的实参为指针类型的对象，也即相应的 对象 通过 pointer receiver 来实现 type Entity interface {} 中指定的方法。<br>或者，可以通过 把 duck type 通过返回值传出，然后调用方通过 type assertion 来得到具体的类型。</p><p><strong>(1) interface declaration</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Entity <span class="keyword">interface</span> &#123;</span><br><span class="line">    Clone() Entity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) interface as function return value</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clone</span><span class="params">(ent Entity)</span> <span class="title">Entity</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ent.Clone()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The structs that implements the interface</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    Sex <span class="keyword">string</span></span><br><span class="line">    Ct  *Creature</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Creature <span class="keyword">struct</span> &#123;</span><br><span class="line">    Category <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Human)</span> <span class="title">Clone</span><span class="params">()</span> <span class="title">Entity</span></span> &#123;   <span class="comment">// 注意：这里的返回值需要是 Entity 而不能是 *Human，否则不匹配(1) 中的 Entity 的 interface 定义。</span></span><br><span class="line">    p := &amp;Human&#123;&#125;</span><br><span class="line">    p.Sex = this.Sex</span><br><span class="line">    p.Ct = this.Ct.Clone()</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    hm := &amp;Human&#123;Sex: <span class="string">"Male"</span>, Ct: &amp;Creature&#123;Category: <span class="string">"Mammal"</span>&#125;&#125;</span><br><span class="line">    tmp := clone(hm)</span><br><span class="line">    hm1, ok := tmp.(*Human)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Failed: hm1 is not a human pointer!"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"OK: hm1 is a human pointer!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(reflect.TypeOf(hm1))</span><br><span class="line">    fmt.Println(hm1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>#### 2. Pointer Receiver---<p>Note that we use a pointer receiver to implement the function, if we do not use pointer receiver to implement the interface declared function,<br>when it is passed as a ducktype argument in function, we won’t be able to modify the instance.</p><p>e.g.</p><p><img src="/image/c508e413-b133-4203-83f5-198f4082a039.png" alt=""></p><p>Output:<br>{1}<br>{1} </p><p>As shown above, the modification of sch in change() function will not take effect!.</p><p>ponter receiver 使用要点：<br>如果 struct 的成员函数需要修改对应对象的字段，必须设置 pointer receiver！</p><p>比如：<br><img src="/image/e6243b42-823b-4e6b-b88e-7bed734ebe6d.png" alt=""></p><p>其他情况下，只要不涉及到 struct 成员变量的修改，并且不是 duck type 的实现，可以互用。</p><p>但是注意：<br>如果定义一个 duck type，那么用如果用 pointer receiver 实现其中的方法的话，只有指针类型是该 duck type 类型，value 类型则不是 duck type。 </p><p>注意：<br>只要函数实现的地方使用了 pinter receiver 去实现，那么调用的地方，用对象的指针去调用，和用对象去调该函数，效果一样。</p><p>比如：</p><p><img src="/image/f8ea3060-5aee-44ce-b701-ee8df1ca7493.png" alt=""> <img src="/image/3617949d-9e43-4e33-91e7-082cb5efa789.png" alt=""> </p><ol start="3"><li>把 interface 接口 作为 struct 成员，即可以是匿名成员，也可以是实名成员。<br><img src="/image/f2977be3-55f4-40e4-83cc-651bc95fbc67.png" alt=""> <img src="/image/f8a90d9e-3358-4c7f-9d7b-36bd2b2110bf.png" alt=""></li></ol><br>#### 3. 接口类型数组---<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entity <span class="keyword">interface</span> &#123;</span><br><span class="line">    Print(<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Identity <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(person Person)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    person.Name = person.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iden Identity)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    iden.Title = iden.Title</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_slice</span><span class="params">(ents []entity)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> ents &#123;</span><br><span class="line">        v.Print()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    per := <span class="built_in">new</span>(Person)</span><br><span class="line">    id := Identity&#123;<span class="string">"Boss"</span>&#125;</span><br><span class="line">    ss := []entity&#123;per, per1&#125;</span><br><span class="line">    test_slice(ss)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-json-编解码-entity-类型"><a href="#4-json-编解码-entity-类型" class="headerlink" title="4. json 编解码 entity 类型"></a>4. json 编解码 entity 类型</h4>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Understand interface{}</title>
      <link href="/Programming/go-interface-principle/"/>
      <url>/Programming/go-interface-principle/</url>
      
        <content type="html"><![CDATA[<br>##### 简介---Go 语言中的 interface 关键字可以用来定义一个接口类型，里面声明一些方法，也可以当做任意类型，那么 interface 类型的底层是怎么实现的呢？ 其实早在 2009 年，Russ Cox 就写过一篇[文章][] 来解释 interface 类型的值在 Go 语言中底层是如何描述的。<p>那篇文章虽然非常经典，但是看完之后可能还是不够过瘾。因此，这篇文章将会试图从源码的层面来抽丝剥茧，解析 interface 在底层到底是如何实现和运作的。</p><p>实际上，一个interface 类型的变量底层用了一个 struct 来存储了一对 (type, value) ，变量的类型会赋给 type，而具体的变量的值则会赋给value，<br>这样的话，这个 interface{} 类型的变量就保存了原始类型的完整信息。</p><p>通过查看源码声明（如下）会发现 inteface 底层用了一个 interface header，用一个结构体来保存这个对象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ifaceWords is interface&#123;&#125; internal representation.</span></span><br><span class="line"><span class="keyword">type</span> ifaceWords <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ  unsafe.Pointer</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见是两个指针成员，一个指向类型，一个指向实体。</p><p>由于 Pointer 是 uintptr 类型，在 64 位机器上是 8 字节大小，所以，当把一个 int 类型的值传递给一个接受 interface{} 类型的函数做参数时，内存空间会增加一倍。</p><p>提示：在 Go 语言中，[]byte 默认是 24 字节大小, string 16 字节大小。</p><br>##### 如何 indirect （解引用）一个 interface{} 类型 ?---<p>首先拿到它的 reflect.value， 我们设为 v<br>判断 v 是否是指针类型？ 是否一个 named type：<br>If v is a named type and is <strong>addressable</strong>，(也即 v.CanAddr()) start with its address, so that if the type has pointer methods。</p><p>解释一下什么叫做 <strong>addressable</strong>， addressable 的意思就是这个 value 是可以寻址的，<br>也就是说要解析的这个值必须是这个值本身，而不是它的一个拷贝，或者一个临时变量。<br>比如： 在作为函数参数传递时，如果传递的是值传递， 而不是指针，或者传了个临时变量， 那么 就不是 addressable 的了。<br>这个特点有点类似于 <strong>settable</strong> 这个特性。 如果是传了一个 拷贝，那么也不是settable 的， 必须传指针才行。<br><strong>Settability is a bit like addressability, but stricter</strong>. 而且，<strong>只有 struct 的 field 是大写，exported， 这个field才是 settable的。</strong></p><p>var x float64 = 3.4<br>p := reflect.ValueOf(&amp;x) // Note: take the address of x.<br>fmt.Println(“type of p:”, p.Type())<br>p 本身不是 settable 的， 因为 p 是一个指向实际对象的指针， p 指向的对象才是 settable 的。<br>To get to what p points to, we call the Elem method of Value, which indirects through the pointer, and save the result in a reflection Value called v:<br>v := p.Elem()<br>fmt.Println(“settability of v:”, v.CanSet())</p><p>如果是一个 named type， 那么我们就取得它的地址： v = v.Addr()</p><p>因为要 set 这个 named type 的值， 所以我们需要取得该指针指向的真实对象： v = v.Elem()</p><p>我们还需要递归解析 v 的值， </p><br><br><br><h6 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h6><hr><p><a href="http://shanks.leanote.com/post/Untitled-55ca439338f41148cd000759-17" target="_blank" rel="noopener">http://shanks.leanote.com/post/Untitled-55ca439338f41148cd000759-17</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器端编程模型（6）—— Reactor 模式（基于 epoll 的反应堆）</title>
      <link href="/Programming/network-programming-server-mode6/"/>
      <url>/Programming/network-programming-server-mode6/</url>
      
        <content type="html"><![CDATA[<h5 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h5><p>上一篇文章介绍了一个简单的基于 epoll 的反应堆的实现，详述了其工作过程。这一篇文章继续<br>探讨反应堆的设计。</p><p>首先，先来回顾一下 Reactor 的使用方式：<br>注册事件（为需要监听的 fd 加入回调函数）—–&gt; 将事件加入反应堆 ——&gt; 开始事件循环 ——&gt; 事件发生，调用回调函数。</p><p>第一次加入的描述符可以为监听描述符，即由 socket() 函数创建，当这个描述符有事件发生，意味着有新的连接的到来，调用回调函数handler_accept() 其中这个函数里面涉及到调用 accept()系统调用和为这个新连接分配实例，然后设置这个连接的回调函数，即 handler_read() handler_write() 等，设置完后相应的连接描述符如果有事件发生，即可以调用相应的不同种事件的回调函数。这个是我们的总体思路，如果需要多进程方式，可以创建多进程，然后每个进程不同的反应堆，但是需要注意的是，如果父子进程共享监听描述符，会引起进程组的惊群现象，就是说，每一个进程都可能会尝试 accept() 这个新的连接，那么这种方式设计的时候需要为 accept() 加锁，具体方式可以看Nginx关于这方面的设计，不仅实现了 accept() 锁，还达到了进程间的负债均衡。<br>关于连接对象池，可以下次写一篇博文介绍一下对象池的设计方式。</p><p>言归正传，说说反应堆的设计方式，如果需要方便的话，可以使用libevent..memcached的网络模块就是基于这个，相信大家也知道。<br>从上上篇关于 epoll 的介绍中就可以看到，事件是整个系统设计的核心，我们的整个反应堆都是围绕一个叫做事件的东西来做相应的处理。<br>那么，作为应用层的事件，可以这么说来，就是那个地方发生了某件事情，而这个事情是在我们的规定范围的，然后，我们需要知道这个事件给予了我们什么样的权利，比如说，我们可以读，可以写，可以操作等等.<br>（下面不加说明，都是以 epoll 为例 ）<br>操作系统为我们提供的接口也是类似的操作<br>创建一个 epoll —–&gt; 注册相应的事件 epoll_ctl() —–&gt; 进入事件循环监听事件（可能超时返回 ）epoll_wait() —–&gt;返回事件 (event_list[i].event &amp;&amp; EPOLLIN)等<br>我们需要做的事情就是，为这个流程的事件做一个封装，并能够有效的管理整个事件，而不是离散的处理。</p><p>看看 event的封装：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mc_event_s</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mc_event_s</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mc_event_s</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> min_heap_index;</span><br><span class="line">    <span class="keyword">int</span> ev_fd;                      <span class="comment">// file des of event</span></span><br><span class="line">    <span class="keyword">short</span> revent;                   <span class="comment">// event type</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>  <span class="title">ev_timeval</span>;</span>     <span class="comment">// event timeout time</span></span><br><span class="line">    mc_ev_callback callback;        <span class="comment">// callback of this event</span></span><br><span class="line">    <span class="keyword">void</span>  *args;</span><br><span class="line">    <span class="keyword">int</span> ev_flags;</span><br><span class="line">    <span class="keyword">mc_event_base_t</span> *base;</span><br><span class="line">&#125; <span class="keyword">mc_event_t</span>;</span><br></pre></td></tr></table></figure><p>两个指针分别指向事件的前部和后部，标准的双向队列方式，没什么可说的。<br>min_heap_index 是作为超时管理的最小堆的下标，目前还没有最这方面的设计，可以先忽略。<br>ev_fd 是作为这个事件的描述符本身， callback 是注册在事件上的回调函数， ev_flags 是事件的状态，由宏定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_EV_INITD    0x0001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_EV_ADDED    0x0002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_EV_ACTIVE   0x0004</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_EV_DELED    0x0008</span></span><br></pre></td></tr></table></figure><p>状态分为 是否初始化，是否加入了队列，是否加入了激活的队列，已删除。<br>这里注意的是事件分为两个队列，一个是已加入的，另一个是激活的。我们在处理的时候会将accept()返回的时间加入到已加入的队列，当有事件发生，将这个事件加入到激活的事件队列中，然后依次轮训处理每一个激活的事件。<br>整个反应堆需要一个控制块，也就是反应堆的实例，结构是像这样:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mc_event_base_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *added_list;</span><br><span class="line">    <span class="keyword">void</span> *active_list;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> event_num;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> event_active_num;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// mc_minheap  minheap;</span></span><br><span class="line">    <span class="keyword">int</span> epoll_fd;                   <span class="comment">//for epoll only</span></span><br><span class="line">    <span class="keyword">int</span> ev_base_stop;</span><br><span class="line">    <span class="keyword">int</span> magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>  <span class="title">event_time</span>;</span>  </span><br><span class="line">&#125; <span class="keyword">mc_event_base_t</span>;</span><br></pre></td></tr></table></figure><p>可以看到，反应堆中维护了两个队列， added_list 和 active_list 为的是能够有效控制所有的事件。<br>event_num是事件个数， event_active_num 是已激活的事件个数<br>epoll_fd 是由epoll_create()创建的句柄，这里没有加入宏定义来区分是否操作系统有 epoll<br>可以这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (HAVE_EPOLL)</span></span><br><span class="line">    <span class="keyword">int</span>   epoll_fd;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>不同的IO多路复用方式不同，操作句柄也不一样。<br>ev_base_stop是用来判断是否停止的标志位， magic 被定义为一个宏：</p><p>#define MC_BASE_MAGIC  0x1989<br>用来判断整个反应堆是否初始化。</p><p>为事件的封装提供了几种操作，初始化，加入队列，删除事件，改变事件类型，循环监听事件。　　<br>然后将struct mc_event_ops 中的函数指针与实际的操作分开，类似于HOOK 方式，这样做的目的是为不同的底层IO多路复用提供了统一的接口，如 select(),epoll(),kqueue()等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">mc_event_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>* (*init)(<span class="keyword">mc_event_base_t</span> *);</span><br><span class="line">    <span class="keyword">int</span> (*add)(<span class="keyword">void</span> *, <span class="keyword">mc_event_t</span> *);</span><br><span class="line">    <span class="keyword">int</span> (*del)(<span class="keyword">void</span> *, <span class="keyword">mc_event_t</span> *);</span><br><span class="line">    <span class="keyword">int</span> (*mod)(<span class="keyword">void</span> *, <span class="keyword">mc_event_t</span> *);</span><br><span class="line">    <span class="keyword">int</span> (*dispatch)(<span class="keyword">void</span> *, <span class="keyword">mc_event_base_t</span> *,struct timeval);</span><br><span class="line">&#125; mc_event_opt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Functions point of events option</span></span><br><span class="line"><span class="comment"> * there points will point to a instance of function</span></span><br><span class="line"><span class="comment"> * and other module call there function by ops instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> mc_event_opt mc_event_op_val;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mc_event_ini  mc_event_op_val.init</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mc_event_add  mc_event_op_val.add</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mc_event_del  mc_event_op_val.del</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mc_event_mod  mc_event_op_val.mod</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mc_event_loop mc_event_op_val.dispatch</span></span><br></pre></td></tr></table></figure><p>看看实际的操作事件方式，我们为这几个操作添加了epoll 的钩子，具体是下面这样：<br>对应mc_event_ops的第一个钩子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mc_epoll_init</span><span class="params">(<span class="keyword">mc_event_base_t</span> *meb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(meb-&gt;magic != MC_BASE_MAGIC)    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"In function mc_epoll_init %d, %s "</span>,__LINE__,__FILE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    meb-&gt;epoll_fd = epoll_create(MC_EVENT_MAX);</span><br><span class="line">    <span class="keyword">return</span> meb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式很简单，调用 epoll_create() 创建一个 epoll 实例，并把这个实例的句柄赋给反应堆。<br>第二个加入，对应mc_event_ops的第二个钩子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mc_epoll_add</span><span class="params">(<span class="keyword">void</span> * arg,<span class="keyword">mc_event_t</span> *ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;base-&gt;magic != MC_BASE_MAGIC)  &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"In function mc_epoll_add %d, %s "</span>,__LINE__,__FILE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mc_event_base_t</span> *base = ev-&gt;base;</span><br><span class="line">    <span class="keyword">int</span> epoll_fd = base-&gt;epoll_fd;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epoll_ev</span> ;</span> </span><br><span class="line">    epoll_ev.data.ptr = ev;</span><br><span class="line">    epoll_ev.events = EPOLLIN|EPOLLET;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(!(ev-&gt;ev_flags &amp; MC_EV_ADDED)) &#123;</span><br><span class="line">        err = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, ev-&gt;ev_fd, &amp;epoll_ev);</span><br><span class="line">        <span class="keyword">if</span>(err != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"epoll_ctl"</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"In function mc_epoll_add the epoll_ctl error in file:%s,line:%d\n"</span>,__FILE__,__LINE__);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ev-&gt;ev_flags |=  MC_EV_ADDED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体来说是调用了 epoll_ctl 并设置宏为 EPOLL_CTL_ADD然后设置事件类型<br>第三个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mc_epoll_del</span><span class="params">(<span class="keyword">void</span> * arg,<span class="keyword">mc_event_t</span> *ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;base-&gt;magic != MC_BASE_MAGIC) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"In function mc_epoll_add %d, %s "</span>,__LINE__,__FILE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mc_event_base_t</span> *base = ev-&gt;base;</span><br><span class="line">    <span class="keyword">int</span> epoll_fd = base-&gt;epoll_fd;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(!(ev-&gt;ev_flags &amp; MC_EV_INITD)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    err = epoll_ctl(epoll_fd, EPOLL_CTL_DEL, ev-&gt;ev_fd, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(err != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"In function mc_epoll_del the epoll_ctl error in file:%s,line:%d\n"</span>,__FILE__,__LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ev-&gt;ev_flags = <span class="number">0x0000</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mc_epoll_mod</span><span class="params">(<span class="keyword">void</span> * arg,<span class="keyword">mc_event_t</span> *ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;base-&gt;magic != MC_BASE_MAGIC) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"In function mc_epoll_mod %d, %s "</span>,__LINE__,__FILE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mc_event_base_t</span> *base = ev-&gt;base;</span><br><span class="line">    <span class="keyword">int</span> epoll_fd = base-&gt;epoll_fd;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mode;</span><br><span class="line">    <span class="keyword">if</span>(!(ev-&gt;ev_flags &amp; MC_EV_INITD)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epoll_ev</span> ;</span>     </span><br><span class="line">    epoll_ev.data.ptr = ev;</span><br><span class="line">    <span class="keyword">if</span>(arg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mode = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)arg;</span><br><span class="line">    epoll_ev.events = mode;</span><br><span class="line">    err = epoll_ctl(epoll_fd, EPOLL_CTL_MOD, ev-&gt;ev_fd, &amp;epoll_ev);</span><br><span class="line">    <span class="keyword">if</span>(err != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"In function mc_epoll_del the epoll_ctl error in file:%s,line:%d\n"</span>,__FILE__,__LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五个钩子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">mc_epoll_loop</span><span class="params">(<span class="keyword">void</span> * args, <span class="keyword">mc_event_base_t</span> *base, struct timeval ev_time)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"base == NULL  in mc_epoll_loop in file:%s,line:%d\n"</span>,__FILE__,__LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(base-&gt;magic != MC_BASE_MAGIC) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"In function mc_epoll_mod %d, %s "</span>,__LINE__,__FILE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">int</span> nfds;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* we pass args as nevents in this function */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">nevents</span> = (<span class="title">struct</span> <span class="title">epoll_event</span> *)<span class="title">args</span>;</span></span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epoll_ev</span> ;</span> </span><br><span class="line">    nfds = epoll_wait( base-&gt;epoll_fd, nevents, MC_EVENT_MAX, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(nfds &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"epoll wait function in mc_epoll_loop in file:%s,line:%d\n"</span>,__FILE__,__LINE__);</span><br><span class="line">        <span class="keyword">return</span> nfds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nfds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现方式具体可以看相应的代码。文章有点长了，很多代码就不贴出来了。<br>然后看看最后的一开始提到的几个操作：</p><p>注册事件（为需要监听的fd加入回调函数）—–&gt;将事件加入反应堆——&gt;开始事件循环——&gt;事件发生，调用回调函数<br><a href="http://www.cnblogs.com/Bozh/archive/2012/04/26/2471106.html#" target="_blank" rel="noopener">+ View Code</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mc_event_base_t</span> * mc_base_new(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">mc_event_base_t</span> * base = (<span class="keyword">mc_event_base_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">mc_event_base_t</span>));</span><br><span class="line">    <span class="keyword">if</span>(base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Init the base moudle in mc_base_new error in file:%s,line:%d\n"</span>,__FILE__,__LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// init the base lists</span></span><br><span class="line">    base-&gt;added_list = <span class="literal">NULL</span>;</span><br><span class="line">    base-&gt;active_list = <span class="literal">NULL</span>;</span><br><span class="line">    base-&gt;magic = MC_BASE_MAGIC;</span><br><span class="line">    base-&gt;event_num = <span class="number">0</span>;</span><br><span class="line">    base-&gt;event_active_num = <span class="number">0</span>;</span><br><span class="line">    base-&gt;ev_base_stop = MC_BASE_STOP;</span><br><span class="line">    base-&gt;magic = MC_BASE_MAGIC;</span><br><span class="line">    gettimeofday(&amp;base-&gt;event_time,<span class="literal">NULL</span>);</span><br><span class="line">    mc_event_ini(base);</span><br><span class="line">    <span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mc_event_set</span><span class="params">(<span class="keyword">mc_event_t</span> *ev, <span class="keyword">short</span> revent, <span class="keyword">int</span> fd, mc_ev_callback callback, <span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">" mc_event_set error, ev == NULL or other segment error in file:%s,line:%d\n"</span>,__FILE__,__LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> (HAVE_EPOLL)   </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> epoll_flag;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="built_in">memset</span>(ev,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">mc_event_t</span>));</span><br><span class="line">    ev-&gt;revent = revent;</span><br><span class="line">    ev-&gt;ev_fd     = fd  ;</span><br><span class="line">    ev-&gt;callback = callback;</span><br><span class="line">    ev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ev-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(args == <span class="literal">NULL</span>)</span><br><span class="line">        ev-&gt;args = <span class="literal">NULL</span> ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ev-&gt;args = args ;  </span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* This job post to mc_event_post</span></span><br><span class="line"><span class="comment">     *if(revent &amp; MC_EV_LISTEN)</span></span><br><span class="line"><span class="comment">     *&#123;</span></span><br><span class="line"><span class="comment">     *  err = mc_event_add(NULL, ev);</span></span><br><span class="line"><span class="comment">     *  if(err != 0)</span></span><br><span class="line"><span class="comment">     *      fprintf(stderr,"mc_event_add in mc_event_set \n");</span></span><br><span class="line"><span class="comment">     *&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* event should post to base */</span></span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;base == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> (HAVE_EPOLL)</span></span><br><span class="line">        <span class="keyword">if</span>(revent &amp; MC_EV_READ) &#123;</span><br><span class="line">            epoll_flag = EPOLLIN|EPOLLET;</span><br><span class="line">         </span><br><span class="line">            err = mc_event_mod((<span class="keyword">void</span> *)&amp;epoll_flag, ev);</span><br><span class="line">            <span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"mc_event_mod (MC_EVENT_READ) in mc_event_set in file:%s,line:%d\n"</span>,__FILE__,__LINE__);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span>(revent &amp; MC_EV_WRITE) &#123;</span><br><span class="line">            epoll_flag = EPOLLOUT|EPOLLET;</span><br><span class="line">            err = mc_event_mod((<span class="keyword">void</span> *)&amp;epoll_flag,ev);</span><br><span class="line">            <span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"mc_event_mod (MC_EVENT_WRITE) in mc_event_set in file:%s,line:%d\n"</span>,__FILE__,__LINE__);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        ev-&gt;ev_flags |= MC_EV_INITD ;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mc_event_post</span><span class="params">(<span class="keyword">mc_event_t</span> *ev, <span class="keyword">mc_event_base_t</span> * base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev == <span class="literal">NULL</span> || base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">" In function mc_event_post, the args error, please check your arguments in file:%s,line:%d\n"</span>,__FILE__,__LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(base-&gt;magic != MC_BASE_MAGIC) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"The mc_event_base_t * points base non inited in mc_event_post in file:%s,line:%d\n"</span>,__FILE__,__LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    ev-&gt;base = base;</span><br><span class="line">    add_event_to_queue(ev,(<span class="keyword">mc_event_t</span> **)&amp;(base-&gt;added_list));</span><br><span class="line">    base-&gt;event_num++;</span><br><span class="line">     </span><br><span class="line">    err = mc_event_add(<span class="literal">NULL</span>, ev);</span><br><span class="line">    <span class="keyword">if</span>(err == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"In function mc_event_add error in file:%s,line:%d\n"</span>,__FILE__,__LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mc_dispatch</span><span class="params">(<span class="keyword">mc_event_base_t</span> * base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"base == NULL in function mc_dispatch in file:%s,line:%d\n"</span>,__FILE__,__LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(base-&gt;magic != MC_BASE_MAGIC) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"In function mc_disptahch noinitlized line:%d, in file:%s "</span>,__LINE__,__FILE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">nevents</span> = (<span class="title">struct</span> <span class="title">epoll_event</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">epoll_event</span>));</span></span><br><span class="line">    <span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">int</span> nevent;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">mc_event_t</span> *levent;</span><br><span class="line">    <span class="keyword">mc_event_t</span> *retevent;</span><br><span class="line">    <span class="keyword">while</span>(!done) &#123;</span><br><span class="line">        nevent = mc_event_loop(nevents, base, base-&gt;event_time);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(nevent == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"No event check, return in file:%s line:%d \n"</span>,__FILE__,__LINE__);</span><br><span class="line">            <span class="keyword">goto</span> err1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nevent; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nevents[i].events &amp; EPOLLERR || nevents[i].events &amp; EPOLLHUP)  &#123;</span><br><span class="line">                levent = nevents[i].data.ptr;</span><br><span class="line">                <span class="keyword">if</span>(!(levent-&gt;ev_flags &amp; MC_EV_INITD))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>((levent-&gt;ev_flags &amp; MC_EV_ACTIVE) || (levent-&gt;ev_flags &amp; MC_EV_ADDED))</span><br><span class="line">                    del_event_from_queue(levent);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nevents[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">                levent = nevents[i].data.ptr;</span><br><span class="line">                levent-&gt;revent = MC_EV_READ ;</span><br><span class="line">                add_event_to_queue(levent, (<span class="keyword">mc_event_t</span> **)&amp;(base-&gt;active_list)); </span><br><span class="line">                levent-&gt;ev_flags |=  MC_EV_ACTIVE; </span><br><span class="line">                base-&gt;event_active_num++;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nevents[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                levent = nevents[i].data.ptr;</span><br><span class="line">                levent-&gt;revent = MC_EV_WRITE;</span><br><span class="line">                add_event_to_queue(levent, (<span class="keyword">mc_event_t</span> **)&amp;(base-&gt;active_list)); </span><br><span class="line">                levent-&gt;ev_flags |=  MC_EV_ACTIVE; </span><br><span class="line">                base-&gt;event_active_num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Unknow err in file:%s,line:%d\n"</span>,__FILE__,__LINE__);</span><br><span class="line">                <span class="keyword">goto</span> err1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        retevent  = (<span class="keyword">mc_event_t</span> *)(base-&gt;active_list);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; nevent; i++) &#123;  </span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">" %d event(s)\n"</span>,nevent);</span><br><span class="line">            <span class="keyword">if</span>(retevent == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">         </span><br><span class="line">            retevent = get_event_and_del((<span class="keyword">mc_event_t</span> *)(base-&gt;active_list));</span><br><span class="line">            <span class="comment">/* If we want to reuse this event we should set event again */</span></span><br><span class="line">            retevent-&gt;ev_flags = retevent-&gt;ev_flags&amp;(~MC_EV_ACTIVE);</span><br><span class="line">            base-&gt;event_active_num--;</span><br><span class="line">            <span class="keyword">if</span>(retevent == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"event is NULL file:%s,line:%d\n"</span>,__FILE__,__LINE__);   </span><br><span class="line">     </span><br><span class="line">            retevent-&gt;callback(retevent-&gt;ev_fd,retevent-&gt;revent,retevent-&gt;args);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    err1:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 dispatch函数中，我们的每一次 epoll 返回后都会轮训 active 事件列表，然后调用事件相应的回调函数。</p><p>附上一开头所说的一些宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_EPOLL     1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_EV_READ     0x0001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_EV_WRITE    0x0002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_EV_SIGNAL   0x0004</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_EV_TIMEOUT  0x0008</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_EV_LISTEN   0x0010</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* the ev_flags value  in mc_event_s */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_EV_INITD    0x0001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_EV_ADDED    0x0002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_EV_ACTIVE   0x0004</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_EV_DELED    0x0008   </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_BASE_STOP   0x0000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_BASE_ACTIVE 0x0001</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_BASE_MAGIC  0x1989</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_EVENT_MAX   10240</span></span><br></pre></td></tr></table></figure><p>总结：这篇文章不是那么的完善，涉及的内容太多，希望大家谅解，后续会有更新。<br>贴出了反应堆的设计方式和简单的思路，仅供参考。系列文章服务器端的模型就到这里。后续可能会写关于在这个模型上不同的知名的软件的设计方式，比如说 libevent的，apache ，Nginx 等。　　</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器端编程模型（5）—— 反应堆模式（基于epoll的反应堆）</title>
      <link href="/Programming/network-programming-server-mode5/"/>
      <url>/Programming/network-programming-server-mode5/</url>
      
        <content type="html"><![CDATA[<p>引言：前面一章简单介绍了关于epoll 的使用方式，这一章介绍一下一个简单的反应堆模型，没有实现超时机制的管理。最主要的是要介绍一下关于异步事件反应堆的设计方式。</p><p>反应堆的模型图在上一张可以看到，但是那张图是盗来的，展示的是 twisted 的反应堆。今天给不熟悉这个部分的朋友介绍一下基于 epoll 的反应堆，过程类似于 libevent。</p><p>反应堆可以提供几个操作：</p><p>（0）创建一个反应堆：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mc_event_base_t</span> * mc_base_new(<span class="keyword">void</span>) ;</span><br></pre></td></tr></table></figure><p>返回一个操作句柄.　　</p><p>（1）为某一个需要监听的文件描述符加入回调函数，并注册事件类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mc_event_set</span><span class="params">( <span class="keyword">mc_event_t</span> *ev , <span class="keyword">short</span> revent , <span class="keyword">int</span> fd , mc_ev_callback callback , <span class="keyword">void</span> *args )</span>  </span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initialize a event , add callback and event type</span></span><br><span class="line"><span class="comment"> * if the event exists , this function will change the mode of this event</span></span><br><span class="line"><span class="comment"> * and fd</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>这里的 revent 由宏定义为几种类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_EV_READ     0x0001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_EV_WRITE    0x0002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_EV_SIGNAL   0x0004</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_EV_TIMEOUT  0x0008</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MC_EV_LISTEN   0x0010</span></span><br></pre></td></tr></table></figure><p>相应的操作可以使用 | 运算来并几个需要监听的事件类型。<br>事件类型定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mc_event_s</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mc_event_s</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mc_event_s</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">int</span> ev_fd;                  <span class="comment">// file des of event</span></span><br><span class="line">    <span class="keyword">short</span> revent;               <span class="comment">// event type</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>;</span>             <span class="comment">// event timeout time</span></span><br><span class="line">    mc_ev_callback callback;    <span class="comment">// callback of this event</span></span><br><span class="line">    <span class="keyword">void</span>  *;</span><br><span class="line">    <span class="keyword">int</span> ev_flags;</span><br><span class="line">    <span class="keyword">mc_event_base_t</span> *base;</span><br><span class="line">&#125; <span class="keyword">mc_event_t</span> ;</span><br></pre></td></tr></table></figure><p>事件结构本身后面解释。　</p><p>（2）将需要监听的并且已经初始化的事件加入反应堆。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mc_event_post</span><span class="params">( <span class="keyword">mc_event_t</span> *ev , <span class="keyword">mc_event_base_t</span> * base )</span> </span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Post this event to event_base</span></span><br><span class="line"><span class="comment"> * struct base has two queue , active queue and added queue</span></span><br><span class="line"><span class="comment"> * this function will post event to added queue , but not in active queue</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>将刚才注册了事件类型和回调函数的事件加入 base， 即将其看做一个反应堆。</p><p>（3）最后提供了一个 dispatch 函数，反应堆开始循环，等待事件的发生。如果对应的 fd 上的事件发生，调用相应的回调函数。由第一步注册。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mc_dispatch</span><span class="params">( <span class="keyword">mc_event_base_t</span> * base )</span> </span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * start loop</span></span><br><span class="line"><span class="comment"> * and dispatch event by</span></span><br><span class="line"><span class="comment"> * mc_event_loop</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>反应堆支持在循环过程中，通过相应的回调函数再注册事件，类似于热加入，热移除。<br>实现方式很简单，就是在第一个事件的回调函数上调用 mc_event_set()然后注册。再加入 base.</p><p>base 的结构如下 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mc_event_base_s</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *added_list;</span><br><span class="line">    <span class="keyword">void</span> *active_list;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> event_num;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> event_active_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mc_minheap minheap;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> epoll_fd;  <span class="comment">//for epoll only</span></span><br><span class="line">    <span class="keyword">int</span> ev_base_stop;</span><br><span class="line">    <span class="keyword">int</span> magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">event_time</span>;</span>  </span><br><span class="line">&#125; <span class="keyword">mc_event_base_t</span>;</span><br></pre></td></tr></table></figure><p>让我们来看一个简单的 demo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//_____________________test bellow ______________________</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mc_sock_fd  int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_NET AF_INET</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_DATA_GRAM   SOCK_STREAM</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_PORT        (1115)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_BACKLOG     (200)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* simple connection */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">connection</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd            ;</span><br><span class="line">    <span class="keyword">mc_event_t</span>  read  ;</span><br><span class="line">    <span class="keyword">mc_event_t</span>  write ;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>]    ;</span><br><span class="line">    <span class="keyword">mc_event_base_t</span> * base ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setreuseaddr</span><span class="params">( mc_sock_fd fd )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> yes = <span class="number">1</span> ;</span><br><span class="line">    setsockopt( fd , SOL_SOCKET , SO_REUSEADDR , &amp;yes , <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mc_socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retsock = socket(DEFAULT_NET,DEFAULT_DATA_GRAM,<span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">if</span>( retsock &lt; <span class="number">0</span>  ) &#123;</span><br><span class="line">        <span class="comment">/* we should add some debug information here</span></span><br><span class="line"><span class="comment">        fprintf(LOGPATH,"socket error\n");</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retsock ;</span><br><span class="line">&#125;      </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mc_bind</span><span class="params">(mc_sock_fd listenfd )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span> ;</span></span><br><span class="line">    bzero(&amp;serveraddr,<span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"> </span><br><span class="line">    serveraddr.sin_family = AF_INET ;</span><br><span class="line">    serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serveraddr.sin_port = htons(DEFAULT_PORT);</span><br><span class="line">    <span class="keyword">return</span> bind(listenfd,(struct sockaddr *)&amp;serveraddr , <span class="keyword">sizeof</span>(serveraddr ));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mc_isten</span><span class="params">(mc_sock_fd listenfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listen(listenfd,DEFAULT_BACKLOG);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_accept</span><span class="params">( <span class="keyword">int</span> fd , <span class="keyword">short</span> revent , <span class="keyword">void</span> *args )</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">in_addr</span> ;</span></span><br><span class="line">    <span class="keyword">size_t</span> in_len ;</span><br><span class="line">    <span class="keyword">int</span> s   ;</span><br><span class="line">    <span class="keyword">int</span> done = <span class="number">0</span> ;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">connection</span> * <span class="title">lc</span> = (<span class="title">struct</span> _<span class="title">connection</span> *)<span class="title">args</span> ;</span></span><br><span class="line">     </span><br><span class="line">    in_len = <span class="keyword">sizeof</span>( in_addr );</span><br><span class="line">    mc_setnonblocking(fd) ;</span><br><span class="line">    <span class="keyword">while</span>( !done ) &#123;</span><br><span class="line">        s = accept( fd , (struct sockaddr *)&amp;in_addr , &amp;in_len );</span><br><span class="line">        <span class="keyword">if</span>( s == <span class="number">-1</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span>( (errno == EAGAIN )|| (errno == EWOULDBLOCK ) ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                perror(<span class="string">"accept"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( s == <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Accept a connection on %d \n"</span>,fd );</span><br><span class="line">        &#125;</span><br><span class="line">        done = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">        mc_setnonblocking(s) ;</span><br><span class="line">        lc-&gt;fd = s ;</span><br><span class="line">        mc_event_set( &amp;(lc-&gt;read) , MC_EV_READ , lc-&gt;fd , handler_read , lc );</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        mc_event_set( &amp;(lc-&gt;write) , MC_EV_WRITE , lc-&gt;fd , handler_write , lc );</span><br><span class="line">        mc_event_post( &amp;(lc-&gt;write) , lc-&gt;base );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_read</span><span class="params">( <span class="keyword">int</span> fd , <span class="keyword">short</span> revent , <span class="keyword">void</span> *args )</span> </span>&#123;</span><br><span class="line">    mc_setnonblocking(fd) ;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">connection</span> * <span class="title">lc</span> ;</span></span><br><span class="line">    lc  = (struct _connection *)args ;</span><br><span class="line">    read( fd , lc-&gt;buf , <span class="number">1024</span> );</span><br><span class="line">    mc_event_set( &amp;(lc-&gt;write) , MC_EV_WRITE , lc-&gt;fd , handler_write , lc );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_write</span><span class="params">( <span class="keyword">int</span> fd , <span class="keyword">short</span> revent , <span class="keyword">void</span> *args )</span> </span>&#123;</span><br><span class="line">    mc_setnonblocking(fd) ;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">connection</span> * <span class="title">lc</span> ;</span></span><br><span class="line">    lc  = (struct _connection *)args ;</span><br><span class="line">    write( fd , lc-&gt;buf , <span class="number">1024</span> );</span><br><span class="line">    mc_event_set( &amp;(lc-&gt;read) , MC_EV_READ , lc-&gt;fd , handler_read , lc );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cab</span><span class="params">( <span class="keyword">int</span> fd , <span class="keyword">short</span> revent , <span class="keyword">void</span> *args )</span> </span>&#123;</span><br><span class="line">    mc_setnonblocking(fd) ;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = <span class="string">"xx00xx00xx00xx00\n"</span>;</span><br><span class="line">    write(fd,buf,<span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mc_event_t</span> mev ;</span><br><span class="line">    <span class="keyword">mc_event_base_t</span>  *base = mc_base_new() ;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">connection</span> <span class="title">lc</span> ;</span></span><br><span class="line">    lc.base = base ;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">int</span> sockfd = mc_socket() ;</span><br><span class="line">    mc_bind(sockfd);</span><br><span class="line">    mc_isten(sockfd);</span><br><span class="line">     </span><br><span class="line">    mc_event_set( &amp;(lc.read) , MC_EV_READ , sockfd , handler_accept , &amp;lc );</span><br><span class="line">    mc_event_post( &amp;(lc.read) , base );</span><br><span class="line">    mc_dispatch(base);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先：封装的几个套接口操作没有考虑错误处理，作为简单的实例。</p><p>定义了一个 connection 结构，用于表示每一个到来的连接，这里的 struct _connection 中包含读写事件和一个缓冲区，还有指向反应堆的指针和对应注册的fd</p><p>工作过程如下：（主要看  main 函数）</p><p>（1）创建一个反应堆。<br>（2）实例化一个 connection<br>（3）创建套接口，bind,listen 老生常谈，这里就不多说了<br>（4）将这个监听套接口注册相应的回调函数，这里我们注册的是 handler_accept() 函数，回调函数类型都是  void *XXX(  int  , short , void *) ;</p><p>当监听套接口发生可读事件时，第一次我们认为是相应的监听套接口得到了新的连接，所以，第一次调用的时候直接调用注册了的回调函数 handler_accept().</p><p>在handler_accept() 函数中，我们为这个连接的读写事件添加了相应的回调函数，并把连接描述符（不是监听描述符）注册到这个上。下次这个套接口可读的时候调用handler_read()，可写的时候调用handler_write(). 如果需要改变状态或改变回调函数，只需要一个状态机或者别的方式来确定需要的回调函数是哪一个，在我们的handler_write() 和 handler_read()中可以改变回调函数，代码所示。</p><p>需要注意的是，我们的事件是一个实例，不管是在connection结构中或是自己定义，都需要不断的向操作系统申请空间，如果采用对象池或者connection池的方式，可以减少服务器的负载。</p><p>总结：反应堆模式最基本的操作就是：注册事件（为需要监听的fd加入回调函数）—–&gt;将事件加入反应堆——&gt;开始事件循环——&gt;事件发生，调用回调函数。</p><p>异步操作的精髓就是在这里，而不是同步的等待每一个事件。下一章讲解这个反应堆的实现。</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器端编程模型（4）—— Reactor 模式（epoll 简介）</title>
      <link href="/Programming/network-programming-server-mode4/"/>
      <url>/Programming/network-programming-server-mode4/</url>
      
        <content type="html"><![CDATA[<p>引言：上一篇说到了线程池方式来处理服务器端的并发，并给出了一个线程池的方案（半同步，半异步方式）。各有各的好处吧，今天来讲讲关于非阻塞的异步IO。<br>说到异步IO，其实现在很难实现真正的异步，大部分情况下仍然需要阻塞在某个多路复用函数，比如select 或者 epoll 上，得到就绪描述符，然后调用注册在相应描述符上的回调函数。这种方式是现在的反应堆设计的基本思路。<br>下面是一个 Reactor 模型的示例图：<br><img src="http://upload-images.jianshu.io/upload_images/1452123-c374c5d5a01b5623.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这个图是截取至 python的 twisted 服务器的反应堆文章介绍，但是大致和我们需要的理念一样。<br>事件循环阻塞查看描述符是否就绪，当就绪后返回可读或可写的描述符，也有可能带外数据或者出错等情况。</p><p>select 很多文章都介绍了，而 epoll 是 Linux 2.6 版本正式引入的 IO 多路复用方式。<br>epoll 较 select 的一些优点就不多说了，内核采用红黑树机制，大大提高了epoll 的性能。著名的 libevent, Nginx 等内部都采用这个机制。<br>废话不多说，看一个简单的epoll 模式，其实本来不想介绍这个的，因为直接 man epoll 就可以看到一个简单的demo，但是为了文章的连贯性，还是继续把这部分介绍一下。</p><p>epoll 主要有几个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>在现在的Linux版本中，size 已不重要，默认的不超过最大值就可以。size 就是描述符数目的最大值。<br>函数的返回值是一个描述符（句柄），很简单的就创建了epoll.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数是由 epoll_create 返回的描述符<br>第二个参数是由宏定义的几个值<br>EPOLL_CTL_ADD：类似于 select 的 FD_SET() ，将一个描述符加入到epoll 监听队列中EPOLL_CTL_MOD：修改已经注册的fd的事件类型EPOLL_CTL_DEL：将一个描述符从epoll 监听队列中删除<br>第三个参数是需要加入的描述符<br>第四个是一个结构体参数，结构是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">__uint32_t</span> events;</span><br><span class="line">    <span class="keyword">epoll_data_t</span> data; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">__uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><p>epoll_event 结构体里面的events 表示的是返回的事件类型或者是加入时候的事件类型。也有可能是带外数据或者错误等，它由几个宏定义：<br>EPOLLIN ：文件描述符上的读事件<br>EPOLLOUT：文件描述符上的写事件<br>EPOLLPRI：描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br>EPOLLERR：描述符发生错误；<br>EPOLLHUP：描述符被挂断；<br>EPOLLET： 边缘触发(Edge Triggered)模式<br>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到 EPOLL队列里</p><p>值得一说的是，很多文章都没有提到这个宏其实可能是由你自己改变的，通过 epoll_ctl 或者是在 epoll_wait 返回的时候操作系统改的，因为描述符有可能出错等。<br>一般情况下，对于一个描述符，可以使用 | 运算来组合。<br>添加一个描述符，监听是否可读或可写：<br>EPOLLIN | EPOLLOUT </p><p>注意一下epoll_data_t中的 ptr 或者 fd 而不是 ptr 和 fd，这个结构只能包含其中一个，所以在注册相应的描述符上的事件的时候，要么注册的是对应的描述符fd，要么注册的是相应的事件封装，当然，事件封装里面必然有fd，不然无法继续下面的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数是epoll的描述符<br>第二个参数是一个指向 struct epoll_event  的指针，这里需要传入的是一个数组，epoll_event 类型.<br>第三个参数是最大的监听事件数组值。<br>第四个参数是超时时间，对于 Nginx 或者很多如 libevent 的超时时间管理是利用红黑树和最小堆来管理的，很巧妙的方式，以后写一篇博文介绍，这里只需要知道 timeout 是 epoll_wait 的阻塞的最大值，如果超过这个值不管是否有事件都返回，0表示立即返回，即有无事件都返回，-1 是永久阻塞。</p><p>一个简单的 epoll demo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>,<span class="title">events</span>[1024];</span></span><br><span class="line">epfd=epoll_create(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( ; ; ) &#123;</span><br><span class="line">       nfds = epoll_wait(epfd,events,<span class="number">1024</span>,time_value);</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;++i)  &#123;</span><br><span class="line">           <span class="keyword">if</span>(events[i].data.fd==listenfd) &#123; <span class="comment">// 如果加入的监听描述符有事件</span></span><br><span class="line">               connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); <span class="comment">// accept这个连接并得到链接描述符，将描述符加入到epoll 监听事件队列</span></span><br><span class="line">               setnonblocking(connfd);</span><br><span class="line">               ev.data.fd=connfd;</span><br><span class="line">               ev.events=EPOLLIN|EPOLLET;  <span class="comment">// 读事件</span></span><br><span class="line">               epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); <span class="comment">// 将新的fd添加到epoll的监听队列中</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>( events[i].events&amp;EPOLLIN ) &#123; <span class="comment">// 接收到数据，读socket</span></span><br><span class="line">               n = read(sockfd, line, MAXLINE)) &lt; <span class="number">0</span>  </span><br><span class="line">               ev.data.ptr = my_ev;     <span class="comment">// ev 可以是自己定义的事件封装或者是fd</span></span><br><span class="line">               ev.events=EPOLLOUT|EPOLLET;</span><br><span class="line">               epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); <span class="comment">// 修改标识符，等待下一个循环时发送数据</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLOUT) &#123; <span class="comment">// 对应的描述符可写，即套接口缓冲区有缓冲区可写</span></span><br><span class="line">               struct my_event* my_ev= (my_event*)events[i].data.ptr;  </span><br><span class="line">               sockfd = my_ev-&gt;fd;</span><br><span class="line">               send( sockfd, ev-&gt;ptr, <span class="built_in">strlen</span>((<span class="keyword">char</span>*)my_ev-&gt;ptr), <span class="number">0</span> );       </span><br><span class="line">               ev.data.fd=sockfd;</span><br><span class="line">               ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">               epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// ...</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>以上内容只是给出了一个大概的 epoll 使用方式，并不完善，其中还有很多需要注意的地方。<br>这里的目的只是想让不懂异步事件和反应堆模式的读者了解这种模式。注意的是这种模式下连接描述符需要设置为非阻塞，然后IO 操作函数应该记录每次读写的状态，如果缓冲区满的话需要记录状态，下次返回这个描述符的时候继续上一次的状态继续传输或读取，因为一个套接口缓冲区读取的是应用层数据，而 TCP 层的数据如果比较大的时候分段的话会导致一次不能完全读取或写入全部数据而套接口缓冲区已经满了。需要选取的模式是LT 水平触发方式，如果是ET 边缘触发方式，一次读取套接口或者写入套接口但是缓冲区满了不能继续写后，epoll_wait不会继续返回，不需要状态机记录。ET 方式也是所谓的高速模式。</p><br>##### 总结：<p>这里只是对epoll 做了一个简单的介绍，如有错误，请指教。希望大牛们不要介意，承前启后，后面会有一个反应堆的框架的介绍，这里没有使用到事件封装和设置回调函数等，只是一个demo，还不是我自己写的。下一篇文章会继续分享一个 epoll 异步事件封装。</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器端编程模型（3）——多线程并发式（线程池）</title>
      <link href="/Programming/network-programming-server-mode3/"/>
      <url>/Programming/network-programming-server-mode3/</url>
      
        <content type="html"><![CDATA[<p>引言：上篇文章说到了多进程并发式的服务端模型，如上一篇文章所述，进程的频繁创建会导致服务器不堪负载，那这一篇文章主要讲述的是线程模型和线程池的方式来提高服务端的负载能力。同时比较一下不同的模型的好处与坏处。</p><p>在Linux下创建一个线程的方式很简单，pthread_create() 函数来创建线程，其中的一个参数的回调函数，也就是线程本身的执行体函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_entry</span><span class="params">(<span class="keyword">void</span> *args)</span></span>;</span><br></pre></td></tr></table></figure><p>那么，在服务端的线程使用方式一般为三种种：<br>（1）按需生成(来一个连接生成一个线程)<br>（2）线程池(预先生成很多线程)<br>（3）Leader follower（LF）</p><p>主要讲解第一种和第二种，第三种暂时手上没有实例代码<br>第一种方式的范式大概是这样:<br>回调函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_entry</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = *(<span class="keyword">int</span>*)args;</span><br><span class="line">    do_handler_fd(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序主体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    fd = accept();</span><br><span class="line">    pthread_create(..., thread_entry, &amp;fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里所展示的只是一个最简单的方式，但是可以代表多线程的服务器端模型。</p><p>大体服务端分为主线程和工作线程，主线程负责 accept() 连接，而工作线程负责处理业务逻辑和流的读取等。这样，即使在工作线程阻塞的情况下，也只是阻塞在线程范围内，关于这部分内容，可以参考《C++网络编程》第一卷的第五章。在应用层和内核之间的线程比例为 1:1 的操作系统线程机制中，一个线程在内核中会有一个内核线程实例，那么就是说，如果这个线程阻塞，不会引起在同一个进程里面的线程也阻塞。现在大多是的操作系统采用的都是 1:1 的模型，但是这个比传统的 N:1 模型更消耗资源。<br>N:1 模型就是，在应用层级别的多个线程在操作系统中只有一个实例，可以看做一个组，一旦一个线程阻塞，这个工作组的其他线程都会阻塞。</p><p>故上述代码的 <code>do_handler_fd(fd)</code> 里面的系统调用如果阻塞，不会引起整个进程阻塞，线程的阻塞只是在线程范围内。所以，主线程可以一直等待客户连接，而把工作处理过程放到线程中去。</p><p>这个是传统的线程方式，这种方式也会带来一些问题：</p><p>（1）工作开销过大，线程的频繁创建的销毁也是一个很消耗资源的过程，虽然较进程小很多。　<br>（2）对于临界资源的访问需要控制加锁等操作，加大了程序设计的复杂性。<br>（3）一个线程的崩溃会导致整个进程的崩溃，比如调用了exit() 函数等，虽然阻塞操作只阻塞一个线程，但是其他一些系统调用的失败或崩溃将导致服务器整个宕机。后果不堪设想。<br>但是在很多地方也提到了，多线程的方式适合 IO 密集型的程序，比如大文件传输等，这样可以在用户看来所有的操作都是并行的。</p><p>下面来说说线程池的方式，它改进了上述的问题的第一个，频繁的创建线程。<br>线程池的基本思想就是预先创建一部分线程，然后等到任务来的时候，通过条件变量或者其他的机制来唤醒一个工作线程。</p><p>下面详细的讲述一下前段时间写的一个简单的线程池方案。</p><p>线程池有一个任务队列，即由任务对象组成的一组队列。</p><p>我们为这个任务队列提供两个接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mc_thread_pool_add_task</span><span class="params">(<span class="keyword">void</span> *task, <span class="keyword">size_t</span> tasksize)</span></span></span><br></pre></td></tr></table></figure><p>解释一下这个接口的含义和参数， task 是一个指向任务实例的指针，tasksize 一般取 sizeof(instance_task) 为的是在加入任务队列的时候队列的一些其他操作。为了简单化，这里没有提供任务优先级的考虑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mc_thread_pool_get_task</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>这个函数用来取得一个指向任务实例的指针，然后可以操作这个任务。<br>一般情况下，由主线程调用第一个函数，而工作线程调用第二个函数。</p><p>我们来看看线程池的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">thread_pool_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span>  queue_lock;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span>   task_cond;</span><br><span class="line">    <span class="keyword">list_t</span>          *tasks;       <span class="comment">// treat it as queue thread_task_t type</span></span><br><span class="line">    <span class="keyword">pthread_t</span>       *pthreads;</span><br><span class="line">    <span class="keyword">int</span>              isdestoried;</span><br><span class="line">    <span class="keyword">int</span>              workersnum;</span><br><span class="line">    <span class="keyword">char</span>             ready;</span><br><span class="line">    thread_task_handler thread_pool_task_handler;</span><br><span class="line">&#125; <span class="keyword">thread_pool_t</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  this structure is a global control block of threads poll</span></span><br><span class="line"><span class="comment"> *  as you can see, queue_lock and task_cond is define to protecte access of this whole poll</span></span><br><span class="line"><span class="comment"> *  and task_cond is used to signal to threads that the task queue is ready</span></span><br><span class="line"><span class="comment"> *  tasks is a queue of tasks, each task should posted to this queue and threads</span></span><br><span class="line"><span class="comment"> *  in this pool can get it, we defined this task as void * to use wildly</span></span><br><span class="line"><span class="comment"> *  isdestoried is a boolean flag as his/her name</span></span><br><span class="line"><span class="comment"> *  workersnum is the total number of threads</span></span><br><span class="line"><span class="comment"> *  ready is a flag also and used to judge if the tasks queue is ready</span></span><br><span class="line"><span class="comment"> *  thread_pool_task_handler is a function point which points to the task handler you defined</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在线程池的结构中，我们定义了两个变量：queue_lock 和 task_cond</p><p>一个是锁，用来控制线程对于 task 任务队列的访问，另一个 task_cond 用来唤醒工作线程。</p><p>说说基本原理：工作线程默认情况下是阻塞在 pthread_cond_wait() 系统调用下的，如果有任务到来，我们可用使用 pthread_cond_singal() 来唤醒一个处于阻塞状态的线程，这样这个线程就可以执行 mc_thread_pool_get_task() 来取得一个任务，并调用相应的回调函数。</p><p>tasks 就是上面所说的任务队列，pthreads 是一个 pthread_t 的数组，也就是用来标示线程 id 的数组。每一次创建线程的时候都会返回线程 id，所以我们需要记录。</p><p>ready 是一个 flag, 标示是否任务队列可用。thread_task_handler 是一个函数指针，定义是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*thread_task_handler)</span><span class="params">(<span class="keyword">void</span> *args)</span></span>;</span><br></pre></td></tr></table></figure><p>结构体里的 thread_pool_task_handler 就是在初始化的时候设置的线程的执行体。</p><p>下面看看初始化函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mc_thread_pool_ini</span><span class="params">(<span class="keyword">mc_thread_pool_t</span> *par_tp, <span class="keyword">int</span> workersnum, thread_task_handler par_handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="comment">//par_tp = (thread_pool_t *)malloc(sizeof(thread_pool_t));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(par_tp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"thread_pool_t malloc\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    par_tp-&gt;workersnum = workersnum;</span><br><span class="line">     </span><br><span class="line">    pthread_mutex_init(&amp;par_tp-&gt;queue_lock,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;par_tp-&gt;task_cond, <span class="literal">NULL</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    par_tp-&gt;queue_lock = PTHREAD_MUTEX_INITIALIZER;</span></span><br><span class="line"><span class="comment">    par_tp-&gt;task_cond  = PTHREAD_COND_INITIALIZER ;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    par_tp-&gt;tasks = mc_listcreate();</span><br><span class="line">    <span class="keyword">if</span>(par_tp-&gt;tasks == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"listcreate() error\n"</span>);</span><br><span class="line">        <span class="comment">//free(par_tp);</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    par_tp-&gt;pthreads = (<span class="keyword">pthread_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>)*workersnum);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>(par_tp-&gt;pthreads == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthreads malloc\n"</span>);</span><br><span class="line">        <span class="comment">//free(par_tp);</span></span><br><span class="line">        mc_freelist(par_tp-&gt;tasks);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; workersnum; i++) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"start to create threads\n"</span>);</span><br><span class="line">        err = pthread_create(&amp;(par_tp-&gt;pthreads[i]),<span class="literal">NULL</span>,mc_thread_entry,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(err == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create error\n"</span>);</span><br><span class="line">            <span class="comment">//free(par_tp);</span></span><br><span class="line">            mc_freelist(par_tp-&gt;tasks);</span><br><span class="line">            <span class="built_in">free</span>(par_tp-&gt;pthreads);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    par_tp-&gt;thread_pool_task_handler = par_handler;</span><br><span class="line">    par_tp-&gt;ready = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"successed to create threads\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化函数中，我们传递了一个函数执行体的入口点，也就是函数指针给线程池，当我们有任务的时候，一个线程被唤醒，执行相应的回调函数。</p><p>其他需要注意的地方是使用 for 循环来创建很多的线程，并利用数组方式记录了线程的id 。</p><p>创建线程时候的回调函数并不是我们的参数传递的回调函数地址。因为在创建线程好线程的时候，我们需要一个阻塞操作，使得线程处于睡眠状态，不然函数执行完毕后线程就退出了。所以，创建线程时候的回调函数是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">mc_thread_entry</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *task;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mc_global_threads_pool.queue_lock);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">" locked to wait task\n"</span>);</span><br><span class="line">        <span class="keyword">while</span>(mc_global_threads_pool.ready == <span class="number">0</span>)&#123;</span><br><span class="line">            pthread_cond_wait(&amp;mc_global_threads_pool.task_cond, &amp;mc_global_threads_pool.queue_lock);</span><br><span class="line">        &#125;</span><br><span class="line">        task = mc_thread_pool_get_task();</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"get a task and ready to unlock \n"</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mc_global_threads_pool.queue_lock);</span><br><span class="line">        mc_global_threads_pool.thread_pool_task_handler(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的一点是，我们要用两个变量来判断一个队列是否就绪，ready 和条件变量本身。</p><p>判断条件是 while() 而不是 if，这样可以使得线程在没有工作任务的时候，也就是工作队列为空的时候阻塞在 pthread_cond_wait 上，关于 pthread_cond_wait 的工作机制可以参考 IBM developerworks 上的相关文章。</p><p>这里简单讲一下，pthread_cond_wait 在发现没有任务的时候，条件不成立的时候，是会有一个默认的操作的，就是释放锁，第二个参数的锁，使得其他线程可以得到condition 的竞争权利。所以我们在函数体内 pthread_cond_wait 的调用上下有一个加锁和释放锁的操作。</p><p>在函数内部有一个  mc_global_threads_pool.thread_pool_task_handler(task) 这个操作就是线程内部得到了任务后调用回调函数过程。</p><p>将任务队列加入的函数实例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mc_thread_pool_add_task</span><span class="params">(<span class="keyword">void</span> *task, <span class="keyword">size_t</span> tasksize)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mc_global_threads_pool.queue_lock);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"thread locked and append to list\n"</span>);</span><br><span class="line">    mc_list_append(mc_global_threads_pool.tasks, task, tasksize);</span><br><span class="line">    pthread_mutex_unlock(&amp;mc_global_threads_pool.queue_lock);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"thread unlocked and successed append to list\n"</span>);</span><br><span class="line">    mc_global_threads_pool.ready = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mc_global_threads_pool.ready == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"signal to threads\n"</span>);</span><br><span class="line">        pthread_cond_signal(&amp;mc_global_threads_pool.task_cond);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了 ready 来判断是有任务，如果有，使用 pthread_cond_signal 来唤醒一个等待的线程。</p><p>取得一个队列的任务方式很简单，直接返回队列的第一个任务：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mc_thread_pool_get_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * ret_task;</span><br><span class="line">    ret_task = mc_getnode_del(mc_global_threads_pool.tasks, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret_task == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"get node_del error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">" got a task\n"</span>);</span><br><span class="line">    mc_global_threads_pool.ready = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ret_task == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"getnode_del error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ret_task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主体框架是这样的：</p><p>定义一个自己的task结构体比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">thread_task_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> task_num;</span><br><span class="line">&#125; <span class="keyword">mc_thread_task_t</span>;</span><br></pre></td></tr></table></figure><p>定义自己的回调函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_thread_task_handler</span><span class="params">(<span class="keyword">void</span> * task)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"task-&gt;tasknum %d\n"</span>, ((<span class="keyword">mc_thread_task_t</span> *)task)-&gt;task_num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  if the task is a event we can like this demo:</span></span><br><span class="line"><span class="comment">     *  (event_t *)task-&gt;handler((event_t *)task);</span></span><br><span class="line"><span class="comment">     *  so in event_t structure there should be a callback called handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数主体就是这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mc_thread_task_t</span> ltask;</span><br><span class="line">    ltask.task_num = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"begin to ini pool\n"</span>);</span><br><span class="line">    mc_thread_pool_ini(&amp;mc_global_threads_pool, <span class="number">20</span>, my_thread_task_handler);</span><br><span class="line">    mc_thread_pool_add_task(&amp;ltask, <span class="keyword">sizeof</span>(<span class="keyword">mc_thread_task_t</span>));</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        ltask.task_num = i;</span><br><span class="line">        mc_thread_pool_add_task(&amp;ltask, <span class="keyword">sizeof</span>(<span class="keyword">mc_thread_task_t</span>));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池初始化的时候所传入的结构体就是自己定义的 task 的回调函数。<br>上述所说的是线程池一个方案。回到我们的服务端模型上来看。<br>我们的服务端的改写方式可以换成这样：</p><p>定义一个任务结构，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">task_handler</span><span class="params">(<span class="keyword">void</span> *task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = *(<span class="keyword">int</span> *)task;</span><br><span class="line">    do_handler_fd(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，我们的服务器主体框架可以是这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mc_thread_pool_ini(&amp;mc_global_threads_pool, N, task_handler);  <span class="comment">// 第二个参数为线程池工作线程数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    fd = accept();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task</span> * <span class="title">newtask</span> = (<span class="title">struct</span> <span class="title">task</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">task</span>));</span></span><br><span class="line">    newtask-&gt;fd = fd;</span><br><span class="line">    mc_thread_pool_add_task(&amp;newtask, <span class="keyword">sizeof</span>(struct task*)); <span class="comment">//将newtask 指针加入队列，而不是实例，可以减少队列的存储空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>线程池的方案能够减少线程创建时候带来的开销，但是对于临界资源的访问控制等变得更加的复杂，考虑的因素更多。这里没有完整的贴出线程池的代码。上述模型在平常使用的过程中适合并发连接数目不大的情况，IO密集型。对于CPU 密集型的服务端，线程池返回会加大资源消耗。下一篇文章我们来看看反应堆模型，异步事件驱动，非阻塞IO，并贴出一个简单的 epoll 的反应堆。</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器端编程模型（2）—— 多进程并发式</title>
      <link href="/Programming/network-programming-server-mode2/"/>
      <url>/Programming/network-programming-server-mode2/</url>
      
        <content type="html"><![CDATA[<p>引言：上篇文章讲到同步阻塞迭代式的进程方式，这篇文章讲述一下关于处理单进程阻塞于系统调用的情况。使用方式是多进程的方式，可以减少很大一部分的因为进程阻塞所带来的服务器无法响应问题。</p><p>基本思想是这样，如上篇文章所述，在单进程阻塞在read() 系统调用的时候，会导致服务器无法响应其他的连接请求，那么我们可以通过在服务器fork() 出很多子进程来处理业务，而主进程负责 accept() 其他的客户连接。</p><p>主体框架是这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    fd = accept(...);</span><br><span class="line">    ret = fork() ;</span><br><span class="line">    <span class="keyword">switch</span>(ret) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span> :</span><br><span class="line">           do_err_handler();</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>  :   <span class="comment">// child process</span></span><br><span class="line">           do_handler_fd(fd);</span><br><span class="line">           <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">default</span> :   <span class="comment">// parent process</span></span><br><span class="line">           <span class="keyword">continue</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体来说，符合上述所说的，主进程负责 accept() 连接，子进程处理连接。<br>当然，在 do_handler_fd(fd) 中，可以关闭监听套接口等，只负责处理连接套接口。处理过程也是和上一章所说的一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read(fd, buf, n);</span><br><span class="line">dosomething(buf);</span><br><span class="line">write(fd, buf, n);</span><br></pre></td></tr></table></figure><p>在父进程中需要设置信号处理函数，用来处理子进程退出时候产生的 SIG_CHLD 型号，信号处理函数中调用 wait() 。避免产生僵尸进程、</p><p>我们来比较一下这个模型和前一个同步阻塞迭代式：</p><p>（1）并发量：这里的服务器主进程不再阻塞于 read() 或者 write() 系统调用，而是通过子进程完成业务处理。阻塞也只是阻塞在子进程中。那么可以减轻服务器主进程的相应时间要求。并发量大大加强，但是会受到操作系统的限制。<br>（2）代码复杂度：越到后面的代码复杂度肯定越高，开发难度也会慢慢加强。<br>（3）稳定性：服务器的稳定性现在两个版本还没有体现出来。不过如果没有处理好进程之间的协作和并发控制等第二个版本还是会比第一个版本稍微显得不稳定。</p><p>多进程还有另一种方式 Pre-fork 方式，也就是进程池方式，这里没有做过多的介绍，以后会加上这部分内容。 </p><p><strong>总结：</strong><br>说一下多进程并发式的服务器端模型的好处就是，主进程不用阻塞在IO系统调用中，而专注于负责处理连接请求。但是，进程本身的开销是很大的，频繁的创建进程会消耗很多务器端的资源。所以，还有其他的处理方式，那就是线程模型。既然创建多进程消耗系统资源，我们可以采取采用线程的方式来达到目的。这就是下一篇文章要谈论的：多线程方式（会有一个线程池的实例）</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cooperative development workflow using git branch</title>
      <link href="/Git/git-git-rebase-branch/"/>
      <url>/Git/git-git-rebase-branch/</url>
      
        <content type="html"><![CDATA[<p>When we work cooperatively with other people in a team using git, the common practice is to use git’s branch to<br>manage our local changes, once we are done with the changes (committed), we merge them to the master or a main branch that we work on.</p><p>For example, we create a featured branch(e.g. <code>feat-branch</code>) with a team of 5 people working on it, each one should pull this branch to their own local system, then create his own local branch(e.g. <code>me-branch</code>), based off this featured branch, to manage his own changes. After done with the changes, he should commit them, and then checkout to <code>feat-branch</code>, using <code>git merge me-branch</code> command to merge the changes from <code>me-branch</code> onto <code>feat-branch</code>.</p><p><strong>Note that</strong> this is a very common practice that many developers are using.<br>However, this pactice has a flaw, which is that it convolutes the commit history of the main-line. By another word, it makes the <code>feat-branch</code> commit history non-linear and thus hard to read and track. </p><p>A recommended practice would be to use <code>git rebase &lt;base&gt;</code> on our local branch before we merge it to the <code>feat-branch</code> or <code>master branch</code>. <code>git rebase</code> is very powerful command that help us keep the commit history clean and linear, it replays all commits from the base we branch out and modifies (actuall create new) the commits that we have done since in our own local branch. </p><p>see this:<br><img src="http://o8chcdh8l.bkt.clouddn.com/markdown/img/1473567249898.png" alt=""></p><p>As explained above, let’s see what the workflow would look like:<br>Assume we work on <code>master branch</code> in a team of five, each member creates his own local branch to make changes.<br><strong>Note:</strong> local branch name doesn’t matter (even if it conflicts with others’ branch names) as it only stays on our own local system and never been pushed to the public. </p><br>##### step 1Checkout to local branch, make changes and commit<pre><code>git checkout -b me-branch# Start(edit some files)....# Endgit add .git commit -am &quot;me-1&quot;</code></pre><br>##### step 2Go back to master branch and get the latest updates from remote repo<pre><code>git checkout mastergit pull --rebase</code></pre><p>Note:<br>Since we don’t make any changes to <code>master</code> on local, <code>git pull --rebase</code> has the same effects as <code>git pull</code>.</p><br>##### step 3Again, checkout back to local branch `me-branch`, then rebase the commits to master<pre><code>git checkout me-branchgit rebase master</code></pre><p>Note:<br>In rebasing process, it’s possible that we encounter conflicts, use <a href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing/the-golden-rule-of-rebasing" target="_blank" rel="noopener">mergetool</a> to sovle them and then<br>use <code>git rebase --continue</code> as instructed until we’re done with it. Once we’re done, the changes should have been committed successfully. Go to the next step.</p><br>##### step 4<pre><code>git checkout mastergit merge me-branch</code></pre><p>Note:<br>When we execute <code>git merge me-branch</code>, it will use a fast-forward fashion to merge all commits from me-branch onto master branch.<br>Since we have rebased in me-branch, the commits history is clean and linear therefore fast-forward will succeed.</p><p>By now, all changes are merged and committed in a clean and graceful way, we are ready to push it to the public.</p><br>##### step 5<pre><code>git push -u origin master</code></pre><p>You may think <strong><code>step2</code></strong> and <strong><code>step 3</code></strong> are boring and tedious, I found out a way that can shorten this process.<br><strong>that is:</strong><br>Stay in your local branch, and pull the latest updates from remote master branch, and rebase our local commits on it.</p><pre><code>git pull origin master --rebase</code></pre><hr><p style="color:blue; font-size: 28px"><strong> More thoughts:</strong></p><br>###### Side effects of rebase---The rebase moves all of the commits in master onto the tip of your dedicated branch. The problem is that this only happened in your local repository. All of the other developers are still working with the original master. Since rebasing results in brand new commits, Git will think that your master branch’s history has diverged from everybody else’s.<br>##### AdvancedIf you want to re-write the entire local branch's commit history, use `git merge-base` command.  e.g.   The below command returns the commit ID of the original base, which you can then pass to git rebase:<pre><code>git merge-base feature master</code></pre><p>Note: This only works for private local branches. If you’re collaborating with other developers via the same feature branch, and that branch is public, you’re not allowed to re-write its history.</p><br><br><br><br>##### Referenceshttps://www.atlassian.com/git/tutorials/merging-vs-rebasing/the-golden-rule-of-rebasing]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git squash several commits to one</title>
      <link href="/Git/git-git-squash-commits/"/>
      <url>/Git/git-git-squash-commits/</url>
      
        <content type="html"><![CDATA[<p>There are multiple ways to squash several commits to a single commits before we push to the remote repository.</p><br>##### 1. git rebase -i HEAD~x---<p>This is the classic way to interactively modify the commits, take an example,</p><p>Assume we have 3 commits like this:</p><pre><code>$ git log --pretty=format:&quot;%h - %ar : %s&quot;9963f79 - 4 seconds ago : index.md4148da5 - 5 minutes ago : java2921fdb3 - 6 minutes ago : java1</code></pre><p>We want to squash all these 3 commits to one</p><pre><code>$ git rebase -i HEAD~3</code></pre><p>this will open up an editor (e.g. <code>vim</code>), showing below info:</p><pre><code>pick 921fdb3 java1pick 4148da5 java2pick 9963f79 index.md# Rebase c59da30..9963f79 onto c59da30 (3 command(s))# # Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit</code></pre><p>What we need to do is to keep the first line unchanged, it is the oldest commit in these 3, we want to squash the following two commits to it.<br>change the following two picks to <code>squash</code>, like this:</p><pre><code>pick 921fdb3 java1squash 4148da5 java2squash 9963f79 index.md</code></pre><p>Save and exit, we were be prompt another editor asking us to modify the commit messages:</p><pre><code># This is a combination of 3 commits. # The first commit&apos;s message is:java1# This is the 2nd commit message:java2# This is the 3rd commit message:index.md# Please enter the commit message for your changes. Lines starting# with &apos;#&apos; will be ignored, and an empty message aborts the commit.## interactive rebase in progress; onto c59da30# Last commands done (3 commands done):#    squash 4148da5 java2#    squash 9963f79 index.md# No commands remaining.# You are currently editing a commit while rebasing branch &apos;master&apos; on &apos;c59da30&apos;.## Changes to be committed:#       new file:   test/hello.java#       new file:   test/index.md#       new file:   test/world.java</code></pre><p>Edit the commit messages to one like this:</p><pre><code># This is a combination of 3 commits.# The merged commit&apos;s message is:java1 java2 index.md -&gt; one</code></pre><p>Save and exit, then check result:</p><pre><code>$ git log --pretty=format:&quot;%h - %ar : %s&quot;9ca1dde - 25 minutes ago : java1 java2 index.md -&gt; one</code></pre><p>Now we can push this merged commit to remote:</p><pre><code>$ git push</code></pre><br>##### 2. git reset --soft HEAD~X && git commit---<p>This is a way of resetting the last several commits, by which means place those commited files back to staged area and then commit them all together.</p><pre><code>$ git reset --soft HEAD~3$ git commit -m &apos;squash last 3 commits&apos;</code></pre><p>Merge with last commit</p><pre><code>$ git reset --soft HEAD~1</code></pre><p><strong>Note:</strong> This method has an advantage of avoiding interactively modify the commit messages in an editor can could be automated in a script.</p><br>##### 3. git merge --squash---<p>In git, <code>HEAD@{1}</code> is where the branch was just before the previous command, so we can squash all commits from <code>HEAD@{1}</code> to current commit point.</p><pre><code>$ git reset --hard HEAD~3$ git merge --squash HEAD@{1}$ git commit</code></pre><br>###### More<pre><code>Put the to-be-squashed commits on a working branch (if they aren&apos;t already) -- use gitk for thisCheck out the target branch (e.g. &apos;master&apos;)git merge --squash (working branch name)git commit</code></pre><br><br><br><br>###### Referencehttp://stackoverflow.com/questions/5189560/squash-my-last-x-commits-together-using-git/5201642#5201642]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器端编程模型（1）—— 同步阻塞迭代</title>
      <link href="/Programming/network-programming-server-mode1/"/>
      <url>/Programming/network-programming-server-mode1/</url>
      
        <content type="html"><![CDATA[<p>引言：似乎现在阻碍服务端大部分情况下都属于IO瓶颈，硬盘的转速等，而计算的瓶颈大部分云端计算采用分布式计算，如基于 GFS 的 MapReduce 模型，网格计算或者其他的一些分布式处理。所以，现在服务端的服务衡量指标基本集中在并发量，QPS，响应速度，稳定性等。其中一部分也不乏大量的计算，属于CPU密集型的，根据业务的不同应该做相应的调整。今天的话题是浅谈一下几种常用的IO模型。</p><p>理解IO 模型是网络编程的重点。</p><p>最简单的同步迭代IO模型：</p><p>核心代码就是这样，这里我们假设前面的监听套接口已建立。即已绑定套接口，并调用了listen()函数。</p><p>同步迭代IO大致如下，我们假设现在的模型是这样的，服务端监听客户端的连接，并通过读取fd的内容，处理后返回给客户端，类似于http机制。这里省去了一些包裹函数等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">　　fd = accept(...);</span><br><span class="line">　　read(fd,buf,n);</span><br><span class="line">　　dosomtething(buf);</span><br><span class="line">　　write(fd,buf,n);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单进程模式下，如果没有客户端到来，进程一直阻塞在 accept调用上，对于新手来说，有点难理解阻塞的概念，总的来说，就是经过accept调用，陷入内核以后，进程停止其他的工作，等待accept()返回。阻塞在accept()不可怕，如果阻塞在read()系统调用，将导致整个服务器不能对其他的客户端提供服务。</p><p>现在假设一个情景：</p><p>accept()得到一个客户端的连接，此时的fd唯一标示该连接。</p><p>现在服务器进入read()系统调用，但是此时的客户端并没有发送数据，那么服务端一直阻塞在read系统调用。此时来了一个新的连接，但是服务端不能予以相应，就是accept()函数不能被服务器调用。那么这个连接是失败的。可想而知，这样的服务器模型是有多么的低效。不过，UDP恰恰常用这种方式，因为UDP 是非面向连接的，整个过程就是两个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">recvfrom(buf);</span><br><span class="line">dosomething(buf);</span><br><span class="line">sendto(buf);</span><br></pre></td></tr></table></figure><p>因为UDP 的非面向连接性，而且采用的是费可靠传输，传输速率较TCP快。读者可以查阅相关资料，但是最好需要设置客户端的recvfrom()超时，因为在传输过程中数据丢失，会导致客户端阻塞在recvfrom()调用上。</p><p>附一张图说明read()的系统调用的阻塞：</p><p><img src="http://upload-images.jianshu.io/upload_images/1452123-63a219bfd88c1d68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>即进程需要等待内核返回结果以后才能继续处理其他业务。</p><p>总结：同步阻塞迭代方式的IO是最简单的一种形式的IO模型，也是最低效的一种，但是研究东西都需要从最简单的开始。吸取经验。下一章讲解多进程的并发式IO模型。</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mongodb shard cluster</title>
      <link href="/Database/mongodb-shard-cluster/"/>
      <url>/Database/mongodb-shard-cluster/</url>
      
        <content type="html"><![CDATA[<p>A MongoDB sharded cluster consists of the following components:</p><ul><li>shard: Each shard contains a subset of the sharded data. Each shard can be deployed as a <a href="https://docs.mongodb.com/manual/reference/glossary/#term-replica-set" target="_blank" rel="noopener">replica set</a>.</li><li>mongos: The mongos acts as a query router, providing an interface between client applications and the sharded cluster.</li><li>config servers: Config servers store metadata and configuration settings for the cluster. As of MongoDB 3.2, config servers can be deployed as a replica set.</li></ul><p>Production deployment<br>In a production cluster, ensure that data is redundant and that your systems are highly available.</p><ul><li>Deploy <strong>Config Servers</strong> as a 3 member <span class="redBold">replica set</span></li><li>Deploy each <strong>Shard</strong> as a 3 member <span class="redBold">replica set</span></li><li>Deploy one or more mongos routers</li></ul><p>The following restrictions apply to a replica set configuration when used for config servers:</p><ul><li>Must have zero <a href="https://docs.mongodb.com/manual/core/replica-set-arbiter/" target="_blank" rel="noopener">arbiters</a>.</li><li>Must have no <a href="https://docs.mongodb.com/manual/core/replica-set-delayed-member/" target="_blank" rel="noopener">delayed members</a>.</li><li>Must build indexes (i.e. no member should have buildIndexes setting set to false).</li></ul><p><strong>Shard</strong><br>Shards should be deployed as a replica set to provide redundancy and high availability.<br>Performing queries on a single shard only returns a subset of data. Connect to the mongos to perform cluster level operations, including read or write operations.</p><p><span class="magentaBold">IMPORTANT</span><br>MongoDB does not guarantee that any two contiguous chunks reside on a single shard.</p><p>Every database has a <span class="redBold">primary</span> shard that holds all the un-sharded collections for a database. The primary shard has no relation to the primary in a replica set.</p><p>chech shard status<br>sh.status()</p><p><strong>Config Servers</strong><br>Config servers store metadata in the Config Database.<br>In general, you should never edit the content of the config database directly. </p><p><strong>Mongos</strong><br>MongoDB mongos instances route queries and write operations to shards in a sharded cluster. mongosprovide the only interface to a sharded cluster from the perspective of applications. Applications never connect or communicate directly with the shards.</p><p>The mongos uses the metadata to route operations from applications and clients to the mongod instances. </p><p>Note:<br>The most common practice is to run mongos instances on the same systems as your application servers, but you can maintain mongos instances on the shards or on other dedicated resources.</p><p>A mongos instance routes a query to a cluster by:</p><ul><li>Determining the list of shards that must receive the query.</li><li>Establishing a cursor on all targeted shards.</li></ul><p>The mongos then merges the data from each of the targeted shards and returns the result document. </p><p>Certain query modifiers, such as sorting, are performed on a shard such as the primary shard before mongosretrieves the results.</p><p>To detect if the MongoDB instance that your client is connected to is mongos, use the isMastercommand.<br>When a client connects to a mongos, isMaster returns a document with a msg field that holds the string <strong>isdbgrid</strong>.</p><p>e.g.</p><pre>{    "ismaster" : <span class="teal">true</span>,    "msg" : "isdbgrid",}</pre><br><br><br><p><strong>Reference</strong><br><a href="http://blog.csdn.net/irelandken/article/details/8003203" target="_blank" rel="noopener">http://blog.csdn.net/irelandken/article/details/8003203</a><br><a href="https://docs.mongodb.com/manual/core/sharded-cluster-components/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/core/sharded-cluster-components/</a> </p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Use git mergetool to solve commit conflict</title>
      <link href="/Git/git-git-mergetool/"/>
      <url>/Git/git-git-mergetool/</url>
      
        <content type="html"><![CDATA[<p>在使用 Git 与他人合作的过程中，代码冲突（conflict）是一个比较扰人的问题。<br>Git 在 pull 远程库代码时候会自动与本地文件进行 merge（会把把本地文件和远程库文件整合成一个文件），如果不熟悉如何手动 merge 的话，可能容易造成误操作。</p><p>经过我的一些搜索和验证，我总结了以下的一种可行方案，期望可以更好的处理 merge 时出现冲突的代码。<br>简单来说就是需要配置 mergetool，git 提供了 <code>difftool</code> 和 <code>mergetool</code> 用来做文本比对。</p><p>一般我们在使用 Git 进行代码更新时，在本地修改完成之后，进行 commit，然后 push，如果此时远程库有人提交了一次 commit，与我本地的修改是同一个文件，那么肯定会提示冲突导致 push 被 rejected。<br>这时候，我们一般的习惯应该是 <code>git pull --rebase</code> <strong>（记住： 不是 git pull）。</strong> 或者 <code>git fetch &amp;&amp; git rebase</code></p><p>提示：推荐为 <code>pull --rebase</code> 设置 <code>pl</code> 作为 alias:</p><pre><code>git config --global alias.pl pull --rebase</code></pre><p>这样，执行 <code>git pl</code> 之后，Git 会把远程库拉下来之后会自动 merge 有修改的文件。</p><p>下面来看一个例子：<br>假设我们本地和远程都修改一个叫 test.txt 的文件，Git 自动 merge 之后，冲突的行也会在糅合在 test.txt 中，这些冲突的行会按照使用 Git 特有的 conflict marker 来标示。</p><p>e.g.</p><pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADmy local changes=======remote changes&gt;&gt;&gt;&gt;&gt;&gt;&gt; ceabbf16ada5a359ccee1133</code></pre><p>如果我们手动修改这个文件来进行 merge 工作的话，很容易出错，因为冲突的行放在上下而不是同一行进行对比，非常不直观。<br>如果我们想要保留本地修改版本，又想同时保留远程那个版本，会很麻烦。因为只要一执行 <code>git pull</code> 它就会自动进行 merge，产生那个不易看懂的 merge 之后的文件。</p><p>难道它自动 merge 之后我们就只能手动修改那个冲突的文件吗？ 答案显然是NO。</p><p>直接 git pull的话，我们还有有办法找回我们本地的那个文件，因为 git 虽然自动 merge 了，但它其实还为我们保留了 3 份内容，只是没在当前目录显示出来。</p><p>我们可以使用 <code>git checkout --theirs xxx.txt</code> 这种方式来还原 local 或者 remote 版本的文件。</p><p>提示：</p><pre><code>--ours 表示 Local  --theirs 表示 Remote   </code></pre><p>执行 rebase 之后，上述标签的意义的变得相反，Remote 表示本地的修改，而 Local 则表示远程的修改！</p><p>我们也可以在 pull 的时候，直接用本地覆盖远程的，除非你想抛弃本地所有的修改，否则<strong>别这么做</strong>。</p><pre><code>git pull --rebase --strategy-option theirs  </code></pre><p>或者</p><pre><code>git pull -Xtheirs</code></pre><p>当然，我们还可以配置一下 mergetool，使得 Local 和 Remote 版本等文件更好的呈现出来，方便我们进行手动 merge。<br>使用 <code>git mergetool</code> 命令，git 会自动调出你配置好的文本比对工具，然后让我们在这个文本比对工具中进行愉快的 merge。</p><p>Command line mergetool editors:</p><ul><li>Emacs based diff tools: <code>emerge</code>, <code>Ediff</code></li><li>Vim based diff tool: <code>vimdiff</code></li></ul><p>而图形界面系统（Windows/Ubuntu/MaxOS 等）可以使用：<code>Beyond Compare</code>, <code>Meld</code>, <code>P4merge</code>, <code>kdiff3</code> 等工具。<br>下面来看看该怎么配置这些工具，以便我们在执行 <code>git mergetool</code> 命令的时候可以 Call 出它们：</p><p>编辑 <code>~/.gitconfig</code> 文件</p><br>##### 1. 使用 vimdiff---<pre><code>[diff]    tool = vimdiff[merge]    tool = vimdiff</code></pre><p>配置完成之后，当我们使用 git mergetool 调出 vimdiff 的时候，它会显示 4 个窗口， </p><p>布局效果如下：</p><p><img src="http://o8chcdh8l.bkt.clouddn.com/markdown/img/1472649949162.png" alt=""></p><p>提示：在 Vim 中使用 <code>Ctrl + g</code> 来显示当前文件信息（比如文件名，光标所在当前行等等信息）</p><p>我们也可以直接在命令行指定 mergetool，比如：  </p><pre><code>git mergetool -t gvimdiff</code></pre><p>如果想直接用某个版本覆盖另外一个版本，可以在 vim 中使用下列命令：</p><pre><code>:diffg LO  &quot; get from LOCAL:diffg RE  &quot; get from REMOTE:diffg BA  &quot; get from BASE:diffupdate fixes your whitespace issues:only        Show only the merged file:diffget 2  use LOCAL:diffget 3  use REMOTE:</code></pre><p>rebase 之后，LOCAL 就是远程库的内容了，REMOTE 就是你自己本地的修改了。因为现在是基于远程库的内容作为 base！<br>因此，conflict marker 的含义也变了：</p><pre><code>&lt;&lt;&lt;&lt;&lt;&lt; 远程库的修改======本地的修改&gt;&gt;&gt;&gt;&gt;&gt;</code></pre><p>同一个文件中出现多处 conflict：  </p><pre><code>]c move to the next conflict[c move to the previous conflict</code></pre><p>设置 conflict marker 的 style：  </p><pre><code>git config merge.conflictstyle diff3</code></pre><p>Define a user specific layout for vimdiff<br>Since the default layout has 4 windows, which looks over complicated sometimes,<br>We can define a 3-view layout through the below method:</p><pre><code>git config --global mergetool.merge3.cmd &apos;vim -d -c \&quot;wincmd J\&quot; \&quot;$MERGED\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot;git config --global alias.m3 &apos;mergetool -t merge3&apos;</code></pre><p>提示: <strong>wincmd 用于控制如何移动窗口</strong></p><p>notice we’ve defined an alias m3 for merge3, we can also set an alias for the default mergetool (vimdiff) like this:</p><pre><code>git config --global merge.tool vimdiffgit config --global alias.mt mergetool</code></pre><p>效果图：<br><img src="http://o8chcdh8l.bkt.clouddn.com/markdown/img/1473313879722.png" alt=""></p><p><strong>Fugitive</strong></p><pre><code>git config --global mergetool.fugitive.cmd &apos;vim -f -c &quot;Gvdiff&quot; &quot;$MERGED&quot;&apos;git config --global alias.ft &apos;mergetool -t fugitive&apos;</code></pre><p>提示：use <code>Gvdiff</code> will split the window in 3 vertical views: | 1 | 2 | 3 |</p><br>##### 2. Beyond Compare (推荐)---<pre><code>[alias]    bc4 = mergetool -t bc4[diff]    tool = bc4[difftool &quot;bc4&quot;]        cmd = &quot;\&quot;c:/program files (x86)/beyond compare 4/bcompare.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot;&quot;[merge]    tool = bc4[mergetool &quot;bc4&quot;]        cmd = &quot;\&quot;c:/program files (x86)/beyond compare 4/bcompare.exe\&quot; \&quot;$BASE\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; \&quot;$MERGED\&quot;&quot;        trustExitCode = true</code></pre><p>布局效果跟 vimdiff 一样，是 4-way merge。</p><p>我们可以使用 beyond compare 的 <code>2-way merge</code>进行更为直观的 merge：</p><pre><code>[mergetool &quot;bc4&quot;]    cmd = &quot;\&quot;c:/program files (x86)/beyond compare 4/bcompare.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; -savetarget=\&quot;$MERGED\&quot;&quot;    trustExitCode = true</code></pre><p>鉴于目前文本比对工具的局限性，个人认为这种 <code>2-way merge</code> 的方式相对来说比较直观。<br>在这种模式下，只有左右两个 pane，左边是 Local，右边是 Remote。同时，右边的 pane 还作为 merge 的 output file。<br>直接在右边 pane 中修改完成之后保存成 merge 的最终结果文件。</p><p>效果图<br><img src="http://o8chcdh8l.bkt.clouddn.com/markdown/img/1473317625320.png" alt=""></p><p>作为更为高级的一种 merge 方式是使用 <code>3-way merge</code> 模式，当文件中有大量 conflict，或者单行 vs 多行 这种 conflict 时，<br><code>2-way merge</code> 模式可能没有这种方便。因为这种模式下，可以把冲突的部分都加入最终文件，而 <code>2-way merge</code> 只能替换（除非手动 copy &amp;&amp; paste）。</p><br>##### 3. p4merge---<pre><code>[alias]    p4 = mergetool -t p4merge[mergetool &quot;p4merge&quot;]    cmd = &quot;\&quot;c:/program files/Perforce/p4merge.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; \&quot;$MERGED\&quot;&quot;    trustExitCode = true</code></pre><br>##### 4. meld---<pre><code>[alias]    meld = mergetool -t meld[mergetool &quot;meld&quot;]    cmd = meld --diff $BASE $LOCAL --diff $BASE $REMOTE --auto-merge $LOCAL $BASE $REMOTE --output $MERGED    trustExitCode = true</code></pre><p>meld 会打开 3 个 tabs, 第1个 tab, 默认会显示 3-way merge view，我们在中间的 pane 中进行merge。<br>第2个和第3个 tab 是 local 和 remote 分别与 base 的 diff views。</p><p>效果图<br><img src="http://o8chcdh8l.bkt.clouddn.com/markdown/img/1473317961565.png" alt=""></p><p><strong>注意：</strong> 使用 mergetool 时，git 会为冲突的文件生成一个 <code>.orig</code> 备份文件，解决掉冲突之后，这个文件默认不会被自动删除，我们手动把它删除掉就可以了。当然，我们也可以配置 git 不生成这个文件：</p><pre><code>git config --global mergetool.keepBackup falsegit config --global mergetool.keepTemporaries false</code></pre><p><strong>流程：</strong> merge 完成之后，执行下列操作完成 push：</p><pre><code>git rebase --continuegit push -u origin master </code></pre><br><br><br><br>###### 参考http://my.oschina.net/u/1010578/blog/348731 http://stackoverflow.com/questions/161813/how-to-resolve-merge-conflicts-in-githttp://www.zhihu.com/question/21215715http://www.scootersoftware.com/support.php?zz=kb_vcs]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Use msys2 in Windows</title>
      <link href="/Linux/linux-msys2/"/>
      <url>/Linux/linux-msys2/</url>
      
        <content type="html"><![CDATA[<p><strong>msys2</strong>, abbreviated from <code>Minimal SYStem 2</code>, is a Cygwin-derived software distro on Windows, it uses Arch Linux’s Pacman as a package manager.<br>As described in its home page, msys2 is an independent rewrite of MSYS, based on modern <code>Cygwin</code> (POSIX compatibility layer) and <code>MinGW-w64</code> with the aim of better interoperability with native Windows software.</p><p>Since my personal laptop becomes slow as more applications are loaded, especially when a virtual vm starts up, I decide to try out <code>msys2</code> to lighten<br>the loads. <code>msys2</code> together with the <code>MinGW-w64</code> simulate a Linux environment in Windows help me perform tasks that need Linux environment.</p><h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><p><a href="http://msys2.github.io/" target="_blank" rel="noopener">HomePage</a><br>Download: <a href="http://repo.msys2.org/distrib/x86_64/msys2-x86_64-20161025.exe" target="_blank" rel="noopener">msys2 64bit</a></p><p>It will be installed into directory <code>C:\msys64</code>.Files that are installed look like this:<br><img src="http://o8chcdh8l.bkt.clouddn.com/markdown/img/1477476874534.png" alt=""></p><h3 id="Environment-Variables"><a href="#Environment-Variables" class="headerlink" title="Environment Variables"></a>Environment Variables</h3><p>Utilities that are provided by <code>msys2</code> are located in <code>C:\msys64\usr\bin</code>, we can add this directory into windows environment variable <strong>PATH</strong> like this,<br><img src="http://o8chcdh8l.bkt.clouddn.com/markdown/img/1477477009209.png" alt=""><br>We benefit from this since we can now use those Linux commands or utils (e.g. <code>which</code>, <code>ls</code>, etc.) in Windows <code>cmd</code> command line also. </p><h3 id="Home-Path"><a href="#Home-Path" class="headerlink" title="Home Path"></a>Home Path</h3><p>The default <code>$HOME</code> directory is <code>C:\msys64\home\username</code> after install msys2. To use the Windows <code>$HOME</code>, which is <code>C:\Users\username</code>,  there are several ways:</p><ol><li><p>Add a HOME variable in Windows Environment Variable settings, and set its value to <code>C:\Users\username</code>.</p></li><li><p>Modify <code>/etc/fstab</code> and add the below line at the end of file:  </p><p> C:/Users /home ntfs binary,noacl,auto 1 1</p></li></ol><p>this will automatically mount <code>C:\Users</code> as <code>/home</code> directory.</p><ol start="3"><li><p>Modify <code>/etc/nsswitch.conf</code><br>add <code>windows</code> into db_home variables, and put it before other variables. like this:   </p><p> db_home: windows cygwin desc</p></li></ol><p><strong>Warnning:</strong><br>Mind the risk of mis-operation in this <code>$HOME</code> directory as it will affect the real user environment in Windows,<br>executing <code>rm -f</code> in msys2 shell will make you unable to recover the files that are removed.</p><h3 id="Setting-Shell-Style-Theme"><a href="#Setting-Shell-Style-Theme" class="headerlink" title="Setting Shell Style/Theme"></a>Setting Shell Style/Theme</h3><p>msys2 use mitty as the shell window, its style/theme can be configured through <code>~/.mittyrc</code>.Go to <a href="http://ciembor.github.io/4bit/#" target="_blank" rel="noopener">http://ciembor.github.io/4bit/#</a>, configure a theme that we like, copy the configuration settings into our<br>local <code>~/.mittyrc</code>.</p><h3 id="Get-Windows-Environment-to-msys2"><a href="#Get-Windows-Environment-to-msys2" class="headerlink" title="Get Windows Environment to msys2"></a>Get Windows Environment to msys2</h3><p>Sometimes we want to execute applications in Windows $Path (but not in msys2’s $PATH) in msys2 shell (e.g. we’ve installed Python in Windows but<br>we want to test some python scripts in msys2). We need to inherit the Windows $Path value into msys2’s $PATH. Fortunately, msys2 provides a way to do<br>this. msys2 provides a script <code>msys2_shell.cmd</code> to initialize the environment, if we want to get Windows environment variables, we can modify this file.</p><p>Take a look at this:<br><img src="http://o8chcdh8l.bkt.clouddn.com/markdown/img/1477478831843.png" alt=""></p><p>As it described, we can either launch the shell by executing <code>$ msys2_shell.cmd -use-full-path</code> or<br>set a new environment variable <strong>MSYS2_PATH_TYPE</strong> with value <code>inherit</code> in Windows.  </p><p><strong>Some recommendations</strong><br>When using the shells, try to remove as many entries from PATH as you can, ideally only leaving something likeC:\Windows\system32.<br>Mixing in programs from other MSYS2 installations, Cygwin installations or compiler toolchains is not supported and will probably break things in unexpected ways.<br>Do not have these things in PATH when running MSYS2 unless you know exactly what you’re doing.</p><h3 id="Install-base-tools-in-msys2"><a href="#Install-base-tools-in-msys2" class="headerlink" title="Install base tools in msys2"></a>Install base tools in msys2</h3><pre><code>$ pacman -S --needed base</code></pre><h3 id="Install-packages-using-pacman"><a href="#Install-packages-using-pacman" class="headerlink" title="Install packages using pacman"></a>Install packages using pacman</h3><pre><code>$ pacman -Sy git</code></pre><p>To install (build from source) off-line packages from <code>https://github.com/Alexpux/MSYS2-packages</code></p><pre><code>$ cd package_dir$ makepkg</code></pre><p><strong>Note:</strong> we need to run <code>pacman -S --needed base</code> first to make sure command <code>makepkg</code> works.</p><h3 id="More-things-about-msys2"><a href="#More-things-about-msys2" class="headerlink" title="More things about msys2"></a>More things about msys2</h3><p>keep in mind that MSYS2 doesn’t intend to compete with Cygwin or duplicate their efforts. The set of things that belong to the msys2 subsystem is pretty small:</p><ul><li>essential POSIX stuff: filesystem, msys2-runtime, …</li><li>the native toolchain: gcc, binutils, gdb, …</li><li>supporting programs that are hard to port to Windows: bash, automake, make, …</li><li>supporting programs, even though they’re portable: mintty, winpty, python, man, vim, git, …</li><li>random, highly useful stuff: mc, ssh, rsync, lftp, …</li><li>dependencies of these packages</li></ul><p>In other words, if a program is needed to build native software, but is itself hard to port, it can be made into a msys2 package. Anything else needs to be done as a mingw package or vetted individually.</p><p><strong>Introduction of MinGw-w64</strong><br>MinGw-w64 provides a GNU C Compiler toolchains in Windows, it helps to build native Windows applications without the dependencies on third party DLLs. </p><h3 id="Install-MinGW-GCC"><a href="#Install-MinGW-GCC" class="headerlink" title="Install MinGW-GCC"></a>Install MinGW-GCC</h3><p><strong>GCC</strong> in Windows is provided by MinGW tool chains, there are two ways to install it:</p><ol><li><p>Use msys2’s package manager <strong>pacman</strong>:</p><p> <code>$ pacman -S mingw-w64-x86_64-gcc</code></p></li><li><p>Download an offline installer to install a specific version of <code>MinGW-GCC</code>:</p></li></ol><p><a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/dongsheng-daily/" target="_blank" rel="noopener">https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/dongsheng-daily/</a>  </p><br><h6 id="Development-in-msys2"><a href="#Development-in-msys2" class="headerlink" title="Development in msys2"></a>Development in msys2</h6><p>Check cross-platform definitions</p><p>It’s common that we see a conditional include directive in a header files like below:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (defined(_WIN32) || defined(__WIN32__)) &amp;&amp; !defined(WIN32) &amp;&amp; !defined(__SYMBIAN32__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__FreeBSD__) &amp;&amp; (__FreeBSD__ &gt;= 2)</span></span><br><span class="line"><span class="comment">// Needed for __FreeBSD_version symbol definition</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;osreldate.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WIN32) &amp;&amp; !defined(_WIN32_WCE) &amp;&amp; !defined(__CYGWIN__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !(defined(_WINSOCKAPI_) || defined(_WINSOCK_H) || \</span></span><br><span class="line">      defined(__LWIP_OPT_H__) || defined(LWIP_HDR_OPT_H))</span><br><span class="line"><span class="comment">/* The check above prevents the winsock2 inclusion if winsock.h already was</span></span><br><span class="line"><span class="comment">   included, since they can't co-exist without problems */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(WIN32) &amp;&amp; !defined(_WIN32_WCE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(WIN32) &amp;&amp; !defined(__WATCOMC__) &amp;&amp; !defined(__VXWORKS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __BEOS__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;support/SupportDefs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>We can use below commands to check whether these variables are defined:</p><pre><code>$ gcc -m64 -dM -E -x c /dev/null | grep &quot;WIN&quot;#define _WIN32 1#define _WIN64 1#define __WINT_MAX__ 0xffff#define __WINT_MIN__ 0#define __WIN32 1#define __WIN64 1#define __WINNT 1#define __WINNT__ 1#define __WIN32__ 1#define __SIZEOF_WINT_T__ 2#define WIN32 1#define WIN64 1#define __WINT_TYPE__ short unsigned int#define WINNT 1#define __WIN64__ 1$ gcc -mwin32 -dM -E -x c /dev/null | grep &quot;WIN&quot;...</code></pre><br><br><br><p><strong>Reference</strong><br><a href="https://sourceforge.net/p/msys2/wiki/Home/" target="_blank" rel="noopener">https://sourceforge.net/p/msys2/wiki/Home/</a><br><a href="https://sourceforge.net/p/msys2/wiki/MSYS2%20introduction/" target="_blank" rel="noopener">https://sourceforge.net/p/msys2/wiki/MSYS2%20introduction/</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Remove a file from a Git repository without deleting it from the local filesystem</title>
      <link href="/Git/git-git-untrack/"/>
      <url>/Git/git-git-untrack/</url>
      
        <content type="html"><![CDATA[<p>There are sometimes that we want to untrack a file but don’t want to delete, in another word, we want to keep it in local file system but delete it from the git stage area.</p><p>According to <code>git help rm</code>, the following command should do the help.</p><pre><code>$ git rm --cached filename$ git rm --cached ./**/*.out</code></pre><br><br><br><br>###### Referencehttp://stackoverflow.com/questions/1143796/remove-a-file-from-a-git-repository-without-deleting-it-from-the-local-filesystehttp://stackoverflow.com/questions/1273108/how-do-i-git-rm-a-file-without-deleting-it-from-disk]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Undo anything in Git</title>
      <link href="/Git/git-git-undo/"/>
      <url>/Git/git-git-undo/</url>
      
        <content type="html"><![CDATA[<p>When working in a software project whose code base is managed by <code>Git</code>, undo is a very common and frequent operation,<br>and also it is one of the most attracting feature in <code>Git</code>.For better reference, I summarize all the situations that may need undo:</p><h3 id="1-Drop-unsaved-changes"><a href="#1-Drop-unsaved-changes" class="headerlink" title="1. Drop unsaved changes"></a>1. Drop unsaved changes</h3><hr><pre><code>$ git checkout -- filename</code></pre><p>Note:<br>If you have conflict changes on this file and not merged yet, you may encounter errors saying “error: path ‘some/path’ is unmerged<br>“, we can reset the file and then checkout it to drop the changes, e.g.</p><pre><code>$ git reset filename$ git checkout -- filename</code></pre><p>drop all files:</p><pre><code>$ git checkout -- .</code></pre><p>Note that the above commands won’t remove those newly added files that are in untracked status, to remove them also, use this:</p><pre><code>$ git clean -df</code></pre><p>Options explannation:</p><ul><li><code>-d</code>  Remove untracked directories in addition to untracked files</li><li><code>-f</code>  Force (might be not necessary depending on clean.requireForce setting, clean.requireForce is usually true by default)</li></ul><p><strong>Note:</strong><br>you can archive the current changes for later use by <code>git stash</code> commands:</p><pre><code>git stash save or git stash -ugit stash pop</code></pre><h3 id="2-Undo-add"><a href="#2-Undo-add" class="headerlink" title="2. Undo add"></a>2. Undo add</h3><p>The following commands can bring back files added into stage by <code>git add .</code>.</p><pre><code>$ git reset$ git reset HEAD$ git reset HEAD .</code></pre><p>Note:<br>Although these commands can bring files back to workspace and keep its changes, they are not quite practically necessary,<br>as if we add the files into stage, and then want to modify them again, we just simply modify them,<br>the files will be unstaged automatically.</p><h3 id="3-Undo-commit"><a href="#3-Undo-commit" class="headerlink" title="3. Undo commit"></a>3. Undo commit</h3><p><strong>(1) Get back from commit to stage (may not be quite useful)</strong></p><pre><code>$ git reset --soft HEAD^</code></pre><p><strong>(2) Get back from commit to workspace (unstaged)</strong></p><pre><code>$ git reset HEAD~</code></pre><p>or</p><pre><code>$ git reset --mixed HEAD^</code></pre><p><strong>(3) Drop the commit and its all changes</strong></p><pre><code>git reset --hard HEAD~1</code></pre><p><strong>Demo for (2):</strong></p><p>HEAD is just a pointer to the latest commit.<br>In the below diagram, the HEAD points to commit C, (F) is the state of our files.</p><pre><code>   (F)A-B-C    ↑  master</code></pre><p>After we undo the commit(by doing <code>git reset HEAD~</code>), the result becomes:</p><pre><code>   (F)A-B-C  ↑master</code></pre><p>As we can see, by executing <code>git reset HEAD~1</code>, <code>Git</code> moves the HEAD pointer back one commit. and leave the files with the changes as they were. We won’t lose anything.</p><p><strong>Demo for (3):</strong></p><p>Suppose we have a status like below, C is the HEAD and (F) is the state of our files.</p><pre><code>   (F)A-B-C    ↑  master</code></pre><p>After we execute nuke the commit(by doing <code>git reset --hard HEAD~1</code>), the result becomes:</p><pre><code> (F)A-B  ↑master</code></pre><p>Now we can see that B is the HEAD, and we won’t be able to see the commit again after we nuke it.</p><p><strong>But</strong> we still have a way to get it back, use <code>git reflog</code> to check the commit history</p><pre><code>c59da30 HEAD@{0}: reset: moving to HEAD~1993a1cd HEAD@{1}: commit: test undo commit1c59da30 HEAD@{2}: reset: moving to HEAD~abcedbd HEAD@{3}: commit: test undo commitc59da30 HEAD@{4}: rebase finished: returning to refs/heads/masterc59da30 HEAD@{5}: rebase: x22</code></pre><p>as shown, we can get the <code>ref id</code> from there, then execute below command to get to the commit:</p><pre><code>$ git checkout -b tmpBranch abcedbd</code></pre><p>Since we use a <code>hard reset</code>, it becomes a detached commit.</p><p><strong>More:</strong></p><p>We can alway use <code>git checkout commit_it</code> to temporarily get to a commit and come back using <code>git checkout master</code>.If we want to make commits while we’re there, go ahead and make a new branch there:</p><pre><code>$ git checkout -b old_state 0d1d7fc32</code></pre><p><strong>A read world example for (2):</strong></p><p>Suppose we accidently committed a unexpected file and we want to get it back, modify, then commit the rectification.</p><p>A proper workflow may look like this:</p><pre><code>$ git reset HEAD~... edit files ...$ git add .$ git commit -c ORIG_HEAD</code></pre><p><strong>Note:</strong><br><code>commit -c ORIG_HEAD</code> helps us reuse the old commit message.<br>It will open an editor, which initially contains the log message from the old commit,<br>this allows us to edit it. If we do not need to edit the message, can could use the -C option.</p><h3 id="4-Modify-Merge-commit-message"><a href="#4-Modify-Merge-commit-message" class="headerlink" title="4. Modify/Merge commit message"></a>4. Modify/Merge commit message</h3><p>Modify the latest commit message:</p><pre><code>$ git commit --amend -m &quot;New commit message&quot;</code></pre><p>If we have just made a commit, but realize that we forgot to add some files that need to added immediately,<br>or simply need to modify some file, just do:</p><pre><code>git add missing_file.txtgit commit --amend --no-edit</code></pre><p>If we have multiple commits (haven’t pushed yet) in local, and we want to squash those commits to one,<br>we can use <strong>interactive rebase</strong>:</p><pre><code>$ git rebase -i HEAD~X</code></pre><p>or</p><pre><code>$ git rebase -i commit_id</code></pre><p>Note: <code>X</code> is the number of commits to the last commit you want to be able to edit.</p><h3 id="5-Revert-the-pushed-commit"><a href="#5-Revert-the-pushed-commit" class="headerlink" title="5. Revert the pushed commit"></a>5. Revert the pushed commit</h3><p>Once we have pushed the local commits onto the remote repo, we won’t be able to get back using any of the above command,<br>in that case, we should use <code>git revert</code>.</p><p>First, we need to use <code>git log</code> to find out the commit it that we want to revert back to, then use:</p><pre><code>$ git revert c011fb8</code></pre><p>or revert the last two commits:</p><pre><code>$ git revert HEAD~2..HEAD</code></pre><p>or revert all commits to a specific commit_id:</p><pre><code>$ git revert --no-commit 0317e074..HEAD</code></pre><p>The <code>--no-commit</code> flag lets git revert all the commits at once- otherwise you’ll be prompted for a message for each commit in the range, littering your history with unnecessary new commits.</p><p>If one of the commits between 0317e074..HEAD is a merge then there will be an error popping up, in that case we could do: <code>git revert -m 1 HEAD</code>.check <a href="http://stackoverflow.com/questions/5970889/why-does-git-revert-complain-about-a-missing-m-option" target="_blank" rel="noopener">here</a>.</p><p>Note:<br>Before we executing <code>git revert</code>, we need to make sure the working tree is clean, which means there is no uncommited changes.<br>the theorem behind the <code>git revert</code> is that it creates a new commit with the reverse patch.</p><br><br><br><br><h6 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h6><p><a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git" target="_blank" rel="noopener">https://github.com/blog/2019-how-to-undo-almost-anything-with-git</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mgo source code ananlysis</title>
      <link href="/Programming/go-mgo-source-analysis/"/>
      <url>/Programming/go-mgo-source-analysis/</url>
      
        <content type="html"><![CDATA[<p>mgo 是 Go 语言用于连接 mongodb 的 开源 driver 程序。其源码共 2.6w+ 行代码，代码简洁而且质量很高，值得学习。</p><br>#### mgo 的连接模型---使用 mgo 连接 mongodb 可以用下面两种方式：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session, err := mgo.Dial(host)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session, err := mgo.DialWithInfo()</span><br></pre></td></tr></table></figure><p>这个 session 会被全局使用，通常，在实际的程序中，我们会开启 goroutine 来处理每个连接，其他的 goroutine 会通过 session.Clone() 来复用这个连接，使用完成之后通过 session.Close() 来关闭这个连接。<br>如果并发很高，其他 goroutine 可能来不及释放 session，那么当前 goroutine 就要么等待，要么新建一个 session。</p><br>#### 测试方法---在程序中开启 10000 个 goroutines， 在每个 goroutine 里面 time.Sleep(10 * time.Second)，睡眠 10 秒的目的 Hold 住连接暂时不释放，这样的话，就可以看到 mgo 会不断创建新连接。我们可以在 mongodb shell 中执行 `db.serverStatus().connections` 来查看连接数或者直接在本地客户端上执行 `netstat -natp | grep app_name | wc -l` 来查看连接数。<p>在 sleep 状态下由于不释放连接，测试效果如下：<br>100 并发： mongodb 增加 100 个连接<br>1w 并发：  mongodb 增加 4390 - 4700 个左右 的连接。<br>5w 并发：  同上<br>10w 并发： 同上</p><p>由于 mgo 默认的 <strong>pool limit</strong> 是 4096， 在高并发情况下（超过连接池限制时），如果每个 session 不调用 close（我这里使用 sleep 的方式让其不释放连接），这样，连接数会很快就达到 4096，并堵死其他请求，所以 clone 或 copy session 时一定要使用 defer close() 把连接关闭。启用 <code>maxPoolLimit</code> 参数则会限制总连接大小，连接到限制则当前协程会 sleep 等待，直到可以创建连接，高并发时锁有问题，会导致多创建一些连接，我测试下来发现最多4700多个，也就是多了超出连接池限制多创建了 600 多个连接。</p><p>运行 <code>testmgo 4096 &gt; res.txt</code> 创建 4096 个 goroutines, 并把真正执行连接（dial）了的信息打印， log 全部导到 res.txt 中方便分析。</p><pre><code>$ grep &quot;dial&quot; res.txt | wc -l104$ grep &quot;n &gt; 0&quot; res.txt | wc -l3989</code></pre><p>可以看到真正的 dial 只有 104 次， 也就是<strong>只创建了 104 个 socket 物理连接</strong>， 而有 3989 次都复用了 socket。3989 + 104 = 4093。<br>创建的 socket 少，跟查询语句耗时有关，如果一条查询语句耗时很短，那么连接会很快释放而被复用。相反，如果查询比较耗时，那么那个 socket 可能一直占用，那么其他请求来的时候没有可用的 socket 就会创建一个新的 socket。当创建的连接超过 pool limit 时，会返回 errPoolLimit 错误，并且 sleep 0.1s 之后重新获取/创建 socket。</p><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s, abended, err := server.AcquireSocket(poolLimit, socketTimeout)</span><br><span class="line"><span class="keyword">if</span> err == errPoolLimit &#123;</span><br><span class="line">    <span class="keyword">if</span> !warnedLimit &#123;</span><br><span class="line">        warnedLimit = <span class="literal">true</span></span><br><span class="line">        log(<span class="string">"WARNING: Per-server connection limit reached."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)                  <span class="comment">// 注意这里， Sleep 了</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：在不调用 session close 的情况下，其他的连接请求只能新建连接，</p><br>#### 整个连接流程的源码解读---<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sess := session.Copy()   -&gt; copySession()</span><br><span class="line">c := sess.DB(<span class="string">"test"</span>).C(<span class="string">"person"</span>) -&gt;</span><br><span class="line">c.Find().One() -&gt;</span><br><span class="line">s.acquireSocket() -&gt;</span><br><span class="line">s.cluster.AcquireSocket() -&gt; </span><br><span class="line">server.AcquireSocket(poolLimit, socketTimeout) -&gt; </span><br><span class="line">server.Connect(timeout) -&gt; </span><br><span class="line">server.net.DialTimeout(<span class="string">"tcp"</span>, server.ResolvedAddr, timeout)</span><br></pre></td></tr></table></figure><p><strong>核心函数</strong><br>(1). session.DialWithInfo()<br>(2). cluster.newCluster()<br>(3). session.newSession()</p><br>###### (1). session.DialWithInfo()---DialWithInfo establishes a new session to the cluster identified by info.Dial("localhost:27017") 内部实际上也会调用 DialWithInfo()<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialWithInfo</span><span class="params">(info *DialInfo)</span> <span class="params">(*Session, error)</span></span> &#123;</span><br><span class="line">    addrs := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(info.Addrs))</span><br><span class="line">    <span class="keyword">for</span> i, addr := <span class="keyword">range</span> info.Addrs &#123;</span><br><span class="line">        p := strings.LastIndexAny(addr, <span class="string">"]:"</span>)</span><br><span class="line">        <span class="keyword">if</span> p == <span class="number">-1</span> || addr[p] != <span class="string">':'</span> &#123;</span><br><span class="line">            <span class="comment">// XXX This is untested. The test suite doesn't use the standard port.</span></span><br><span class="line">            addr += <span class="string">":27017"</span></span><br><span class="line">        &#125;</span><br><span class="line">        addrs[i] = addr</span><br><span class="line">    &#125;</span><br><span class="line">    cluster := newCluster(addrs, info.Direct, info.FailFast, dialer&#123;info.Dial, info.DialServer&#125;, info.ReplicaSetName)</span><br><span class="line">    session := newSession(Eventual, cluster, info.Timeout)  <span class="comment">// 注意： 初始化时， consistency 是 Eventual</span></span><br><span class="line">    session.defaultdb = info.Database</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> info.PoolLimit &gt; <span class="number">0</span> &#123;                  <span class="comment">// info.PoolLimit &gt; 0 说明传进来的 info对象设置了 PoolLimit， 否则默认为0</span></span><br><span class="line">        session.poolLimit = info.PoolLimit   <span class="comment">// 只要用户自定义了 PoolLimit 的值， 那么就使用该值， 否则使用默认的 4096</span></span><br><span class="line">    &#125;</span><br><span class="line">    cluster.Release()                                   <span class="comment">// 注意： 这里 cluster 就 Release 了， ref-1</span></span><br><span class="line">    <span class="comment">// People get confused when we return a session that is not actually established to any servers yet (e.g. what if url was wrong). </span></span><br><span class="line">    <span class="comment">// So, ping the server to ensure there's someone there, and abort if it fails.</span></span><br><span class="line">    <span class="keyword">if</span> err := session.Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        session.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    session.SetMode(Strong, <span class="literal">true</span>)                             <span class="comment">// 完事之后， 把 consistency 设置成了 Strong</span></span><br><span class="line">    <span class="keyword">return</span> session, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>##### (2). cluster.newCluster()---<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCluster</span><span class="params">(userSeeds []<span class="keyword">string</span>, direct, failFast <span class="keyword">bool</span>, dial dialer, setName <span class="keyword">string</span>)</span> *<span class="title">mongoCluster</span></span> &#123;</span><br><span class="line">    cluster := &amp;mongoCluster&#123;</span><br><span class="line">        userSeeds: userSeeds,                      <span class="comment">// seed server， 用于 查找 topology</span></span><br><span class="line">        references: <span class="number">1</span>,                        <span class="comment">// 这里要注意：创建时 cluster.reference 就是 1， 在 cluster.syncServersLoop() 里面又会 +1</span></span><br><span class="line">        direct: direct,                               所以，一旦 cluster 创建了， 那么 ref 就至少是 <span class="number">1</span></span><br><span class="line">        failFast: failFast,</span><br><span class="line">        dial: dial,</span><br><span class="line">        setName: setName,</span><br><span class="line">    &#125;</span><br><span class="line">    cluster.serverSynced.L = cluster.RWMutex.RLocker()</span><br><span class="line">    cluster.sync = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">    stats.cluster(+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> cluster.syncServersLoop()                        <span class="comment">// 这里 sync servers， 会发现 topology 中所有的 servers</span></span><br><span class="line">    <span class="keyword">return</span> cluster</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>##### (3). session.newSession()---<p>创建新 Session, 函数原型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSession</span><span class="params">(consistency Mode, cluster *mongoCluster, timeout time.Duration)</span> <span class="params">(session *Session)</span></span> &#123;</span><br><span class="line">    cluster.Acquire()</span><br><span class="line">    session = &amp;Session&#123;</span><br><span class="line">        cluster_: cluster,</span><br><span class="line">        syncTimeout: timeout,</span><br><span class="line">        sockTimeout: timeout,</span><br><span class="line">        poolLimit: <span class="number">4096</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    debugf(<span class="string">"New session %p on cluster %p"</span>, session, cluster)</span><br><span class="line">    session.SetMode(consistency, <span class="literal">true</span>)    session.SetSafe(&amp;Safe&#123;&#125;)</span><br><span class="line">    session.queryConfig.prefetch = defaultPrefetch</span><br><span class="line">    <span class="keyword">return</span> session</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>session 有两个 socket， 一个是 masterSocket， 一个是 slaveSocket， 如果 masterSocket 是 nil 的话， 那么 slaveOk 就是true。</p><p><strong>注意：</strong> 在 newSession() 的时候，这两个 sockets 都不会初始化，所以一直会是 nil。<br><span class="redBold">直到真正调用 query 去查询数据库的时候才会通过 session.acqureSocket() 去新建一个 socket！</span></p><p>详细代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c := session.DB(<span class="string">"lanxin"</span>).C(<span class="string">"user_message_to_audit_t"</span>)</span><br><span class="line"><span class="keyword">var</span> res <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err = c.Find(bson.M&#123;<span class="string">"audit_message_id"</span>: <span class="number">99</span>&#125;).One(&amp;res)</span><br></pre></td></tr></table></figure><p>collection.Find() 函数返回一个 Query 对象，<br>Query 对象的 One()函数（linenumber 3032）里面调用 socket, err := session.acquireSocket(true)，<br><span class="redBold">这时候才真正创建一个 socket！</span></p><p>session 的 acquireSocket 定义在 <em>linenumber 4360</em></p><p>详细代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Query)</span> <span class="title">One</span><span class="params">(result <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    q.m.Lock()</span><br><span class="line">    session := q.session</span><br><span class="line">    op := q.op <span class="comment">// Copy.</span></span><br><span class="line">    q.m.Unlock()</span><br><span class="line">    socket, err := session.acquireSocket(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> socket.Release()</span><br><span class="line">    op.limit = <span class="number">-1</span></span><br><span class="line">    session.prepareQuery(&amp;op)</span><br><span class="line">    expectFindReply := prepareFindOp(socket, &amp;op, <span class="number">1</span>)</span><br><span class="line">    data, err := socket.SimpleQuery(&amp;op)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> data == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrNotFound</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> expectFindReply &#123;</span><br><span class="line">        <span class="keyword">var</span> findReply <span class="keyword">struct</span> &#123;</span><br><span class="line">            Ok <span class="keyword">bool</span></span><br><span class="line">            Code <span class="keyword">int</span></span><br><span class="line">            Errmsg <span class="keyword">string</span></span><br><span class="line">            Cursor cursorData</span><br><span class="line">        &#125;</span><br><span class="line">        err = bson.Unmarshal(data, &amp;findReply)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !findReply.Ok &amp;&amp; findReply.Errmsg != <span class="string">""</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;QueryError&#123;Code: findReply.Code, Message: findReply.Errmsg&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(findReply.Cursor.FirstBatch) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ErrNotFound</span><br><span class="line">        &#125;</span><br><span class="line">        data = findReply.Cursor.FirstBatch[<span class="number">0</span>].Data</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> result != <span class="literal">nil</span> &#123;</span><br><span class="line">        err = bson.Unmarshal(data, result)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            debugf(<span class="string">"Query %p document unmarshaled: %#v"</span>, q, result)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            debugf(<span class="string">"Query %p document unmarshaling failed: %#v"</span>, q, err)</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> checkQueryError(op.collection, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = c.Find(bson.M&#123;<span class="string">"audit_message_id"</span>: <span class="number">99</span>&#125;).All(&amp;res)</span><br></pre></td></tr></table></figure><p>会调用 Query 对象的 All() 函数， All() 内部会调用 q.Iter().All()<br>Iter() 里面会调用 socket, err := session.acquireSocket(true) 来新建一个 socket！</p><p>详细代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Query)</span> <span class="title">Iter</span><span class="params">()</span> *<span class="title">Iter</span></span> &#123;</span><br><span class="line">    q.m.Lock()</span><br><span class="line">    session := q.session</span><br><span class="line">    op := q.op</span><br><span class="line">    prefetch := q.prefetch</span><br><span class="line">    limit := q.limit</span><br><span class="line">    q.m.Unlock()</span><br><span class="line">    iter := &amp;Iter&#123;</span><br><span class="line">        session: session,</span><br><span class="line">        prefetch: prefetch,</span><br><span class="line">        limit: limit,</span><br><span class="line">        timeout: <span class="number">-1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    iter.gotReply.L = &amp;iter.m</span><br><span class="line">    iter.op.collection = op.collection</span><br><span class="line">    iter.op.limit = op.limit</span><br><span class="line">    iter.op.replyFunc = iter.replyFunc()</span><br><span class="line">    iter.docsToReceive++</span><br><span class="line">    socket, err := session.acquireSocket(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        iter.err = err</span><br><span class="line">        <span class="keyword">return</span> iter</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> socket.Release()</span><br><span class="line">    session.prepareQuery(&amp;op)</span><br><span class="line">    op.replyFunc = iter.op.replyFunc</span><br><span class="line">    <span class="keyword">if</span> prepareFindOp(socket, &amp;op, limit) &#123;</span><br><span class="line">        iter.findCmd = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    iter.server = socket.Server()</span><br><span class="line">    err = socket.Query(&amp;op)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Must lock as the query is already out and it may call replyFunc.</span></span><br><span class="line">        iter.m.Lock()</span><br><span class="line">        iter.err = err</span><br><span class="line">        iter.m.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面解读处理连接过程的代码</p><br>###### (1). session.acquireSocket()---session.acquireSocket() 会先判断是否已经存在 masterSocket 和 slaveSocket， 如果都为 nil。 那么就会调用 cluster.AcquireSocket()， session 拿到新创建的 socket 之后， 调用 setSocket(socket) -> socket.Acquire() 返回 serverInfo， 通过 serverInfo.Master 来判断是 master 还是 slave,然后相应的设置 s.masterSocket 和 s.slaveSocket<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span> <span class="title">acquireSocket</span><span class="params">(slaveOk <span class="keyword">bool</span>)</span> <span class="params">(*mongoSocket, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Read-only lock to check for previously reserved socket.</span></span><br><span class="line">    s.m.RLock()</span><br><span class="line">    <span class="comment">// If there is a slave socket reserved and its use is acceptable, take it as long</span></span><br><span class="line">    <span class="comment">// as there isn't a master socket which would be preferred by the read preference mode.</span></span><br><span class="line">    <span class="keyword">if</span> s.slaveSocket != <span class="literal">nil</span> &amp;&amp; s.slaveOk &amp;&amp; slaveOk &amp;&amp; (s.masterSocket == <span class="literal">nil</span> || s.consistency != PrimaryPreferred &amp;&amp; s.consistency != Monotonic) &#123;</span><br><span class="line">        socket := s.slaveSocket</span><br><span class="line">        socket.Acquire()</span><br><span class="line">        s.m.RUnlock()</span><br><span class="line">        <span class="keyword">return</span> socket, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.masterSocket != <span class="literal">nil</span> &#123;</span><br><span class="line">        socket := s.masterSocket</span><br><span class="line">        socket.Acquire()</span><br><span class="line">        s.m.RUnlock()</span><br><span class="line">        <span class="keyword">return</span> socket, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    s.m.RUnlock()</span><br><span class="line">    <span class="comment">// No go. We may have to request a new socket and change the session,</span></span><br><span class="line">    <span class="comment">// so try again but with an exclusive lock now.</span></span><br><span class="line">    s.m.Lock()</span><br><span class="line">    <span class="keyword">defer</span> s.m.Unlock()</span><br><span class="line">    <span class="keyword">if</span> s.slaveSocket != <span class="literal">nil</span> &amp;&amp; s.slaveOk &amp;&amp; slaveOk &amp;&amp; (s.masterSocket == <span class="literal">nil</span> || s.consistency != PrimaryPreferred &amp;&amp; s.consistency != Monotonic) &#123;</span><br><span class="line">        s.slaveSocket.Acquire()</span><br><span class="line">        <span class="keyword">return</span> s.slaveSocket, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.masterSocket != <span class="literal">nil</span> &#123;</span><br><span class="line">        s.masterSocket.Acquire()</span><br><span class="line">        <span class="keyword">return</span> s.masterSocket, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Still not good. We need a new socket.</span></span><br><span class="line">    sock, err := s.cluster().AcquireSocket(s.consistency, slaveOk &amp;&amp; s.slaveOk, s.syncTimeout, s.sockTimeout, s.queryConfig.op.serverTags, s.poolLimit)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Authenticate the new socket.</span></span><br><span class="line">    <span class="keyword">if</span> err = s.socketLogin(sock); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        sock.Release()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Keep track of the new socket, if necessary.</span></span><br><span class="line">    <span class="comment">// Note that, as a special case, if the Eventual session was</span></span><br><span class="line">    <span class="comment">// not refreshed (s.slaveSocket != nil), it means the developer</span></span><br><span class="line">    <span class="comment">// asked to preserve an existing reserved socket, so we'll</span></span><br><span class="line">    <span class="comment">// keep a master one around too before a Refresh happens.</span></span><br><span class="line">    <span class="keyword">if</span> s.consistency != Eventual || s.slaveSocket != <span class="literal">nil</span> &#123;</span><br><span class="line">        s.setSocket(sock)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Switch over a Monotonic session to the master.</span></span><br><span class="line">    <span class="keyword">if</span> !slaveOk &amp;&amp; s.consistency == Monotonic &#123;</span><br><span class="line">        s.slaveOk = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sock, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span> <span class="title">setSocket</span><span class="params">(socket *mongoSocket)</span></span> &#123;</span><br><span class="line">    info := socket.Acquire()</span><br><span class="line">    <span class="keyword">if</span> info.Master &#123;</span><br><span class="line">        <span class="keyword">if</span> s.masterSocket != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"setSocket(master) with existing master socket reserved"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        s.masterSocket = socket</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> s.slaveSocket != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"setSocket(slave) with existing slave socket reserved"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        s.slaveSocket = socket</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>###### (2). cluster.AcquireSocket()---<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cluster *mongoCluster)</span> <span class="title">AcquireSocket</span><span class="params">(mode Mode, slaveOk <span class="keyword">bool</span>, syncTimeout time.Duration, socketTimeout time.Duration, serverTags []bson.D, poolLimit <span class="keyword">int</span>)</span> <span class="params">(s *mongoSocket, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> started time.Time</span><br><span class="line">    <span class="keyword">var</span> syncCount <span class="keyword">uint</span></span><br><span class="line">    warnedLimit := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        cluster.RLock()</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            mastersLen := cluster.masters.Len()</span><br><span class="line">            slavesLen := cluster.servers.Len() - mastersLen</span><br><span class="line">            debugf(<span class="string">"Cluster has %d known masters and %d known slaves."</span>, mastersLen, slavesLen)</span><br><span class="line">            <span class="keyword">if</span> mastersLen &gt; <span class="number">0</span> &amp;&amp; !(slaveOk &amp;&amp; mode == Secondary) || slavesLen &gt; <span class="number">0</span> &amp;&amp; slaveOk &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> mastersLen &gt; <span class="number">0</span> &amp;&amp; mode == Secondary &amp;&amp; cluster.masters.HasMongos() &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> started.IsZero() &#123;</span><br><span class="line">                <span class="comment">// Initialize after fast path above.</span></span><br><span class="line">                started = time.Now()</span><br><span class="line">                syncCount = cluster.syncCount</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> syncTimeout != <span class="number">0</span> &amp;&amp; started.Before(time.Now().Add(-syncTimeout)) || cluster.failFast &amp;&amp; cluster.syncCount != syncCount &#123;</span><br><span class="line">                cluster.RUnlock()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"no reachable servers"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            log(<span class="string">"Waiting for servers to synchronize..."</span>)</span><br><span class="line">            cluster.syncServers()</span><br><span class="line">            <span class="comment">// Remember: this will release and reacquire the lock.</span></span><br><span class="line">            cluster.serverSynced.Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> server *mongoServer                   <span class="comment">// 这里的 server 会取一个 Best Fit 的！</span></span><br><span class="line">        <span class="keyword">if</span> slaveOk &#123;</span><br><span class="line">            server = cluster.servers.BestFit(mode, serverTags)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            server = cluster.masters.BestFit(mode, <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        cluster.RUnlock()</span><br><span class="line">        <span class="keyword">if</span> server == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// Must have failed the requested tags. Sleep to avoid spinning.</span></span><br><span class="line">            time.Sleep(<span class="number">1e8</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        s, abended, err := server.AcquireSocket(poolLimit, socketTimeout)</span><br><span class="line">        <span class="keyword">if</span> err == errPoolLimit &#123;</span><br><span class="line">            <span class="keyword">if</span> !warnedLimit &#123;</span><br><span class="line">                warnedLimit = <span class="literal">true</span></span><br><span class="line">                log(<span class="string">"WARNING: Per-server connection limit reached."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            cluster.removeServer(server)</span><br><span class="line">            cluster.syncServers()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> abended &amp;&amp; !slaveOk &#123;</span><br><span class="line">            <span class="keyword">var</span> result isMasterResult</span><br><span class="line">            err := cluster.isMaster(s, &amp;result)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> || !result.IsMaster &#123;</span><br><span class="line">                logf(<span class="string">"Cannot confirm server %s as master (%v)"</span>, server.Addr, err)</span><br><span class="line">                s.Release()</span><br><span class="line">                cluster.syncServers()</span><br><span class="line">                time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"unreached"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>###### 3. server.AcquireSocket()----<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcquireSocket returns a socket for communicating with the server.</span></span><br><span class="line"><span class="comment">// This will attempt to reuse an old connection, if one is available. Otherwise,</span></span><br><span class="line"><span class="comment">// it will establish a new one. The returned socket is owned by the call site,</span></span><br><span class="line"><span class="comment">// and will return to the cache when the socket has its Release method called</span></span><br><span class="line"><span class="comment">// the same number of times as AcquireSocket + Acquire were called for it.</span></span><br><span class="line"><span class="comment">// If the poolLimit argument is greater than zero and the number of sockets in</span></span><br><span class="line"><span class="comment">// use in this server is greater than the provided limit, errPoolLimit is</span></span><br><span class="line"><span class="comment">// returned.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *mongoServer)</span> <span class="title">AcquireSocket</span><span class="params">(poolLimit <span class="keyword">int</span>, timeout time.Duration)</span> <span class="params">(socket *mongoSocket, abended <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        server.Lock()</span><br><span class="line">        abended = server.abended</span><br><span class="line">        <span class="keyword">if</span> server.closed &#123;</span><br><span class="line">            server.Unlock()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, abended, errServerClosed</span><br><span class="line">        &#125;</span><br><span class="line">        n := <span class="built_in">len</span>(server.unusedSockets)</span><br><span class="line">        <span class="keyword">if</span> poolLimit &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(server.liveSockets)-n &gt;= poolLimit &#123;</span><br><span class="line">            server.Unlock()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, errPoolLimit</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">            socket = server.unusedSockets[n<span class="number">-1</span>]</span><br><span class="line">            server.unusedSockets[n<span class="number">-1</span>] = <span class="literal">nil</span> <span class="comment">// Help GC.</span></span><br><span class="line">            server.unusedSockets = server.unusedSockets[:n<span class="number">-1</span>]</span><br><span class="line">            info := server.info</span><br><span class="line">            server.Unlock()</span><br><span class="line">            err = socket.InitialAcquire(info, timeout)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            server.Unlock()</span><br><span class="line">            socket, err = server.Connect(timeout)</span><br><span class="line">            <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">                server.Lock()</span><br><span class="line">                <span class="comment">// We've waited for the Connect, see if we got closed in the meantime</span></span><br><span class="line">                <span class="keyword">if</span> server.closed &#123;</span><br><span class="line">                    server.Unlock()</span><br><span class="line">                    socket.Release()</span><br><span class="line">                    socket.Close()</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span>, abended, errServerClosed</span><br><span class="line">                &#125;</span><br><span class="line">                server.liveSockets = <span class="built_in">append</span>(server.liveSockets, socket)        <span class="comment">// 获得新建的 socket 之后， 就放在 server.liveSockets 列表里！  </span></span><br><span class="line">                server.Unlock()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"unreachable"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>###### (4). server.Connect()----<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connect establishes a new connection to the server. This should generally be done through server.AcquireSocket().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *mongoServer)</span> <span class="title">Connect</span><span class="params">(timeout time.Duration)</span> <span class="params">(*mongoSocket, error)</span></span> &#123;</span><br><span class="line">    server.RLock()</span><br><span class="line">    master := server.info.Master</span><br><span class="line">    dial := server.dial</span><br><span class="line">    server.RUnlock()</span><br><span class="line">    logf(<span class="string">"Establishing new connection to %s (timeout=%s)..."</span>, server.Addr, timeout)</span><br><span class="line">    <span class="keyword">var</span> conn net.Conn</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> !dial.isSet():</span><br><span class="line">        <span class="comment">// Cannot do this because it lacks timeout support. :-(</span></span><br><span class="line">        <span class="comment">//conn, err = net.DialTCP("tcp", nil, server.tcpaddr)</span></span><br><span class="line">        conn, err = net.DialTimeout(<span class="string">"tcp"</span>, server.ResolvedAddr, timeout)               <span class="comment">// 1. 这里是真正的 dial， 建立连接！</span></span><br><span class="line">        <span class="keyword">if</span> tcpconn, ok := conn.(*net.TCPConn); ok &#123;</span><br><span class="line">            tcpconn.SetKeepAlive(<span class="literal">true</span>)                                                  <span class="comment">// 2. 建立连接之后设置 keepAlive ！ </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"internal error: obtained TCP connection is not a *net.TCPConn!?"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> dial.old != <span class="literal">nil</span>:</span><br><span class="line">        conn, err = dial.old(server.tcpaddr)</span><br><span class="line">    <span class="keyword">case</span> dial.<span class="built_in">new</span> != <span class="literal">nil</span>:</span><br><span class="line">        conn, err = dial.<span class="built_in">new</span>(&amp;ServerAddr&#123;server.Addr, server.tcpaddr&#125;)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"dialer is set, but both dial.old and dial.new are nil"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logf(<span class="string">"Connection to %s failed: %v"</span>, server.Addr, err.Error())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    logf(<span class="string">"Connection to %s established."</span>, server.Addr)</span><br><span class="line">    stats.conn(+<span class="number">1</span>, master)</span><br><span class="line">    <span class="keyword">return</span> newSocket(server, conn, timeout), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>###### (5). socket.newSocket()----通过 dial 建立一个 conn 之后， 需要新建一个 socket struct， 把 conn 存进去。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSocket</span><span class="params">(server *mongoServer, conn net.Conn, timeout time.Duration)</span> *<span class="title">mongoSocket</span></span> &#123;</span><br><span class="line">    socket := &amp;mongoSocket&#123;</span><br><span class="line">        conn: conn,                                <span class="comment">// 这里把新连接的 conn 存给了 sockt 对象</span></span><br><span class="line">        addr: server.Addr,</span><br><span class="line">        server: server,</span><br><span class="line">        replyFuncs: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint32</span>]replyFunc),</span><br><span class="line">    &#125;</span><br><span class="line">    socket.gotNonce.L = &amp;socket.Mutex</span><br><span class="line">    <span class="keyword">if</span> err := socket.InitialAcquire(server.Info(), timeout); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"newSocket: InitialAcquire returned error: "</span> + err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    stats.socketsAlive(+<span class="number">1</span>)</span><br><span class="line">    debugf(<span class="string">"Socket %p to %s: initialized"</span>, socket, socket.addr)</span><br><span class="line">    socket.resetNonce()</span><br><span class="line">    <span class="keyword">go</span> socket.readLoop()</span><br><span class="line">    <span class="keyword">return</span> socket</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>###### 6. socket.InitialAcquire()---在新建一个 socket （尚未有人使用, 即 ref == 0）时，或者 从 pool 里面取出一个空闲的（ref == 0）时，需要调用这个 InitialAcquire() 把 ref + 1<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InitialAcquire obtains the first reference to the socket, either right after the connection is made </span></span><br><span class="line"><span class="comment">// or once a recycled socket is fetched from pool for reuse.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(socket *mongoSocket)</span> <span class="title">InitialAcquire</span><span class="params">(serverInfo *mongoServerInfo, timeout time.Duration)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    socket.Lock()</span><br><span class="line">    <span class="keyword">if</span> socket.references &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"Socket acquired out of cache with references"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> socket.dead != <span class="literal">nil</span> &#123;</span><br><span class="line">        dead := socket.dead</span><br><span class="line">        socket.Unlock()</span><br><span class="line">        <span class="keyword">return</span> dead</span><br><span class="line">    &#125;</span><br><span class="line">    socket.references++</span><br><span class="line">    socket.serverInfo = serverInfo</span><br><span class="line">    socket.timeout = timeout</span><br><span class="line">    stats.socketsInUse(+<span class="number">1</span>)</span><br><span class="line">    stats.socketRefs(+<span class="number">1</span>)</span><br><span class="line">    socket.Unlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>##### 关闭连接---<p>session.Close() -&gt; session.unsetSocket() -&gt; socket.Release()<br>                -&gt; cluster.Release() -&gt; for … range –&gt; server.Close() -&gt;<br>                        for … range { liveSockets, unusedSockets } -&gt; socket.Close() -&gt; socket.Kill()</p><br>###### (1). session.Close()----<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.m.Lock()</span><br><span class="line">    <span class="keyword">if</span> s.cluster_ != <span class="literal">nil</span> &#123;</span><br><span class="line">        debugf(<span class="string">"Closing session %p"</span>, s)</span><br><span class="line">        s.unsetSocket()              <span class="comment">// 1. ref--， logout credential</span></span><br><span class="line">        s.cluster_.Release()         <span class="comment">// 2. cluster 中所有 server 里存的 liveSockets 和 unusedSockets 全部 close()</span></span><br><span class="line">        s.cluster_ = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    s.m.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>###### (2). session.unsetSocket()---<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span> <span class="title">unsetSocket</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s.masterSocket != <span class="literal">nil</span> &#123;</span><br><span class="line">        s.masterSocket.Release()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.slaveSocket != <span class="literal">nil</span> &#123;</span><br><span class="line">        s.slaveSocket.Release()</span><br><span class="line">    &#125;</span><br><span class="line">    s.masterSocket = <span class="literal">nil</span></span><br><span class="line">    s.slaveSocket = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>###### (3). socket.Release()---socket.Release() 函数里面会先判断引用计数是否为0， 为0的话就close， 否则 references--<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(socket *mongoSocket)</span> <span class="title">Release</span><span class="params">()</span></span> &#123;</span><br><span class="line">    socket.Lock()</span><br><span class="line">    <span class="keyword">if</span> socket.references == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"socket.Release() with references == 0"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    socket.references--</span><br><span class="line">    stats.socketRefs(<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> socket.references == <span class="number">0</span> &#123;</span><br><span class="line">        stats.socketsInUse(<span class="number">-1</span>)</span><br><span class="line">        server := socket.server</span><br><span class="line">        socket.Unlock()</span><br><span class="line">        socket.LogoutAll()</span><br><span class="line">        <span class="comment">// If the socket is dead server is nil.</span></span><br><span class="line">        <span class="keyword">if</span> server != <span class="literal">nil</span> &#123;</span><br><span class="line">            server.RecycleSocket(socket)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        socket.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>###### (4). cluster.Release()---<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cluster *mongoCluster)</span> <span class="title">Release</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cluster.Lock()</span><br><span class="line">    <span class="keyword">if</span> cluster.references == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"cluster.Release() with references == 0"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    cluster.references--</span><br><span class="line">    debugf(<span class="string">"Cluster %p released (refs=%d)"</span>, cluster, cluster.references)</span><br><span class="line">    <span class="keyword">if</span> cluster.references == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, server := <span class="keyword">range</span> cluster.servers.Slice() &#123;</span><br><span class="line">            server.Close()                         <span class="comment">// 注意： 在这里关闭 server 中的所有 sockets</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Wake up the sync loop so it can die.</span></span><br><span class="line">        cluster.syncServers()</span><br><span class="line">        stats.cluster(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    cluster.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>###### (5). server.Close()---<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *mongoServer)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">    server.Lock()</span><br><span class="line">    server.closed = <span class="literal">true</span></span><br><span class="line">    liveSockets := server.liveSockets</span><br><span class="line">    unusedSockets := server.unusedSockets</span><br><span class="line">    server.liveSockets = <span class="literal">nil</span></span><br><span class="line">    server.unusedSockets = <span class="literal">nil</span></span><br><span class="line">    server.Unlock()</span><br><span class="line">    logf(<span class="string">"Connections to %s closing (%d live sockets)."</span>, server.Addr, <span class="built_in">len</span>(liveSockets))</span><br><span class="line">    <span class="keyword">for</span> i, s := <span class="keyword">range</span> liveSockets &#123;</span><br><span class="line">        s.Close()                             <span class="comment">// 注意： 这里关闭 socket</span></span><br><span class="line">        liveSockets[i] = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> unusedSockets &#123;</span><br><span class="line">        unusedSockets[i] = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>###### (6). socket.Close()---<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(socket *mongoSocket)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">    socket.kill(errors.New(<span class="string">"Closed explicitly"</span>), <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>###### 7. sockete.kill()----<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(socket *mongoSocket)</span> <span class="title">kill</span><span class="params">(err error, abend <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    socket.Lock()</span><br><span class="line">    <span class="keyword">if</span> socket.dead != <span class="literal">nil</span> &#123;</span><br><span class="line">        debugf(<span class="string">"Socket %p to %s: killed again: %s (previously: %s)"</span>, socket, socket.addr, err.Error(), socket.dead.Error())</span><br><span class="line">        socket.Unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    logf(<span class="string">"Socket %p to %s: closing: %s (abend=%v)"</span>, socket, socket.addr, err.Error(), abend)</span><br><span class="line">    socket.dead = err</span><br><span class="line">    socket.conn.Close()                        <span class="comment">// 注意： 这里是真正关闭连接！ </span></span><br><span class="line">    stats.socketsAlive(<span class="number">-1</span>)</span><br><span class="line">    replyFuncs := socket.replyFuncs</span><br><span class="line">    socket.replyFuncs = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint32</span>]replyFunc)</span><br><span class="line">    server := socket.server</span><br><span class="line">    socket.server = <span class="literal">nil</span></span><br><span class="line">    socket.gotNonce.Broadcast()</span><br><span class="line">    socket.Unlock()</span><br><span class="line">    <span class="keyword">for</span> _, replyFunc := <span class="keyword">range</span> replyFuncs &#123;</span><br><span class="line">        logf(<span class="string">"Socket %p to %s: notifying replyFunc of closed socket: %s"</span>, socket, socket.addr, err.Error())</span><br><span class="line">        replyFunc(err, <span class="literal">nil</span>, <span class="number">-1</span>, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> abend &#123;</span><br><span class="line">        server.AbendSocket(socket)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span class="redBold">注意：只有两个地方会调用 conn.Close() 也就是真正的关闭一个连接。</span></p><ul><li>1) 一个是使用 udp trick 去获得一个 tcp 地址的时候， 如果udp 连接成功了， 就获得了 ip 地址，<br>由于目的只是为了获得一个 ip， 所以获得之后就把连接关闭。</li><li>2) 另外一个就是在 socket.kill() 里面 调用 conn.Close() 关闭连接。</li></ul><p><strong>结论：只要程序没有终止，已经获得的连接 conn 永远不会自动关闭， cluster.reference 永远至少是 1。</strong></p><p>Socket 模块通过引用计数的方式来管理所有已连接的和未连接的 sockets， 从 pool（实际上就是一个 []*mongoSocket 数组） 里面取一个 socket，<br>调用 Acquire() 函数会把 referece++， </p><p>调用 Session.Copy() 时会把 Cluster.reference++, 然后判断 session.masterSocket, session.slaveSocket 是否不为nil的话，就复用这个 socket。<br>否则就</p><p>压力测试</p><pre><code>$ ab -n100  -c1000 localhost/</code></pre><p>查询连接数</p><pre><code>$ netstat -n| awk &apos;/^tcp/{++S[$NF]}END{for (key in S) print key,S[key]}&apos;</code></pre><p><strong>建议：对于数据库的连接来说，应该通过应用程序来控制并发连接数，而不是通过 pool 大小来控制并发连接数。</strong></p><br><br><br><h6 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h6><hr><p><a href="https://github.com/go-mgo/mgo" target="_blank" rel="noopener">https://github.com/go-mgo/mgo</a><br><a href="http://www.cnblogs.com/shenguanpu/p/5318727.html" target="_blank" rel="noopener">http://www.cnblogs.com/shenguanpu/p/5318727.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mgo source</title>
      <link href="/Programming/go-mgo-source-structure/"/>
      <url>/Programming/go-mgo-source-structure/</url>
      
        <content type="html"><![CDATA[<p>源码地址：<br><a href="https://github.com/go-mgo/mgo" target="_blank" rel="noopener">https://github.com/go-mgo/mgo</a></p><h4 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h4><p><img src="/image/mgo_source.png" alt=""></p><h4 id="最核心的-4个文件"><a href="#最核心的-4个文件" class="headerlink" title="最核心的 4个文件:"></a>最核心的 4个文件:</h4><p><span class="red">679  ./cluster.go</span><br><span class="red">452  ./server.go</span><br><span class="red">4722 ./session.go</span><br><span class="red">707  ./socket.go</span></p><pre>$ wc -l `find ./ -name "*.go"`   467 ./auth.go  1180 ./auth_test.go   721 ./bson/bson.go  1823 ./bson/bson_test.go   844 ./bson/decode.go   509 ./bson/encode.go   241 ./bson/specdata_test.go   351 ./bulk.go   504 ./bulk_test.go   <span class="red">679 ./cluster.go</span>  1978 ./cluster_test.go   196 ./dbtest/dbserver.go   108 ./dbtest/dbserver_test.go    12 ./dbtest/export_test.go    31 ./doc.go    33 ./export_test.go   761 ./gridfs.go   708 ./gridfs_test.go   138 ./internal/sasl/sasl.go   140 ./internal/sasl/sasl_windows.go   266 ./internal/scram/scram.go    67 ./internal/scram/scram_test.go   133 ./log.go    91 ./queue.go   101 ./queue_test.go     5 ./raceoff.go     5 ./raceon.go    11 ./saslimpl.go    11 ./saslstub.go   <span class="red">452 ./server.go</span>  <span class="red">4722 ./session.go</span>  4127 ./session_test.go   <span class="red">707 ./socket.go</span>   147 ./stats.go   259 ./suite_test.go    15 ./syscall_test.go    11 ./syscall_windows_test.go    12 ./testserver/export_test.go   168 ./testserver/testserver.go   108 ./testserver/testserver_test.go    68 ./txn/chaos.go   109 ./txn/debug.go   205 ./txn/dockey_test.go   985 ./txn/flusher.go   101 ./txn/mgo_test.go   388 ./txn/sim_test.go    94 ./txn/tarjan.go    44 ./txn/tarjan_test.go   611 ./txn/txn.go   753 ./txn/txn_test.go 26200 total</pre>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redigo test report</title>
      <link href="/Programming/go-redigo-analysis/"/>
      <url>/Programming/go-redigo-analysis/</url>
      
        <content type="html"><![CDATA[<p>Redigo 一款开源的 redis driver，用于处理 redis 数据库请求, 使用 Go 语言实现。</p><p>使用 redigo 需要注意相关重要参数，因为这直接涉及到对程序性能的影响。本文总结了 redigo 的一些性能测试结果。</p><p>MaxActive 表示客户端最大能发起的连接的个数，也就是：如果客户端发起的连接数达到了 Maxactive ，再发起连接的话会等待， 而不会再创建连接。</p><p>MaxIdle 表示 pool 里面最大连接数。</p><p>测试发现，如果 MaxActive 设置得很大，反而比设置的小的时候，查询耗时多。</p><p>可能的原因是：对于简单查询（单个查询耗时极短，可能 0.几 ms）来说，创建更多的连接产生了开销, 还不如等个 0.几 ms，也就是等上一个连接回收之后，直接复用那个连接，这样所产生的耗时更少。</p><p>数据：</p><table><thead><tr><th>MaxActive</th><th>连接数</th><th>耗时  ms</th></tr></thead><tbody><tr><td>100</td><td>5000</td><td>271.1 - 220.2</td></tr><tr><td>1000</td><td>5000</td><td>240.0 - 329.5</td></tr><tr><td>1000</td><td>5000</td><td>270.0 - 337.0</td></tr><tr><td>1000</td><td>10000</td><td>585.3 - 793.3</td></tr></tbody></table><table><thead><tr><th>MaxIdle</th><th>MaxActive</th><th>连接数</th><th>耗时(ms)</th></tr></thead><tbody><tr><td>1000</td><td>5000</td><td>5000</td><td>268.5 - 290</td></tr><tr><td>1000</td><td>5000</td><td>10000</td><td>585.5 - inf</td></tr><tr><td>5000</td><td>5000</td><td>10000</td><td>552.5 - inf</td></tr></tbody></table><br>###### 连接复用如果连接池大小（MaxIdle）是1000， 客户端发起 1w 个连接，但是每个连接处理时间很短， 1w 中的后面几千个连接的时候前面 几百个已经处理完了，所以可以复用。最终会出现，虽然发起了 1w 个连接， 但是连接池大小却只有几百。 这个原因主要就是因为每个连接处理时间太短，从而被后面的复用了， 因此没有新开连接。]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cache Introductions</title>
      <link href="/System-Programming/core-techs-linux-cache/"/>
      <url>/System-Programming/core-techs-linux-cache/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> System Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Crash Consistency - FSCK and Journaling</title>
      <link href="/SystemProgramming/core-techs-filesystem-crash-consistency/"/>
      <url>/SystemProgramming/core-techs-filesystem-crash-consistency/</url>
      
        <content type="html"><![CDATA[<p>英文原文：<br><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/file-journaling.pdf" target="_blank" rel="noopener">Crash Consistency - FSCK and Journaling</a></p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>本文讲述两种方法来增强文件系统的健壮性，也就是说机器的突然故障对数据造成的影响可以被恢复。第一种被称之为FSCK(File System Checker)，说白了就是扫描整个磁盘按照各种情况进行恢复，本文对它不感兴趣（因为复杂且不实用，喜欢的可以看后面的参考资料）；第二种是Journaling方法，这个是重点。</p><h2 id="2-The-Crash-Consistency-Problem"><a href="#2-The-Crash-Consistency-Problem" class="headerlink" title="2. The Crash Consistency Problem"></a>2. The Crash Consistency Problem</h2><p>为什么这个问题会存在呢？如果说所有的磁盘写操作都是原子操作，那岂不是就没这个问题了么？最多给Cache也换成那种断点数据不丢失的存储介质。但是事实上，做不到原子啊，天知道在传输的哪一步出问题，而且也不能指望出问题后这个失败的操作没有后遗症。</p><h2 id="3-FSCK"><a href="#3-FSCK" class="headerlink" title="3. FSCK"></a>3. FSCK</h2><p>不准备详细介绍这个方法，一句话总结：“丢了一把钥匙，我却要翻遍整个屋子”。</p><h2 id="4-Journaling"><a href="#4-Journaling" class="headerlink" title="4. Journaling"></a>4. Journaling</h2><p>其实这个又被称作Write-Ahead Logging，跟之前说到的Log-Structure的思想差不多，也就是在更新文件状态前先写数据，这两者有着严格的时间先后顺序。简单来说就是先把数据写入磁盘中的Journaling中，确保写入完成之后再将数据写入到它们最终的地址同时更新状态表明写入成功。</p><p>首先看看这个Journaling跟文件系统是怎么共存在磁盘的。如下图：</p><p>好了，下面正式介绍这个操作吧。</p><p>data journaling<br>假设我们现在要往磁盘里面写入inode，bitmap以及一个datablock，那么为了确保安全，我们先将这些数据写入磁盘的Journaling中，同时我们存入这个操作的元数据，结果是这样子的：</p><p>其中的TxB表示translation begin，里面存储了操作的元数据，比如inode、bitmap、datanode的真实目的地址（就是最终要把这些数据存在哪儿）以及某种形式的Transection ID(TID)；TxE表明transection end，里面当然也包含了TID了。 那么整个的写入操作的过程是这样的:</p><p>Journal write：将上面提到的那个结果TxB和TxW包装的数据写入磁盘的Journaling区域，并且等候操作的完成；<br>Checkpoint: 将数据写入到它们最终目的地。<br>一个问题<br>上面这么操作可行么？答案是不可以，因为真实写操作的时候，磁盘内部可能因为调度而将写的顺序改变，也就是说并不一定是先写TxB，然后Inode 等等，所以可能出现磁盘除了data block外的结果块写完了，然后再去写data block而在这个过程中挂了。这样一来Journaling就认为希望完成了，而实际上却没有。<br>为了解决这个问题，只能分步写了，见下图：</p><p>Journal write: 写传输内容（包括TxB，metadata以及data），等候完成；<br>Journal commit：写TxE，等候完成；<br>Checkpoint：同上<br>Journaling空间管理<br>按照上面的操作，Journaling空间迟早被耗尽，所以怎么办，必须有空间回收机制。所以呢，就把整个Journaling当做一个环形存储，空间到头了就从头开始写。为了便于管理，新增一个Journal Super Block，见下图:</p><p>那么什么时候回收呢？很简单，每次checkpoint之后那些数据就没用了，所以就checkpoint之后回收吧。 以上这种叫做data journaling。</p><p>data journaling总体执行顺序</p><p>效率？ 按照上面的操作应该是可以执行了，但是效率是个问题，因为每个写操作都需要写两次，第一次写入journaling，然后再写到最终目的地。为了提高效率，就考虑直接将data写入到最终目的地。那么问题来了，什么时候写data。必须在Journal commit之前！！ 这种叫做metadata journaling。</p><p>data write:<br>Journal metadata write<br>Journal commit<br>checkpoint metadata<br>free<br>metadata journaling总体执行顺序</p><p>一个很玄乎的错误 这个错误是这样的，对于metadata journaling适用。磁盘地址1000出存储了文件夹foo的数据；此时，在这个文件夹下创建一个新文件，于是需要将文件夹foo的数据（这是metadata哦）做修改；然后，删除文件夹foo以及其包含的所有文件；然后写文件foobar，目的地址恰好也是在block1那边，于是一切正常；注意第一步第三步操作都没有被checkpoint，而第二步压根不需要Journaling。此时机器故障了，那么重启之后根据Journaling数据恢复，此时的Journaling是这样的：<br> 恢复的时候首先checkpoint第一步操作，于是将“修改后的文件夹数据”写入地位为1000的block；接着checkpoint文件foobar，由于是metadata journaling，所以foobar的数据本身是没有的，只有metadata。于是乎，foobar的数据永远丢失了<del>~</del><br>那么怎么处理这个问题呢？<br>有两种方法：</p><p>只有当被删除的block被从journal中checkpoint之后才去使用；也就是说block被删除之后，如果此时journal中还有关于这个block的操作没有被checkpoint，则不用这个block。<br>每次删除block后，将Journal中关于这个block的操作设置为revoked，那么恢复的时候，跳过所有的revoked操作。</p><p>参考：<br><a href="http://xubenbenhit.github.io/CrashConsistency.html" target="_blank" rel="noopener">http://xubenbenhit.github.io/CrashConsistency.html</a></p>]]></content>
      
      
      <categories>
          
          <category> SystemProgramming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fast File System</title>
      <link href="/SystemProgramming/core-techs-filesystem-ffs/"/>
      <url>/SystemProgramming/core-techs-filesystem-ffs/</url>
      
        <content type="html"><![CDATA[<p>英文原文：</p><ol><li><a href="https://people.eecs.berkeley.edu/~brewer/cs262/FFS.pdf" target="_blank" rel="noopener">A Fast File System for UNIX, 1984</a><br>作者：Marshall McKusick, William Joy, Samuel Leffler, Robert Fabry</li></ol><p>点评：<br>这篇文章可以说是 File System 里面最经典的文章之一。现在 Unix File System 也是 FFS 的延伸。</p><p>作者发现了 Old Unix System 的许多问题。做出了改进。</p><p>（1）首先，以前的 FS，由于硬件的限制，把 block size 设计的很小，只有 512KB<br>对于大文件的读取 overhead 很大。以读取一个 2MB 的文件为例，需要四次读取。 FFS 的block size 增加到 2MB, 大大减小了 overhead, 2MB 的文件只需要一次 disk access。但是大的 block size 也带来了问题，如果整个系统的文件都很小，比如只有 512KB，那么会浪费空间。</p><p>FFS 的解决方法是：<br>把 block 分为几个 fragments, 如果一个文件只占用了 block 的一部分，其它文件还可以继续使用。不浪费空间。</p><p>（2）其次，作者观察到以前的 FS 随着时间的推移，其 disk access time 会变得越来越大。<br>原因是一开始系统有一个 list of free space, 随着使用越来越多，删除，添加，更新文件。这个 free list 变成了一个 random list. 一个文件可能被放在相隔很远的 cylinder, 或者 sector 里面，读取一个 block 之后，disk head move 到下一个 block 需要花费很长时间。</p><p>FFS 的解决方案是：<br>给出 Global 和 local layout policy， 对文件或者文件夹位置的安排进行优化，尽量缩短 seek 的时间。但是也有缺点：当硬盘使用率非常高的时候，这个优化的时间会变得非常高，因此效率会大幅下降。</p><ol start="2"><li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/file-ffs.pdf" target="_blank" rel="noopener">Locality and The Fast File System</a></li></ol><p>FFS 是 对 VSFS 的一种优化改进使其可以被实际使用。</p><h2 id="1-FFS-基于-VSFS-的改进思想是什么？"><a href="#1-FFS-基于-VSFS-的改进思想是什么？" class="headerlink" title="1. FFS 基于 VSFS 的改进思想是什么？"></a>1. FFS 基于 VSFS 的改进思想是什么？</h2><p>这个呢，VSFS 在存储文件的时候，根本没有考虑磁盘的寻址时间，把磁盘当做了一种随机存储介质！事实上由于局域性原理的存在，依据局域性而对存储做相应改进是非常有助于性能提升的。FFS 则正是看到了这一点，其改进是将磁盘划分为多个子区域（Cylinder Groups），存储文件的时候同一文件夹下的文件尽可能放在同一个 Group。Cylinder Groups是FFS最大的改进来源。</p><h2 id="2-FFS文件系统的实现"><a href="#2-FFS文件系统的实现" class="headerlink" title="2. FFS文件系统的实现"></a>2. FFS文件系统的实现</h2><p>首先，FFS将磁盘划分为很多子区域，也就是很多个 Cylinder Groups，如下图：</p><p><img src="/image/filesystem/fs_cylinder_group.png" alt=""></p><p>每个组内的结构跟 VSFS 基本一样，对于这里面的 SuperBlock 每个组都会有。</p><p>文件存储<br>既然 FFS 号称利用局域性原理，那么具体是什么操作的呢？</p><ul><li>对于文件夹，它会选择一个包含文件夹少而且剩余的空闲 inode 数目多的组来存储；</li><li>对于文件，它确保一个文件的inode和data是属于同一个组的；而且，将同一文件夹的文件尽量放在一个组，这里面的“尽量”是考虑到大文件可能需要被存在好几个组。</li><li>大文件 大文件是需要特殊处理的，因为否则的话因为组内空间被大文件大量占用，这就会使得很难实现“相关文件放一起”的那个使用局域性原理的设计。那么大文件就必须被“分割”为多块分别存储在各个组内，那么如何设定这个切割的大小呢，或者说大文件的每一块设置为多大。<br>这个需要一点计算。设置大文件切割大小核心在于，设置的太小了，那么读取它的时候影响效率（因为是需要额外寻址的，如果太小，这总的传输效率低）。假设磁盘的平均寻址时间是10ms，那么为了达到一半的传输效率，这意思是说磁盘真正用来传数据的时候和寻址时间相同，假设磁盘传输效率是40MB/s，那么10ms传输的数据是409.6KB。换句话说，只需要409KB，就可使的传输效率为50%。事实上，大约3.7MB就可使得磁盘平均传输效率为90%。所以，切割大小设置为4M左右就可以了。</li></ul><p>FFS 的设计者挺聪明的，其实按照之前的 VSFS 的设计，每个 inode 里面会有15个块指针用来索引文件占用磁盘块的，前面12个直接索引可表示12*4KB=48KB的空间，而一级间接索引就可表示4M的空间。所以除了前48KB，之后的每4M数据均放置在不同的组内，这个刚好可以使用一一级间接索引表示。</p><h2 id="3-FFS-设计细节"><a href="#3-FFS-设计细节" class="headerlink" title="3. FFS 设计细节"></a>3. FFS 设计细节</h2><p>小文件问题 这个是说很多文件太小了，用一个磁盘块（4KB）存储有点浪费空间啊！！所以呢，FFS 引入sub-blocks这个概念，一般是512B，也就是一个sector扇区的大小。那么这样一来又会使得写小文件的操作台低效了，哈哈，不用担心，我们可以写文件的时候现在 Cache 中缓存一下，等到收集了 4KB 的数据再一次性写入。这就是 FFS 提供的 libc 库的作用啦。<br>parameterized placement 这个呢，有点难理解，先看这个图吧：</p><p><img src="/image/filesystem/parameterized_placement.png" alt=""></p><p>假设一个文件就包含了12个磁盘块，而且如左边显示的那样存储于一个磁道上面。那么序列读取数据的时候就会有一个很小的问题：当磁头达到0块的时候读取数据，可是等它读完了准备读1块的数据的时候，磁头早就转过去了（假设转到2块的位置），于是需要接着等磁头转回来！！这样是不是很慢，事实上磁盘会将一个磁道的数据一下子缓存在磁盘里面，但是即使是这样，也需要两圈才能读完。因为你在等1快的数据的时候，磁盘转了一圈读出了整个磁道的数据，然后你获得了1块的数据，可是还是需要转一圈才能依次获得每一块的数据。于是乎就很聪明的将数据排列成右边那个样子，这样一来就只需要一圈啦。。。。</p><p>Fast File System，快速文件系统，是由 Berkeley 大学研究人员设计并实现的建立在UNIX操作系统的一套文件系统。这个系统主要目标已经体现在它的名字上，就是建立一个快速的文件系统。因为他们发现之前的UNIX的文件系统（参考之前的Blog文章“Concepts of Unix File System”）在性能方面存在问题，主要问题是在磁头定位，位置转化过程中浪费了大量的时间，导致效率不高。所以FFS的一大设计思路就是降低磁头的seek时间，而解决方案也很简单，keep related stuff together，这样seek的时候就可以节省时间。整个FFS涉及几个关键概念</p><h4 id="Creating-New-File"><a href="#Creating-New-File" class="headerlink" title="Creating New File"></a>Creating New File</h4><p>Cylinder Group翻译过来就是柱组，已经在之前Blog文章Concepts of Unix File System介绍过了，设计Cylinder Group的目的就是为了完成keep related stuff together，因为在一个柱组的文件可以快速访问。所以相关文件就可以放在一个柱组里。每个Group先包含一个superblock来保存一些metadata，后面接着是inode bitmap和data bitmap用来显示每个block的位置和其是不是已经写满了。</p><p>当创建一个文件的时候，比如/foo/bar.txt，并且这个文件大小是4kb。那么因为这是一个新的文件，所以需要分配新的inode而且inode bitmap也需要更新。同时，这个文件大小4kb，在cylinder group中就要分配一个4kb的block然后更新data bitmap来表示对应的data block已经占用。所以这就需要有四次写操作，但是这只是完成了这个文件的创建，并没有把它放进文件目录中。所以父目录/foo也要更新，来把bar.txt放到这个目录下。如此才算完成了一个文件的创建</p><h4 id="Put-Related-File-Together"><a href="#Put-Related-File-Together" class="headerlink" title="Put Related File Together"></a>Put Related File Together</h4><p>具体策略也很简单。第一，将一个文件的所有block放到一个group，这样就避免了磁盘磁头的long seek，从而节省了时间。第二，在相同目录的文件放在一个group里，比如/dir1/1.txt, /dir1/2.txt, /dir1/3.txt, 和/dir99/4.txt，那么前三个就会被放到一个group里，最后一个就被放到另一个group里。</p><h4 id="Large-File-Exception"><a href="#Large-File-Exception" class="headerlink" title="Large File Exception"></a>Large File Exception</h4><p>Put Related File Together的策略有一个例外，就是写入当大文件时。按照之前的策略一个大文件的所有block都会被放到一个group中，但是由于文件太大，可能整个group或者大部分group都被这个文件占满了，这就不符合把相关的文件放在一起的原则，因为这个group里只有这一个文件，只要有再访问别的文件就需要seek别的group，这大大降低了FFS的性能。对于写入大文件的策略就是，把它所有block平均的放到不同的group中。</p><p>开发一个高效，又节约空间的磁盘文件系统真是好难啊。想了各种办法来优化文件系统，老的UNIX系统算法也是针对它那个时候而设计吧，磁盘小，内存小，存储的也主要是文本小文件所以在那个时候，文件系统是没有问题的，问题是后来计算机系统发展了啊，多媒体文件出现了，文件突然变大了，磁盘也变大了，内存也变大了原来的系统就不适合了，我们可以用更多的空间去换取时间。当然，这篇文章是1984年写的，随着SSD价格不断降低，现在SSD也快普及了，现在的文件系统应该还没有把SSD的性能完全释放出来吧，所以应该会有人续写A Fast Fast Fast Fast File System for UNIX吧，哈哈哈。<br>下面来分析下，作者到底都使了哪些魔法让文件系统变快了呢？<br>首先，增加每个block的大小。这个应该是一般的人都想得到的吧，我在做lab1的时候都觉得512字节一个block是不是也忒小了吧，512字节的block意味着superblock也变小了，这样能存储的磁盘信息就更少了，当然较小的block size以为着更少的磁盘浪费，如果系统里面都是小文件的话。作者把磁盘分块大小增加到了4k，这样一次读操作就可以读取更多的数据，意味着读写速度可以提高接近8倍。</p><p>问题是这样存储小文件的时候会造成极大的浪费，所以作者又提出了一个新的概念—片段（fragement），这样在存储文件的时候就尽量的用完整的块存储，剩余的那么些位置也不能浪费了，用块的片段，这样这些小地方可以和别的文件公有，这样在不浪费空间的情况下可以大大提高读取速度，这个概念比较创新，设计上也复杂的多，比原来那种简单粗暴的方法好。</p><p>磁盘系统里面还有个问题就是磁盘碎片，以前的UNIX系统是通过一个队列保存缓存的block，然后再均匀的释放，这样本身并没有问题，可以解决一部分磁盘碎片的问题，问题是永久了还是会产生大量的碎片，这个在读写大文件的时候尤为严重，因此这个时候可以通过一些高效的hash算法来对文件存储的位置进行一些预判，这样每次存储文件的时候就不是随机分配一些block块了而把文件存储用的块局限在一个小的范围里，提高了寻找文件块的速度。<br>还是对于大文件，我们知道如果对一个大文件连续分配很多空间的话，它之前的文件如果又增加的话，就只能分配到大文件的后面，这样每次读取这个小文件就得越过这个大文件，这样是很不划算的，所以作者把大文件做了特殊对待，只允许你在一片连续的空间写上几兆的内容，这样对于大文件虽然连续性不好，但是大文件一次读取几兆的内容已经就很快了，所以无所谓了，反而是更多的小文件可以保持连续读取，这样提高的了小文件读取速度，这样从整体上来说还是很划算的。不过这个方法也不是一直都很好用，因为系统需要使用一些hash算法来保证磁盘上文件被分配到比较好位置，问题是当磁盘已经快被放满了呢，这个时候hash算法就基本上失效啦，可供分配文件的位置就大大减少，这样文件系统的性能大大下降，这样来看的，文件系统对磁盘的实际使用率也不算很高啊。<br>//老规矩，扯一下淡凑字数-_-!计算机系统原理虽然很难，学起来很痛苦，但是很有意思啊，在老师给出的基本框架下我们自己实现一个简单的文件系统，了解了不少系统底层的知识，对硬件也不那么陌生了，甚至还捡起来一些算法和数据结构的只是，要知道现在天天做web系统开发，基本上不用考虑算法和数据结构的问题，而且web系统本身结构清晰，现代的语言本身也是为简化开发者难度设计的，开发起来很快，有时候常常不知道所以然。通过一个个痛苦的lab，居然慢慢捡起来了原来那么点点的c知识，链表，队列，二叉树这些以前比较头疼的数据结构也不觉得那么难，谢谢老师在这门课上做出的努力，感谢整个计算机系统原理教学团队。</p>]]></content>
      
      
      <categories>
          
          <category> SystemProgramming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Journaling File System，日志文件系统是怎样工作的</title>
      <link href="/SystemProgramming/core-techs-filesystem-journal-filesystem/"/>
      <url>/SystemProgramming/core-techs-filesystem-journal-filesystem/</url>
      
        <content type="html"><![CDATA[<p>日志文件系统（Journaling File System）是一个具有故障恢复能力的文件系统，在这个文件系统中，因为对目录以及位图的更新信息总是在原始的磁盘日志被更新之前写到磁盘上的一个连续的日志上，所以它保证了数据的完整性。当发生系统错误时，一个全日志文件系统将会保证磁盘上的数据恢复到发生系统崩溃前的状态。同时，它还将覆盖未保存的数据，并将其存在如果计算机没有崩溃的话这些数据可能已经遗失的位置，这是对关键业务应用来说的一个很重要的特性。</p><p>文件系统要解决的一个关键问题是怎样防止掉电或系统崩溃造成数据损坏，在此类意外事件中，导致文件系统损坏的根本原因在于写文件不是原子操作，因为写文件涉及的不仅仅是用户数据，还涉及元数据(metadata)包括 Superblock、inode bitmap、inode、data block bitmap 等，所以写操作无法一步完成，如果其中任何一个步骤被打断，就会造成数据的不一致或损坏。举一个简化的例子，我们对一个文件进行写操作，要涉及以下步骤：</p><p>从 data block bitmap 中分配一个数据块；<br>在 inode 中添加指向数据块的指针；<br>把用户数据写入数据块。<br>如果步骤2完成了，3未完成，结果是数据损坏，因为该文件认为数据块是自己的，但里面的数据其实是垃圾；<br>如果步骤2完成了，1未完成，结果是元数据不一致，因为该文件已经把数据块据为己有，然而文件系统却还认为该数据块未分配、随后又可能会把该数据块分配给别的文件、造成数据覆盖；<br>如果步骤1完成了、2未完成，结果就是文件系统分配了一个数据块，但是没有任何文件用到这个数据块，造成空间浪费；<br>如果步骤3完成了，2未完成，结果就是用户数据写入了硬盘数据块中，但白写了，因为文件不知道这个数据块是自己的。</p><p><strong>日志文件系统(Journal File System)</strong>就是为解决上述问题而诞生的。</p><p>它的原理是在进行写操作之前，把即将进行的各个步骤（称为 transaction）事先记录下来，保存在文件系统上单独开辟的一块空间上，这就是所谓的日志(journal)，也被称为 write-ahead logging，日志保存成功之后才进行真正的写操作、把文件系统的元数据和用户数据写进硬盘（称为checkpoint），这样万一写操作的过程中掉电，下次挂载文件系统之前把保存好的日志重新执行一遍就行了（术语叫做 replay），避免了前述的数据损坏场景。</p><p>有人问如果保存日志的过程中掉电怎么办？最初始的想法是把一条日志的数据一次性写入硬盘，相当于一个原子操作，然而这并不可行，因为硬盘通常以512字节为单位进行操作，日志数据一超过512字节就不可能一次性写入了。所以实际上是这么做的：给每一条日志设置一个结束符，只有在日志写入成功之后才写结束符，如果一条日志没有对应的结束符就会被视为无效日志，直接丢弃，这样就保证了日志里的数据是完整的。</p><p>一条日志在它对应的写操作完成之后就没用了，占用的硬盘空间就可以释放。保存日志的硬盘空间大小是有限的，被循环使用，所以日志也被称为circular log。</p><p>至此可以总结一下日志文件系统的工作步骤了：</p><ul><li>Journal write : 把 transaction 写入日志中；</li><li>Journal commit : 在一条日志保存好之后，写入结束符；</li><li>Checkpoint : 进行真正的写操作，把元数据（metadata）和用户数据（user data）写入文件系统；</li><li>Free : 回收日志占用的硬盘空间。</li></ul><p>以上方式把用户数据（User Data）也记录在日志中，称为 Data Journaling ，Linux EXT3 文件系统就支持这种方式，这种方式存在效率问题：就是每一个写操作涉及的元数据（metadata）和用户数据（user data）实际上都要在硬盘上写两次，一次写在日志里，一次写在文件系统上。元数据倒也罢了，用户数据通常比较大，拷贝几个GB的电影文件也要乘以2实在是降低了效率。</p><p>一个更高效的方式是 Metadata Journaling ，不把用户数据（user data）记录在日志中，它防止数据损坏的方法是先写入用户数据（user data）、再写日志，即在上述 ”Journal write” 之前先写用户数据，这样就保证只要日志是有效的，那么它对应的用户数据也是有效的，一旦发生掉电故障，恢复的时候可以放心地把日志重新执行一遍。Metadata Journaling 又叫 Ordered Journaling，大多数文件系统都采用这种方式。像 Linux EXT3 文件系统也是可以选择 Data Journaling 还是 Ordered Journaling 的。</p>]]></content>
      
      
      <categories>
          
          <category> SystemProgramming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VSFS, Very Simple File System</title>
      <link href="/SystemProgramming/core-techs-filesystem-vsfs/"/>
      <url>/SystemProgramming/core-techs-filesystem-vsfs/</url>
      
        <content type="html"><![CDATA[<p>英文原文：<br><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/file-implementation.pdf" target="_blank" rel="noopener">http://pages.cs.wisc.edu/~remzi/OSTEP/file-implementation.pdf</a></p><h1 id="标题：简单文件系统的实现"><a href="#标题：简单文件系统的实现" class="headerlink" title="标题：简单文件系统的实现"></a>标题：简单文件系统的实现</h1><p>这篇文章介绍一个简单的文件系统实现，称为 vsfs（非常简单的文件系统）。该文件系统是典型UNIX文件系统的简化版本，因此可用于介绍当今许多文件系统中的一些基本磁盘结构，访问方法和各种策略。</p><p>文件系统是纯软件;与我们开发的CPU和内存虚拟化不同，我们不会添加硬件功能来使文件系统的某些方面更好地工作（尽管我们将要注意设备特征以确保文件系统正常运行）。由于我们在构建文件系统方面具有很大的灵活性，因此从AFS（Andrew文件系统）[H + 88]到ZFS（Sun的Zettabyte文件系统）[B07]的字面上构建了许多不同的文件系统。所有这些文件系统都有不同的数据结构，并且做得比其他同行更好或更差。因此，我们将通过案例研究来了解我们将如何学习文件系统：首先，本章介绍一个简单的文件系统（vsfs），介绍大多数概念，然后对真实文件系统进行一系列研究，以了解它们在实践。</p><h2 id="文件系统的功能"><a href="#文件系统的功能" class="headerlink" title="文件系统的功能"></a>文件系统的功能</h2><p>考虑文件系统，我们通常建议考虑两个不同的方面;如果你理解了这两个方面，你可能会理解文件系统的基本工作原理。</p><p>首先是文件系统的数据结构。换句话说，文件系统使用什么类型的磁盘结构来组织其数据和元数据？我们将看到的第一个文件系统（包括下面的vsfs）使用简单的结构，如块或其他对象的数组，而更复杂的文件系统（如SGI的XFS）使用更复杂的基于树的结构[S + 96]。</p><p>文件系统的第二个方面是访问方法。它如何将进程所调用的映射映射到它的结构上？比如open() read() write()等等。在执行特定系统调用期间读取哪些结构？哪些被写？所有这些步骤的执行效率如何？</p><p>如果您了解文件系统的数据结构和访问方法，那么您已经开发了一个关于它如何工作的良好mental model，这是系统思维的一个关键部分。在深入研究我们的第一个实施时，努力开发您的mental model</p><h2 id="文件系统的组织"><a href="#文件系统的组织" class="headerlink" title="文件系统的组织"></a>文件系统的组织</h2><blockquote><p>可以参考鸟哥的Linux私房菜 p199-200</p></blockquote><p>我们现在开发了 vsfs 文件系统数据结构的磁盘整体组织。 我们需要做的第一件事是将磁盘分成块(block); 简单的文件系统只使用一个块大小，这正是我们在这里要做的。 我们选择一个4 KB的常用大小。</p><p>因此，我们对构建文件系统的磁盘分区的看法很简单：一系列块，每块大小为4 KB。 在大小为N 4-KB块的分区中，这些块从0到N-1。 假设我们有一个非常小的磁盘，只有64块：</p><p>现在让我们考虑一下我们需要在这些块中存储什么来构建文件系统。 当然，首先想到的是用户数据。 实际上，任何文件系统中的大部分空间都是（也应该是）用户数据。 让我们将用于数据区域的用户数据所用的磁盘区域称为数据区域，并且为了简单起见，为这些块保留磁盘的固定部分，例如磁盘上64个块的最后56个：</p><p><img src="/image/filesystem/vsfs_64blocks.png" alt=""></p><p>正如我们在最后一章中了解到的，文件系统必须跟踪每个文件的信息。 这些信息是元数据的关键部分，可以跟踪数据块（在数据区域中）包含文件，文件大小，所有者和访问权限，访问和修改时间以及其他类似的 信息。 为了存储这个信息，文件系统通常有一个叫inode的结构（我们将在下面阅读更多关于inode的内容）。</p><p>为了存放inode，我们还需要为磁盘保留一些空间。 让我们将这部分磁盘称为inode表，它只保存一个磁盘inode数组。 因此，假设我们将64个块中的5块用于inode（由图中的I表示），我们的磁盘映像现在看起来就像这张图片：</p><p><img src="/image/filesystem/vsfs_64blocks_inode.png" alt=""></p><p>我们应该在这里注意，inode 通常不是那么大，例如128或256个字节。假设每个inode有256个字节，一个4-KB块可以容纳16个inode，而我们上面的文件系统则包含80个inode。在我们简单的文件系统中，建立在一个小小的64块分区上，这个数字表示我们文件系统中可以拥有的最大文件数量;但是，请注意，建立在更大磁盘上的相同文件系统可以简单地分配更大的inode表，从而容纳更多文件。</p><p>到目前为止，我们的文件系统有数据块（D）和inode（I），但仍有一些东西缺失。正如您可能已经猜到的那样，仍然需要一个主要组件来跟踪inode或数据块是空闲还是分配。因此这种分配结构是任何文件系统中必不可少的元素。</p><p>当然，许多分配跟踪方法都是可能的。例如，我们可以使用一个空闲列表指向第一个空闲块，然后指向下一个空闲块，等等。我们选择一个简单流行的结构，称为<strong>位图 bitmap</strong>，一个用于数据区域（数据位图），另一个用于 inode表（inode位图）。位图是一个简单的结构：每个位用于指示相应的对象/块是空闲的（0）还是正在使用的（1）。因此，我们新的磁盘布局，包含一个 inode位图（i）和一个数据位图（d）：</p><p><img src="/image/filesystem/vsfs_64blocks_inode1.png" alt=""></p><p>您可能会注意到对这些位图使用整个4-KB块是有点矫枉过正的; 这样的位图可以跟踪是否分配32K对象，但我们只有80个inode和56个数据块。 但是，为了简单起见，我们只为这些位图中的每一个使用整个 4 KB 块。</p><p>仔细的读者（即仍然醒着的读者）可能已经注意到，在我们非常简单的文件系统的磁盘结构设计中还剩一块。 我们保留这个超级块，在下图中用S表示。 超级块包含关于该特定文件系统的信息，包括例如文件系统中有多少 inode 和数据块（在这个例子中分别为80和56），inode 表开始（块3）等等。 它可能还会包含某种类型的幻数以识别文件系统类型（在本例中为vsfs）。</p><p><img src="/image/filesystem/vsfs_64blocks_inode2.png" alt=""></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>在我的服务器上进行相关的测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">~$ df</span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">udev             1005964       0   1005964   0% /dev</span><br><span class="line">tmpfs             204832    3280    201552   2% /run</span><br><span class="line">/dev/vda1       41151808 4352784  34685596  12% /</span><br><span class="line">tmpfs            1024144       0   1024144   0% /dev/shm</span><br><span class="line">tmpfs               5120       0      5120   0% /run/lock</span><br><span class="line">tmpfs            1024144       0   1024144   0% /sys/fs/cgroup</span><br><span class="line">tmpfs             204832       0    204832   0% /run/user/0</span><br><span class="line">tmpfs             204832       0    204832   0% /run/user/1001</span><br></pre></td></tr></table></figure><p>用 df 显示挂载的设备，可以看到 /dev/vda1 表示主要的 fs</p><p>查看这个块，可以获得一个很长的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~$ dumpe2fs /dev/vda1</span><br><span class="line">dumpe2fs 1.42.13 (17-May-2015)</span><br><span class="line">dumpe2fs: Permission denied while trying to open /dev/vda1</span><br><span class="line">Couldn&apos;t find valid filesystem superblock.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">~$ sudo dumpe2fs /dev/vda1</span><br><span class="line">dumpe2fs 1.42.13 (17-May-2015)</span><br><span class="line">Filesystem volume name:   /</span><br><span class="line">Last mounted on:          /</span><br><span class="line">Filesystem UUID:          e2048966-750b-4795-a9a2-7b477d6681bf</span><br><span class="line">Filesystem magic number:  0xEF53</span><br><span class="line">Filesystem revision #:    1 (dynamic)</span><br><span class="line">Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize</span><br><span class="line">Filesystem flags:         signed_directory_hash</span><br><span class="line">Default mount options:    user_xattr acl</span><br><span class="line">Filesystem state:         clean</span><br><span class="line">Errors behavior:          Continue</span><br><span class="line">Filesystem OS type:       Linux</span><br><span class="line">Inode count:              2621440</span><br><span class="line">Block count:              10485248</span><br><span class="line">Reserved block count:     524261</span><br><span class="line">Free blocks:              9890156</span><br><span class="line">Free inodes:              2545206</span><br><span class="line">First block:              0</span><br><span class="line">Block size:               4096</span><br><span class="line">Fragment size:            4096</span><br><span class="line">Reserved GDT blocks:      1021</span><br><span class="line">Blocks per group:         32768</span><br><span class="line">Fragments per group:      32768</span><br><span class="line">Inodes per group:         8192</span><br><span class="line">Inode blocks per group:   512</span><br><span class="line">RAID stride:              32639</span><br><span class="line">Flex block group size:    16</span><br><span class="line">Filesystem created:       Thu Aug 17 15:42:55 2017</span><br><span class="line">Last mount time:          Thu Oct 26 20:34:20 2017</span><br><span class="line">Last write time:          Fri Oct 27 04:34:18 2017</span><br><span class="line">Mount count:              1</span><br><span class="line">Maximum mount count:      -1</span><br><span class="line">Last checked:             Fri Oct 27 04:34:18 2017</span><br><span class="line">Check interval:           0 (&lt;none&gt;)</span><br><span class="line">Lifetime writes:          3921 MB</span><br><span class="line">Reserved blocks uid:      0 (user root)</span><br><span class="line">Reserved blocks gid:      0 (group root)</span><br><span class="line">First inode:              11</span><br><span class="line">Inode size:           256</span><br><span class="line">Required extra isize:     28</span><br><span class="line">Desired extra isize:      28</span><br><span class="line">Journal inode:            8</span><br><span class="line">First orphan inode:       931259</span><br><span class="line">Default directory hash:   half_md4</span><br><span class="line">Directory Hash Seed:      24cbf2f0-10b9-4f68-9cdd-33073e41c59a</span><br><span class="line">Journal backup:           inode blocks</span><br><span class="line">Journal features:         journal_incompat_revoke</span><br><span class="line">Journal size:             128M</span><br><span class="line">Journal length:           32768</span><br><span class="line">Journal sequence:         0x00139661</span><br><span class="line">Journal start:            7881</span><br><span class="line">Group 0: (Blocks 0-32767) [ITABLE_ZEROED]</span><br><span class="line">  Checksum 0xeaa0, unused inodes 3739</span><br><span class="line">  Primary superblock at 0, Group descriptors at 1-3</span><br><span class="line">  Reserved GDT blocks at 4-1024</span><br><span class="line">  Block bitmap at 1025 (+1025), Inode bitmap at 1041 (+1041)</span><br><span class="line">  Inode table at 1057-1568 (+1057)</span><br><span class="line">  20947 free blocks, 3886 free inodes, 474 directories, 3739 unused inodes</span><br><span class="line">  Free blocks: 11821-32767</span><br><span class="line">  Free inodes: 664, 3956, 4070, 4082, 4104, 4112, 4119, 4122, 4126-4127, 4140, 4147, 4166, 4173, 4176, 4180, 4183, 4187, 4189, 4193, 4207, 4217, 4244, 4247, 4270, 4274, 4277, 4286-4287, 4292-4296, 4298, 4301-4302, 4305-4306, 4309, 4311, 4313-4315, 4318-4319, 4321-4323, 4326-4327, 4329-4332, 4334-4339, 4341-4343, 4345-4347, 4349-4351, 4353-4355, 4357-4359, 4361-4363, 4365-4367, 4369-4371, 4373-4378, 4384-4387, 4389-4390, 4393-4395, 4397-4399, 4401, 4403, 4405-4407, 4409, 4411, 4413-4416, 4418-4422, 4425-4427, 4429-8192</span><br></pre></td></tr></table></figure><p>可以看到 Ubuntu 对应的文件信息。</p><h2 id="文件组织与-inode"><a href="#文件组织与-inode" class="headerlink" title="文件组织与 inode"></a>文件组织与 inode</h2><p>ASIDE：数据结构 - INODE<br>inode是在许多文件系统中使用的通用名称，用于描述保存给定文件的元数据的结构，例如其长度，权限和组成块的位置。 这个名称至少可以追溯到UNIX（如果不是早期的系统，可能还会回到Multics）; 它是索引节点的简称，因为索引节点号用于索引磁盘inode数组，以便查找该索引节点的索引节点。 我们将看到，inode的设计是文件系统设计的一个关键部分。 大多数现代系统对于它们跟踪的每个文件都有这样的结构，但也许称它们为不同的东西（如dnodes，fnodes等）。</p><p>文件系统最重要的磁盘结构之一是inode;几乎所有的文件系统都有类似的结构。名称inode是索引节点的缩写，它是由UNIX开发人员Ken Thompson [RT74]给出的历史名称，因为这些节点最初排列在一个数组中，并且在访问特定索引节点时索引了数组。</p><p>每个inode都被一个数字（称为inumber）隐式引用，我们之前称之为文件的低级名称。在vsfs（和其他简单的文件系统）中，给定一个i-number，你应该能够直接计算磁盘上相应节点的位置。例如，如上所述，获取vsfs的inode表：大小为20 KB（5个4 KB块），因此由80个inode（假设每个inode为256个字节）组成;进一步假设inode区域从12KB开始（即，超级块从0KB开始，inode位图在4KB地址，数据位图在8KB，因此inode表紧随其后）。在vsfs中，我们因此在文件系统分区的开始部分（在特写视图中）具有以下布局：</p><p>inode summary</p><p>要读取inode编号32，文件系统将首先计算inode区域的偏移量（32·sizeof（inode）或8192），将其添加到磁盘inode表的起始地址（inodeStartAddr = 12KB），然后到达所需的inode块的正确字节地址：20KB。重新调用磁盘不是字节可寻址的，而是由大量的可寻址扇区组成，通常是512字节，因此，要获取包含inode的块inode 32，文件系统将向扇区发出读取<br>20×1024或40，以获取所需的inode块。</p><p>可以如下计算inode块的地址</p><p>$iaddr：blk =（inumber sizeof（inode_t））/ blockSize$;<br>$sector =（（blk blockSize）+ inodeStartAddr）/ sectorSize;$</p><p>在每个inode中，实际上是所有关于文件的信息：其类型（例如，常规文件，目录等），大小，分配给它的块数，保护信息（如谁拥有文件，以及谁可以访问它），一些时间信息，包括文件的创建，修改或上次访问时间，以及有关其数据块在磁盘上的位置（例如某种指针）的信息。我们将所有关于文件的信息称为元数据;实际上，文件系统内部不是纯粹的用户数据的任何信息通常都是这样的。 ext2 [P09]中的一个inode示例如下表40.1所示。</p><p>inode table</p><p>inode设计中最重要的决定之一就是它如何引用数据块的位置。一种简单的方法是在inode中有一个或多个直接指针（磁盘地址）;每个指针指向属于该文件的一个磁盘块。这种方法是有限的：例如，如果您想要一个非常大的文件（例如，大于块的大小乘以直接点数的数量），那么您运气不好。</p><p>多级索引<br>为了支持更大的文件，文件系统设计者必须在inode中引入不同的结构。一个常见的想法是有一个称为间接指针的特殊指针。它不是指向包含用户数据的块，而是指向包含更多指针的块，每个指针指向用户数据。因此，inode可以具有一些固定数量的直接指针（例如12）和单个间接指针。如果文件变得足够大，则会分配一个间接块（来自磁盘的数据块区域），并将inode的间接指针槽设置为指向它。假设一个块是4KB和4个字节的磁盘地址，则会增加1024个指针;该文件可以增长为（12 + 1024）·4K或4144KB。</p><p>直接指针：inode条目–&gt;block（存的是文件数据）</p><p>​ 间接指针：inode条目–&gt;block（存的是指针）–&gt;block（存的是文件数据）</p><p>​ 二重指针：inode条目–&gt;block（存的是指针）–&gt;block（存的是指针）–&gt;block（存的是文件数据）</p><p>​ 三重指针：inode条目–&gt;block（存的是指针）–&gt;block（存的是指针）–&gt;block（存的是指针）–&gt;block（存的是文件数据）</p><p>毫不奇怪，在这种方法中，您可能想要支持更大的文件。为此，只需向inode添加另一个指针：双重间接指针。该指针指向包含指向间接块的指针的块，每个块都包含指向数据块的指针。因此，双重间接块增加了使用额外的1024×1024或1百万个4KB块扩展文件的可能性，换句话说，支持超过4GB大小的文件。不过，你可能想要更多，我们打赌你知道这是在哪里：三重间接指针。</p><p>总的来说，这种不平衡的树被称为指向文件块的多级索引方法。我们来看一个带有十二个直接指针的例子，以及一个单独的和一个双重的间接块。假设块大小为4 KB，并且指针为4字节，则该结构可以容纳一个仅超过4 GB的文件（即（12 + 1024 + 10242）×4 KB）。你能否通过增加一个三重间接块来判断文件的大小？ （提示：很大）</p><p>许多文件系统使用多级索引，包括常用文件系统，如Linux ext2 [P09]和ext3，NetApp的WAFL以及原始UNIX文件系统。其他文件系统，包括SGI XFS和Linux ext4，使用扩展而不是简单的指针;有关基于范围的方案如何工作的细节（它们与虚拟内存讨论中的细分类似）。</p><p>您可能想知道：为什么使用这样的不平衡树？为什么不采用不同的方法？那么，事实证明，许多研究人员已经研究过文件系统以及它们的使用方式，几乎每次他们发现几十年来都有的“真相”。一个这样的发现是大多数文件很小。这种不平衡的设计反映了这样的现实;如果大多数文件确实很小，那么为这种情况优化是有意义的。因此，使用少量直接指针（12是典型数字），inode可以直接指向48 KB的数据，需要一个（或多个）间接块来存放较大的文件。见Agrawal等人。 a [A + 07]为最近的研究;表40.2总结了这些结果。</p><p>设计inode的另一个更简单的方法是使用链表。因此，在一个inode中，而不是有多个指针，你只需要一个，指向文件的第一个块。要处理较大的文件，请在该数据块的末尾添加另一个指针等，这样就可以支持大文件。<br>正如您可能已经猜到的那样，链接文件分配对于某些工作负载表现不佳;例如，考虑阅读文件的最后一个块，或者只是进行随机访问。因此，为了使链接分配更好地工作，一些系统将保留链接信息的内存表，而不是将下一个指针与数据块本身一起存储。该表由数据块D的地址索引;一个条目的内容只是D的下一个指针，即D后面的文件中的下一个块的地址。空值也可以在那里（指示文件结束）或其他标记来指示一个特定的块是免费的。拥有这样的下一个指针表使得链接分配机制可以有效地进行随机文件访问，只需首先扫描（在内存中）表来查找所需的块，然后直接访问（在磁盘上）。</p><p>这样的table听起来很熟吗？我们所描述的是所谓的文件分配表或FAT文件系统的基本结构。是的，在NTFS [C94]之前，这款经典的旧Windows文件系统基于简单的基于链接的分配方案。与标准的UNIX文件系统还有其他不同之处;例如，本身没有inode，而是存储关于文件的元数据的目录条目，并且直接指向所述文件的第一个块，这使得不可能创建硬链接。参见Brouwer [B02]了解更多不雅的细节。</p><p>目录组织<br>在vsfs中（如在许多文件系统中），目录有一个简单的组织;一个目录基本上只包含一个（入口名，inode号）对的列表。对于给定目录中的每个文件或目录，目录的数据块中都有一个字符串和一个数字。对于每个字符串，可能还有一个长度（假定可变大小的名称）。</p><p>例如，假设目录dir（inode number 5）中有三个文件（foo，bar和foobar），它们的inode编号分别为12,13和24。 dir的磁盘数据可能如下所示：</p><p>inum | reclen | strlen | name<br>5        4        2     .<br>2        4        3     ..<br>12       4        4     foo<br>13       4        4     bar<br>24       8        7     foobar<br>在本例中，每个条目都有一个inode编号，记录长度（名称的总字节数加上空格剩余空间），字符串长度（名称的实际长度）以及条目的名称。请注意，每个目录有两个额外的条目，。 “点”和“点 - 点”; dot目录就是当前目录（在本例中为dir），而dot-dot是父目录（在本例中为根目录）。</p><p>删除一个文件（例如调用unlink（））会在目录中间留下一个空白空间，因此应该有一些方法来标记它（例如，保留的inode数字，例如零）。这种删除是使用记录长度的一个原因：新条目可能会重复使用旧的，更大的条目，从而在其中留有额外的空间。</p><p>您可能想知道确切的目录存储在哪里。通常，文件系统将目录视为特殊类型的文件。因此，目录有一个inode，inode表中的某处（inode表中的inode标记为“目录”的类型字段而不是“常规文件”）。该目录具有由inode指向的数据块（也可能是间接块）;这些数据块位于我们简单文件系统的数据块区域中。我们的磁盘结构因此保持不变。<br>我们还应该再次注意到，这个简单的线性目录列表并不是存储这些信息的唯一方法。如前所述，任何数据结构都是可能的。例如，XFS [S + 96]以B-树形式存储目录，使文件创建操作（必须确保文件名在创建之前未被使用）比具有必须在其中扫描的简单列表的系统更快整体。</p><p>空闲空间管理<br>创建文件 –&gt; 为你的文件申请inode–&gt; 从块中的inode bitmap中寻找到对应的inode –&gt; 把inode标注为used.</p><p>空闲空间的管理方式不唯一，你可以使用freelist, 也可以使用B-Tree(LIKE XFS).</p><p>读写文件：实际发生的故事<br>现在我们已经知道文件和目录如何存储在磁盘上，我们应该能够在读取或写入文件的过程中遵循操作流程。理解这个访问路径上发生的事情是开发人员理解文件系统如何工作的第二个关键;请注意！<br>对于下面的例子，让我们假设文件系统已经被挂载，因此超级块已经在内存中。其他所有内容（即inode，目录）仍在磁盘上。</p><p>从磁盘读取文件<br>在这个简单的例子中，让我们先假设你想简单地打开一个文件（例如/ foo / bar，读取它，然后关闭它）。对于这个简单的例子，假设文件的大小只有4KB（即， 1块）。</p><p>当您发出打开（“/ foo / bar”，ORDONLY）调用时，文件首先需要找到文件栏的inode，以获取有关文件的一些基本信息（权限信息，文件大小等）。要做到这一点，他的文件系统必须能够找到inode，但它现在的所有文件都是完整的路径名。文件系统必须遍历路径名，从而找到所需的inode。</p><p>所有遍历都从文件系统的根目录开始，在根目录中简单地称为/。因此，FS从磁盘读取的第一件事是根目录的inode。但是这个inode在哪里？要找到一个inode，我们必须知道它的i号码。通常，我们在其父目录中找到文件或目录的i编号;根没有父（根据定义）。因此，根节点号必须是“众所周知的”;当安装文件系统时，FS必须知道它是什么。在大多数UNIX文件系统中，根索引节点编号为2.因此，要开始该进程，FS会读入包含索引节点编号2（第一个索引节点块）的块。</p><p>一旦inode被读入，FS可以在里面查找指向数据块的指针，数据块包含根目录的内容。因此，FS将使用这些磁盘上的指针来读取目录，在这种情况下寻找foo的条目。通过读入一个或多个目录数据块，它将找到foo的条目;一旦找到，FS也会找到下一个需要的foo的inode数量（比如44）。</p><p>下一步是递归遍历路径名，直到找到所需的inode。在这个例子中，FS会接下来读取包含foo的inode的块，然后读取其目录数据，最后找到bar的inode号。 open（）的最后一步是将它的inode读入内存;然后FS可以进行最终权限检查，在每个进程的开放文件表中为此进程分配一个文件描述符，并将其返回给用户。</p><p>一旦打开，程序就可以发出一个read（）系统调用来读取文件。第一次读取（除非lseek（）已被调用，则在偏移量0处）将在文件的第一个块中读取，查阅inode以查找这种块的位置;它也可以用新的上次访问时间更新inode。读取将进一步更新此文件描述符的内存中打开文件表，更新文件偏移量以便下一次读取将读取第二个文件块等。</p><p>在某个时候，文件将被关闭。这里要做的工作要少得多;很明显，文件描述符应该被释放，但现在，这是所有FS真正需要做的。没有磁盘I / O发生。</p><p>整个过程的描述见图40.3（时间向下）。在该图中，打开导致无数次读取以便最终找到文件的索引节点。之后，读取每个块需要文件系统首先查询inode，然后读取该块，然后使用写入更新inode的最后访问时间字段。花一些时间，试着理解发生了什么。</p><p>还要注意open所产生的I / O的数量与路径名的长度成正比。对于路径中的每个附加目录，我们都必须读取它的inode及其数据。更糟糕的是会出现大型目录;在这里，我们只需要读取一个块来获取目录的内容，而对于大目录，我们可能需要读取很多数据块才能找到所需的条目。是的，阅读文件时生活会变得很糟糕;正如你将要发现的那样，写一个文件（尤其是创建一个新文件）更糟糕。</p><p>read in fs</p><p>写入<br>write&amp;create in fs</p><p>写入文件是一个类似的过程。首先，文件必须打开（如上）。然后，应用程序可以发出write（）调用以用新内容更新文件。最后，文件关闭。</p><p>与读取不同，写入文件也可能会分配一个块（例如，除非块被覆盖）。当写出新文件时，每次写入不仅必须将数据写入磁盘，而且必须首先决定将哪个块分配给文件，并相应地更新磁盘的其他结构（例如，数据位图）。因此，对文件的每次写入在逻辑上会生成三个I / O：一个读取数据位图，然后更新它以标记所使用的新分配的块，一个写入位图（以反映其新的状态到磁盘），和一个写实际的块本身。</p><p>如果考虑简单和常见的操作（例如文件创建），写入流量会更差。要创建一个文件，文件系统不仅要分配一个inode，还要在包含新文件的目录中分配空间。这样做的I / O流量总量非常高：一个读取inode位图（查找空闲inode），一个写入inode位图（将其标记为已分配），一个写入新的inode本身（初始化它），一个目录的数据（将文件的高级名称链接到它的inode编号），以及一个读写目录inode以更新它。如果目录需要增长以适应新条目，则还需要额外的I / O（即数据位图和新的目录块）。所有这些只是为了创建一个文件！</p><p>我们来看一个具体的例子，其中创建了file / foo / bar，并且向它写入了三个块。图40.4显示了在open（）（创建文件）期间以及在3个4KB写入期间发生的情况。</p><p>在该图中，对磁盘的读取和写入被分组在导致它们发生的系统调用下，并且它们可能发生的粗略排序从图的顶部到底部进行。您可以看到创建该文件需要多少工作：在这种情况下，有10个I / O，用于遍历路径名，然后创建文件。您还可以看到每个分配写入需要5个I / O：一对读取和更新inode，另一对读取和更新数据位图，最后写入数据本身。文件系统如何以合理的效率完成这些任务？</p><p>Caching and Buffering<br>Caching<br>As the examples above show, reading and writing files can be expen- sive, incurring many I/Os to the (slow) disk. To remedy what would clearly be a huge performance problem, most file systems aggressively use system memory (DRAM) to cache important blocks.<br>Imagine the open example above: without caching, every file open would require at least two reads for every level in the directory hierarchy (one to read the inode of the directory in question, and at least one to read its data). With a long pathname (e.g., /1/2/3/ … /100/file.txt), the file system would literally perform hundreds of reads just to open the file!Early file systems thus introduced a fix-sized cache to hold popular blocks. As in our discussion of virtual memory, strategies such as LRU and different variants would decide which blocks to keep in cache. This fix-sized cache would usually be allocated at boot time to be roughly 10% of total memory. Modern systems integrate virtual memory pages and file system pages into a unified page cache [S00]. In this way, memory can be allocated more flexibly across virtual memory and file system, depending on which needs more memory at a given time.<br>Now imagine the file open example with caching. The first open may generate a lot of I/O traffic to read in directory inode and data, but sub- sequent file opens of that same file (or files in the same directory) will mostly hit in the cache and thus no I/O is needed.</p><p>Buffer<br>Let us also consider the effect of caching on writes. Whereas read I/O can be avoided altogether with a sufficiently large cache, write traffic has to go to disk in order to become persistent. Thus, a cache does not serve as the same kind of filter on write traffic that it does for reads. That said, write buffering (as it is sometimes called) certainly has a number of performance benefits. First, by delaying writes, the file system can batch some updates into a smaller set of I/Os; for example, if an inode bitmap is updated when one file is created and then updated moments later as another file is created, the file system saves an I/O by delaying the write after the first update. Second, by buffering a number of writes in memory, the system can then schedule the subsequent I/Os and thus increase per- formance. Finally, some writes are avoided altogether by delaying them; for example, if an application creates a file and then deletes it, delaying the writes to reflect the file creation to disk avoids them entirely. In this case, laziness (in writing blocks to disk) is a virtue.<br>For the reasons above, most modern file systems buffer writes in mem- ory for anywhere between five and thirty seconds, representing yet an- other trade-off: if the system crashes before the updates have been prop- agated to disk, the updates are lost; however, by keeping writes in mem- ory longer, performance can be improved by batching, scheduling, and even avoiding writes.<br>Some applications (such as databases) don’t enjoy this trade-off. Thus, to avoid unexpected data loss due to write buffering, they simply force writes to disk, by calling fsync(), by using direct I/O interfaces that work around the cache, or by using the raw disk interface and avoiding the file system altogether1. While most applications live with the trade- offs made by the file system, there are enough controls in place to get the system to do what you want it to, should the default not be satisfying.</p><p>参考：<br><a href="https://www.maplewish.cn/2018/06/05/%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">https://www.maplewish.cn/2018/06/05/%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0/</a></p>]]></content>
      
      
      <categories>
          
          <category> SystemProgramming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux Overview</title>
      <link href="/SystemProgramming/core-techs-linux-overview/"/>
      <url>/SystemProgramming/core-techs-linux-overview/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-Kernel-Map"><a href="#Linux-Kernel-Map" class="headerlink" title="Linux Kernel Map"></a>Linux Kernel Map</h1><p><img src="/image/linux/LKM3_2048.png" alt=""></p><p>Operting System</p><p>操作系统环境<br>进程线程模型<br>处理器调度<br>同步机制<br>存储模型<br>文件系统<br>I/O系统<br>死锁</p><p>内存泄漏检测</p><p>死锁检测</p><p>活锁</p><h2 id="操作系统环境"><a href="#操作系统环境" class="headerlink" title="操作系统环境"></a>操作系统环境</h2><p>CPU：运算器、控制器、通用寄存器、控制和状态寄存器（PC、IR、PSW）、高速缓存<br>CPU状态：内核态（特权指令R0）、用户态（用户R3）<br>中断／异常机制：CPU暂停当前执行程序，保留现场，硬件自动转去处理程序，处理完后回到断点，继续被打断的程序<br>事件：中断响应外部事件，异步处理，总是返回下一条指令，如I/O、时钟、硬件故障；异常源于内部正在执行的程序，同步处理，分为陷入、故障、终止，如系统调用、页故障、断点、权限保护、程序<br>中断响应（硬件）：指令周期末扫描中断寄存器，CPU切换到内核态，保存现场（PSW+PC），通过中断码查中断向量表（中断处理程序入口+处理机状态字），推送中断处理程序入口到寄存器<br>中断处理程序（软件）：保存相关寄存器信息，分析发生原因。执行处理功能，恢复现场<br>系统调用：用户在编程时可以调用的操作系统功能，如进程控制、通信、文件使用、目录操作、设备管理、信息维护<br>程序调用：应用程序可以通过库函数和API进入系统调用，也可直接引发系统调用，系统调用再调用对应内核函数<br>系统调用设计：中断／异常机制（支持系统调用服务的实现），陷入指令（引发异常，用户态切换到内核态），系统调用号和参数（不同系统调用的编号），系统调用表（服务程序的入口地址），参数传递（陷入指令自带、通用寄存器、内存中专用堆栈区）<br>系统调用过程：CPU执行到特殊的陷入指令；中断硬件保护现场，通过门描述符（段选择符+偏移量）查系统调用表；转入查到的系统调用总入口程序，保护现场，保存参数到内核堆栈，通过系统调用号查系统调用表；执行查到的系统调用例程；恢复现场，返回用户程序</p>]]></content>
      
      
      <categories>
          
          <category> SystemProgramming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PCIe Introduction</title>
      <link href="/SystemProgramming/core-techs-storage-pcie/"/>
      <url>/SystemProgramming/core-techs-storage-pcie/</url>
      
        <content type="html"><![CDATA[<p>现在很多 SSD 都开始使用 PCIe 接口。那为什么 SSD 要用 PCIe 接口？因为它快，比 SATA 快。它究竟有多快？我们今天首先从 PCIe 接口的速度开始我们的PCIe之旅。</p><p>PCIe 发展到现在，从 PCIe 1.0，PCIe 2.0，到现在的 PCIe 3.0，速度一代比一代快。</p><p><img src="/image/storage/PCIePCI1.png" alt=""></p><p>在第一行，我们看到 X1，X2，X4…，这是什么意思？这是指 PCIe 连接的通道数（Lane）。就像高速一样，有单根道，有 2 根道的，有 4 根道的，不过像 8 根道或者更多道的公路不常见，但 PCIe 是可以最多 32 条道的。</p><p>两个设备之间的PCIe连接，叫做一个Link，如下图所示：</p><p><img src="/image/storage/PCIePCI3.png" alt=""></p><p>从A到B，之间是个双向连接，车可以从A驶向B，同时，车也可以从B驶向A，各行其道。两个PCIe设备之间，有专门的发送和接收通道，数据可以同时往两个方向传输，PCIe spec称这种工作模式为双单工模式（dual-simplex），可以理解为全双工模式。</p><h3 id="SATA-是什么工作模式呢？"><a href="#SATA-是什么工作模式呢？" class="headerlink" title="SATA 是什么工作模式呢？"></a>SATA 是什么工作模式呢？</h3><p><img src="/image/storage/PCIePCI4.png" alt=""></p><p>和 PCIe 一样，SATA 也有独立的发送和接收通道，但它与 PCIe 工作模式不一样：同一时间，只有一条道可以进行数据传输，也就是说，你在一条道上发送数据，另外一条道上不能接收数据，反之亦然。这种工作模式应该是半双工模式。PCIe犹如我们的手机，双方可以同时讲话，而SATA就是对讲机了，一个人在说话，另外一个人就只能听不能说。</p><p>回到前面 PCIe 带宽那张表，上面的带宽，比如PCIe3.0x1，带宽为2GB/s，是指双向带宽，即读写带宽。如果单指读或者写，该值应该减半，即1GB/s的读速度或者写速度。</p><h4 id="我们来看看表里面的带宽是怎么算出来的。"><a href="#我们来看看表里面的带宽是怎么算出来的。" class="headerlink" title="我们来看看表里面的带宽是怎么算出来的。"></a>我们来看看表里面的带宽是怎么算出来的。</h4><p>PCIe是串行总线，PCIe1.0的线上比特传输速率为2.5Gb/s，物理层使用8/10编码，即8比特的数据，实际在物理线路上是需要传输10比特的，因此：</p><p><strong>PCIe1.0 x 1 的带宽=（2.5Gb/s x 2（双向通道））/ 10bit = 0.5GB/s</strong></p><p>这是单条Lane的带宽，有几条Lane，那么整个带宽就0.5GB/s乘以Lane的数目。</p><p>PCIe2.0的线上比特传输速率在PCIe1.0的基础上翻了一倍，为5Gb/s，物理层同样使用8/10编码，所以：</p><p><strong>PCIe2.0 x 1 的带宽=（5Gb/s x 2（双向通道））/ 10bit = 1GB/s</strong></p><p>同样，有多少条 Lane，带宽就是 1GB/s 乘以 Lane 的数目。</p><p>PCIe3.0 的线上比特传输速率没有在 PCIe2.0 的基础上翻倍，不是 10Gb/s，而是 8Gb/s，但物理层使用的是 128/130 编码进行数据传输，所以：</p><p><strong>PCIe3.0 x 1 的带宽=（8Gb/s x 2（双向通道））/ 8bit = 2GB/s</strong></p><p>同样，有多少条 Lane，带宽就是 2GB/s 乘以 Lane 的数目。</p><p>由于采用了128/130编码，128 比特的数据，只额外增加了 2bit 的开销，有效数据传输比率增大，虽然线上比特传输率没有翻倍，但有效数据带宽还是在 PCIe2.0 的基础上做到翻倍。</p><p>这里值得一提的是，上面算出的数据带宽已经考虑到8/10或者128/130编码，因此，大家在算带宽的时候，没有必要再考虑线上编码的问题了。</p><p>和 SATA 单通道不同，PCIe 连接可以通过增加通道数扩展带宽，弹性十足。通道数越多，速度越快。不过，通道数越多，成本越高，占用更多空间，还有就是更耗电。因此，使用多少通道，应该在性能和其他因素之间进行一个综合考虑。单考虑性能的话，PCIe 最高带宽可达 64GB/s，PCIe 3.0 x 32 对应的带宽，很恐怖的一个数据。不过，现有的 PCIe 接口 SSD，一般最多使用 4 通道，如 PCIe3.0x4，双向带宽为 8GB/s，读或者写带宽为 4GB/s。</p><p><img src="/image/storage/PCIePCI5.png" alt=""></p><p>几个 GB/s 的传输速度，读写小电影那是杠杠的。</p><p>在此，顺便来算算PCIe3.0x4理论上最大的4K IOPS。PCIe3.0x4理论最大读或者写的速度为4GB/s，不考虑协议开销，每秒可以传输4GB/4K个4K大小的IO，该值为1M，即理论上最大IOPS为1000K。因此，一个SSD，不管你底层用什么介质，flash还是3d xpoint，接口速度就这么块，最大IOPS是不可能超过这个值的。</p><p>PCIe是从PCI发展过来的，PCIe的”e”是express的简称，快的意思。PCIe怎么就能比PCI（或者PCI-X）快呢？PCIe在物理传输上，跟PCI有着本质的区别：PCI使用并口传输数据，而PCIe使用的是串口传输。我PCI并行总线，单个时钟周期可以传输32bit或者64bit，怎么就比不了你单个时钟周期传输1个bit数据的串行总线呢？</p><p>在实际时钟频率比较低的情况下，并口因为可以同时传输若干比特，速率确实比串口快。随着技术的发展，数据传输速率要求越来越快，要求时钟频率也越来越快，但是，并行总线时钟频率不是想快就能快的。</p><p><img src="/image/storage/PCIePCI6.png" alt=""></p><p>在发送端，数据在某个时钟沿传出去（左边时钟第一个上升沿），在接收端，数据在下个时钟沿（右边时钟第二个上升沿）接收。因此，要在接收端能正确采集到数据，要求时钟的周期必须大于数据传输的时间（从发送端到接收端，flight time)。受限于数据传输时间（该时间还随着数据线长度的增加而增加），因此时钟频率不能做得太高。另外，时钟信号在线上传输的时候，也会存在相位偏移（clock skew )，影响接收端的数据采集；还有，并行传输，接收端必须等最慢的那个bit数据到了以后，才能锁住整个数据 （signal skew）。</p><p>PCIe使用串行总线进行数据传输就没有这些问题。它没有外部时钟信号，它的时钟信息通过8/10编码或者128/130编码嵌入在数据流，接收端可以从数据流里面恢复时钟信息，因此，它不受数据在线上传输时间的限制，你导线多长都没有问题，你数据传输频率多快也没有问题；没有外部时钟信号，自然就没有所谓的clock skew问题；由于是串行传输，只有一个bit传输，所以不存在signal skew问题。但是，如果使用多条lane传输数据（串行中又有并行，哈哈），这个问题又回来了，因为接收端同样要等最慢的那个lane上的数据到达才能处理整个数据。</p>]]></content>
      
      
      <categories>
          
          <category> SystemProgramming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Goroutine Notes</title>
      <link href="/SystemProgramming/core-techs-database-index/"/>
      <url>/SystemProgramming/core-techs-database-index/</url>
      
        <content type="html"><![CDATA[<h3 id="聚集索引-Clustered-Index"><a href="#聚集索引-Clustered-Index" class="headerlink" title="聚集索引 Clustered Index"></a>聚集索引 Clustered Index</h3><p>聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。</p><p>比如，们的汉语字典的正文本身就是一个聚集索引。比如，我们要查“安”字，就会很自然地翻开字典的前几页，因为“安”的拼音是“an”，而按照拼音排序汉字的字典是以英文字母“a”开头并以“z”结尾的，那么“安”字就自然地排在字典的前部。如果您翻完了所有以“a”开头的部分仍然找不到这个字，那么就说明您的字典中没有这个字；</p><p>字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。</p><p>用比较规范的语言来定义聚集索引就是：聚集索引中键值的逻辑顺序决定了表中相应行的物理顺序。</p><p>聚集索引对于那些经常要搜索范围值的列特别有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。例如，如果应用程序执行 的一个查询经常检索某一日期范围内的记录，则使用聚集索引可以迅速找到包含开始日期的行，然后检索表中所有相邻的行，直到到达结束日期。这样有助于提高此 类查询的性能。同样，如果对从表中检索的数据进行排序时经常要用到某一列，则可以将该表在该列上聚集（物理排序），避免每次查询该列时都进行排序，从而节 省成本。<br>　　　　<br>当索引值唯一时，使用聚集索引查找特定的行也很有效率。例如，使用唯一雇员 ID 列 emp_id 查找特定雇员的最快速的方法，是在 emp_id 列上创建聚集索引或 PRIMARY KEY 约束。</p><h3 id="非聚集索引-Non-Clustered-Index"><a href="#非聚集索引-Non-Clustered-Index" class="headerlink" title="非聚集索引 Non-Clustered Index"></a>非聚集索引 Non-Clustered Index</h3><p>定义：索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。</p><p>回到查字典那个例子</p><p>查字典时，我们也可能会遇到您不认识的字，不知道它的发音。这时候，就不能按照刚才的方法找到字，而需要去根据“偏旁部首”查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合“部首目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如您查“张”字，我们可以看到在查部首之后的检字表中“张”的页码是672页，检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。很显然，这些字并不是真正的分别位于“张”字的上下方，现在您看到的连续的“驰、张、弩”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。</p><h3 id="Innodb的聚集索引"><a href="#Innodb的聚集索引" class="headerlink" title="Innodb的聚集索引"></a>Innodb的聚集索引</h3><p>Innodb存储引擎中行记录就是按照聚集索引维度顺序存储的，Innodb的表也称为索引表；因为行记录只能按照一个维度进行排序，所以一张表只能有一个聚集索引。</p><p>Innodb的存储索引是基于B+tree，理所当然，聚集索引也是基于B+tree。与非聚集索引的区别则是，聚集索引既存储了索引，也存储了行值。当一个表有一个聚集索引，它的数据是存储在索引的叶子页（leaf pages）。因此innodb也能理解为基于索引的表。</p><p>非聚集索引索引项顺序存储，但索引项对应的内容却是随机存储的；</p><p>举个例子说明下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student (</span><br><span class="line"></span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> AUTO_INCREMENT,</span><br><span class="line"></span><br><span class="line"><span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line"></span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="string">`id`</span>),</span><br><span class="line"></span><br><span class="line"><span class="keyword">KEY</span>(<span class="string">`name`</span>)</span><br><span class="line"></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>该表中主键id是该表的聚集索引、name为非聚集索引；表中的每行数据都是按照聚集索引id排序存储的；比如要查找name=’Arla’和name=’Arle’的两个同学，他们在name索引表中位置可能是相邻的，但是实际存储位置可能差的很远。<strong>name 索引表节点按照 name 排序，检索的是每一行数据的主键。聚集索引表按照主键 id 排序，检索的是每一行数据的真实内容。</strong></p><p>也就是说查询 name=’Arle’ 的记录时，首相通过name索引表查找到Arle的主键id（可能有多个主键id，因为有重名的同学），再根据主键id的聚集索引找到相应的行记录；</p><p><strong>聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为NULL的唯一索引，如果还是没有的话，就采用Innodb存储引擎为每行数据内置的6字节ROWID作为聚集索引。</strong></p><p>每张表只有一个聚集索引，因为聚集索引在精确查找和范围查找方面良好的性能表现（相比于普通索引和全表扫描），聚集索引就显得弥足珍贵，聚集索引选择还是要慎重的（一般不会让没有语义的自增id充当聚集索引）。</p><p>从宏观上分析下聚集索引和普通索引的性能差异，还是针对上述student表：</p><p>（1）select * from student where id &gt;5000 and id &lt;20000;</p><p>（2）select * from student where name &gt; ‘Alie’ and name &lt; ‘John’;</p><p>第一条SQL语句根据id进行范围查询，因为(5000, 20000)范围内的记录在磁盘上按顺序存储，顺序读取磁盘很快就能读到这批数据。</p><p>第二条SQL语句查询（’Alie’, ‘John’）范围内的记录，主键id分布可能是离散的1，100，20001，5000…..；增加了随机读取数据页几率；所以普通索引的范围查询效率被聚集索引甩开几条街都不止；非聚集索引的精确查询效率还是可以的，比聚集索引查询只增加了一次IO开销。</p>]]></content>
      
      
      <categories>
          
          <category> SystemProgramming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LevelDB Notes</title>
      <link href="/SystemProgramming/core-techs-database-leveldb/"/>
      <url>/SystemProgramming/core-techs-database-leveldb/</url>
      
        <content type="html"><![CDATA[<h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>随着</p><p>LevelDB 使用 LSM-Tree 来作为存储数据结构，极大得提升了写性能。我们知道，MySQL 这种数据库的存储引擎使用了 B+ 树来持久化数据, B+ 树是一个索引树, 可以说是同时考虑了读写均衡, 其结构上对树高进行了优化, 搜索耗时相比 AVL 树降下来. 然而问题是 “对一个随机读优化的排序结构执行随机写是有很大开销的”, 所以对那些需要高频写操作的系统来讲, B+ 树作为存储结构可能并不合适.</p><p>LSM-Tree 则更适合需要高频写的场景。它是一种类似日志的数据结构, 它将随机写变为顺序写, 核心思想是:</p><ul><li>对变更进行批量 &amp; 延时处理</li><li>通过归并排序将更新迁移到硬盘上</li></ul><p>LSM-Tree 全称是 “Log Structured-Merge Tree”，最早在 1996 年由 麻省波斯顿大学的 Patrick O’Neil 及其他 3 个研究者发表的论文 <a href="https://www.cs.umb.edu/~poneil/lsmtree.pdf" target="_blank" rel="noopener">The Log-Structured Merge-Tree (LSM-Tree)</a> 中被设计出来。</p><h3 id="Log-Structured-File-System"><a href="#Log-Structured-File-System" class="headerlink" title="Log-Structured File System"></a>Log-Structured File System</h3><p>要理解 Log Structured-Merge Tree 是什么原理，我们需要先回到 Log Structured 到底是什么数据结构，实际上，它最早是由 Berkeley 研究人员（Mendel Rosenblum &amp; John Ousterhout）在 1991 年发表的论文 [1992SOSP-The Design and Implementation of a Log-Structured File System][] 中提出并实现，这篇论文是日志结构文件系统的鼻祖，其目的就是系统的写瓶颈:</p><blockquote><p>The fundamental idea of a log-structured ﬁle system is to improve write performance by buffering a sequence of ﬁle system changes in the ﬁle cache and then writing all the changes to disk sequentially in a single disk write operation.</p></blockquote><p>核心思想就是使用顺序写(追加)替代随机写，因为顺序写不需要多次寻址, 速度能达到硬盘理论传输速度, 而随机写则受限于硬盘寻址速度.</p><p>威斯康辛大学的重量级教授 Remzi Arpaci-Dusseau 出版了一本操作系统的书，叫做 “Operating Systems: Three Easy Pieces”，其在 [“Log-structured File Systems”][] 一章中详细介绍了 LFS 的原理，有兴趣的可以详细查看，我在另一篇介绍 LFS 的文章中根据其内容进行简要的介绍和总结。</p><h2 id="LSM-Tree"><a href="#LSM-Tree" class="headerlink" title="LSM-Tree"></a>LSM-Tree</h2><p>LSM 被设计来提供比传统的 B+ 树或者 ISAM 更好的<strong>写操作</strong>吞吐量，通过消去随机的本地更新操作来达到这个目标。</p><p>LSM 是当前被用在许多产品的文件结构策略：BigTable, Dynamo, HBase, Cassandra, LevelDB/RocksDB, SQLite,甚至在 MongoDB 3.0 中也带了一个可选的 LSM 引擎（Wired Tiger 实现的）</p><h2 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h2><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="1-Put-Get"><a href="#1-Put-Get" class="headerlink" title="1) Put/Get"></a>1) Put/Get</h3><h3 id="2-Log-format"><a href="#2-Log-format" class="headerlink" title="2) Log format"></a>2) Log format</h3><h3 id="3-Insert-amp-Read-a-record"><a href="#3-Insert-amp-Read-a-record" class="headerlink" title="3) Insert &amp; Read a record"></a>3) Insert &amp; Read a record</h3><h3 id="4-Multi-Level-SSTable"><a href="#4-Multi-Level-SSTable" class="headerlink" title="4) Multi-Level SSTable"></a>4) Multi-Level SSTable</h3><h3 id="5-SSTable-Merge-Minor-Major-Compaction"><a href="#5-SSTable-Merge-Minor-Major-Compaction" class="headerlink" title="5) SSTable Merge - Minor/Major Compaction"></a>5) SSTable Merge - Minor/Major Compaction</h3><h3 id="6-VersionSet-VersionEdit"><a href="#6-VersionSet-VersionEdit" class="headerlink" title="6) VersionSet, VersionEdit"></a>6) VersionSet, VersionEdit</h3><h3 id="7-Format-of-SSTable"><a href="#7-Format-of-SSTable" class="headerlink" title="7) Format of SSTable"></a>7) Format of SSTable</h3><h2 id="1、版本控制-VersionEdit"><a href="#1、版本控制-VersionEdit" class="headerlink" title="1、版本控制 VersionEdit"></a>1、版本控制 VersionEdit</h2><p>参考：<br><a href="https://draveness.me/bigtable-leveldb" target="_blank" rel="noopener">https://draveness.me/bigtable-leveldb</a></p><p><a href="https://leanote.com/api/file/getAttach?fileId=5a57265dab64415def0012d6" target="_blank" rel="noopener">1992SOSP-The Design and Implementation of a Log-Structured File System</a><br><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/file-lfs.pdf" target="_blank" rel="noopener">Log-structured File Systems</a><br><a href="https://arxiv.org/pdf/1812.07527.pdf" target="_blank" rel="noopener">LSM-based Storage Techniques: A Survey</a><br><a href="https://www.usenix.org/legacy/event/hotos05/final_papers/full_papers/stein/stein.pdf" target="_blank" rel="noopener">Stupid File Systems Are Better</a></p>]]></content>
      
      
      <categories>
          
          <category> SystemProgramming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Memcached Notes</title>
      <link href="/SystemProgramming/core-techs-database-memcached/"/>
      <url>/SystemProgramming/core-techs-database-memcached/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>memcached 有以下特性：</p><ul><li>协议简单(ascii 或 binary 协议)</li><li>基于 libevent 事件处理</li><li>内置的内存存储方式</li><li>不互相通信的分布式(由客户端程序负责分布式)</li><li>基于 LRU(least recently used)算法自动删除不使用的缓存</li></ul><h2 id="memcached-事件模型"><a href="#memcached-事件模型" class="headerlink" title="memcached 事件模型"></a>memcached 事件模型</h2><p>memcached 使用 libevent 作为其底层的网络库。</p><p>memcached 使用 master-worker 的方式, 以多线程对外提供服务, 主线程监听端口建立连接, 然后顺序分配给各个工作线程(对应工具的 -t 选项). 每个线程都有一个 event loop, 它们可以服务于不同的客户端. master 线程和 worker 线程之间使用管道通信, 每个工作的线程都会创建一个管道来保存写端和读端, 并将读端加入 event loop, 监听可读事件。多线程的模型可以充分发挥多核主机的优势.</p><h2 id="memcached-内存分配"><a href="#memcached-内存分配" class="headerlink" title="memcached 内存分配"></a>memcached 内存分配</h2><p>memcached 默认情况下采用了 Slab Allocator 的机制分配和管理内存. 在该机制出现之前内存分配简单的通过 malloc 和 free 来管理所有的记录,旧的方式会导致产生很多内存碎片, 加重机器管理内存的负担, 甚至有可能导致操作系统比 memcached 进程本身还慢, Slab Allocator 则解决了该问题.</p><p>Slab 的基本原理是按照预先规定的大小, 将分配的内存分割成特定长度的块(chunk), 以解决内存碎片的问题。这也意味着存取记录的时候可以减少内存分配的次数, 有点类似线程池/内存池的感觉。当往 memcache 中存储对象时，memcache 并不是简单的按对象大小来分配内存，因为这种情况下会导致内存碎片，加重操作系统内存管理器的负担。memcache 采用的是slab allocation 的内存分配策略，如下图所示：</p><p><img src="/image/database/slab_allocator.png" alt=""></p><p>这张图片里面涉及了slab_class、slab、page、chunk四个概念，它们之间的关系是：</p><p>1、Memcache 将内存空间分为一组slab<br>2、每个 slab 下又有若干个 page，每个 page 默认是 1M，如果一个 slab 占用 100M 内存的话，那么这个 slab 下应该有 100个page<br>3、每个 page 里面包含一组 chunk，chunk 是真正存放数据的地方，同一个 slab 里面的 chunk 的大小是固定的<br>4、有相同大小 chunk 的 slab 被组织在一起，称为 slab_class</p><p>Slaballocation的基本原理是按照预先规定的大小，将分配的内存以page为单位进行分割，默认情况下一个page是1M，可以通过-I参数在启动时指定，分割成各种尺寸的块(chunk)，并把尺寸相同的块分成组(chunk的集合)，如果需要申请内存时，memcached会划分出一个新的page并分配给需要的slab区域。page一旦被分配在重启前不会被回收或者重新分配，以解决内存碎片问题。</p><p>Slab 的原理也比较简单, 是将分配的内存分割成各种尺寸的块(chunk), 且把尺寸相同的 chunk 分成组(chunk 集合), 一个组称为 slab class.<br>Slab class 的主要术语包括以下：<br>page: 分配给 Slab 的内存空间, 默认是 1MB, 分配给 slab 之后根据 slab 大小分成 chunk.<br>chunk: 用于缓存记录的内存空间.<br>slab class: 特定大小的 chunk 的组.</p><p>由此可以看出, 三者之间在内存分配上的关系为 slab class -&gt; page -&gt; chunk, 比如以下信息：<br>$ memcached-tool 127.0.0.1:11211 display</p><h1 id="Item-Size-Max-age-Pages-Count-Full-Evicted-Evict-Time-OOM"><a href="#Item-Size-Max-age-Pages-Count-Full-Evicted-Evict-Time-OOM" class="headerlink" title="Item_Size  Max_age   Pages   Count   Full?  Evicted Evict_Time OOM"></a>Item_Size  Max_age   Pages   Count   Full?  Evicted Evict_Time OOM</h1><p>1      96B         0s       1       0      no        0        0    0<br>2     120B   2417392s      30  257107      no        0        0    0</p><p>该 memcached 内存中, slab class 1 的 chunk 大小为 96 字节, 只分配了一个 page(1MB), 里面的记录数为 0, slab class 2 的 chunk 大小为 120 字节, 一共 30 个 page(约 30MB), 里面的记录数为 257107 个. 我们通过简单计算就可以得知, 30MB ~= 257107 * 120B. 在达到 30M 上线的时候, 如果再增加 key-value 值, 则直接分配一个 page 给 slab class 2, 这就是预分配的功能. 所以 Slab Allocation 的构造图大致如下：<br>       slab class 1         slab class 2<br>      +————-+     +—————+<br>      | 96B  | 96B  |     |  120B  | 120B |<br>      +——+——+     +——–+——+<br>      | 96B  |more..|     |  120B  |more..|<br>      +————-+     +—————+</p><pre><code> slab class 3         slab class 4+-------------+     +---------------+| 152B | 152B |     | 192B  | 192B  |+------+------+     +-------+-------+| 152B |more..|     | 192B  |more.. |+-------------+     +---------------+.....</code></pre><p>每个 slab class 的大小按照增长因子(-f 选项, 默认 1.25)增加,比如上述的 slab 1 默认为 96 字节, 那么 slab 2 则为 96*1.25 = 120 字节, 以此类推. 另外 slab allocator 还有重复使用已分配内存的目的. 也就是说, 分配的到内存不会释放, 而是重复利用.</p><p>Slab的内存分配具体过程如下：<br>Memcached在启动时通过-m参数指定最大使用内存，但是这个不会一启动就占用完，而是逐步分配给各slab的。如果一个新的数据要被存放，首先选择一个合适的slab，然后查看该slab是否还有空闲的chunk，如果有则直接存放进去；如果没有则要进行申请，slab申请内存时以page为单位，无论大小为多少，都会有1M大小的page被分配给该slab(该page不会被回收或者重新分配，永远都属于该slab)。申请到page后，slab会将这个page的内存按chunk的大小进行切分，这样就变成了一个chunk的数组，再从这个chunk数组中选择一个用于存储数据。若没有空闲的page的时候，则会对改slab进行LRU，而不是对整个memcache进行LRU。</p><p>接下来我们通过一组memcache命令来查看memcache的内存分配策略，首先通过telnet命令连接上mencached服务器，通过stats slabs命令我们可以看到memcache的slab信息，从中里我们可以看到，一共有7个在使用中的slab，各个字段的含义如下：<br>chunk_size:slab中每个chunk的大小，这也是该slab能存储的最大item size上限</p><p>chunks_per_page:每个page中chunk数量 chuans_per_size = page大小/chunk_size</p><p>total_pages:该slab中的page数量</p><p>total_chunks:该slab中的chunk总数</p><p>used_chunks:已经使用过的chunk数量</p><p>free_chunks:未使用的chunk数量</p><p>total_malloced:实际已经分配的总内存数，这个数值决定memcache还能申请多少内存</p><p>通过stats命令可以查看memcache能申请的总内存大小。</p><p>limit_maxbytes表示memcache能申请的最大内存数，单位为byte，默认为64m。</p><p>slab 缓存记录的原理</p><p>memcached 会根据收到数据的大小选择合适的 slab class, slab 内保存着空闲的 chunk 列表, memcached 根据这些列表选择合适的 chunk, 然后将数据缓存到该 chunk 中. 如下图所示, 比如需要缓存 100 字节的记录, 则可以选择大小为 120B 的 chunk, 最后存到 slab class 2 中.</p><pre><code>     Slab classes+----------------+| class 1 (96B)  |+----------------+</code></pre><p>  +———-+   +–| class 2 (120B) |<br>  | 100 byte |  /   +—————-+<br>  +———-+      | class 3 (152B) |<br>                    +—————-+<br>                    |  ……        |<br>                    +—————-+</p><p>slab allocator 的缺点</p><p>尽管 slab 很好的解决了内存碎片的问题, 但该机制也给 memcached 带来了新的问题. 比如上述的缓存记录原理一节中, 由于分配的 chunk 都是固定的长度 120 字节, 将 100 字节存到改 chunk 中之后, 剩余的 20 字节就会被浪费, 如下:<br>      |   120 bytes chunk   |<br>      +————-+——-+<br>      | 100 bytes   | …   |<br>      +————-+——-+</p><p>该问题还没有比较完美的解决方案, 不过应用程序如果能预先知道数据的大小, 只要尽力选择合适的 chunk, 就可以减少内存浪费, 比如 110 字节的数据都保存到 120字节的 chunk 中. 下面小节介绍的增长因子则能较好的减少内存浪费.</p><p>使用增长因子(growth factor)调优</p><p>上述小节中提到了增长因子(-f 选项), 此功能可以用来调节不同 slab class 之间 chunk 的大小差别, 默认为 1.25. 比如以下结果:</p><p>$ memcached-tool 127.0.0.1:11212 display</p><h1 id="Item-Size-Max-age-Pages-Count-Full-Evicted-Evict-Time-OOM-1"><a href="#Item-Size-Max-age-Pages-Count-Full-Evicted-Evict-Time-OOM-1" class="headerlink" title="Item_Size  Max_age   Pages   Count   Full?  Evicted Evict_Time OOM"></a>Item_Size  Max_age   Pages   Count   Full?  Evicted Evict_Time OOM</h1><p>  1      96B   2327514s       1       2      no        0        0    0<br>  2     120B   2071695s       3    6981      no        0        0    0<br>  3     152B   1038377s      23   90100      no        0        0    0<br>  4     192B         0s       1       0      no        0        0    0<br>  5     240B   2327378s       1      28      no        0        0    0<br>  6     304B   2313765s       1       1      no        0        0    0<br>  7     384B   2326507s       1       3      no        0        0    0<br>  8     480B   2310076s       1       1      no        0        0    0<br>  9     600B   2327669s       1       8      no        0        0    0<br> 10     752B   2327425s       1      47      no        0        0    0</p><p>从 class 1 的 chunk 大小 96 字节开始, 增长因子为 1.25，后续的 class 2 的 chunk 大小即为 96<em>1.25 = 120, class 3 的即为 120</em>1.25 = 152 等等. 从示例中我们看到, memcached 中的记录都保存在于 class 2 和 class 3 中. 这意味着大部分数据在 96 ~ 152 字节之间. 假如这里有很多 100 字节和 125 字节的记录的话, 可想而知会有很多的内存被浪费掉, 这个时候, 如果我们调节增长因子为 1.1, 则会减少很多内存的浪费, 如下:</p><h1 id="Item-Size"><a href="#Item-Size" class="headerlink" title="Item_Size"></a>Item_Size</h1><p>  1        96B<br>  2        112B<br>  3        128B</p><p>调整为 1.1 的因子后, 一个 100 字节的记录比调整前少浪费了 8 字节, 一个 125 字节的记录比调整前少浪费了 24 字节. 由此可见在内存使用很紧张的情况下, 调整增长因子也能节省相当多的内存.</p><h2 id="如何处理连接过多的问题"><a href="#如何处理连接过多的问题" class="headerlink" title="如何处理连接过多的问题"></a>如何处理连接过多的问题</h2><p>这个问题在一些短连接的应用中较为突出, 比如使用短连接连接 memcached 的 php 应用, 每一次请求 php 就会新起一个进程连接 memcached,而每起一个进程则消耗一个本地端口, 因为本地端口为两个字节所以最大就是 65535, 如果在并发较大的情况下, 很容易发生本地端口不够用的情况。这个时候程序可以考虑通过 memcached socket 连接 memcached, 但是这种解决方案只适用于 memcached 和应用在一台机器上,如果不在一台机器上则可以考虑官方文档中介绍的使用 udp 协议连接, 而不是 tcp 协议连接, 不过在数据包较大的情况下会引起 udp 连接丢包的现象,这需要应用程序做一个很好的把控, 最好上线前做好测试。</p><h2 id="查看-slabs-的使用状况"><a href="#查看-slabs-的使用状况" class="headerlink" title="查看 slabs 的使用状况"></a>查看 slabs 的使用状况</h2><p>可以使用 memcached 作者编写的 memcahced-tool 工具查看 slabs 的使用状况, 比如上述示例中介绍的命令:<br>$ memcached-tool 127.0.0.1:11211 display</p><h1 id="Item-Size-Max-age-Pages-Count-Full-Evicted-Evict-Time-OOM-2"><a href="#Item-Size-Max-age-Pages-Count-Full-Evicted-Evict-Time-OOM-2" class="headerlink" title="Item_Size  Max_age   Pages   Count   Full?  Evicted Evict_Time OOM"></a>Item_Size  Max_age   Pages   Count   Full?  Evicted Evict_Time OOM</h1><p>  1      96B         0s       1       0      no        0        0    0<br>  2     120B   2417392s      30  257107      no        0        0    0</p><p>各列的含义如下：</p><h2 id="列-含义"><a href="#列-含义" class="headerlink" title="  列            含义"></a>  列            含义</h2><h1 id="slab-class-编号"><a href="#slab-class-编号" class="headerlink" title="slab class 编号"></a>slab class 编号</h1><p>  Item_Size   chunk 大小<br>  Max_age     LRU 内最旧的记录的生存时间<br>  Pages       slab 中 page 的个数, 一个 page 默认大小为 1MB 大小<br>  Count       slab 内的记录数<br>  Full        slab 内是否含有空闲的 chunk<br>  Evicted     slab 中未过期的条目被 LRU 移除的个数<br>  Evict_Time  slab 中最近被移除的条目最后一次访问经过的秒数<br>  OOM         slab 中存储新条目失败的次数</p><h2 id="memcached-删除机制"><a href="#memcached-删除机制" class="headerlink" title="memcached 删除机制"></a>memcached 删除机制</h2><p>所有的数据都缓存到 memcached 中, 所以数据不会永久保存到磁盘上. 上述小节中也介绍过 memcahced 通过 slab 机制不会释放已分配的内存, 记录超时或删除后不会释放内存, 而是重复利用. 另外 memcached 内部不会监视过期的条目, 而是在 get 时查看时间戳, 检查记录是否过期. 这种特性成为 lazy expiration.</p><h2 id="LRU-删除数据的原理"><a href="#LRU-删除数据的原理" class="headerlink" title="LRU: 删除数据的原理"></a>LRU: 删除数据的原理</h2><p>memcached 优先使用超时的记录的内存空间, 但这也会发生增加新条目时空间不足的情况, memcached 采用 LRU(Least Recently Used) 机制解决内存不足的情况. LRU 即表示删除最近最少使用的意思, 很多数据库工具软件都采用 LRU 算法解决类似的问题, 比如 MySQL 的 InnoDB buffer 也采用该机制解决内存不足的问题; 在 memcached 可用内存不足的情况下, 就从最近未被使用的记录中进行搜索, 并将其分配给新的条目记录.</p><p>如果不想采用 LRU 机制可以使用 -M 选项启动 memcached, 该选项在内存用尽时直接返回错误.</p><h2 id="memcached-二进制协议"><a href="#memcached-二进制协议" class="headerlink" title="memcached 二进制协议"></a>memcached 二进制协议</h2><p>老版本中仅支持 ascii 文本协议, 较新的版本都支持新的二进制协议, -B 选项可以选择要使用的协议, 默认情况自动选择. 使用了二进制协议后程序和 memcached 的交互不再需要文本的解析处理, 同样也能减少文本协议相关的漏洞, 所以理论上使用二进制协议效果更好.</p><p>memcached 源代码文件 memcached-master/doc/protocol-binary.xml 对二进制协议做了很详尽的描述, 一个 memcached 协议报文由两部分组成: header 和 memcached 命令. 这两部分组成一个通用格式的 memcached 协议报文, 如下:</p><pre><code>General format of a packet:</code></pre><p>Byte/       0       |       1       |       2       |       3       |<br>    /               |               |               |               |<br>    |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|<br>    +—————+—————+—————+—————+<br>   0/ HEADER                                                        /<br>    /                                                               /<br>    /                                                               /<br>    /                                                               /<br>    +—————+—————+—————+—————+<br>  24/ COMMAND-SPECIFIC EXTRAS (as needed)                           /<br>    +/  (note length in the extras length header field)             /<br>    +—————+—————+—————+—————+<br>   m/ Key (as needed)                                               /<br>    +/  (note length in key length header field)                    /<br>    +—————+—————+—————+—————+<br>   n/  Value (as needed)                                            /<br>   +/  (note length is total body length header field, minus        /<br>   +/  sum of the extras and key length body fields)                /<br>    +—————+—————+—————+—————+<br>    Total 24 bytes</p><p>可以看到一个memcached 的数据报文, 其中包括24字节的头部(header), 8 字节的 Extras 信息(包括 4 字节的 flag 和 4 字节的 expiration 字段), 以及相应的 key 和 value 长度字节, 这两个长度可以 header 头部中查找到.</p><p>另外 header 头部则可以分为请求 header 和应答 header，如下所示:</p><pre><code>Request header:</code></pre><p>Byte/       0       |       1       |       2       |       3       |<br>    /               |               |               |               |<br>    |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|<br>    +—————+—————+—————+—————+<br>   0| Magic         | Opcode        | Key length                    |<br>    +—————+—————+—————+—————+<br>   4| Extras length | Data type     | Reserved                      |<br>    +—————+—————+—————+—————+<br>   8| Total body length                                             |<br>    +—————+—————+—————+—————+<br>  12| Opaque                                                        |<br>    +—————+—————+—————+—————+<br>  16| CAS                                                           |<br>    |                                                               |<br>    +—————+—————+—————+—————+<br>    Total 24 bytes</p><pre><code>Response header:</code></pre><p> Byte/       0       |       1       |       2       |       3       |<br>     /               |               |               |               |<br>     |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|<br>     +—————+—————+—————+—————+<br>    0| Magic         | Opcode        | Key length                    |<br>     +—————+—————+—————+—————+<br>    4| Extras length | Data type     | Reserved                      |<br>     +—————+—————+—————+—————+<br>    8| Total body length                                             |<br>     +—————+—————+—————+—————+<br>   12| Opaque                                                        |<br>     +—————+—————+—————+—————+<br>   16| CAS                                                           |<br>     |                                                               |<br>     +—————+—————+—————+—————+<br>     Total 24 bytes</p><p>可以看到请求头部和应答头部的格式相同, 我们同样查看文档 doc/protocol-binary.xml, 各 header 字段的含义如下:</p><p>Magic: Magic number.<br>Opcode: Command code.<br>Key length: Length in bytes of the text key that follows the command extras.<br>Status: Status of the response (non-zero on error).<br>Extras length: Length in bytes of the command extras.<br>Data type: Reserved for future use (Sean is using this soon).<br>Reserved: Really reserved for future use (up for grabs).<br>Total body length: Length in bytes of extra + key + value.<br>Opaque: Will be copied back to you in the response.<br>CAS: Data version check.</p><h2 id="抓包分析-memcached-二进制协议"><a href="#抓包分析-memcached-二进制协议" class="headerlink" title="抓包分析 memcached 二进制协议"></a>抓包分析 memcached 二进制协议</h2><p>我们使用以下 perl 程序以二进制方式连接测试 memcached, 再抓包分析进行说明, 如下程序:</p><p>#!/usr/bin/env perl<br>use strict;<br>use Data::Dumper;<br>use Cache::Memcached::libmemcached;</p><p>my $memd = Cache::Memcached::libmemcached-&gt;new({<br>  ‘servers’ =&gt; [ “127.0.0.1:11211”],<br>  ‘debug’ =&gt; 0,<br>  ‘compress_threshold’ =&gt; 10_000,<br>});<br>$memd-&gt;set_binary_protocol(1);  # 使用二进制协议<br>print Dumper($memd);<br>$memd-&gt;set(“foo10”, “Some value”);  # set 值</p><p>my $val = $memd-&gt;get(“foo10”);<br>if ($val) {<br>    print Dumper($val);<br>}</p><p>抓包后, 使用 wireshark 分析, 我们以 set request 包分析如下, 下半部分为16进制数据:</p><p>Memcache Protocol, Set Request<br>    Magic: Request (128)<br>    Opcode: Set (1)<br>    Key Length: 5<br>    Extras length: 8<br>    Data type: Raw bytes (0)<br>    Reserved: 0<br>    [Value length: 10]<br>    Total body length: 23<br>    Opaque: 65536<br>    CAS: 0<br>    Extras<br>    Key: foo10<br>    Value: Some value</p><p>0000   80 01 00 05 08 00 00 00 00 00 00 17 00 01 00 00  …………….<br>0010   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  …………….<br>0020   66 6f 6f 31 30 53 6f 6d 65 20 76 61 6c 75 65     foo10Some value</p><p>对比上一小节的 header 头部可以分析如下, memcached 的数据(memcached 通用报文)大小总共为 47 字节:<br>Magic: 80<br>Opcode: 01<br>Key Length: 00 05<br>Extras length: 08<br>Data type: 00<br>Status: 00 00<br>Total body length: 00 00 00 17<br>Opaque: 00 01 00 00<br>CAS: 00 00 00 00 00 00 00 00<br>Extras: 00 00 00 00 00 00 00 00 (4 字节 Flags, 4 字节 Expiration)<br>Key: 66 6f 6f 31 30<br>Value: 53 6f 6d 65 20 76 61 6c 75 65</p><p>key length 为两个字节, 这意味着 key 的最大长度可以到 65535 字节, 比起老的版本确实是很大的进步.</p><p>总结</p><p>综上介绍, 我们可以很好的理解 memcached slab 内存分配的机制, 也能理解通过增长因子就可以达到一定的性能优化, 在一些场景下可能会节省较多的内存消耗.最后通过测试详细说明了二进制协议在 memcached 中的报文格式, 对二进制格式有了较为深入的了解, 值得一提的是大部分的编程语言驱动包还只是支持文本协议, 要使用二进制协议需要安装非通用的驱动包。更多关于Memcached内部协议解析，请参考此处。其特性大致可以总结归纳为如下几点：<br>1、MemCache中可以保存的item数据量是没有限制的，只要内存足够</p><p>2、MemCache单进程在32位机中最大使用内存为2G，这个已经提了多次了，64位机则没有限制</p><p>3、Key最大为250个字节，超过该长度无法存储</p><p>4、单个item最大数据是1MB，超过1MB的数据不予存储</p><p>5、MemCache服务端是不安全的，比如已知某个MemCache节点，可以直接telnet过去，并通过flush_all让已经存在的键值对立即失效</p><p>6、不能够遍历MemCache中所有的item，因为这个操作的速度相对缓慢且会阻塞其他的操作</p><p>来源：<br><a href="http://www.freeoa.net/osuport/servap/memcached-mem-alloca-optimiz_3180.html" target="_blank" rel="noopener">http://www.freeoa.net/osuport/servap/memcached-mem-alloca-optimiz_3180.html</a></p>]]></content>
      
      
      <categories>
          
          <category> SystemProgramming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis Notes</title>
      <link href="/SystemProgramming/core-techs-database-redis/"/>
      <url>/SystemProgramming/core-techs-database-redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-Architecture-Design"><a href="#Redis-Architecture-Design" class="headerlink" title="Redis Architecture Design"></a>Redis Architecture Design</h1><p>Redis is generally known as a single-process, single-thread model. This is not true. Redis also runs multiple backend threads to perform backend cleaning works, such as cleansing the dirty data and closing file descriptors. In Redis, the main thread is responsible for the major tasks, including but not limited to: receiving the connections from clients, processing the connection read/write events, parsing requests, processing commands, processing timer events, and synchronizing data. Only one CPU core runs a single process and single thread. For small packets, a Redis server can process 80k to 100k QPS. A larger QPS is beyond the processing capacity of a Redis server. A common solution is to partition the data and adopt multiple servers in distributed architecture. However, this solution also has many drawbacks. For example, too many Redis servers to manage; some commands that are applicable to a single Redis server do not work on the data partitions; data partitions cannot solve the hot spot read/write problem; and data skew, redistribution, and scale-up/down become more complex. Due to restrictions of the single process and single thread, we hope that the multi-thread can be reconstructed to fully utilize the advantages of the SMP multi-core architecture, thus increasing the throughput of a single Redis server. To make Redis multi-threaded, the simplest way to think of is that every thread performs both I/O and command processing. However, as the data structure processed by Redis is complex, the multi-thread needs to use the locks to ensure the thread security. Improper handling of the lock granularity may deteriorate the performance.</p><p>We suggest that the number of I/O threads should be increased to enable an independent I/O thread to read/write data in the connections, parse commands, and reply data packets, and still let a single thread process the commands and execute the timer events. In this way, the throughput of a single Redis server can be increased.</p><p>单进程-单线程的优缺点</p><h2 id="Single-Process-and-Single-Thread-Model"><a href="#Single-Process-and-Single-Thread-Model" class="headerlink" title="Single Process and Single Thread Model"></a>Single Process and Single Thread Model</h2><h3 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h3><p>Due to restrictions of the single-process and single-thread model, time-consuming operations (such as dict rehash and expired key deletion) are broken into multiple steps and executed one by one in Redis implementation. This prevents execution of an operation for a long time and therefore avoids long time blocking of the system by an operation. The single-process and single-thread code is easy to compile, which reduces the context switching and lock seizure caused by multi-process and multi-thread.</p><h3 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages"></a>Disadvantages</h3><ul><li>Only one CPU core can be used, and the multi-core advantages cannot be utilized.</li><li>For heavy I/O applications, a large amount of CPU capacity is consumed by the network I/O operations. Applications that use Redis as cache are often heavy I/O applications. These applications basically have a high QPS, use relatively simple commands (such as get, set, and incr), but are RT sensitive. They often have a high bandwidth usage, which may even reach hundreds of megabits. Thanks to popularization of the 10-GB and 25-GB network adapters, the network bandwidth is no longer a bottleneck. Therefore, what we need to think about is how to utilize the advantages of multi-core and performance of the network adapter.</li></ul><p>单线程模型会严重影响整体的吞吐量，CPU计算过程中，整个IO调度都是被阻塞的。</p><p>为什么 Redis 使用单线程而不是多线程模型？</p><ul><li><strong>Ease of programming</strong> - Writing a multi-threaded program can be trickier. Sometimes multi-threading may not work, locks can block other threads.</li><li><strong>Concurrency</strong> can be achieved on single threaded system. Concurrency is not parallism.</li><li><strong>CPU is not bottleneck</strong> - Usually network is bottleneck. CPUs are very fast. If application is designed right, i.e. avoiding blocking IO, threading will be near the bottom of the list to worry about.</li><li><strong>Cost effective deployment</strong> - Such applications can work on any machine having at least a single CPU core.</li></ul><p>由于单线程无法发挥多核的优势，所以可以考虑改造为多线程，但需要考虑所增加的复杂度。</p><h1 id="Multi-Thread-Model-and-Implementation"><a href="#Multi-Thread-Model-and-Implementation" class="headerlink" title="Multi-Thread Model and Implementation"></a>Multi-Thread Model and Implementation</h1><h2 id="Thread-Model"><a href="#Thread-Model" class="headerlink" title="Thread Model"></a>Thread Model</h2><p>There are three thread types, namely:</p><ul><li>Main thread</li><li>I/O thread</li><li>Worker thread</li></ul><p>由一个主线程和多个 IO 线程组成。</p><ul><li>Main thread: Receives connections, creates clients, and forwards connections to the I/O thread.</li><li>I/O thread: Processes the connection read/write events, parses commands, forwards the complete parsed commands to the worker thread for processing, sends the response packets, and deletes connections.</li><li>Worker thread: Processes commands, generates the client response packets, and executes the timer events.</li><li>The main thread, I/O thread, and worker thread are driven by events separately.</li><li>Threads exchange data through the lock-free queue and send notifications through tunnels.</li></ul><p><img src="/image/database/redis_multi_threads.jpeg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                                                Memcached Redis</span><br><span class="line">Sub-millisecond latency                             Yes Yes</span><br><span class="line">Developer ease of use                               Yes Yes</span><br><span class="line">Data partitioning                                   Yes Yes</span><br><span class="line">Support for a broad set of programming languages    Yes Yes</span><br><span class="line">Advanced data structures                            -   Yes</span><br><span class="line">Multithreaded architecture                          Yes -</span><br><span class="line">Snapshots                                           -   Yes</span><br><span class="line">Replication                                         -   Yes</span><br><span class="line">Transactions                                        -   Yes</span><br><span class="line">Pub/Sub                                             -   Yes</span><br><span class="line">Lua scripting                                       -   Yes</span><br><span class="line">Geospatial support                                  -   Yes</span><br></pre></td></tr></table></figure><h1 id="Redis-Datastructures"><a href="#Redis-Datastructures" class="headerlink" title="Redis Datastructures"></a>Redis Datastructures</h1><p>Redis的 5 种对象类型：</p><ul><li>string</li><li>hash</li><li>list</li><li>set</li><li>sorted set</li></ul><h2 id="Redis-Memory-model"><a href="#Redis-Memory-model" class="headerlink" title="Redis Memory model"></a>Redis Memory model</h2><p>丰富的类型是 Redis 相对于Memcached等的一大优势。在了解了 Redis 5 种对象类型用法和特点的基础上，进一步了解 <strong>Redis 的内存模型</strong>，对Redis的使用会有很大帮助!</p><ul><li>估算Redis内存使用量。目前为止，内存的使用成本仍然相对较高，使用内存不能无所顾忌；根据需求合理的评估Redis的内存使用量，选择合适的机器配置，可以在满足需求的情况下节约成本。</li><li>优化内存占用。了解Redis内存模型可以选择更合适的数据类型和编码，更好的利用Redis内存。</li><li>分析解决问题。当Redis出现阻塞、内存占用等问题时，尽快发现导致问题的原因，便于分析解决问题。</li></ul><p>Redis占用内存的情况及如何查询、不同的对象类型在内存中的编码方式、内存分配器（jemalloc）、简单动态字符串（SDS）、RedisObject等</p><h3 id="1-Redis内存统计"><a href="#1-Redis内存统计" class="headerlink" title="1. Redis内存统计"></a>1. Redis内存统计</h3><p>在客户端通过 redis-cli 连接服务器后, 使用 info 命令可以查看内存使用情况</p><h3 id="2-Redis内存划分"><a href="#2-Redis内存划分" class="headerlink" title="2. Redis内存划分"></a>2. Redis内存划分</h3><p>除了数据以外，Redis的其它部分也会占用内存。</p><p>1、数据<br>作为数据库，数据是最主要的部分，这部分占用的内存会统计在used_memory中。</p><p>Redis 提供的 5 种类型是对外提供的。实际上，在Redis内部，每种类型可能有2种或更多的内部编码实现。此外，Redis在存储对象时，并不是直接将数据扔进内存，而是会对对象进行各种包装：如RedisObject、SDS等。</p><p>2、进程本身运行需要的内存<br>Redis 主进程本身运行肯定需要占用内存，如代码、常量池等等。这部分内存大约几兆，在大多数生产环境中与Redis数据占用的内存相比可以忽略。这部分内存不是由jemalloc分配，因此不会统计在used_memory中。</p><p>补充说明：除了主进程外，Redis创建的子进程运行也会占用内存，如Redis执行AOF、RDB重写时创建的子进程。当然，这部分内存不属于Redis进程，也不会统计在used_memory和used_memory_rss中。</p><p>3、缓冲内存</p><p>缓冲内存包括：<br>客户端缓冲区：存储客户端连接的输入输出缓冲；<br>复制积压缓冲区：用于部分复制功能；<br>AOF缓冲区：用于在进行AOF重写时，保存最近的写入命令。</p><p>在了解相应功能之前，不需要知道这些缓冲的细节。这部分内存由jemalloc分配，因此会统计在used_memory中。</p><p>4、内存碎片<br>内存碎片是Redis在分配、回收物理内存过程中产生的。例如，如果对数据更改频繁，而且数据之间的大小相差很大，可能导致Redis释放的空间在物理内存中并没有释放，但Redis又无法有效利用，这就形成了内存碎片。内存碎片不会统计在used_memory中。</p><p>内存碎片的产生与对数据进行的操作、数据的特点等都有关。此外，与使用的内存分配器也有关系——如果内存分配器设计合理，可以尽可能的减少内存碎片的产生。后面将要说到的jemalloc便在控制内存碎片方面做的很好。</p><p>如果Redis服务器中的内存碎片已经很大，可以通过安全重启的方式减小内存碎片。因为重启之后，Redis重新从备份文件中读取数据，在内存中进行重排，为每个数据重新选择合适的内存单元，减小内存碎片。</p><h3 id="3-Redis-数据存储的细节"><a href="#3-Redis-数据存储的细节" class="headerlink" title="3. Redis 数据存储的细节"></a>3. Redis 数据存储的细节</h3><p>。。。</p><p>Redis 内部使用一个redisObject对象来表示所有的key和value。redisObject主要的信息包括数据类型（type）、编码方式(encoding)、数据指针（ptr）、虚拟内存（vm）等。type代表一个value对象具体是何种数据类型，encoding是不同数据类型在redis内部式。</p><p><img src="/image/database/redisObject.png" alt="redisObject 对象示意图"></p><h4 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h4><p>字符串是Redis值的最基础的类型。Redis中使用的字符串是通过包装的，基于c语言字符数组实现的简单动态字符串(simple dynamic string, SDS)一个抽象数据结构。</p><p>SDS 源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">//len表示buf中存储的字符串的长度。</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">//free表示buf中空闲空间的长度。</span></span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">//buf用于存储字符串内容。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>SDS 与 C 字符串的比较</p><p>SDS 在 C 字符串的基础上加入了free和len字段，带来了很多好处：</p><p>获取字符串长度：SDS是O(1)，C字符串是O(n)。</p><p>缓冲区溢出：使用C字符串的API时，如果字符串长度增加（如strcat操作）而忘记重新分配内存，很容易造成缓冲区的溢出；而SDS由于记录了长度，相应的API在可能造成缓冲区溢出时会自动重新分配内存，杜绝了缓冲区溢出。</p><p>修改字符串时内存的重分配：对于C字符串，如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。而对于SDS，由于可以记录len和free，因此解除了字符串长度和空间数组长度之间的关联，可以在此基础上进行优化——空间预分配策略（即分配内存时比实际需要的多）使得字符串长度增大时重新分配内存的概率大大减小；惰性空间释放策略使得字符串长度减小时重新分配内存的概率大大减小。</p><p>存取二进制数据：SDS 可以，C 字符串不可以。因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而SDS以字符串长度len来作为字符串结束标识，因此没有这个问题。</p><p>此外，由于SDS中的buf仍然使用了C字符串（即以‘\0’结尾），因此SDS可以使用C字符串库中的部分函数。但是需要注意的是，只有当SDS用来存储文本数据时才可以这样使用，在存储二进制数据时则不行（‘\0’不一定是结尾）。</p><p>参考：<br><a href="https://blog.csdn.net/tTU1EvLDeLFq5btqiK/article/details/81140409" target="_blank" rel="noopener">https://blog.csdn.net/tTU1EvLDeLFq5btqiK/article/details/81140409</a><br><a href="https://blog.csdn.net/qq_26624661/article/details/79269740" target="_blank" rel="noopener">https://blog.csdn.net/qq_26624661/article/details/79269740</a></p><h3 id="Redis-实现分布式锁？"><a href="#Redis-实现分布式锁？" class="headerlink" title="Redis 实现分布式锁？"></a>Redis 实现分布式锁？</h3><p>锁的本质就是互斥，保证任何时候能有一个客户端持有同一个锁，如果考虑使用redis来实现一个分布式锁，最简单的方案就是在实例里面创建一个键值，释放锁的时候，将键值删除。但是一个可靠完善的分布式锁需要考虑的细节比较多，我们就来看看如何写一个正确的分布式锁。</p><p>单机版分布式锁 SETNX</p><p>setNX 命令作用是 SET if Not eXists，我们利用它来实现一个简单的锁。</p><p>锁的获取：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET &lt;resource_name&gt; &lt;my_random_value&gt; NX PX 30000</span><br></pre></td></tr></table></figure><p>锁的释放：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>几个细节需要注意：</p><ul><li><p>首先在获取锁的时候我们需要设置设置超时时间。设置超时时间是为了，防止客户端崩溃，或者网络出现问题以后锁一直被持有。真个系统就死锁了。</p></li><li><p>使用 setNX 命令，保证查询和写入两个步骤是原子的</p></li><li><p>在锁释放的时候我们判断了KEYS[1]) == ARGV[1]，在这里 KEYS[1]是从redis里面取出来的value，ARGV[1]是上文生成的my_random_value。之所以进行以上的判断，是为了保证锁被锁的持有者释放。我们假设不进行这一步校验：</p><ul><li>客户端A获取锁，后发线程挂起了。时间大于锁的过期时间。</li><li>锁过期后，客户端B获取锁。</li><li>客户端A恢复以后，处理完相关事件，向redis发起 del命令。锁被释放</li><li>客户端C获取锁。这个时候一个系统中同时两个客户端持有锁。</li></ul></li></ul><p>造成这个问题的关键，在于客户端B持有的锁，被客户端A释放了。</p><ul><li>锁的释放必须使用 lua 脚本，保证操作的原子性。锁的释放包含了 get，判断，del 三个步骤。如果不能保证三个步骤的原子性，分布式锁就会有并发问题。</li></ul><p>注意了以上细节，一个单redis节点的分布式锁就达成了。</p><p>在这个分布式锁中还是存在一个单点的redis。也许你会说，Redis是 master-slave的架构，发生故障的时候切换到slave就好，但是Redis的复制是异步的。</p><p>如果在客户端A在master上拿到了锁。<br>在master将数据同步到slave上之前，master宕机。<br>客户端B就从slave上又一次拿到了锁。<br>这样由于Master的宕机，造成了同时多人持有锁。如果你的系统可用接受短时时间内，有多人持有锁。这个简单的方案就能解决问题。</p><p>但是如果解决这个问题。Redis的官方提供了一个Redlock的解决方案。</p><h3 id="RedLock-的实现"><a href="#RedLock-的实现" class="headerlink" title="RedLock 的实现"></a>RedLock 的实现</h3><p>为了解决，Redis 单点的问题。Redis的作者提出了RedLock的解决方案。方案非常的巧妙和简洁。<br>RedLock的核心思想就是，同时使用多个Redis Master来冗余，且这些节点都是完全的独立的，也不需要对这些节点之间的数据进行同步。</p><p>假设我们有 N 个 Redis 节点，N 应该是一个大于 2 的奇数。RedLock 的实现步骤:</p><ul><li>取得当前时间</li><li>使用上文提到的方法依次获取 N 个节点的 Redis 锁。</li><li>如果获取到的锁的数量大于 （N/2+1）个，且获取的时间小于锁的有效时间(lock validity time)就认为获取到了一个有效的锁。锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。</li><li>如果获取锁的数量小于 （N/2+1），或者在锁的有效时间(lock validity time)内没有获取到足够的说，就认为获取锁失败。这个时候需要向所有节点发送释放锁的消息。<br>对于释放锁的实现就很简单了。向所有的 Redis 节点发起释放的操作，无论之前是否获取锁成功。</li></ul><p>同时需要注意几个细节：</p><p>重试获取锁的间隔时间应当是一个随机范围而非一个固定时间。这样可以防止，多客户端同时一起向 Redis 集群发送获取锁的操作，避免同时竞争。同时获取相同数量锁的情况。（虽然概率很低）<br>如果某 master 节点故障之后，回复的时间间隔应当大于锁的有效时间。</p><p>假设有 A，B，C 三个 Redis 节点。<br>客户端 foo 获取到了 A、B 两个锁。<br>这个时候 B 宕机，所有内存的数据丢失。<br>B 节点恢复。<br>这个时候客户端bar重新获取锁，获取到B，C两个节点。<br>此时又有两个客户端获取到锁了。</p><p>所以如果恢复的时间将大于锁的有效时间，就可以避免以上情况发生。同时如果性能要求不高，甚至可以开启Redis的持久化选项。</p><p>总结<br>了解了Redis分布式的实现以后，其实觉得大多数的分布式系统其实原理很简单，但是为了保证分布式系统的可靠性需要注意很多的细节，琐碎异常。<br>RedLock算法实现的分布式锁就是简单高效，思路相当巧妙。</p><p>虽然看上去 RedLock 实现了分布式锁，但是网上有人（Martin Kleppmann）对这种实现发出了批评，他先是提出了两个使用锁的原因：</p><p>1）提升效率，用锁来保证一个任务没有必要被执行两次。比如（很昂贵的计算）<br>2）保证正确，使用锁来保证任务按照正常的步骤执行，防止两个节点同时操作一份数据，造成文件冲突，数据丢失。</p><p>然后，其指出，对于第一种原因，我们对锁是有一定宽容度的，就算发生了两个节点同时工作，对系统的影响也仅仅是多付出了一些计算的成本，没什么额外的影响。这个时候 使用单点的 Redis 就能很好的解决问题，没有必要使用RedLock，维护那么多的Redis实例，提升系统的维护成本。</p><p>对于第二种原因，对正确性严格要求的场景（比如订单，或者消费），就算使用了 RedLock 算法仍然不能保证锁的正确性。</p><p>因为，RedLock 只是保证了锁的高可用性，并没有保证锁的正确性。</p><p>Martin给出了一个解决的方案，增加一个 token-fencing，它是单调递增的，我们可以把其理解为一个乐观锁，所以 RedLock 是一个严重依赖系统时钟的分布式系统</p><p>最后， Redis 作者 antirez 还打出了一个暴击，既然 Martin 提出的系统使用 fecting token 保证数据的顺序处理。还需要 RedLock，或者别的分布式锁 干啥？？</p><h3 id="Redis-数据库实现与键过期"><a href="#Redis-数据库实现与键过期" class="headerlink" title="Redis 数据库实现与键过期"></a>Redis 数据库实现与键过期</h3><h4 id="1）Redis-的数据库实现"><a href="#1）Redis-的数据库实现" class="headerlink" title="1）Redis 的数据库实现"></a>1）Redis 的数据库实现</h4><p>主要在 <code>server.h/redisServer/</code> 中</p><ol><li>redisServer</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    redisDb *db; <span class="comment">// 保存 db 的数组</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;   <span class="comment">// db 的数量</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>redisDb</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP)*/</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><ol start="3"><li>dict</li></ol><p><img src="/image/database/dict_struacture.png" alt=""></p><p>总体来说 redis 的 server 包含若干个（默认16个） redisDb 数据库。</p><p><img src="/image/database/redisServer.jpg" alt=""></p><p>Redis 是一个 kv 存储的键值对数据库。其中字典 dict 保存了数据库中的所有键值对。</p><p>在执行对键的读写操作的时候，Redis 还要做一些额外的维护动作：</p><ul><li>维护 hit 和 miss 两个计数器。用于统计 Redis 的缓存命中率。</li><li>更新键的 LRU 时间，记录键的最后活跃时间。</li><li>如果在读取的时候发现键已经过期，Redis 先删除这个过期的键然后再执行余下操作。</li><li>如果有客户对这个键执行了 WATCH 操作，会把这个键标记为 dirty，让事务注意到这个键已经被改过。</li><li>没修改一次 dirty 会增加1。</li><li>如果服务器开启了数据库通知功能，键被修改之后，会按照配置发送通知。</li></ul><h4 id="2）Redis-键过期的策略"><a href="#2）Redis-键过期的策略" class="headerlink" title="2）Redis 键过期的策略"></a>2）Redis 键过期的策略</h4><p>我们可以看到 redisDb 结构体中 expires 就是用来保存过期时间的。</p><p>对于过期的判断逻辑很简单：</p><ul><li>在 expires 字典中检查 key 是否存在。</li><li>如果 key 存在，判断 value 的时间戳是否小于当前系统时间戳。</li></ul><p>key的删除有三种策略：</p><ul><li>定时删除，Redis定时的删除内存里面所有过期的键值对，这样能够保证内存友好，过期的key都会被删除，但是如果key的数量很多，一次删除需要CPU运算，CPU不友好。</li><li>惰性删除，只有 key 在被调用的时候才去检查键值对是否过期，但是会造成内存中存储大量的过期键值对，内存不友好，但是极大的减轻CPU 的负担。</li><li>定时部分删除，Redis定时扫描过期键，但是只删除部分，至于删除多少键，根据当前 Redis 的状态决定。</li></ul><p>这三种策略就是对时间和空间有不同的倾向。Redis 为了平衡时间和空间，采用了后两种策略，<strong>惰性删除</strong>和<strong>定时部分删除</strong>。</p><p>惰性删除比较简单，不做过多介绍。主要讨论一下定时部分删除。</p><p>过期键的定时删除的策略由 expire.c/activeExpireCycle() 函数实现，server.c/serverCron() 定时的调用 activieExpireCycle() 。</p>]]></content>
      
      
      <categories>
          
          <category> SystemProgramming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BigTable Notes</title>
      <link href="/SystemProgramming/core-techs-database-bigtable/"/>
      <url>/SystemProgramming/core-techs-database-bigtable/</url>
      
        <content type="html"><![CDATA[<p>文章前面对于 Bigtable 的介绍其实都是对 LevelDB 这部分内容所做的铺垫，当然这并不是说前面的内容就不重要，LevelDB 是对 Bigtable 论文中描述的键值存储系统的单机版的实现，它提供了一个极其高速的键值存储系统，并且由 Bigtable 的作者 Jeff Dean 和 Sanjay Ghemawat 共同完成，可以说高度复刻了 Bigtable 论文中对于其实现的描述。</p><p>因为 Bigtable 只是一篇论文，同时又因为其实现依赖于 Google 的一些不开源的基础服务：GFS、Chubby 等等，我们很难接触到它的源代码，不过我们可以通过 LevelDB 更好地了解这篇论文中提到的诸多内容和思量。</p>]]></content>
      
      
      <categories>
          
          <category> SystemProgramming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RockDB Notes</title>
      <link href="/SystemProgramming/core-techs-database-rocksdb/"/>
      <url>/SystemProgramming/core-techs-database-rocksdb/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> SystemProgramming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis 与 Memcached 的区别</title>
      <link href="/SystemProgramming/core-techs-database-redis-memcached/"/>
      <url>/SystemProgramming/core-techs-database-redis-memcached/</url>
      
        <content type="html"><![CDATA[<p>1、redis 不仅支持 key-value 数据类型，同时还提供了 list，set，zset，hash 等数据结构的存储。<br>2、redis 支持数据备份，即 master-slave 模式的数据备份<br>3、redis 支持数据持久化，可以将内存数据保存在磁盘中，重启的时候可以再次加载进行使用。</p><p>下面详细介绍区别：</p><h2 id="一、网络-IO-模型"><a href="#一、网络-IO-模型" class="headerlink" title="一、网络 IO 模型"></a>一、网络 IO 模型</h2><p>memcached是多线程的，非阻塞IO复用网络模型，分为 listener主线程 和 worker子线程，listener线程监听网络连接，接受请求后将连接描述字pipe传递给worker（一般的高复用都是这种处理方式），进行读写IO，网络层使用的libevent封装的事件库，多线程模型可以发挥多核作用，但是也引入了cache coherency 和 锁的问题,比如：memcached最常用的stats命令，实际memcached所有的操作都要对这个全局变量加锁，进行计数等工作，这会带来性能损耗。</p><p>redis使用的是单线程IO复用模型，自己封装了一个简单的AeEvent事件处理框架（可以去看源码哦C++丢了好久，马马虎虎磕磕碰碰的看了一点），主要实现了epoll，kquue 和 select，对于单存只有 IO操作来说，单线程可以将速度发挥大最大优势，但是redis也提供了简单的计算功能，比如排序、聚合等，对于这些操作，单线程模型会严重影响整体的吞吐量，CPU计算过程中，整个IO调度都是被阻塞的。</p><h2 id="二、内存管理机制"><a href="#二、内存管理机制" class="headerlink" title="二、内存管理机制"></a>二、内存管理机制</h2><p>redis 与 memcached 均使用了自身设计的内存管理机制，但实现方法存在很大差异：</p><p>memcached默认使用 Slab Allocation机制管理内存，其主要思想按照预先规定的大小将分配的内存分割成特定长度的块以存储相应长度的key-value数据，以完全解决内存碎片问题。Slab Allocation机制职位存储外部数据而设计，也就是说所有的key-value数据都存在 Slab Allocation系统中，而 memcached其他内存请求则通过普通的malloc/free来申请，因为这些请求的数量和频率决定了它们不会对整个系统造成影响。</p><p>如下图所示，它首先从操作系统申请一大块内存，并将其分割成各种尺寸的块Chunk，并把尺寸相同的块分成组Slab Class。其中，Chunk就是用来存储key-value数据的最小单位。每个Slab Class的大小，可以在Memcached启动的时候通过制定Growth Factor来控制。假定图中Growth Factor的取值为1.25，如果第一组Chunk的大小为88个字节，第二组Chunk的大小就为112个字节，依此类推</p><p><img src="/image/database/slab_alloc.jpg" alt=""></p><p>当Memcached接收到客户端发送过来的数据时首先会根据收到数据的大小选择一个最合适的Slab Class，然后通过查询Memcached保存着的该Slab Class内空闲Chunk的列表就可以找到一个可用于存储数据的Chunk。当一条数据库过期或者丢弃时，该记录所占用的Chunk就可以回收，重新添加到空闲列表中。从以上过程我们可以看出Memcached的内存管理制效率高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。因为每个Chunk都分配了特定长度的内存空间，所以变长数据无法充分利用这些空间。如图 所示，将100个字节的数据缓存到128个字节的Chunk中，剩余的28个字节就浪费掉了。</p><p><img src="/image/database/chunk_wasted.jpg" alt=""></p><p>Redis的内存管理主要通过源码中zmalloc.h和zmalloc.c两个文件来实现的。Redis为了方便内存的管理，在分配一块内存之后，会将这块内存的大小存入内存块的头部。如图所示，real_ptr是redis调用malloc后返回的指针。redis将内存块的大小size存入头部，size所占据的内存大小是已知的，为size_t类型的长度，然后返回ret_ptr。当需要释放内存的时候，ret_ptr被传给内存管理程序。通过ret_ptr，程序可以很容易的算出real_ptr的值，然后将real_ptr传给free释放内存。</p><p><img src="/image/database/mem_block.jpg" alt=""></p><p>Redis通过定义一个数组来记录所有的内存分配情况，这个数组的长度为ZMALLOC_MAX_ALLOC_STAT。数组的每一个元素代表当前程序所分配的内存块的个数，且内存块的大小为该元素的下标。在源码中，这个数组为zmalloc_allocations。zmalloc_allocations[16]代表已经分配的长度为16bytes的内存块的个数。zmalloc.c中有一个静态变量used_memory用来记录当前分配的内存总大小。所以，总的来看，Redis采用的是包装的mallc/free，相较于Memcached的内存管理方法来说，要简单很多。</p><p>在Redis中，并不是所有的数据都一直存储在内存中的。这是和Memcached相比一个最大的区别。当物理内存用完时，Redis可以将一些很久没用到的value交换到磁盘。Redis只会缓存所有的key的信息，如果Redis发现内存的使用量超过了某一个阀值，将触发swap的操作，Redis根据“swappability = age*log(size_in_memory)”计算出哪些key对应的value需要swap到磁盘。然后再将这些key对应的value持久化到磁盘中，同时在内存中清除。这种特性使得Redis可以保持超过其机器本身内存大小的数据。当然，机器本身的内存必须要能够保持所有的key，毕竟这些数据是不会进行swap操作的。同时由于Redis将内存中的数据swap到磁盘中的时候，提供服务的主线程和进行swap操作的子线程会共享这部分内存，所以如果更新需要swap的数据，Redis将阻塞这个操作，直到子线程完成swap操作后才可以进行修改。当从Redis中读取数据的时候，如果读取的key对应的value不在内存中，那么Redis就需要从swap文件中加载相应数据，然后再返回给请求方。 这里就存在一个I/O线程池的问题。在默认的情况下，Redis会出现阻塞，即完成所有的swap文件加载后才会相应。这种策略在客户端的数量较小，进行批量操作的时候比较合适。但是如果将Redis应用在一个大型的网站应用程序中，这显然是无法满足大并发的情况的。所以Redis运行我们设置I/O线程池的大小，对需要从swap文件中加载相应数据的读取请求进行并发操作，减少阻塞的时间。</p><p>Memcached使用预分配的内存池的方式，使用slab和大小不同的chunk来管理内存，Item根据大小选择合适的chunk存储，内存池的方式可以省去申请/释放内存的开销，并且能减小内存碎片产生，但这种方式也会带来一定程度上的空间浪费，并且在内存仍然有很大空间时，新的数据也可能会被剔除，原因可以参考Timyang的文章：<a href="http://timyang.net/data/Memcached-lru-evictions/" target="_blank" rel="noopener">http://timyang.net/data/Memcached-lru-evictions/</a></p><p>Redis使用现场申请内存的方式来存储数据，并且很少使用free-list等方式来优化内存分配，会在一定程度上存在内存碎片，Redis跟据存储命令参数，会把带过期时间的数据单独存放在一起，并把它们称为临时数据，非临时数据是永远不会被剔除的，即便物理内存不够，导致swap也不会剔除任何非临时数据（但会尝试剔除部分临时数据），这点上Redis更适合作为存储而不是cache。</p><h2 id="三、数据存储及持久化"><a href="#三、数据存储及持久化" class="headerlink" title="三、数据存储及持久化"></a>三、数据存储及持久化</h2><p>memcached不支持内存数据的持久化操作，所有的数据都以in-memory的形式存储。</p><p>redis支持持久化操作。redis提供了两种不同的持久化方法来讲数据存储到硬盘里面，一种是快照（snapshotting)，它可以将存在于某一时刻的所有数据都写入硬盘里面。另一种方法叫只追加文件（append-only file， AOF),它会在执行写命令时，将被执行的写命令复制到硬盘里面。</p><h2 id="四、数据一致性问题"><a href="#四、数据一致性问题" class="headerlink" title="四、数据一致性问题"></a>四、数据一致性问题</h2><p>Memcached提供了cas命令，可以保证多个并发访问操作同一份数据的一致性问题。 Redis没有提供cas 命令，并不能保证这点，不过Redis提供了事务的功能，可以保证一串 命令的原子性，中间不会被任何操作打断。</p><h2 id="五、集群管理不同"><a href="#五、集群管理不同" class="headerlink" title="五、集群管理不同"></a>五、集群管理不同</h2><p>Memcached是全内存的数据缓冲系统，Redis虽然支持数据的持久化，但是全内存毕竟才是其高性能的本质。作为基于内存的存储系统来说，机器物理内存的大小就是系统能够容纳的最大数据量。如果需要处理的数据量超过了单台机器的物理内存大小，就需要构建分布式集群来扩展存储能力。</p><p>Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。下图给出了Memcached的分布式存储实现架构。当客户端向Memcached集群发送数据之前，首先会通过内置的分布式算法计算出该条数据的目标节点，然后数据会直接发送到该节点上存储。但客户端查询数据时，同样要计算出查询数据所在的节点，然后直接向该节点发送查询请求以获取数据。</p><p>相较于Memcached只能采用客户端实现分布式存储，Redis更偏向于在服务器端构建分布式存储。最新版本的Redis已经支持了分布式存储功能。Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，具有线性可伸缩的功能。Redis Cluster的分布式存储架构，节点与节点之间通过二进制协议进行通信，节点与客户端之间通过ascii协议进行通信。在数据的放置策略上，Redis Cluster将整个key的数值域分成4096个哈希槽，每个节点上可以存储一个或多个哈希槽，也就是说当前Redis Cluster支持的最大节点数就是4096。Redis Cluster使用的分布式算法也很简单：crc16( key ) % HASH_SLOTS_NUMBER。</p><p>为了保证单点故障下的数据可用性，Redis Cluster引入了Master节点和Slave节点。在Redis Cluster中，每个Master节点都会有对应的两个用于冗余的Slave节点。这样在整个集群中，任意两个节点的宕机都不会导致数据的不可用。当Master节点退出后，集群会自动选择一个Slave节点成为新的Master节点。</p><p>来源：<br><a href="https://my.oschina.net/exit/blog/733684" target="_blank" rel="noopener">https://my.oschina.net/exit/blog/733684</a></p>]]></content>
      
      
      <categories>
          
          <category> SystemProgramming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL Notes</title>
      <link href="/SystemProgramming/core-techs-database-mysql/"/>
      <url>/SystemProgramming/core-techs-database-mysql/</url>
      
        <content type="html"><![CDATA[<p>1、MySQL的复制原理以及流程<br>基本原理流程，3个线程以及之间的关联；<br>主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；<br>从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；<br>从：sql执行线程——执行relay log中的语句；</p><p>2、MySQL中myisam与innodb的区别，至少5点</p><p>(1)、问5点不同；<br>1&gt;.InnoDB支持事物，而MyISAM不支持事物<br>2&gt;.InnoDB支持行级锁，而MyISAM支持表级锁<br>3&gt;.InnoDB支持MVCC, 而MyISAM不支持<br>4&gt;.InnoDB支持外键，而MyISAM不支持<br>5&gt;.InnoDB不支持全文索引，而MyISAM支持。</p><p>(2)、innodb引擎的4大特性<br>插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)</p><p>(3)、2者selectcount(*)哪个更快，为什么<br>myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</p><p>3、MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义<br>(1)、varchar与char的区别<br>char是一种固定长度的类型，varchar则是一种可变长度的类型<br>(2)、varchar(50)中50的涵义<br>最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)<br>(3)、int（20）中20的涵义<br>是指显示字符的长度<br>但要加参数的，最大为255，比如它是记录行数的id,插入10笔资料，它就显示00000000001 <del>~</del>00000000010，当字符的位数超过11,它也只显示11位，如果你没有加那个让它未满11位就前面加0的参数，它不会在前面加0<br>20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；<br>(4)、mysql为什么这么设计<br>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；</p><p>4、问了innodb的事务与日志的实现方式</p><p>(1)、有多少种日志；<br>错误日志：记录出错信息，也记录一些警告信息或者正确的信息。<br>查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。<br>慢查询日志：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。<br>二进制日志：记录对数据库执行更改的所有操作。<br>中继日志：中继日志也是二进制日志，用来给slave 库恢复<br>事务日志：重做日志redo和回滚日志undo</p><p>(2)、事物的4种隔离级别<br>隔离级别<br>读未提交(RU)<br>读已提交(RC)<br>可重复读(RR)<br>串行</p><p>(3)、事务是如何通过日志来实现的，说得越深入越好。<br>事务日志是通过redo和innodb的存储引擎日志缓冲（Innodb log buffer）来实现的，当开始一个事务的时候，会记录该事务的lsn(log sequence number)号; 当事务执行时，会往InnoDB存储引擎的日志的日志缓存里面插入事务日志；当事务提交时，必须将存储引擎的日志缓冲写入磁盘（通过innodb_flush_log_at_trx_commit来控制），也就是写数据前，需要先写日志。这种方式称为“预写日志方式”</p><p>5、MySQL binlog的几种日志录入格式以及区别<br>Statement：每一条会修改数据的sql都会记录在binlog中。<br>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。(相比row能节约多少性能 与日志量，这个取决于应用的SQL情况，正常同一条记录修改或者插入row格式所产生的日志量还小于Statement产生的日志量，但是考虑到如果带条 件的update操作，以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据应用的实际情况，其所 产生的日志量会增加多少，以及带来的IO性能问题。)<br>缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的 一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同 的结果。另外mysql 的复制,像一些特定函数功能，slave可与master上要保持一致会有很多相关问题(如sleep()函数， last_insert_id()，以及user-defined functions(udf)会出现问题).<br>使用以下函数的语句也无法被复制：<br>LOAD_FILE()<br>UUID()<br>USER()<br>FOUND_ROWS()<br>SYSDATE() (除非启动时启用了 –sysdate-is-now 选项)</p><p>同时在INSERT …SELECT 会产生比 RBR 更多的行级锁<br>Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。<br>优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下 每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题<br>缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比 如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。<br>Mixedlevel: 是以上两种level的混合使用，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则 采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择 一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更。</p><p>6、MySQL数据库cpu飙升到500%的话他怎么处理？</p><p>1、列出所有进程 show processlist,观察所有进程 ,多秒没有状态变化的(干掉)<br>2、查看超时日志或者错误日志 (做了几年开发,一般会是查询以及大批量的插入会导致cpu与i/o上涨,当然不排除网络状态突然断了,导致一个请求服务器只接受到一半，比如where子句或分页子句没有发送,,当然的一次被坑经历)</p><p>7、sql优化各种方法<br>(1)、explain出来的各种item的意义；<br>select_type<br>表示查询中每个select子句的类型<br>type<br>表示MySQL在表中找到所需行的方式，又称“访问类型”<br>possible_keys<br>指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用<br>key<br>显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL<br>key_len<br>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度<br>ref<br>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值<br>Extra<br>包含不适合在其他列中显示但十分重要的额外信息<br>(2)、profile的意义以及使用场景；<br>查询到 SQL 会执行多少时间, 并看出 CPU/Memory 使用量, 执行过程中 Systemlock, Table lock 花多少时间等等<br>8、备份计划，mysqldump以及xtranbackup的实现原理<br>(1)、备份计划；<br>这里每个公司都不一样，您别说那种1小时1全备什么的就行<br>(2)、备份恢复时间；<br>这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考<br>20G的2分钟（mysqldump）<br>80G的30分钟(mysqldump)<br>111G的30分钟（mysqldump)<br>288G的3小时（xtra)<br>3T的4小时（xtra)<br>逻辑导入时间一般是备份时间的5倍以上<br>(3)、xtrabackup实现原理<br>在InnoDB内部会维护一个redo日志文件，我们也可以叫做事务日志文件。事务日志会存储每一个InnoDB表数据的记录修改。当InnoDB启动时，InnoDB会检查数据文件和事务日志，并执行两个步骤：它应用（前滚）已经提交的事务日志到数据文件，并将修改过但没有提交的数据进行回滚操作。<br>9、mysqldump中备份出来的sql，如果我想sql文件中，一行只有一个insert….value()的话，怎么办？如果备份需要带上master的复制点信息怎么办？<br>–skip-extended-insert</p><p>[root@helei-zhuanshu ~]# mysqldump -uroot -p helei –skip-extended-insert</p><p>Enter password:</p><p>KEY <code>idx_c1</code> (<code>c1</code>),</p><p>KEY <code>idx_c2</code> (<code>c2</code>)</p><p>) ENGINE=InnoDB AUTO_INCREMENT=51 DEFAULT CHARSET=latin1;</p><p>/*!40101 SET character_set_client = @saved_cs_client */;</p><p>–</p><p>– Dumping data for table <code>helei</code></p><p>–</p><p>LOCK TABLES <code>helei</code> WRITE;</p><p>/*!40000 ALTER TABLE <code>helei</code> DISABLE KEYS */;</p><p>INSERT INTO <code>helei</code> VALUES (1,32,37,38,’2016-10-18 06:19:24’,’susususususususususususu’);</p><p>INSERT INTO <code>helei</code> VALUES (2,37,46,21,’2016-10-18 06:19:24’,’susususususu’);</p><p>INSERT INTO <code>helei</code> VALUES (3,21,5,14,’2016-10-18 06:19:24’,’susu’);<br>复制代码10、500台db，在最快时间之内重启<br>可以使用批量 ssh 工具 pssh 来对需要重启的机器执行重启命令。 也可以使用 salt（前提是客户端有安装 salt）或者 ansible（ ansible 只需要 ssh 免登通了就行）等多线程工具同时操作多台服务器<br>11、innodb的读写参数优化<br>(1)、读取参数<br>global buffer pool以及 local buffer；<br>复制代码(2)、写入参数；<br>innodb_flush_log_at_trx_commit</p><p>innodb_buffer_pool_size<br>复制代码(3)、与IO相关的参数；<br>innodb_write_io_threads = 8</p><p>innodb_read_io_threads = 8</p><p>innodb_thread_concurrency = 0<br>复制代码(4)、缓存参数以及缓存的适用场景。<br>query cache/query_cache_type<br>复制代码并不是所有表都适合使用query cache。造成query cache失效的原因主要是相应的table发生了变更<br>第一个：读操作多的话看看比例，简单来说，如果是用户清单表，或者说是数据比例比较固定，比如说商品列表，是可以打开的，前提是这些库比较集中，数据库中的实务比较小。<br>第二个：我们“行骗”的时候，比如说我们竞标的时候压测，把query cache打开，还是能收到qps激增的效果，当然前提示前端的连接池什么的都配置一样。大部分情况下如果写入的居多，访问量并不多，那么就不要打开，例如社交网站的，10%的人产生内容，其余的90%都在消费，打开还是效果很好的，但是你如果是qq消息，或者聊天，那就很要命。<br>第三个：小网站或者没有高并发的无所谓，高并发下，会看到 很多 qcache 锁 等待，所以一般高并发下，不建议打开query cache<br>12、你是如何监控你们的数据库的？你们的慢日志都是怎么查询的？<br>监控的工具有很多，例如zabbix，lepus，我这里用的是lepus<br>13、你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？<br>主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等<br>14、你们数据库是否支持emoji表情，如果不支持，如何操作？<br>如果是utf8字符集的话，需要升级至utf8_mb4方可支持<br>15、你是如何维护数据库的数据字典的？<br>这个大家维护的方法都不同，我一般是直接在生产库进行注释，利用工具导出成excel方便流通。<br>16、表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主，请问<br>拆带来的问题：连接消耗 + 存储拆分空间；不拆可能带来的问题：查询性能；</p><p>1、如果能容忍拆分带来的空间问题,拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区) 顺序IO,减少连接消耗,最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗</p><p>2、如果能容忍不拆分带来的查询性能损失的话:上面的方案在某个极致条件下肯定会出现问题,那么不拆就是最好的选择</p><p>17、MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？<br>InnoDB是基于索引来完成行锁<br>例: select * from tab_with_index where id = 1 for update;<br>for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列,<br>如果 id 不是索引键那么InnoDB将完成表锁,,并发将无从谈起<br>18、开放性问题：据说是腾讯的<br>一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。</p><p>1、如果A表TID是自增长,并且是连续的,B表的ID为索引</p><p>select * from a,b where a.tid = b.id and a.tid&gt;500000 limit 200;<br>复制代码<br>2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。</p><p>select * from b , (select tid from a limit 50000,200) a where b.id = a .tid;<br>复制代码19、什么是存储过程？有哪些优缺点？<br>存储过程是一些预编译的SQL语句。</p><p>1、更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。<br>2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全</p><p>20、索引是什么？有什么作用以及优缺点？</p><p>1、索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构<br>2、索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。</p><p>MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引</p><p>1、索引加快数据库的检索速度<br>2、索引降低了插入、删除、修改等维护任务的速度<br>3、唯一索引可以确保每一行数据的唯一性<br>4、通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能<br>5、索引需要占物理和数据空间</p><p>21、什么是事务？<br>事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。<br>22、使用索引查询一定能提高查询的性能吗？为什么<br>通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.</p><p>1、索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:<br>2、基于一个范围的检索,一般查询返回结果集小于表中记录数的30%<br>3、基于非唯一性索引的检索</p><p>23、简单说一说drop、delete与truncate的区<br>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别</p><p>1、delete和truncate只删除表的数据不删除表的结构<br>2、速度,一般来说: drop&gt; truncate &gt;delete<br>3、delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;<br>4、如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.<br>24、drop、delete与truncate分别在什么场景之下使用？</p><p>1、不再需要一张表的时候，用drop<br>2、想删除部分数据行时候，用delete，并且带上where子句<br>3、保留表而删除所有数据的时候用truncate</p><p>25、超键、候选键、主键、外键分别是什么？</p><p>1、超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p><p>2、候选键：是最小超键，即没有冗余元素的超键。</p><p>3、主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p><p>4、外键：在一个表中存在的另一个表的主键称此表的外键。</p><p>26、什么是视图？以及视图的使用场景有哪些？</p><p>1、视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p><p>2、只暴露部分字段给访问者，所以就建一个虚表，就是视图。</p><p>3、查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异</p><p>27、说一说三个范式。</p><p>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。<br>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。<br>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y</p><p>28、数据库的乐观锁和悲观锁是什么？<br>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。<br>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作<br>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p><p>来源：<br><a href="https://juejin.im/post/5cb6c4ef51882532b70e6ff0" target="_blank" rel="noopener">https://juejin.im/post/5cb6c4ef51882532b70e6ff0</a></p>]]></content>
      
      
      <categories>
          
          <category> SystemProgramming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>The Log-structured File System</title>
      <link href="/SystemProgramming/core-techs-filesystem-lfs/"/>
      <url>/SystemProgramming/core-techs-filesystem-lfs/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leanote.com/api/file/getAttach?fileId=5a57265dab64415def0012d6" target="_blank" rel="noopener">1992SOSP-The Design and Implementation of a Log-Structured File System</a><br>By Mendel Rosenblum</p><p>Mendel is the founder of VMware, and also an investor in Datriums</p><p>LFS, Log-structured File System 简单来说就是用日志方式来组织的文件系统，由于日志是一条一条添加的（没有修改），所以这是最直观的解释。<br>LFS 跟 FFS（Fast File System）的出发点是一样的，那就是顺序写（Sequential Write）有更高的性能。随着内存技术的提高，很多内容都可以留在 Cache 中，读的性能得到了极大的提高，那么，影响文件系统性能的瓶颈就在写操作上了。 LFS 使用 Copy-On-Write 而不是 Update-In-Place 的方式，有效的提升写性能。</p><ul><li>Basic idea: Buffer all writes (data + metadata) using an in-memory segment; once the segment is full, write the segment to a log<br>• The segment write is a sequential write, so its fast<br>• We write one large segment (e.g., 4 MB) instead of a bunch of block-sized chunks to ensure that, at worst, we pay only one seek and then no rotational latencies (instead of one seek and possibly many rotational latencies)<br>• There are no in-place writes!</li><li>Reads still require random seeks, but physical RAM is plentiful, so buffer cache hit rate should be high</li></ul><h3 id="1）4-个主要的出发点"><a href="#1）4-个主要的出发点" class="headerlink" title="1）4 个主要的出发点"></a>1）4 个主要的出发点</h3><ul><li>System memories are growing<br>内存增大之后，更多内容可以被 Cache，读性能提高，写操作成为瓶颈</li><li>There is a large gap between random I/O performance and sequential I/O performance<br>磁盘转速和寻道技术限制了随机 I/O 性能</li><li>Existing file systems perform poorly on many common workloads<br>普通的单个写操作实际上包含多个写操作，导致性能低下。</li><li>File systems are not RAID-aware<br>没有考虑 RAID</li></ul><h3 id="2）Log-structured-File-System-by-Rosenblum-amp-Ousterhout"><a href="#2）Log-structured-File-System-by-Rosenblum-amp-Ousterhout" class="headerlink" title="2）Log-structured File System by Rosenblum &amp; Ousterhout"></a>2）Log-structured File System by Rosenblum &amp; Ousterhout</h3><ul><li>当准备往 disk 写内容的时候， 先在内存的某个 segment 中进行 buffer，包括（data 和 metadata）</li><li>当 segment 满的时候，把内容写入一个新申请的 disk 区域。</li><li>LFS 绝不覆盖已有数据，而总是把内心写入未使用过的区域。</li><li>由于 segment 比较大（几 MB），磁盘利用率会得到极大的提升。</li></ul><p><strong>问题的关键：如何才能把所有操作都变成顺序操作？</strong></p><ul><li>读操作：不可能，因为 block 可能在磁盘中的任意地方</li><li>写操作：有可能。</li></ul><h3 id="3）如何顺序写？"><a href="#3）如何顺序写？" class="headerlink" title="3）如何顺序写？"></a>3）如何顺序写？</h3><p>使用一种非常老的技术 Write buffering，也就是，在写入 disk 之前，现在 memory 中把操作缓存，当收到足够多的操作之后，再一次性写入 disk。</p><p>作为对比：<br>（1）一次只写入一个 block 和其 inode 信息</p><p><img src="/image/filesystem/one_block_write.png" alt=""></p><p>（1）一次写入多个 block 和对应 inode 信息</p><p><img src="/image/filesystem/multi_block_write.png" alt=""></p><h3 id="4）缓存多大合适？"><a href="#4）缓存多大合适？" class="headerlink" title="4）缓存多大合适？"></a>4）缓存多大合适？</h3><p>写入操作的耗时主要跟两个因素有关：寻道速度 + 传输速率</p><p>比如：我们的磁盘寻道平均耗时 10ms，传输速率峰值是 100 MB/s，假设我们要使用 90% 的带宽，也就是 100 MB * 0.9 = 90 MB/s，那么我们可以得出缓存 D = 90 MB/s * 0.01 seconds = 9 MB。</p><h3 id="5）如何找到-inode？"><a href="#5）如何找到-inode？" class="headerlink" title="5）如何找到 inode？"></a>5）如何找到 inode？</h3><p>在 FFS 中或者传统的 Unix File System 中，找到 inode 很简单，因为它们是在磁盘的固定位置，保存在一个数组中。FFS 中，inode 则分布在每个 Cylinder Group 中的固定位置。</p><p>但是，在 LFS 中，事情变得复杂，因为我们把 inode 散布在整个磁盘中，因为我们从不原地覆盖的写。</p><p>解决办法：</p><p><strong>使用 Inode Map (imap)</strong></p><p>简单来说，就是用一个间接引用来保存 inode 的实际磁盘地址，这个 imap 中的每个条目用 inode number 对应一个 inode address，imap 必须是持久保存的（persistent），因此必须保存在 disk 中，那么把它保存在磁盘哪个位置合适？</p><p>如果保存在磁盘某个固定位置，那么寻道时间的开销依然很大，LFS 采用的方式是把 data, inode 和 imap 三者一起写入磁盘，如下：</p><p><img src="/image/filesystem/imap_disk.png" alt=""></p><p><strong>Checkpoint Region</strong></p><p>从上图我们可以看到，现在 imap 也分布在整个磁盘了，我们又该如何找到 imap 呢？终究还是逃不过啊。<br>所以，最终，我们还是需要在磁盘上有一个固定的位置能保存全局的索引信息。</p><p>LFS 使用一个叫 checkpoint region(CR) 的磁盘固定位置，它保存着指向最新的 inode map 的引用(pointer)，因此 imap 可以通过先创建 CR 的方式来找到。<br>CR 会已固定的周期进行更新，比如每 30 秒更新一次，因为其对性能影响不大。</p><p><img src="/image/filesystem/checkpoint_region.png" alt=""></p><h3 id="6）从硬盘读取文件"><a href="#6）从硬盘读取文件" class="headerlink" title="6）从硬盘读取文件"></a>6）从硬盘读取文件</h3><p>为了更好的理解 LFS 原理，我们还需要了解它是如何读取文件的。</p><p>首先，我们必须先从磁盘中把 CR 读取到内存，它包含指向整个 imap 的信息。然后，只要我们给定一个 inode number，我们就能找到其对应的磁盘地址，然后读取其最新的 inode version，从而得到最新的 block 地址。</p><p><strong>如何存取目录？</strong><br>目录也是 Unix 中的普通文件，它保存的内容是 name 和 inode 的一一对应关系。当创建一个新文件的时候，也需要更新文件对它的索引。</p><p><img src="/image/filesystem/imap_directory.png" alt=""></p><h3 id="7-Garbage-Colleciton"><a href="#7-Garbage-Colleciton" class="headerlink" title="7) Garbage Colleciton"></a>7) Garbage Colleciton</h3><p>由于我们不断把新内容写入新的磁盘地址，老的内容就变成 Garbage。</p><p>我们有两种方式写入新的 Block 和 inode：</p><p>1）append 一个新的 block 和 新 inode map</p><p><img src="/image/filesystem/append_block_inode.png" alt=""></p><p>2）append 新 block 和 新 inode map，同时，这个新的 inode map 也保留对老的 block 的引用</p><p><img src="/image/filesystem/append_block_inode_with_old.png" alt=""></p><p>第二种方式给了用户更多选择，因为保留多个版本的信息可以让用户对数据有更多权限，比如误删之后的数据恢复。这种方式也叫 <strong>“versioning file system”</strong>。</p><p>旧数据的管理除了进行数据恢复，还需要定时清理，已保证磁盘有高效可用的空间，一个 GC 算法的好坏主要体现在可以及时释放大量连续的磁盘空间，而不是离散的磁盘空间。</p><p>LFS cleaner 基于 segment 来进行处理，它的基本流程如下：</p><ul><li>周期性地读取老的 segments（partially used），判断其中的哪些 blocks 仍然有效（live）</li><li>然后把那些 live 的 blocks 写入（compact/merge）一个新的 segment，释放老的 segment</li></ul><h4 id="如何判断-Block-liveness"><a href="#如何判断-Block-liveness" class="headerlink" title="如何判断 Block liveness"></a>如何判断 Block liveness</h4><p>为了判断 Block 是否 live 的了，LFS 在 segment 中添加了一个叫做 <strong>segment summary block(SS)</strong> 来记录每个 block 对应的 inode number <strong>N</strong> 和其 offset <strong>T</strong>。</p><p>具体流程：</p><ul><li>block <strong>D</strong> 所在地址 A，在 <strong>segment summary block</strong> 中找到其对应的 <strong>N</strong> 和 <strong>T</strong></li><li>在 imap 中找到 <strong>N</strong> 所在的地址，把其读取进内存</li><li>根据 <strong>T</strong> 计算这个 block 的地址，如果它指向的是磁盘地址，那么就是 live，否则就不是 live。</li></ul><p>伪代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(N, T) = SegmentSummary[A];</span><br><span class="line">inode = Read(imap[N]);</span><br><span class="line">if (inode[T] == A)</span><br><span class="line">    // block D is alive</span><br><span class="line">else</span><br><span class="line">    // block D is garbage</span><br></pre></td></tr></table></figure><h4 id="Clean-Policy-When-and-Which？"><a href="#Clean-Policy-When-and-Which？" class="headerlink" title="Clean Policy: When and Which？"></a>Clean Policy: When and Which？</h4><p>1）When？<br>很简单，周期性或者磁盘不够用时执行 clean 即可</p><p>2）Which？<br>决定清理哪些 block 有些复杂，在原始的 LFS 论文中，作者提出了一种把 segment 分成 hot 和 cold 的方式。对于 hot segment 来说，由于会频繁进行覆盖写操作，因此等待较长时间再 clean 是比较合适的，而 cold segment 则可以更早进行清理，以便尽快腾出空间。</p><h3 id="8）Crash-Recovery-And-The-Log"><a href="#8）Crash-Recovery-And-The-Log" class="headerlink" title="8）Crash Recovery And The Log"></a>8）Crash Recovery And The Log</h3><p>CR 是周期性的更新的（每隔 30 秒），为了保证每次 CR 的更新是原子操作，LFS 实际上会使用两个 CRs，它们各在磁盘的两端，在更新 CR 的时候，LFS 也定义了一套协议规则，先写入一个 header（with timestamp），然后写入 CR body，最后再写入一个最后一个 block（with timestamp），如果更新的时候 Crush 了，LFS 通过检查 timestamp 是否匹配就可以判断 CR 是否有效。</p><p>由于更新需要花时间，所以实际上进行系统恢复的时候，会丢失一些信息（several seconds）。</p><p>为了解决这个缺陷，LFS 使用了一种叫做 “roll forward” 的技术（常用在 database 领域），最基本的思想就是：</p><p>从上一次 CR 开始，找到最后的 log（包含在 CR 中），使用它来读取后续的 segments 并判断其中是否存在有效的 updates。如果存在，LFS 就根据其来更新系统。</p><p>注：有兴趣的读者可以查看 Rosenblum 的原论文 “<a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/1992/CSD-92-696.pdf" target="_blank" rel="noopener">Design and Implementation of the Log-structured File System</a>” 了解更多细节。</p><h2 id="LFS-的优势和劣势"><a href="#LFS-的优势和劣势" class="headerlink" title="LFS 的优势和劣势"></a>LFS 的优势和劣势</h2><p>data can be lost if it has been written but not checkpointed. This can be mitigated by decreasing the time between checkpoints or allowing applications to ask to wait until the next checkpoint before proceeding.</p><p>most reads are absorbed by cache; writes always append to the log, so they are sequential and very fast.</p><p>blocks are located on disk in exactly (or almost exactly) the order in which they were last written. Even if reads miss cache, they will have good locality if the order in which files are read mimics the order in which they are written.</p><p>LFS is good for flash memory (solid-state disks or SSDs): flash memory degrades with each subsequent write, but LFS naturally levels out writes evenly across all segments.</p><p>SSDs also require write operations on very large segments; writing segments fits these usage characteristics very well.</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>LSM 除了有更好的写性能，还有其它一些好处。比如，由于 SSTable 文件是不可修改的，这让对他们的锁操作非常简单。一般来说，唯一的竞争资源就是 Memtable，相对来说需要相对复杂的锁机制来管理在不同的级别。</p><p>而如 Scylladb，通过异步 IO，非阻塞线程，线程和线程之间通过消息通讯，没有内存的共享，没有互斥锁，也没有原子操作来大幅的提高了 cpu 的效率。</p><p>2016年，Lanyue Lu等人发布了WiscKey论文，这篇论文提出了一种新的设计 WiscKey: Separating Keys from Values</p><p>in SSD-conscious Storage，专门为SSD所优化，将key和value分别存储以减少I/O放大。key存在LSM tree中， value存在WAL中，叫做value log。</p><p>通常情况下，key比较小，所以LSM tree比较小，当获取value值的时候，再从SSD存储中读取。</p><p>参考文章：<br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nilfs2/index.html" target="_blank" rel="noopener">从 NILFS2 看 Log-Structure 文件系统</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-cache/index.html" target="_blank" rel="noopener">Linux 内核的文件 Cache 管理机制介绍</a><br><a href="http://www.penglixun.com/tech/system/linux_cache_discovery.html" target="_blank" rel="noopener">Linux Cache 机制探究 | P.Linux Laboratory</a></p><p><a href="http://www.eecs.harvard.edu/~cs161/notes/lfs.pdf" target="_blank" rel="noopener">http://www.eecs.harvard.edu/~cs161/notes/lfs.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> SystemProgramming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unix File System</title>
      <link href="/SystemProgramming/core-techs-filesystem-ufs/"/>
      <url>/SystemProgramming/core-techs-filesystem-ufs/</url>
      
        <content type="html"><![CDATA[<h2 id="Types-of-Unix-files"><a href="#Types-of-Unix-files" class="headerlink" title="Types of Unix files"></a>Types of Unix files</h2><p><img src="/image/filesystem/unix_filesystem.png" alt=""></p><ul><li>Regular file: On a Unix system, everything is a file; if something is not a file, it is a process</li><li>Directories: files that are lists of other files.</li><li>Special files: the mechanism used for input and output. Most special files are in /dev, we will discuss them later.</li><li>Links: a system to make a file or directory visible in multiple parts of the system’s file tree. We will talk about links in detail.</li><li>(Domain) sockets: a special file type, similar to TCP/IP sockets, providing inter-process networking protected by the file system’s access control.</li><li>Named pipes: act more or less like sockets and form a way for processes to communicate with each other, without using network socket semantics.</li></ul><table><thead><tr><th>Symbol</th><th>Meaning</th></tr></thead><tbody><tr><td>-</td><td>Regular file</td></tr><tr><td>d</td><td>Directory</td></tr><tr><td>l</td><td>Link</td></tr><tr><td>c</td><td>Special file</td></tr><tr><td>s</td><td>Socket</td></tr><tr><td>p</td><td>Named pipe</td></tr><tr><td>b</td><td>Block device</td></tr></tbody></table><h2 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h2><p>在介绍 Unix 文件系统之前先来介绍一下机械硬盘的典型构造中的基本概念[在 Unix 问世的时代，还没有SSD]，机械硬盘主体是由多个圆形硬盘盘所组成的，依据硬盘盘能够容纳的数据量，而有所谓的单碟(一块硬盘里面只有一个硬盘盘)或者是多碟(一块硬盘里面含有多个硬盘盘)的硬盘，一般情况下都是多碟。</p><p>disk head 磁头主要进行该硬盘盘上面的读写动作。磁头需要进行位置变换，来找到对应的位置进行读写。<br>disk track 磁道就是磁头在磁盘盘上转一圈所形成的圆<br>disk cylinder 在一个拥有多个磁盘盘的磁盘里，所有相同半径的那一个磁道就组成了磁柱[Cylinder]<br>disk sector 由圆心向外划直线，则可将磁道再细分为一个一个的扇区[Sector]，这个扇区就是硬盘盘上面的最小储存物理量了，通常一个sector的大小约为512 Bytes<br>disk partition 硬盘的分割，也就是记录每一个分割区的起始与结束磁柱，这两个磁柱之间形成了一个环状的区域</p><p>以上这些就是典型机械硬盘的基本概念，后面介绍的是逻辑概念。</p><p>block 硬盘的最小储存单位是 sector，也就是说对于硬盘它是一个 sector 一个 sector 存的。但是数据存储的最小单位并不是 sector，用 sector 来储存太没有效率了，因为一个sector只有512Bytes，而磁头是一个一个sector的读取，也就是说，如果我的文件有10MBytes，那么为了读这个文件，我的磁头必须要进行I/O操作20480次。所以在这之上我们要构建一个逻辑存储单位，把几个sector聚在一次，这样就会大大降低I/O次数[这也是为什么会有virtual memory而不是OS直接操作硬盘的原因]。</p><p>Block这个最小储存单位是架构在sector的大小上面[因为sector为硬盘的最小物理储存单位，此为硬件设定]。 Block的大小为sector的2的次方倍数。此时，磁头一次可以读取一个block，如果假设我们在格式化的时候，指定Block为4 KBytes[亦即由连续的八个sector所构成一个block]，那么同样一个10MBytes的文件，磁头要读取的次数则大幅降为 2560次，这个时候可就大大的增加文件的读取效能。当然有不能一味的增加大小，要是这样的话，将所有sector都设为一个block岂不是更方便，但是真是情况并不是这样。所以Block单位的规划并不是越大越好，因为一个Block最多仅能容纳一个文件。举例来说好了，假如Block规划为4KBytes，而一个文件大小为0.1KBytes，这个小文件将占用掉一个Block的空间，也就是说，该Block虽然可以容纳4Kbytes的容量，然而由于文件只占用了0.1Kbytes，所以，实际上剩下的3.9KBytes是不能再被使用了.</p><p>superblock 当我们在进行磁盘分区时，每个磁盘分区就是一个文件系统[filesystem]，而每个文件系统开始的位置的那个block就称为superblock，所以一个partiiton拥有一个superblock来存储一个描述数据的数据，类似metadata。superblock储存了文件系统的大小、空的和填满的区块，以及他各自的总数和其他诸如此类的信息等等，这也就是说，当要使用这一个磁盘分区槽来进行数据存取的时候，第一个要经过的就是superblock这个区块，如果superblock坏了，对应的磁盘槽大概也就回天乏术了！</p><p>free list 在unix文件系统里是一个 a linked list of all the free blocks in the file system，就是一个存折所有空白区块的链表。</p><p>inode 是unix文件系统的基础，inode 存的是索引信息。</p><p>Block是记录文件内容数据的区域。首先，每个文件不止有文件的内容数据，还包括文件的种种属性，例如：所属群组、所属使用者、能否执行、文件建立时间、文件特殊属性等等。由于操作系统是一个多人多任务的环境，为了要保护每个用户所拥有数据的隐密性，所以文件属性的增加是在所难免的。所以一般情况下每个文件的内容分为两个部分来储存，一个是文件的属性，另一个则是文件的内容。所以规划出inode与Block来分别储存文件的属性(放在inode当中)与文件的内容(放置在Block area当中)。当我们要将一个partition格式化时，就必须要指定inode与Block的大小才行，也就是说，当partition被格式化时，它一定会有inode table与block area这两个区域。</p><p>inode包含文件的元信息，具体来说有以下内容：文件的字节数，文件拥有者的User ID，文件的Group ID，文件的读、写、执行权限，文件的时间戳，链接数（即有多少文件名指向这个inode），文件数据block的位置</p><p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。</p><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。这里值得重复一遍，Unix系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</p>]]></content>
      
      
      <categories>
          
          <category> SystemProgramming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Network overview</title>
      <link href="/SystemProgramming/core-techs-network-overview/"/>
      <url>/SystemProgramming/core-techs-network-overview/</url>
      
        <content type="html"><![CDATA[<p>OSI 模型7层结构，TCP/IP 模型结构？</p><p>tcp/udp</p><p>socket<br>RPC<br>IPC</p><p>IP Routing<br>字节序</p><p>HTTP</p><p><a href="https://www.cs.rutgers.edu/~pxk/416/notes/16-sockets.html" target="_blank" rel="noopener">https://www.cs.rutgers.edu/~pxk/416/notes/16-sockets.html</a></p>]]></content>
      
      
      <categories>
          
          <category> SystemProgramming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP notes</title>
      <link href="/SystemProgramming/core-techs-network-tcp/"/>
      <url>/SystemProgramming/core-techs-network-tcp/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> SystemProgramming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ Basics</title>
      <link href="/C/core-techs-lang-cpp-basics/"/>
      <url>/C/core-techs-lang-cpp-basics/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vector operations</title>
      <link href="/C/core-techs-lang-cpp-vector/"/>
      <url>/C/core-techs-lang-cpp-vector/</url>
      
        <content type="html"><![CDATA[<h4 id="1-Pushing-the-values-one-by-one"><a href="#1-Pushing-the-values-one-by-one" class="headerlink" title="1. Pushing the values one-by-one"></a>1. Pushing the values one-by-one</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">  vec.push_back(<span class="number">1</span>);</span><br><span class="line">  vec.push_back(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; vec[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Using-the-overloaded-constructor-of-the-vector-class"><a href="#2-Using-the-overloaded-constructor-of-the-vector-class" class="headerlink" title="2. Using the overloaded constructor of the vector class"></a>2. Using the overloaded constructor of the vector class</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num_of_ele = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// the overloaded constructor takes the number of</span></span><br><span class="line">  <span class="comment">// values and the value itself as parameters.</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(num_of_ele, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; vec[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Using-arrays"><a href="#3-Using-arrays" class="headerlink" title="3. Using arrays"></a>3. Using arrays</h4><p>Pass an array to the constructor of the vector class</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; vec[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Using-another-already-initialized-vector"><a href="#4-Using-another-already-initialized-vector" class="headerlink" title="4. Using another, already initialized, vector"></a>4. Using another, already initialized, vector</h4><p>Pass another vector to the constructor of the vector</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec_1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec_2(vec_1.begin(), vec_1.end());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec_2.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; vec_2[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang Basics</title>
      <link href="/Go/core-techs-lang-go-basics/"/>
      <url>/Go/core-techs-lang-go-basics/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Goroutine Notes</title>
      <link href="/SystemProgramming/core-techs-lang-go-goroutine/"/>
      <url>/SystemProgramming/core-techs-lang-go-goroutine/</url>
      
        <content type="html"><![CDATA[<h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><p>1）轻量</p><ul><li>内存小：2KB 的栈内存空间。作为对比：创建一个 POSIX 线程需要 2MB 的内存空间</li><li>用户层：创建goroutine 则是纯用户层的操作。作为对比：创建一个POSIX-thread是一次系统调用，需要陷入内核层，申请OS资源成功后返回用户层；</li></ul><p>2）调度复杂度 O(1)<br>不会随着 goroutine 的增加</p><p>3）网络 IO 操作不会阻塞其他 goroutine 的调度<br>runtime 底层采用 epoll 监听网络 IO 事件。从操作系统角度来看，可以将 go runtime 认为是事件驱动的 C 程序。</p><h2 id="Goroutine-调度"><a href="#Goroutine-调度" class="headerlink" title="Goroutine 调度"></a>Goroutine 调度</h2><p>G-P-M</p><ul><li>G: 表示Goroutine，每个Goroutine对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。G并非执行体，每个G需要绑定到P才能被调度执行。</li><li>P: Processor，表示逻辑处理器， 对G来说，P相当于CPU核，G只有绑定到P(在P的local runq中)才能被调度。对M来说，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，P的数量决定了系统内最大可并行的G的数量（前提：物理CPU核数 &gt;= P的数量），P的数量由用户设置的GOMAXPROCS决定，但是不论GOMAXPROCS设置为多大，P的数量最大为256。</li><li>M: Machine，OS线程抽象，代表着真正执行计算的资源，在绑定有效的P后，进入schedule循环；而schedule循环的机制大致是从Global队列、P的Local队列以及wait队列中获取G，切换到G的执行栈上并执行G的函数，调用goexit做清理工作并回到M，如此反复。M并不保留G状态，这是G可以跨M调度的基础，M的数量是不定的，由Go Runtime调整，为了防止创建过多OS线程导致系统调度不过来，目前默认最大限制为10000个。</li></ul><p>在Go 1.0发布的时候，它的调度器其实G-M模型，也就是没有P的，调度过程全由G和M完成，这个模型暴露出一些问题：</p><ul><li>单一全局互斥锁(Sched.Lock)和集中状态存储的存在导致所有 goroutine 相关操作，比如：创建、重新调度等都要上锁；</li><li>goroutine 传递问题：M经常在M之间传递『可运行』的 goroutine，这导致调度延迟增大以及额外的性能损耗；</li><li>每个 M 做内存缓存，导致内存占用过高，数据局部性较差；</li><li>由于 syscall 调用而形成的剧烈的 worker thread 阻塞和解除阻塞，导致额外的性能损耗。</li></ul><p>这些问题实在太扎眼了，导致Go1.0虽然号称原生支持并发，但是这些性能问题饱受诟病，核心开发大佬 Dmitry Vyukov 重新设计并实现了现在的 Go 调度器（在原 G-M 模型下引入 P），并且实现了一个 working-steal 的调度算法：</p><ul><li>每个P维护一个G的本地队列；</li><li>当一个G被创建出来，或者变为可执行状态时，就把他放到P的可执行队列中；</li><li>当一个G在M里执行结束后，P会从队列中把该G取出；如果此时P的队列为空，即没有其他G可以执行， M就随机选择另外一个P，从其可执行的G队列中取走一半。</li></ul><p>该算法避免了在goroutine调度时使用全局锁。</p><p>至此，Go调度器的基本模型确立：</p><p><img src="/image/go/gpm_schedule.png" alt=""></p><p>参考：<br><a href="https://juejin.im/entry/5b2878c7f265da5977596ae2" target="_blank" rel="noopener">https://juejin.im/entry/5b2878c7f265da5977596ae2</a></p><p>1、协作式<br>Go 在设计之初并没考虑将 goroutine 设计成抢占式的。用户负责让各个 goroutine 交互合作完成任务。一个 goroutine 只有在涉及到加锁，读写通道或者主动让出 CPU 等操作时才会触发切换。</p><p>垃圾回收器是需要stop the world的。如果垃圾回收器想要运行了，那么它必须先通知其它的goroutine合作停下来，这会造成较长时间的等待时间。考虑一种很极端的情况，所有的goroutine都停下来了，只有其中一个没有停，那么垃圾回收就会一直等待着没有停的那一个。</p><p>2、抢占式</p><p>Go在1.2版中开始引入比较初级的抢占式调度，当然，只是引入了一些很初级的抢占，并没有像操作系统调度那么复杂，没有对goroutine分时间片，设置优先级等。<br>只有长时间阻塞于系统调用，或者运行了较长时间才会被抢占。runtime会在后台有一个检测线程（sysmon），它会检测这些情况，并通知goroutine执行调度。</p><h3 id="sysmon"><a href="#sysmon" class="headerlink" title="sysmon"></a>sysmon</h3><p>rutime sysmon 不绑定到任何 P 就可以运行，并且其会定期唤醒作系统状态检查。运行一个sysmon函数。这个函数会周期性地做epoll操作，同时它还会检测每个P是否运行了较长时间。<br>如果检测到某个P状态处于Psyscall超过了一个sysmon的时间周期(20us)，并且还有其它可运行的任务，则切换P。<br>如果检测到某个P的状态为Prunning，并且它已经运行了超过10ms，则会将P的当前的G的stackguard设置为StackPreempt。这个操作其实是相当于加上一个标记，通知这个G在合适时机进行调度。<br>目前这里只是尽最大努力送达，但并不保证收到消息的goroutine一定会执行调度让出运行权。</p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2>]]></content>
      
      
      <categories>
          
          <category> SystemProgramming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Split a string with specified delimiter</title>
      <link href="/C/core-techs-lang-cpp-split/"/>
      <url>/C/core-techs-lang-cpp-split/</url>
      
        <content type="html"><![CDATA[<h2 id="Use-getline-to-split"><a href="#Use-getline-to-split" class="headerlink" title="Use getline to split"></a>Use getline to split</h2><p>Here we use another feature of <code>std::getline</code>: it returns a stream that’s passed to it, and that stream is convertible to bool (or to void*) before C++11. This boolean indicates if no error has occured (so true is no error has occured, false if an error has occured). And that error check includes whether or not the stream is at an end.</p><p>So the while loop will nicely stop when the end of the stream (and therefore of the string) has been reached.</p><p>Advantages:</p><ul><li>very clear interface works on any delimiter</li><li>the delimiter can be specified at runtime</li></ul><p>Drawbacks:</p><ul><li>not standard, though easy to re-use</li></ul><h2 id="getline-prototype"><a href="#getline-prototype" class="headerlink" title="getline prototype"></a>getline prototype</h2><p>istream&amp; getline (istream&amp; is, string&amp; str, char delim);<br>istream&amp; getline (istream&amp; is, string&amp; str);</p><p><strong>Functionality:</strong><br>Extracts characters from is and stores them into str until the delimitation character delim is found</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; split(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s, <span class="keyword">char</span> delimiter)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; tokens;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> token;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">istringstream</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; tokenStream(s);</span><br><span class="line">    <span class="keyword">while</span>(getline(s, token, delimiter)) &#123;</span><br><span class="line">        tokens.push_back(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>iterator version</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;Out&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s, <span class="keyword">char</span> delimiter, Out result)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> token;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; tokenStream;</span><br><span class="line">    tokenStream.str(s);</span><br><span class="line">    <span class="keyword">while</span>(getline(s, token, delimiter)) &#123;</span><br><span class="line">        *(result++) = token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; split(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s, <span class="keyword">char</span> delimiter) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; tokens;</span><br><span class="line">    split(s, delimiter, <span class="built_in">std</span>::back_inserter(tokens));</span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sharing data between threads</title>
      <link href="/Operating-System/os-share-data-threads/"/>
      <url>/Operating-System/os-share-data-threads/</url>
      
        <content type="html"><![CDATA[<p>Threads share the same address space as opposed to being sand-boxed like processes are.</p><p>The stack is just some memory in your application that has been specifically reserved and is used to hold things such as function parameters, local variables, and other function-related information.</p><p>Every thread has it’s own stack. This means that when a particular thread is executing, it will use it’s own specific stack to avoid trampling over other threads which might be idle or executing simultaneously in a multi-core system.</p><p>Remember that these stacks are all still inside the same address space which means that any thread can access the contents of another threads’ stack.</p><p>A simple example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// if thread t is executing this function then j will sit inside thread t's stack</span></span><br><span class="line">    <span class="comment">// if we call this function from the main thread then j will sit inside the main stack</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">456</span>;</span><br><span class="line"></span><br><span class="line">    i++; <span class="comment">// we can see i because threads share the same address space</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">123</span>; <span class="comment">// this will sit inside the main threads' stack</span></span><br><span class="line"></span><br><span class="line">    std::thread t(std::bind(&amp;Foo, std::ref(i))); // we pass the address of i to our thread</span><br><span class="line">    t.join();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>An illustration:<br><img src="https://i.stack.imgur.com/FktZN.jpg" alt=""></p><p>As we can see, each thread has its own stack (which is just some part of the processes’ memory) which lives inside the same address space.</p><p>Static member variables are defined once per class and their “accessibility” from other parts of the program is defined in the C++11 standard §11 “Member access control”.</p><p>Static member variable initialization is performed in a thread safe manner before function main will be executed.</p><p>However, accessing a variable (class or instance) from different threads where at least one thread modifies the variable requires synchronization primitives like memory barriers, mutex, etc. Otherwise, your program has “undefined behavior”.</p><p>Technically saying, every thread has a separate stack, but it is not necessarily ‘private’. Other threads are usually allowed to access it.<br>The main reason each thread has its own stack is so that the thread can actually do something (like call a functions)</p><p><a href="http://www.hoard.org/" target="_blank" rel="noopener">http://www.hoard.org/</a></p><br>##### Referencehttp://stackoverflow.com/questions/35466550/multiple-threads-inside-class-accessing-data]]></content>
      
      
      <categories>
          
          <category> Operating System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shadowsocks 手动添加和编辑 PAC 中的网址规则</title>
      <link href="/Network-Technology/vps-pac-rules/"/>
      <url>/Network-Technology/vps-pac-rules/</url>
      
        <content type="html"><![CDATA[<p><strong>PAC 全称是 Proxy Auto-Configuration</strong>，它是一个自动代理配置脚本，能够决定网络流量走默认通道还是代理服务器通道，控制的流量类型包括：HTTP、HTTPS 和 FTP。。如果我们不想全局都走代理，就可以选择 PAC 模式。</p><p>默认情况下，Shadowsocks 为我们提供了一个基础的 PAC 规则配置文件，里面大致列举了一些主流需要走代理的网站，比如 <code>*.google.com</code>, <code>*.bbc.com</code> 等等。</p><p>但是，还有很多网站也被屏蔽了，所以这时候就需要我们手动编辑 PAC 规则文件，以适应这些变化。但是显然很多人对 PAC 规则不是非常了解，那么这篇文章就来简单介绍 PAC 规则以及如何在 Shadowsock 客户端手动编辑该规则文件。</p><p>PAC 文件里面包含的是一个 JavaScript 语法的函数，这个函数长这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindProxyForURL</span>(<span class="params">url, host</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = FindProxyForURL(url, host);</span><br></pre></td></tr></table></figure><p>我们可以看到，这个函数有两个入参：url 和 host。</p><p>那么它们分别是很么形式呢？</p><ul><li>url 就是要通过 proxy 访问的链接，链接前面的 http:// 去除。比如 google.com 就是一个合法 url。</li><li>host 是从 url 中抽取出来的 hostname。</li></ul><p><strong>返回值</strong><br>返回值是一个字符串，可以是空，也可以是如下任何一种形式的字符串：</p><ul><li>DIRECT          表示无代理直接连接</li><li>PROXY host:port 表示走host:port 的 proxy 服务</li><li>SOCKS host:port 表示走host:port 的 socks 服务</li><li>HTTP host:port</li><li>HTTPS host:port</li><li>SOCKS4 host:port</li><li>SOCKS5 host:port</li></ul><p>返回值例子：<br>PROXY w3proxy.netscape.com:8080; PROXY mozilla.netscape.com:8081<br>PROXY w3proxy.netscape.com:8080; PROXY mozilla.netscape.com:8081; DIRECT<br>PROXY w3proxy.netscape.com:8080; SOCKS socks:1080</p><p>可以看到，而返回的接口可以是多个代理串联，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return &quot;PROXY 222.20.74.89:8800; SOCKS 222.20.74.89:8899; DIRECT&quot;;</span><br></pre></td></tr></table></figure><p>上面介绍的是 PAC 脚本，Shadowsocks 通过执行该脚本来决定是否对某个 URL 进行网络代理。</p><p>PAC 对应的配置文件就是我们常见的 <code>pac.txt</code> (默认提供），如果我们需要自定义一个 rule，可以新建一个配置文件比如叫 <code>user-rule.txt</code>，然后根据规则填写即可。当然，也可以指直接在原 <code>pac.txt</code> 中进行添加和修改。</p><blockquote><p>注：shadowsocks 目录下有一个 pac.txt 文件，而 pac.txt 这个文件是可以使用在线 PAC 或通过本地的 GWFlist 去更新的。所以不建议把自定义的规则直接加在 pac.txt 上面。</p></blockquote><p><img src="/image/vps/win_ss_pac_txt.jpg" alt=""></p><p>打开 pac.txt 文件，可以看到头部是如下内容：</p><p><img src="/image/vps/user_rules.jpg" alt=""></p><p>可以看到，PAC 配置文件使用的是 JavaScript 语法，里面定义了一个变量 rules，是一个 Json 数组格式的数据类型，数组里面存放的是各种 URL 的通配符。</p><p>那么在 PAC 模式下，如果当访问符合这个数组里面任意一个 URL 通配符的网址时，系统会走代理，反之直连。比如访问谷歌搜索首页时，会走代理，而访问百度、新浪等国内网站则会选择直连方式。</p><p>比如，我们想要访问 ipip.net 这个网址的时候走代理，那么我们就需要添加如下一条规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">||ipip.net^</span><br></pre></td></tr></table></figure><p>这个规则的意思是，任何以 <code>ipip.net</code> 为主的所有子域名包括自身，同时还有所有的互联网协议(http://, https:// 以及 ftp://)，都走 Shadowsocks 代理。</p><p>编辑完 user-rule.txt 文件并保存后，记得在 Shadowsocks 中进行更新，否则规则不会生效的。<br>注：在 Mac 版的 ShadowsocksX-NG-R8 中编辑规则后，需要重启软件才会生效。</p><p>上述操作完成之后，我们在浏览器中打开 <code>www.ipip.net</code> 就会通过代理来访问而不是直接链接了。</p><p>注意：每一行规则末尾必须加上 ^ 符号，意思是这个规则在这个符号的地方结束。</p><h4 id="通配符匹配规则"><a href="#通配符匹配规则" class="headerlink" title="通配符匹配规则"></a>通配符匹配规则</h4><p>ShadowSocks 默认使用 GFWList 规则和使用 adblock plus 的引擎，下面介绍一下通配符匹配规则</p><ul><li>通配符支持。<br>比如 <code>*.example.com/*</code> ，实际书写时可省略 * ， 如 <code>.example.com/</code> 和 <code>*.example.com/*</code> 效果一样</li><li>正则表达式支持。<br>以 \ 开始和结束， 如 <code>\[\w]+:\/\/example.com\</code></li><li>例外规则 @@<br>如 @@<em>.example.com/</em> 满足 @@ 后规则的地址不使用代理</li><li>匹配地址开始和结尾 |<br>如 <code>|http://example.com</code>, <code>example.com|</code> 分别表示以 <code>http://example.com</code> 开始和以 <code>example.com</code> 结束的地址</li><li>||标记<br>如 <code>||example.com</code> 则 <code>http://example.com</code>, <code>https://example.com</code>, <code>ftp://example.com</code> 等地址址满足条件。</li><li>注释 !如 !我是注释</li><li>分隔符^<br>表示除了字母、数字或者 _ – . % 之外的任何字符。如 <code>http://example.com^</code>, <code>http://example.com/</code> 和 <code>http://example.com:8000/</code> 均满足条件，而 <code>http://example.com.ar/</code> 不满足条件。</li></ul><p>更多语法规则，可以参考 AdBlockPlus 过滤规则 <a href="https://adblockplus.org/zh_CN/filters" target="_blank" rel="noopener">AdBlockPlus</a></p><br>参考：https://doubibackup.com/3we1qxzj-6.html<br>全文完！<br><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Network Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Proxying </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The difference between slice and array in Go</title>
      <link href="/Programming/go-slice-array/"/>
      <url>/Programming/go-slice-array/</url>
      
        <content type="html"><![CDATA[<p>本文介绍 Go 语言中 array 和 slice 的区别。</p><p>在 Go 的官方指南中指出：Arrays are not often seen in Go programs because the size of an array is part of its type, which limits its expressive power.<br>由于声明 array 时需要指定 size 大小，size 是 array 类型的一部分，这极大地限制了它的表达能力，所以在 Go 程序中很少见到使用 array 的情况。</p><p>array 和 slice 最明显的一个区别体现在申明方式上：<br>array 声明时需要指定大小，什么方式是：<code>[2]int{1, 2}</code> 或者 <code>[...]int{1, 2, 3}</code>。生成的对象是 [num]type 类型（比如: [2]int 和 [3]int 是两种完全不同的类型。)<br>然而, slice 申明时则无需指定大小， 使用[]int{1, 2, 3} 或者 make([]int, len, cap) 这种方式来声明即可。</p><p>同时，不能使用 array 类型的变量返回给 slice。</p><p>e.g.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testArray</span><span class="params">()</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    arr := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> arr                     <span class="comment">// error: cannot use arr (type [2]int) as type []int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们一定要使用上述方式，我们可以使用 arr[:] 来把 array 描述成 slice， 把上述 return arr 改成 return arr[:] 之后就可以了。<br>当然，还可以使用 arr[i:len(arr)] 来表示，其余 arr[:] 效果完全一样。</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>slice in Go</title>
      <link href="/Programming/go-slice/"/>
      <url>/Programming/go-slice/</url>
      
        <content type="html"><![CDATA[<p>本文详细介绍 Go 语言中 slice 的用法。</p><p>对于可以随机访问的顺序存储数据结构来说，Go 提供了 array 和 slice。<br>array 作为固定长度的数组，在 Go 语言中使用场景极少，而 slice 作为动态数组切片则相反，由于其灵活的特性，在 Go 程序中大量而广泛的使用。<br>因此，要想更熟练的使用 Go 语言进行编程，掌握 slice 的用法非常重要。</p><p>slice 本质是对底层数组的引用，在申明一个 slice 时，Go 实际上会在底层先分配一个数组，然后通过引用的方式来访问这个底层数组。</p><br>##### 如何遍历 slice?---使用 range 关键字进行遍历。遍历时，既可以返回单值，也可以返回双值。返回单值时就是 index，返回双值时会是 index 和 value。e.g.<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myslice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> myslice &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> myslice&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>##### Go 可否同时遍历多个 length 相同的 slice ？**---答案是 不可以！<p>Golang 不支持类似如下 python 的语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> range([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]):</span><br><span class="line">    <span class="keyword">print</span> x, y</span><br></pre></td></tr></table></figure><p>要想实现同时遍历两个或多个 slice，可以通过共享 index 的方式。也就是如果两个 slice 长度相同，那么遍历其中一个 slice 的同时，使用其 index 来访问另一个 slice 的元素，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> x &#123;</span><br><span class="line">    fmt.Println(x[i], y[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>##### 如何 Copy Slice ? （深拷贝）---<br>###### 两种方式：**1. 使用 Go 语言内置函数 copy**<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">make</span>([]T, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="built_in">copy</span>(b, a)</span><br></pre></td></tr></table></figure><p><strong>2. 使用 append 函数</strong><br>把要 copy 的 slice append 到一个 empty slice 中去。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">append</span>([]T(<span class="literal">nil</span>), a...)</span><br></pre></td></tr></table></figure><br>##### 如何对一个 Slice 进行排序？---Go provides a `sort` package to do all things about sort, binary search, etc.<p>使用前需要 <code>import &quot;sort&quot;</code>，sort 包提供了对 float64, int, string 这 3 个基本数据类型的排序操作（不支持 int64，int32等其他类型的排序，需要用户自己转换）<br>同时，还提供了 IsSorted, Search 等函数用于支持对 slice 的相关操作。</p><p>函数原型<br>e.g.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ints</span><span class="params">(a []<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Search</span><span class="params">(n <span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br></pre></td></tr></table></figure><br>##### 如何只对 slice 的某一部分进行排序？---<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort.Ints(slice[<span class="number">5</span>:<span class="number">11</span>])</span><br></pre></td></tr></table></figure><br>##### 如何排序一个自定义的数据类型？---Sort a user-defined data structureSorting user-defined data in Go requires you to implement the sort.Interface. This interface requires three simple methods: Len, Less, and Swap.<p>函数原型:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Len() <span class="keyword">int</span></span><br><span class="line">Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">Swap(i, j <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>In simple, as long as the user-defined slice of data implement these three methods, we can call sort.Sort(data) to sort it.</p><p>e.g.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> intervals []Interval</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(slice intervals)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(slice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>##### 如何删除 slice 中的元素？---<p>没有提供 build-in 的函数来实现 remove 功能。需要我们手动操作。<br>主要的方法就是<span class="redBold">拼接</span></p><p>(1) 删除尾部元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*sol = (*sol)[<span class="number">0</span> : <span class="built_in">len</span>(*sol)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>(2) 删除中间元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+<span class="number">1</span>:]...)</span><br></pre></td></tr></table></figure><p>总结：<br>从 slice 这种数据结构本质来看，其并不适合做删除操作。实际上，无论什么语言，数组（连续空间，随机访问）这种数据结构，做删除操作的话，都是需要移动元素的，而移动元素会导致大量的 copy，效率很低。</p><p>如果实在需要使用 slice 又不可避免需要删除元素，那么可以使用下述方法提高效率。<br>前提是不关心删除之后元素的原有顺序，那么可以用最后一个元素替换要删除的元素，然后去掉最后一个元素，<br>e.g</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[i] = a[<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>当然，如果需要频繁删除中间或开头的元素，更好的是选择链表这样的数据结构。<br>Go中可以使用 map 或 container/list 包。</p><br>##### 如何清空一个 slice---清空 slice， 也即把这个 slice 置 nil<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice = <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>要弄清楚一个 slice 置为 nil 具体是怎么回事，我们可以借助下述这个 slice 结构体定义来理解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sliceHeader&#123;</span><br><span class="line">    Length:        <span class="number">0</span>,</span><br><span class="line">    Capacity:      <span class="number">0</span>,</span><br><span class="line">    ZerothElement: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述结构中我们可以看到，一个 置为 nil 的 slice 是指它的 length 和 capacity 成员都是 0，并且它的底层数组指向 nil。从功能表现上来看，nil slice 可以被 append，并且自动分配内存。</p><p>比如，下述例子把一个 slice 中的所有元素拷贝到一个 nil slice 中去，从而实现复制功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice1 := <span class="built_in">append</span>([]<span class="keyword">int</span>(<span class="literal">nil</span>), slice...)</span><br></pre></td></tr></table></figure><p>可见，通过简单的 <code>slice = nil</code> 是最好的清空 slice 的方式，通过这样的方式，其底层的数组原占的内存也会被 gc 自动回收。<br>注意：不要通过 <code>slice = slice[:0]</code> 这样的方式去清空一个 slice，因为这会导致潜在的内存泄露。也就是说，内存已经不再使用了，但是却有可能通过 re-slice的方式访问到。</p><br>#### 如何插入一个元素到  slice 中？---use copy to shift items around in a single slice<p>给一个 slice 插入元素的时候需要注意 len 和 cap 属性，如果当前 slice 的 len 小于 cap，那么无需重新分配内存。<br>否则，插入一个元素必然需要重新分配内存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insert</span><span class="params">(slice []<span class="keyword">int</span>, index, value <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    slice = slice[<span class="number">0</span> : <span class="built_in">len</span>(slice)+<span class="number">1</span>]       <span class="comment">// Grow the slice by one element, make sure cap &gt;= len(slice) + 1</span></span><br><span class="line">    <span class="built_in">copy</span>(slice[index+<span class="number">1</span>:], slice[index:])  <span class="comment">// Use copy to move the upper part of the slice out of the way and open a hole.</span></span><br><span class="line">    slice[index] = value</span><br><span class="line">    <span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>##### slice 作为函数参数---<br>###### 1. 如果只是改变原有 slice 中的值，那么不需要传指针：虽然本质上，slice 做函数参数时，本身是做为值传递的，但是由于 slice 这个数据结构包含了一个指向底层数组的指针，在修改 slice 原有内容的时候的，是修改了底层数组的内容，因此修改效果可以体现。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(a []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>###### 2. 如果有 append 操作，必须取该 slice 变量的指针再传递：这是由于 append 会导致 slice 底层结构体中的引用的数组地址改变，length 成员变量的值也会改变, append 之后，slice 引用的还是原来的数组地址，因此修改无效！必须传递该 slice 的指针，以便获得修改后的效果。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSlice</span><span class="params">(a *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testAppend</span><span class="params">(slice0 []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">" %p \n"</span>, &amp;slice0)</span><br><span class="line">    slice0 = <span class="built_in">append</span>(slice0, <span class="number">4</span>)</span><br><span class="line">    fmt.Printf(<span class="string">" %p \n"</span>, &amp;slice0)</span><br><span class="line">    slice0 = <span class="built_in">append</span>(slice0, <span class="number">5</span>)</span><br><span class="line">    fmt.Printf(<span class="string">" %p \n"</span>, &amp;slice0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice0 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">" %p \n"</span>, &amp;slice0)</span><br><span class="line">    testAppend(slice0)</span><br><span class="line">    fmt.Printf(<span class="string">" %p \n"</span>, &amp;slice0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>0xc0820403c0<br>0xc082040420           // 可见， 做参数传递时， slice 复制了一份，因此地址变了。<br>0xc082040420<br>0xc082040420<br>0xc0820403c0</p></blockquote><p>如果不想通过参数中传指针的方式，那么利用返回值的方式来获得改变后的 slice。具体做法是在函数拷贝一个原 slice（使用copy(src, dest)），然后在函数末尾返回一个 slice， 如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSlice</span><span class="params">(a []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    dest := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(a))</span><br><span class="line">    <span class="built_in">copy</span>(dest, a)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> dest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>##### 二维 slice 的 append 操作---当使用二维 slice 时，需要把一个一维的 slice append 到 这个 二维 slice中， 如果这个 一维 slice 会频繁变动，比如作为临时 slice 使用（在算法题 SubSet， Combination Sum 等中经常见到）， 一定要记得拷贝一份再 append 给 那个 二维 slice。<p>使用这个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*all = <span class="built_in">append</span>(*all, <span class="built_in">append</span>([]<span class="keyword">int</span>(<span class="literal">nil</span>), *sol...))</span><br></pre></td></tr></table></figure><p>e.g.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2d</span><span class="params">(all *[][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    r1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    r2 := []<span class="keyword">int</span>&#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>&#125;</span><br><span class="line">    *all = <span class="built_in">append</span>(*all, r1)</span><br><span class="line">    *all = <span class="built_in">append</span>(*all, r2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1d</span><span class="params">(d1 *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *d1 = <span class="built_in">append</span>(*d1, <span class="number">88</span>)</span><br><span class="line">    *d1 = <span class="built_in">append</span>(*d1, <span class="number">99</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    all := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    test2d(&amp;all)</span><br><span class="line">    fmt.Println(all)</span><br><span class="line"></span><br><span class="line">    d1 := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    test1d(&amp;d1)</span><br><span class="line">    fmt.Println(d1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>###### 总结：---在什么情况下需要用到指针形式的 slice 呢？<ul><li>(1). 做函数参数， 需要对 slice 结构做 append 操作修改原数据。</li><li>(2). 为 slice 提供 pointer receiver 形式的成员函数修改本 slice。<br>  比如，<a href="https://blog.golang.org/slices" target="_blank" rel="noopener">https://blog.golang.org/slices</a> 提供的一个例子：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> path []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *path)</span> <span class="title">TruncateAtFinalSlash</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := bytes.LastIndex(*p, []<span class="keyword">byte</span>(<span class="string">"/"</span>))</span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        *p = (*p)[<span class="number">0</span>:i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pathName := path(<span class="string">"/usr/bin/tso"</span>) <span class="comment">// Conversion from string to path.</span></span><br><span class="line">    pathName.TruncateAtFinalSlash()</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, pathName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 这里的 receiver 必须是 pointer 类型的，否则修改无效。</p><br><br><br><h6 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h6><p><a href="https://blog.golang.org/go-slices-usage-and-internals" target="_blank" rel="noopener">https://blog.golang.org/go-slices-usage-and-internals</a><br><a href="http://lib.csdn.net/article/go/37533" target="_blank" rel="noopener">http://lib.csdn.net/article/go/37533</a><br><a href="https://www.dotnetperls.com/slice-go" target="_blank" rel="noopener">https://www.dotnetperls.com/slice-go</a><br><a href="https://blog.golang.org/slices" target="_blank" rel="noopener">https://blog.golang.org/slices</a><br><a href="http://blog.csdn.net/erlib/article/details/50957218" target="_blank" rel="noopener">http://blog.csdn.net/erlib/article/details/50957218</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop runtime paramters</title>
      <link href="/BigData/hadoop-hadoop-runtime/"/>
      <url>/BigData/hadoop-hadoop-runtime/</url>
      
        <content type="html"><![CDATA[<p>We can specify configuration parameters in configuration files like: <code>mapred-site.xml</code>, <code>hdfs-site.xml</code>, <code>core-site.xml</code>, we can also specify them dynamically using <code>-D</code> option when we submit job.</p><pre><code>$HADOOP_BIN jar $HADOOP_HOME/contrib/streaming/hadoop-streaming.jar \    -D mapred.map.task=1000 \    -D mapred.job.name=&quot;$JOBNAME&quot; \    -D mapred.job.priority=&quot;HIGH&quot; \    -D mapred.ignore.badcompress=true \    -D mapred.linerecordreader.maxlength=51200000 \    -input $INPUT     \    -output &quot;$OUTPUT&quot;   \    -mapper &quot;python2.7 $MAPRED -m&quot; \</code></pre><p><strong>Example:</strong></p><pre><code>#!/bin/bashcwd=`dirname $0`cd $cwddate=&quot;${1}&quot;if [ -z &quot;$date&quot; ]; then    date=`date -d &quot;1 day ago&quot; +&quot;%Y%m%d&quot;`else    echo &quot;Date is: ${date}&quot;fi# exit 1MAPRED=&apos;mr_result.py&apos;PHP_CMD=&quot;/usr/bin/php&quot;HADOOP_HOME=&quot;/usr/local/hadoop-2.7.2&quot;HADOOP_BIN=&quot;$HADOOP_HOME/bin/hadoop&quot;HADOOP_GET=&quot;$HADOOP_BIN fs -get &quot;alarm=&quot;/usr/bin/php ${cwd}/../lib/alarm/Alarm_Cli.php&quot;JOBNAME=&quot;shichunhui_${date}@ub-hadoop&quot;INPUT=&quot;./output/part-00000&quot;OUTPUT=&quot;./output_sorted&quot;TASK_NUM=1function my_log(){    dd=`date +&quot;%Y-%m-%d %H:%M:%S&quot;`    echo &quot;[${dd}] | ${1}&quot; &gt;&gt; hdp.log}$HADOOP_BIN fs -rm -r -f ${OUTPUT}my_log &quot;Hadoop Begin: ${date}&quot;# hadoop$HADOOP_BIN jar $HADOOP_HOME/share/hadoop/tools/lib/hadoop-streaming-2.7.2.jar \    -D mapreduce.job.name=&quot;$JOBNAME&quot; \    -D mapreduce.job.priority=&quot;VERY_HIGH&quot; \    -D mapreduce.ignore.badcompress=true \    -D mapreduce.output.key.comparator.class=org.apache.hadoop.mapred.lib.KeyFieldBasedComparator \    -D stream.num.reduce.output.key.fields=2 \    -D mapreduce.text.key.comparator.options=&quot;-k1,1nr&quot; \    -input $INPUT \    -output &quot;$OUTPUT&quot; \    -mapper &quot;python $MAPRED -m&quot; \    -reducer &quot;python $MAPRED -r&quot; \    -file &quot;$MAPRED&quot;    # -D stream.num.map.output.key.fields=2 \    # -D mapreduce.input.linerecordreader.line.maxlength=51200000 \if [ $? -ne 0 ]; then    my_log &quot;Hadoop Error: Run hadoop error&quot;    exit 1else    if [ -f &quot;/home/hadoop/data/output/sorted.txt&quot; ]; then        rm -rf &quot;/home/hadoop/data/output/sorted.txt&quot;    fi    ${HADOOP_GET} &quot;${OUTPUT}/part-00000&quot; &quot;/home/hadoop/data/output/sorted.txt&quot;fiexit 0</code></pre><p><strong>Explanation</strong></p><p>(1) -input: input file<br>(2) -output: output file<br>(3) -mapper: mapper application or commands<br>(4) -reducer: reducer application or commands<br>(5) -file: files that need to submitted to the hadoop jobs, they could be input files (e.g. config files, executables) mappers or reducer.<br>This is ussually required as all files are in local file system, we have to upload them to hdfs so that they can be executed.<br>(6) -partitioner：用户自定义的partitioner程序<br>(7) -D：Properties of job </p><p>common properties:</p><ul><li><strong>mapred.map.tasks</strong>  number of map tasks<br>If input has M number of parts, and this property is set larger than M, then actual number of map task is still M.</li><li><strong>mapred.reduce.tasks</strong> number of reduce task, default to 1</li></ul>]]></content>
      
      
      <categories>
          
          <category> BigData </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop Installation</title>
      <link href="/BigData/hadoop-hadoop-install/"/>
      <url>/BigData/hadoop-hadoop-install/</url>
      
        <content type="html"><![CDATA[<h2 id="Single-node-Installation"><a href="#Single-node-Installation" class="headerlink" title="Single-node Installation"></a>Single-node Installation</h2><p>Running Hadoop on Ubuntu (Single node cluster setup)</p><p>Before we set up a hadoop cluster, we will understand the meaning of the following:</p><p><strong>DataNode:</strong><br>A DataNode stores data in the Hadoop File System. A functional file system has more than one DataNode, with the data replicated across them.</p><p><strong>NameNode:</strong><br>The NameNode is the centrepiece of an HDFS file system. It keeps the directory of all files in the file system, and tracks where across the cluster the file data is kept. It does not store the data of these file itself.</p><p><strong>Jobtracker:</strong><br>The Jobtracker is the service within hadoop that farms out MapReduce to specific nodes in the cluster, ideally the nodes that have the data, or atleast are in the same rack.</p><p><strong>TaskTracker:</strong><br>A TaskTracker is a node in the cluster that accepts tasks- Map, Reduce and Shuffle operatons – from a Job Tracker.</p><p><strong>Secondary Namenode:</strong><br>Secondary Namenode whole purpose is to have a checkpoint in HDFS. It is just a helper node for namenode.</p><h3 id="System-Environment-Setup"><a href="#System-Environment-Setup" class="headerlink" title="System Environment Setup"></a>System Environment Setup</h3><p>Adding a dedicated Hadoop system user<br>We will use a dedicated Hadoop user account for running Hadoop.</p><pre><code>$ sudo addgroup hdgroup$ sudo adduser --ingroup hdgroup hduser1</code></pre><h4 id="Configuring-SSH"><a href="#Configuring-SSH" class="headerlink" title="Configuring SSH"></a>Configuring SSH</h4><p>The hadoop control scripts rely on SSH to peform cluster-wide operations. For example, there is a script for stopping and starting all the daemons in the clusters. To work seamlessly, SSH needs to be setup to allow password-less login for the hadoop user from machines in the cluster. The simplest way to achive this is to generate a public/private key pair, and it will be shared across the cluster.</p><p>Hadoop requires SSH access to manage its nodes, i.e. remote machines plus your local machine. For our <strong>single-node</strong> setup of Hadoop, we therefore need to configure SSH access to localhost for the hduser user we created in the earlier.</p><p>We have to generate an SSH key for the hduser user.</p><pre><code>$ su – hduser1$ ssh-keygen -t rsa -P &quot;&quot;</code></pre><p>We have to enable SSH access to your local machine with this newly created key which is done by the following command.</p><pre><code>$ cat $HOME/.ssh/id_rsa.pub &gt;&gt; $HOME/.ssh/authorized_keys</code></pre><p>The final step is to test the SSH setup by connecting to the local machine with the hduser1 user. The step is also needed to save your local machine’s host key fingerprint to the hduser user’s known hosts file.</p><pre><code>$ ssh localhost</code></pre><p>If the SSH connection fails, we can try the following (optional):</p><ul><li>Enable debugging with ssh -vvv localhost and investigate the error in detail.</li><li>Check the SSH server configuration in /etc/ssh/sshd_config. If you made any changes to the SSH server configuration file, you can force a configuration reload with sudo /etc/init.d/ssh reload.</li></ul><h4 id="Format-the-namenode"><a href="#Format-the-namenode" class="headerlink" title="Format the namenode"></a>Format the namenode</h4><pre><code>$ hdfs namenode -format</code></pre><h4 id="Start-hadoop-cluster"><a href="#Start-hadoop-cluster" class="headerlink" title="Start hadoop cluster"></a>Start hadoop cluster</h4><pre><code>$ sbin/start-dfs.sh$ sbin/start-yarn.sh</code></pre><h4 id="Check-hadoop-cluster-infomation"><a href="#Check-hadoop-cluster-infomation" class="headerlink" title="Check hadoop cluster infomation"></a>Check hadoop cluster infomation</h4><pre><code>$ hdfs dfsadmin -report$ yarn node -list</code></pre><p>check cluster info through Web UI:</p><pre><code>$ http://localhost:50070/</code></pre><p><strong>Reference</strong><br><a href="http://doctuts.readthedocs.io/en/latest/hadoop.html" target="_blank" rel="noopener">http://doctuts.readthedocs.io/en/latest/hadoop.html</a></p>]]></content>
      
      
      <categories>
          
          <category> BigData </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solve &quot;Unable to load native-hadoop library for your platform...&quot;</title>
      <link href="/BigData/hadoop-native-hadoop-lib/"/>
      <url>/BigData/hadoop-native-hadoop-lib/</url>
      
        <content type="html"><![CDATA[<p><strong>StatckOverflow:</strong><br><a href="http://stackoverflow.com/questions/19943766/hadoop-unable-to-load-native-hadoop-library-for-your-platform-warning" target="_blank" rel="noopener">http://stackoverflow.com/questions/19943766/hadoop-unable-to-load-native-hadoop-library-for-your-platform-warning</a></p><pre><code>$ export HADOOP_OPTS=&quot;$HADOOP_OPTS -Djava.library.path=$HADOOP_HOME/lib/native&quot;</code></pre><p>First, we need to make sure that the library file <code>libhadoop.so.1.0.0</code> in native directory must be compiled in 64-bit. We can get this information through <strong>file</strong> command:</p><pre><code>$ file /usr/local/hadoop-2.7.2/lib/native/libhadoop.so.1.0.0/usr/local/hadoop-2.7.2/lib/native/libhadoop.so.1.0.0: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=80bb5f017d77795a3610d1413154204d9f8b094d, not stripped</code></pre><p>From above above we can see that <code>libhadoop.so.1.0.0</code> is already 64-bit compiled, but we still have the error saying <span class="red">“Unable to load native-hadoop library for your platform…” </span>. So what could be the cause? from the second answer, we know that it is because <code>java.library.path</code> wasn’t specified, as long as we give it a correct value, there should be no errors any more. So we do this:</p><pre><code>$ export HADOOP_OPTS=&quot;$HADOOP_OPTS -Djava.library.path=$HADOOP_HOME/lib/native&quot;</code></pre><p>Now the warning info is disappeared.</p><h4 id="More"><a href="#More" class="headerlink" title="More"></a>More</h4><p>We can use <code>ldd</code> command to check what libs it is linking to:</p><pre><code>$ ldd /usr/local/hadoop-2.7.2/lib/native/libhadoop.so.1.0.0linux-vdso.so.1 =&gt; (0x00007ffeb5cb4000)libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fa8c647b000)libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fa8c60b1000)/lib64/ld-linux-x86-64.so.2 (0x00005613a2c53000)</code></pre><p>We can see more details about the error when we executing hadoop commands by setting a different log level:</p><pre><code>$ export HADOOP_ROOT_LOGGER=DEBUG,console​</code></pre><p>After setting this, every time when we execute a hadoop command, the detailed information will be shown, this is extremely helpful for us to locate the error:</p><pre><code>16/05/17 15:00:38 DEBUG util.NativeCodeLoader: Trying to load the custom-built native-hadoop library...16/05/17 15:00:38 DEBUG util.NativeCodeLoader: Failed to load native-hadoop with error:                                                java.lang.UnsatisfiedLinkError: no hadoop in java.library.path16/05/17 15:00:38 DEBUG util.NativeCodeLoader: java.library.path=/usr/java/packages/lib/amd64:                                               /usr/lib/x86_64-linux-gnu/jni:/lib/x86_64-linux-gnu:                                               /usr/lib/x86_64-linux-gnu:/usr/lib/jni:/lib:/usr/li</code></pre><p>From above error message we can clearly see, native lib wasn’t found (by which means <code>libhadoop.so</code> wasn’t found), and it’s due to the reason that the <code>java.library.path</code> was not specified.</p><p><strong>Reference</strong><br><a href="http://blog.csdn.net/lalaguozhe/article/details/10580727" target="_blank" rel="noopener">http://blog.csdn.net/lalaguozhe/article/details/10580727</a><br><a href="https://hadoop.apache.org/docs/r2.7.2/hadoop-project-dist/hadoop-common/NativeLibraries.html" target="_blank" rel="noopener">https://hadoop.apache.org/docs/r2.7.2/hadoop-project-dist/hadoop-common/NativeLibraries.html</a></p>]]></content>
      
      
      <categories>
          
          <category> BigData </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Windows command line script to create VMs in VirtualBox</title>
      <link href="/VirtualBox/vbox-vbox-create-vms-using-vboxmanage/"/>
      <url>/VirtualBox/vbox-vbox-create-vms-using-vboxmanage/</url>
      
        <content type="html"><![CDATA[<p>This article introduces a script to create VirtualBox VMs in Windows</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">SETLOCAL ENABLEEXTENSIONS</span><br><span class="line"><span class="built_in">set</span> VmName=Ubuntu16_</span><br><span class="line"><span class="built_in">set</span> storage=Storage</span><br><span class="line"><span class="built_in">set</span> ext=_Ext</span><br><span class="line"><span class="built_in">set</span> sub=.vdi</span><br><span class="line"></span><br><span class="line">:: (1) <span class="built_in">clone</span> hd</span><br><span class="line">:: <span class="keyword">for</span> /l %%i <span class="keyword">in</span> (1,1,3) <span class="keyword">do</span> vboxmanage clonevdi <span class="string">"D:\Program Files\VDIs\ubuntu1610.vdi"</span> <span class="string">"D:\Program Files\VDIs\%VmName%%%i%sub%"</span></span><br><span class="line"></span><br><span class="line">:: (2) create vms</span><br><span class="line"><span class="keyword">for</span> /l %%i <span class="keyword">in</span> (1,1,3) <span class="keyword">do</span> vboxmanage createvm --name %VmName%%%i --ostype Ubuntu_64 --register</span><br><span class="line"></span><br><span class="line">pause</span><br><span class="line">:: (3) modifyvm</span><br><span class="line"><span class="keyword">for</span> /l %%i <span class="keyword">in</span> (1,1,3) <span class="keyword">do</span> vboxmanage modifyvm %VmName%%%i --cpus 1 --memory 1024 --nic1 nat --nic2 intnet</span><br><span class="line"></span><br><span class="line">pause</span><br><span class="line">:: (4) add controller</span><br><span class="line"><span class="keyword">for</span> /l %%i <span class="keyword">in</span> (1,1,3) <span class="keyword">do</span> vboxmanage storagectl %VmName%%%i --name %VmName%%%i%storage% --add sata</span><br><span class="line"></span><br><span class="line">pause</span><br><span class="line">:: (5) extra hd</span><br><span class="line">:: <span class="keyword">for</span> /l %%i <span class="keyword">in</span> (1,1,3) <span class="keyword">do</span> vboxmanage createhd --filename <span class="string">"D:\Program Files\VDIs\%VmName%%%i%sub%"</span> --size 40000</span><br><span class="line"></span><br><span class="line">:: (6) attach devices to controller, i) cloned dev ii) extra hd</span><br><span class="line"><span class="keyword">for</span> /l %%i <span class="keyword">in</span> (1,1,3) <span class="keyword">do</span> vboxmanage storageattach %VmName%%%i --storagectl %VmName%%%i%storage% --port 0 --device 0 --<span class="built_in">type</span> hdd --medium <span class="string">"D:\Program Files\VDIs\%VmName%%%i%sub%"</span></span><br><span class="line">pause</span><br><span class="line">:: <span class="keyword">for</span> /l %%i <span class="keyword">in</span> (1,1,3) <span class="keyword">do</span> vboxmanage storageattach %VmName%%%i --storagectl %VmName%%%i%storage% --port 1 --device 0 --<span class="built_in">type</span> hdd --medium e:\vm\%VmName%%%i%ext%%sub%</span><br><span class="line">pause</span><br><span class="line">EDNLOCAL</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> VirtualBox </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HDFS High Availability</title>
      <link href="/BigData/hadoop-hadoop-ha/"/>
      <url>/BigData/hadoop-hadoop-ha/</url>
      
        <content type="html"><![CDATA[<h2 id="HDFS-High-Availability-Using-the-Quorum-Journal-Manager"><a href="#HDFS-High-Availability-Using-the-Quorum-Journal-Manager" class="headerlink" title="HDFS High Availability Using the Quorum Journal Manager"></a>HDFS High Availability Using the Quorum Journal Manager</h2><p>This guide provides an overview of the HDFS High Availability (HA) feature and how to configure and manage an HA HDFS cluster, using the Quorum Journal Manager (QJM) feature.</p><p>This document assumes that the reader has a general understanding of general components and node types in an HDFS cluster. Please refer to the HDFS Architecture guide for details.</p><p>Note: Using the Quorum Journal Manager or Conventional Shared Storage</p><p>This guide discusses how to configure and use HDFS HA using the Quorum Journal Manager (QJM) to share edit logs between the Active and Standby NameNodes. For information on how to configure HDFS HA using NFS for shared storage instead of the QJM, please see this alternative guide.</p><p><strong>Background</strong><br>Prior to Hadoop 2.0.0, the NameNode was a single point of failure (SPOF) in an HDFS cluster. Each cluster had a single NameNode, and if that machine or process became unavailable, the cluster as a whole would be unavailable until the NameNode was either restarted or brought up on a separate machine.</p><p>This impacted the total availability of the HDFS cluster in two major ways:</p><p>In the case of an unplanned event such as a machine crash, the cluster would be unavailable until an operator restarted the NameNode.</p><p>Planned maintenance events such as software or hardware upgrades on the NameNode machine would result in windows of cluster downtime.</p><p>The HDFS High Availability feature addresses the above problems by providing the option of running two (and as of 3.0.0 more than two) redundant NameNodes in the same cluster in an Active/Passive configuration with a hot standby. This allows a fast failover to a new NameNode in the case that a machine crashes, or a graceful administrator-initiated failover for the purpose of planned maintenance.</p><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>In a typical HA cluster, two or more separate machines are configured as NameNodes. At any point in time, exactly one of the NameNodes is in an Active state, and the others are in a Standby state. The Active NameNode is responsible for all client operations in the cluster, while the Standbys are simply acting as workers, maintaining enough state to provide a fast failover if necessary.</p><p>In order for the Standby node to keep its state synchronized with the Active node, both nodes communicate with a group of separate daemons called “JournalNodes” (JNs). When any namespace modification is performed by the Active node, it durably logs a record of the modification to a majority of these JNs. The Standby node is capable of reading the edits from the JNs, and is constantly watching them for changes to the edit log. As the Standby Node sees the edits, it applies them to its own namespace. In the event of a failover, the Standby will ensure that it has read all of the edits from the JounalNodes before promoting itself to the Active state. This ensures that the namespace state is fully synchronized before a failover occurs.</p><p>In order to provide a fast failover, it is also necessary that the Standby node have up-to-date information regarding the location of blocks in the cluster. In order to achieve this, the DataNodes are configured with the location of all NameNodes, and send block location information and heartbeats to all.</p><p>It is vital for the correct operation of an HA cluster that only one of the NameNodes be Active at a time. Otherwise, the namespace state would quickly diverge between the two, risking data loss or other incorrect results. In order to ensure this property and prevent the so-called “split-brain scenario,” the JournalNodes will only ever allow a single NameNode to be a writer at a time. During a failover, the NameNode which is to become active will simply take over the role of writing to the JournalNodes, which will effectively prevent the other NameNode from continuing in the Active state, allowing the new Active to safely proceed with failover.</p><p>Hardware resources</p><p>In order to deploy an HA cluster, you should prepare the following:</p><p>NameNode machines - the machines on which you run the Active and Standby NameNodes should have equivalent hardware to each other, and equivalent hardware to what would be used in a non-HA cluster.</p><p>JournalNode machines - the machines on which you run the JournalNodes. The JournalNode daemon is relatively lightweight, so these daemons may reasonably be collocated on machines with other Hadoop daemons, for example NameNodes, the JobTracker, or the YARN ResourceManager. Note: There must be at least 3 JournalNode daemons, since edit log modifications must be written to a majority of JNs. This will allow the system to tolerate the failure of a single machine. You may also run more than 3 JournalNodes, but in order to actually increase the number of failures the system can tolerate, you should run an odd number of JNs, (i.e. 3, 5, 7, etc.). Note that when running with N JournalNodes, the system can tolerate at most (N - 1) / 2 failures and continue to function normally.</p><p>Note that, in an HA cluster, the Standby NameNodes also performs checkpoints of the namespace state, and thus it is not necessary to run a Secondary NameNode, CheckpointNode, or BackupNode in an HA cluster. In fact, to do so would be an error. This also allows one who is reconfiguring a non-HA-enabled HDFS cluster to be HA-enabled to reuse the hardware which they had previously dedicated to the Secondary NameNode.</p><p><strong>Reference</strong><br><a href="http://hadoop.apache.org/docs/r3.0.0-alpha1/hadoop-project-dist/hadoop-hdfs/HDFSHighAvailabilityWithQJM.html" target="_blank" rel="noopener">http://hadoop.apache.org/docs/r3.0.0-alpha1/hadoop-project-dist/hadoop-hdfs/HDFSHighAvailabilityWithQJM.html</a></p>]]></content>
      
      
      <categories>
          
          <category> BigData </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh</title>
      <link href="/Linux/linux-ssh/"/>
      <url>/Linux/linux-ssh/</url>
      
        <content type="html"><![CDATA[<p><strong>SSH</strong> (Secure Shell) is a UNIX-based command interface and protocol for securely getting access to a remote computer. SSH is actually a suite of three utilities - slogin, ssh, and scp - that are secure versions of the earlier UNIX utilities, rlogin, rsh, and rcp. SSH commands are encrypted and secure in several ways. Both ends of the client/server connection are authenticated using a digital certificate, and passwords are protected by being encrypted.</p><p>SSH is the most common way to access remote Linux and Unix-like servers. A very common use of SSH is for Github account service.</p><h3 id="Basic-Syntax"><a href="#Basic-Syntax" class="headerlink" title="Basic Syntax"></a>Basic Syntax</h3><pre><code>$ ssh remote_username@remote_host</code></pre><p>SSH is a secure communication protocol, it works by connecting a ssh client to a ssh server, the most popular implementation of SSH in Linux is OpenSSH,<br>it provides a <strong>ssh</strong> command as the <code>ssh client</code> and <strong>sshd</strong> as the <code>ssh server</code>. In windows, an open source ssh client <code>PuTTy</code> can be used.<br>Make sure the <strong>sshd server</strong> is already running on the remote_host before we connect to it.</p><p>On Ubuntu 16.04, use <code>sudo systemctl start ssh</code> to start the sshd server if it is not started.</p><h3 id="SSH-server-Configuration"><a href="#SSH-server-Configuration" class="headerlink" title="SSH server Configuration"></a>SSH server Configuration</h3><pre><code>$ sudo vim /etc/ssh/sshd_config</code></pre><p>Below are some most common settings</p><pre><code>HostKey /etc/ssh/ssh_host_rsa_keyHostKey /etc/ssh/ssh_host_dsa_keyHostKey /etc/ssh/ssh_host_ecdsa_key</code></pre><p>The host keys declarations specify where to look for global host keys. </p><pre><code>LoginGraceTime 120PermitRootLogin yesStrictModes yes</code></pre><p><strong>LoginGraceTime</strong> specifies how many seconds to keep the connection alive without successfully logging in.</p><p>It may be a good idea to set this time just a little bit higher than the amount of time it takes you to log in normally.</p><p><strong>PermitRootLogin</strong> selects whether root is allowed to log in.</p><p>In most cases, this should be changed to “no” when you have created user account that has access to elevated privileges (through su or sudo) and can log in through ssh.</p><p><strong>strictModes</strong> is a safety guard that will refuse a login attempt if the authentication files are readable by everyone.</p><p>This prevents login attempts when the configuration files are not secure.</p><pre><code>X11Forwarding yesX11DisplayOffset 10</code></pre><p>These parameters configure an ability called X11 Forwarding. This allows you to view a remote system’s graphical user interface (GUI) on the local system.</p><p>This option <strong>must be enabled</strong> on the server and given with the SSH client during connection with the -X option.</p><h3 id="Login-using-SSH-with-Keys"><a href="#Login-using-SSH-with-Keys" class="headerlink" title="Login using SSH with Keys"></a>Login using SSH with Keys</h3><p>By default username/passwords are required to login to a remote system, but it could be tedious every time when we need to login to the remote server, we can set up key-based authentication to enable passwordless login.</p><h4 id="How-Does-Key-based-Authentication-Work"><a href="#How-Does-Key-based-Authentication-Work" class="headerlink" title="How Does Key-based Authentication Work?"></a>How Does Key-based Authentication Work?</h4><p>Key-based authentication works by creating a pair of keys: a private key and a public key.</p><p>The <strong>private key</strong> is located on the client machine and is secured and kept secret.</p><p>The <strong>public key</strong> can be given to anyone or placed on any server you wish to access.</p><p>When you attempt to connect using a key-pair, the server will use the public key to create a message for the client computer that can only be read with the private key.</p><p>The client computer then sends the appropriate response back to the server and the server will know that the client is legitimate.</p><p>This entire process is done in the background automatically after you set up keys.</p><h3 id="Create-SSH-Keys"><a href="#Create-SSH-Keys" class="headerlink" title="Create SSH Keys"></a>Create SSH Keys</h3><pre><code>$ ssh-keygen -t rsa</code></pre><p>By default, this command will generate a key pairs <code>id_rsa.pub</code> and <code>id_rsa</code> in <code>~/.ssh</code> directory.</p><p>RSA key and ED25519 key are considered strong enough, we can have more options when we generate them:</p><pre><code>$ ssh-keygen -t rsa -b 4096 -o -a 100$ ssh-keygen -t ed25519 -o -a 100</code></pre><p>We can specify another name using <code>-f</code> option</p><pre><code>$ ssh-keygen -f test -C &quot;test key&quot;$ cd ~/.ssh$ ls-rw-r--r-- 1 alex alex  807 Nov  9 20:55 authorized_keys-rw------- 1 alex alex 1679 Nov  9 22:01 id_rsa-rw-r--r-- 1 alex alex  396 Nov  9 22:01 id_rsa.pub</code></pre><p>As shown, the id_rsa file is <strong>readable and writable only (600)</strong> to the owner. This is how it should be to keep it secret.</p><h3 id="How-To-Transfer-the-Public-Key-to-the-Server"><a href="#How-To-Transfer-the-Public-Key-to-the-Server" class="headerlink" title="How To Transfer the Public Key to the Server"></a>How To Transfer the Public Key to the Server</h3><p><strong>(1) Manually copy to remote server</strong> </p><pre><code>$ cat ~/.ssh/id_rsa.pub | ssh hostname &quot;cat &gt;&gt; ~/.ssh/authorized_keys&quot;</code></pre><p>Now when ssh to the remote machine, it should ask you for your key passphrase instead of your password. If it doesn’t, it could be that the permissions and mode of the authorized_keys file and .ssh directory on the remote server need to be set more restrictively. You can do that with these commands on the remote server:</p><pre><code>$ chmod 700 ~/.ssh$ chmod 600 ~/.ssh/authorized_keys</code></pre><p><strong>(2) Automatically copy  to remote server</strong></p><pre><code>$ ssh-copy-id remote_host</code></pre><p>This will start an SSH session, which you will need to <strong>authenticate with your password</strong>.</p><p>After you enter your password, it will copy your public key to the server’s <code>~/.ssh/authorized_keys</code> file, which will allow you to log in without the password next time.</p><h3 id="Client-Side-Options"><a href="#Client-Side-Options" class="headerlink" title="Client-Side Options"></a>Client-Side Options</h3><p>See debug info of login, very helpful when we failed to login.</p><pre><code>$ ssh -v remote_hostdebug1: identity file /home/chris/.ssh/id_rsa type 2...debug1: Authentications that can continue: publickey,keyboard-interactivedebug1: Next authentication method: publickeydebug1: Offering public key: /home/chris/.ssh/id_rsa...debug1: Authentication succeeded (publickey)</code></pre><p>Some optional flags may need to match the settings in the remote host’s sshd configuration.</p><p>For instance, you if you changed the port number in your sshd configuration, you will need to match that port on the client-side by typing:</p><pre><code>$ ssh -p port_number remote_host</code></pre><p>If you only wish to execute a single command on a remote system, you can specify it after the host like so:</p><pre><code>$ ssh remote_host command_to_run</code></pre><h3 id="Using-the-ssh-agent-program"><a href="#Using-the-ssh-agent-program" class="headerlink" title="Using the ssh-agent program"></a>Using the ssh-agent program</h3><p>The true usefulness of using key based authentication comes in the use of the ssh-agent program. Usually, the ssh-agent program is a program that starts up before starting X windows and in turn starts X windows for you. All X windows programs inherit a connection back to the ssh-agent, including your terminal windows like Gnome Terminal, Konsole, xfce4-terminal, aterm, xterm and so on. What this means is that after you’ve started up X windows through ssh-agent, you can use the ssh-add program to add your passphrase one time to the agent and the agent will in turn pass this authentication information automatically every time you need to use your passphrase. </p><p>Most recent distributions will automatically start ssh-agent when you login to X windows through a session manager like gdm (graphical login).</p><p>We can check if it is already running by </p><pre><code>$ ps ef | grep ssh-agent</code></pre><p>If it is not running, we can start it by</p><pre><code>$ eval `ssh-agent -s`</code></pre><p>or</p><pre><code>$ exec ssh-agent bash</code></pre><p>Once it is running, add ssh key to it by running the ssh-add command:</p><pre><code>$ ssh-add</code></pre><p>this will add default generated private key <em>id_rsa</em> into <code>ssh-agent</code>, to add a different named ssh key, we can do this:</p><pre><code>$ ssh-add ~/.ssh/my_pk</code></pre><p>To list all ssh-keys that have been added into ssh-agent</p><pre><code>$ ssh-add -l</code></pre><h4 id="How-to-start-ssh-agent-automatically-on-system-start-up"><a href="#How-to-start-ssh-agent-automatically-on-system-start-up" class="headerlink" title="How to start ssh-agent automatically on system start up"></a>How to start ssh-agent automatically on system start up</h4><p>Adding the following to <code>~/.bash_profile</code> will automatically start <code>ssh-agent</code> and load the ssh-key(s) on login:</p><pre><code>if [ -z &quot;$SSH_AUTH_SOCK&quot; ] ; then  eval `ssh-agent -s`  ssh-addfi</code></pre><p><strong>Why do we need to use eval instead of just ssh-agent?</strong><br>Because when we execute <code>ssh-agent -s</code>, it will output below infomation. These information simply means that by starting ssh-agent,<br>it will set some environment variables as shown and exports them to the current shell. Using <code>eval</code> command will simply evaluate the scripts in enbraced by ``, so that its result will take effects on current shell.</p><pre><code>SSH_AUTH_SOCK=/tmp/ssh-XH65nCfLn4Hj/agent.8612; export SSH_AUTH_SOCK;SSH_AGENT_PID=9456; export SSH_AGENT_PID;echo Agent pid 9456;</code></pre><p>check <a href="http://stackoverflow.com/a/4086756/456814" target="_blank" rel="noopener">here</a> for more explanations.</p><p><span class="purpleOnRice">A summary note on permission settings in SSH&gt;</span></p><p>There are cases when we ‘correctly’ set up key-pairs following the above procedure, and still encounter error messages <span class="red">“Authentication refused: Bad owner or permissions on”</span> when we login through SSH. This is essentially because of the inappropriate permission mode of the directory <strong>~/.ssh</strong> and files in it.</p><p>File Permission in local machine and remote machine</p><p><strong>Local Machine</strong>  </p><ul><li><strong>~/.ssh</strong>          Write permission should be restricted only to the owner. e.g. 755 drwxr-xr-x</li><li><strong>~/.ssh/id_rsa</strong>   Write, Read and Execute permission should be restricted only to the owner. e.g. 600</li><li><strong>~/.ssh/config</strong>   Write permission should be restricted only to the owner. e.g. 700 or 600</li></ul><p><strong>Remote Machine</strong></p><ul><li><strong>~/.ssh</strong>                 Write permission should restricted be only to the owner. e.g. 700 drwx—–</li><li><strong>~/.ssh/authorized_key</strong>  Write permission should be restricted only to the owner. e.g. 600</li></ul><p>In short, if any of the file </p><p>Also, if we are not sure what the errors come from, we can always check <code>/var/log/secure</code> for more details.</p><p>A sample client side configuration: <a href="/materials/sshconfig">~/.ssh/config</a></p><p><strong>Reference</strong><br><a href="https://support.suso.com/supki/SSH_Tutorial_for_Linux" target="_blank" rel="noopener">https://support.suso.com/supki/SSH_Tutorial_for_Linux</a><br><a href="http://rabexc.org/posts/pitfalls-of-ssh-agents" target="_blank" rel="noopener">http://rabexc.org/posts/pitfalls-of-ssh-agents</a><br><a href="http://unix.stackexchange.com/questions/90853/how-can-i-run-ssh-add-automatically-without-password-prompt" target="_blank" rel="noopener">http://unix.stackexchange.com/questions/90853/how-can-i-run-ssh-add-automatically-without-password-prompt</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Executing commands on remote machine using SSH</title>
      <link href="/Linux/linux-ssh-remote-cmds/"/>
      <url>/Linux/linux-ssh-remote-cmds/</url>
      
        <content type="html"><![CDATA[<p>如果在远程执行 sudo 的过程中报错提示：<span class="red">sudo: no tty present and no askpass program specified</span></p><p>这是因为：sudo will only run a program as a different user if one of these 3 conditions has been met (as far as passwords are concerned):</p><ul><li>&lt;1&gt;. the NOPASSWD option is specified</li><li>&lt;2&gt;. the user entered the correct target password</li><li>&lt;3&gt;. the user entered the correct source password</li></ul><p>Since options 2 and 3 require a TTY (sudo won’t read from a pipe) it won’t run if it can’t find one. Check your script if at any point you’re running a script remotely using ssh, as it’s possible that it won’t allocate a TTY for a non-interactive remote command.</p><p>执行远程命令的时候， 如果需要在命令行接收用户输入的密码， 那么远程的系统必须要分配一个 TTY 以便用户能输入，如果没法分配，则会报错。</p><p><strong>最方便的解决办法是：</strong><br>在远程机器中 修改 <code>/etc/sudoers</code> 文件， 添加一行 <code>Defaults visiblepw</code></p><p>错误提示： <span class="red">sudo: sorry, you must have a tty to run sudo</span><br>解决方法：编辑文件 <code>vi /etc/sudoers</code> 把 <code>Defaults requiretty</code> 这一行注释掉<br>错误提示：<span class="red">no tty present and no askpass program specified</span><br>解决方法：编辑文件 <code>vi /etc/sudoers</code> 把 <code>Defaults visiblepw</code> 这一行加进去<br>错误提示：<span class="red">Permission denied, please try again.</span><br>解决方法：修改/<code>etc/ssh/sshd_config</code> 将 <code>PermitRootLogin</code> 这一行注释解除<br>但是修改后，出现其他问题，此错误仍会重现 本文链接</p><p><strong>参考：</strong><a href="http://www.cxybl.com/html/xwzx/20130509/37645.html" target="_blank" rel="noopener">http://www.cxybl.com/html/xwzx/20130509/37645.html</a></p><p>在脚本中 ssh 到远程机器执行命令的时候， 无法读取脚本中（相当于本地）定义的变量的值。<br>比如：<br>FILENAME=”test.txt”<br>ssh remote_server <strong>‘</strong>echo $FILENAME<strong>‘</strong></p><p>将无法显示 $FILENAME 的值</p><p><strong>解决办法是：</strong> 使用双引号，而不是单引号！<br>ssh remote_server <strong>“</strong> echo $FILENAME <strong>“</strong></p><p><strong>注意：</strong></p><ul><li>ssh 中执行连续的多个命令时，命令之间一定要记得用分号<strong>;</strong> 连接起来！</li><li>如果要在 ssh 中定义变量并且引用他， 在引用是一定要记得在 $前面加个 反斜线 \ 做一次转义，否则无法引用。<br>比如： 要写成 ssh remote_server “k=99; echo <span class="red"><strong>\</strong></span>$k”<br>在一键部署的时候， 一般是把 需要部署的主机好填写在一个 txt 文件中， 然后脚本读取这个文件，来分别 scp + ssh 部署。</li></ul><p>如果把逐行读取放在外循环， 内循环 ssh 的话， 会导致读取的时候失败！<br><strong>一个解决办法是：</strong> 先读取文件内容到数组变量中， 再遍历这个数组。</p><p><strong>读取文件内容到变量有几种方法：</strong><br>在 bash 4 中， 支持 <strong>mapfile</strong>， 和 *<em>readarray *</em>两种新命令， 使用方法如下：</p><pre><code>readarray myarray &lt; hosts.txtmapfile -t myarray &lt; hosts.txt</code></pre><p><strong>参考：</strong><a href="http://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html#index-readarray" target="_blank" rel="noopener">http://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html#index-readarray</a></p><p><strong>如果不是 bash 4， 可以使用如下方法：</strong></p><pre><code>IFS=/font&gt;\n&apos; read -d &apos;&apos; -r -a myarray &lt; hosts.txt</code></pre><p><strong>打印数组的方法：</strong></p><pre><code>echo ${myarray[*]}</code></pre><p>或者</p><pre><code>for i in ${lines[@]}; do echo $i; done</code></pre><p>在 ssh 执行远程命令时， 没法处理 <code>awk &#39;{print $2}&#39;</code> 这种有单引号的命令</p><p><strong>解决办法是：</strong><br>把这种命令写在一个 .sh 脚本里，然后 scp 到远程机器上执行<br>比如：<br>    scp  -oStrictHostKeyChecking=no <br>        awktest.sh remote_server:.<br>    ssh -oStrictHostKeyChecking=no <br>        bash awktest.sh</p><p><strong>如果进程存在，就 先 kill 它:</strong><br>kill $(ps aux | grep ‘[p]ython csp_build.py’ | awk ‘{print $2}’)</p><p><span class="blueBold"> 这种方式还可以解决很多通过 ssh 命令解决不了的问题！</span><br>比如远程登录时可能 shell 不同，ssh 命令中某些命令在不同的 shell 下语法不一样导致不能通用等。</p><p>ssh 远程执行解压命令之后，如果解压出来的文件夹的所属用户和组是 1044:1044，需要 chown 命令来改变用户和组信息！</p><p>例子：</p><pre><span>#!/usr/bin/sh</span><span># -----------------</span><span># 1. 执行 ssh 命令</span><span># 2. 读取本地变量需要加 双引号</span><span># 3. || 后面执行多个语句需要加 ()</span><span># -----------------</span><span>FILENAME="aaa.tar.gz"</span><span>POSTFIX=".tar.gz"</span><span>DEST="/usr/local"</span><span>file="hosts.txt"</span><span>test -e ../$FILENAME || (echo "$FILENAME not exist"; exit 1)</span><span>test -e $file || (echo "$file not exist"; exit 1)</span><span>readarray myarray < $file</span><span>for i in ${myarray[@]}; do</span>    <span class="magentaBold">scp</span> -oStrictHostKeyChecking=no \        ../$FILENAME $i:.    <span class="magentaBold">ssh </span>**-oStrictHostKeyChecking=no \        $USER@$i \        " \        echo "host: $i"        sudo tar zxf $FILENAME -C /usr/local;        sleep 1s        "done</pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Network Modes in VirtualBox</title>
      <link href="/VirtualBox/vbox-vbox-network-mode/"/>
      <url>/VirtualBox/vbox-vbox-network-mode/</url>
      
        <content type="html"><![CDATA[<p>VirtualBox 中的 Guest OS 想要上网，可以通过 VirtualBox 提供的 NAT，NAT network 和 Bridge 三种方式来实现。</p><br>### (1) NAT 模式---<p>NAT 是通过 VirtualBox 内置的 NAT Engine 把 Guest OS 中的网络请求转发给 Host OS 的 DNS 服务器来实现上网， 外网返回回来的网络数据会通过 NAT Engine 发送给 Guest OS。<br>NAT engine 会为 Guest OS 分配一个 ip 地址， VirtualBox 中默认的 NAT engine 会使用 10.0.2.0 作为第一个 NAT 网卡的网关，在这个网段内分配 ip 地址。<br>NAT 模式的缺点是： 主机不可访问虚拟机，因为不在同一个网段内（只能通过端口转发的方式来访问）。虚拟机可以访问主机，因为请求被 NAT 转发了。</p><br>### (2) NAT network 模式---<p>NAT network 原理跟 NAT 相同， 区别在于 NAT 模式下， 各个 Guest OS 之间互相不可见， 不可访问，因为在不同网段。而 NAT network 模式下， 各个 Guest OS 之间可见，在同一个网段内。</p><br>### (3) Bridge 模式---<p>Bridge 会虚拟一块 Physical 网卡(Interface)， 然后所有流过 Host OS 的网络数据也会同时流向 Guest OS。<br>Bridge 模式下， 主机与虚拟机相互可见， 因为在同一网段内。<br>Bridge 的缺点是： 由于需要为 Guest OS 设置一个静态 IP， 如果网段内的这个 IP 已经被其他主机使用了， 那么会造成 ip 地址冲突从而不能上网。<br>另外， 如果是在公司的网络中，由于安全的缘故，通常网络管理员会绑定 ip 和 MAC，所以除了公司设备之外，其他机器由于 MAC 不在公司的列表中，无法绑定 Ip，从而也不能上网。这时候只能采用 NAT 模式。</p><p>假设在 NAT 模式下，Guest 主机想要上网，只需要在 VirtualBox 中设置相应的模式即可，如下图：</p><p><img src="/image/network_mode.png" alt=""></p><br><br>###### Referencehttps://www.virtualbox.org/manual/ch06.html]]></content>
      
      
      <categories>
          
          <category> VirtualBox </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop Configuration</title>
      <link href="/BigData/hadoop-hadoop-configurations/"/>
      <url>/BigData/hadoop-hadoop-configurations/</url>
      
        <content type="html"><![CDATA[<p>Hadoop configurations</p><p>Once we have installed hadoop cluster we need to set up its configuration before it can work properly.<br>One of the common tasks when using Hadoop is interacting with its runtime - whether it is a local setup or a remote cluster, one needs to properly configure and bootstrap Hadoop in order to submit the required jobs. </p><h2 id="1-Configurations-files"><a href="#1-Configurations-files" class="headerlink" title="1. Configurations files"></a>1. Configurations files</h2><p>All the Hadoop configuration files are located in <code>$HADOOP_HOME/etc/hadoop</code>, hadoop provides a lot of environment variables, e.g. <code>$HADOOP_CONF_DIR</code> represents etc/hadoop.</p><p>There are maily four files: core-site.xml、hdfs-site.xml、mapred-site.xml and yarn-site.xml</p><table><thead><tr><th>config file</th><th>parameters</th><th>content</th></tr></thead><tbody><tr><td>core-site.xml</td><td>global settings</td><td>port number used for Hadoop instance, tmp dir, memory allocated for the file system, memory limit for storing the data, and size of Read/Write buffers</td></tr><tr><td>hdfs-site.xml</td><td>HDFS parameters</td><td>value of replication data, namenode path, and datanode paths of our local file systems. It specifies the place where we want to store the Hadoop infrastructure.</td></tr><tr><td>mapred-site.xml</td><td>Mapreduce parameters</td><td>Including two parts: JobHistory Server and application parameter. e.g. number of reduce tasks, buffer size, etc.</td></tr><tr><td>yarn-site.xml</td><td>Resource config parameters</td><td>Config which ports are used by ResourceManager，NodeManager, web monitor, etc.</td></tr></tbody></table><h2 id="2-Configuration-settings"><a href="#2-Configuration-settings" class="headerlink" title="2. Configuration settings"></a>2. Configuration settings</h2><p>Hadoop configuration are specified by resources, a resource contains a set of name/value pairs as XML data. Each resource is named by either a String or by a Path. If named by a String, then the classpath is examined for a file with that name.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line">&lt;?xml-stylesheettype="text/xsl" href="configuration.xsl"?&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>define the default port used by hadoop instance<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>io.file.buffer.size<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>131072<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">final</span>&gt;</span>4096<span class="tag">&lt;/<span class="name">final</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>buffer size for io stream is 4K<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/home/hduser/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase forother temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>The root element of Hadoop configuration file is <code>configuration</code>, it contains sub-element property each property is a config option.<br>Each config option contains a name, value and description . The name of the config option can be string or filepath, the value can be any of boolean, int, long, float, or string, file, array.<br>The above configuration sets up host/port, buffer size of io stream, and temporary directory for a hadoop cluster.</p><h2 id="3-Core-parameters"><a href="#3-Core-parameters" class="headerlink" title="3. Core parameters"></a>3. Core parameters</h2><p>Here is a list of the most common parameters of the four config files</p><h3 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h3><table><thead><tr><th>parameter name</th><th>defualt value</th><th>description</th></tr></thead><tbody><tr><td>fs.defaultFS</td><td>file:///</td><td>host and port of local file system used by hadoop instance</td></tr><tr><td>io.file.buffer.size</td><td>4096</td><td>buffer size of io stream</td></tr><tr><td>hadoop.tmp.dir</td><td>/tmp/hadoop-${user.name}</td><td>temp dir</td></tr></tbody></table><h3 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h3><table><thead><tr><th>parameter name</th><th>defualt value</th><th>description</th></tr></thead><tbody><tr><td>dfs.replication</td><td>3</td><td>number of replications</td></tr><tr><td>dfs.namenode.name.dir</td><td>file://${hadoop.tmp.dir}/dfs/name</td><td>name node directory of local file system</td></tr><tr><td>dfs.datanode.data.dir</td><td>file://${hadoop.tmp.dir}/dfs/data</td><td>data node directory of local file system</td></tr></tbody></table><h3 id="mapred-site-xml"><a href="#mapred-site-xml" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h3><table><thead><tr><th>parameter name</th><th>defualt value</th><th>description</th></tr></thead><tbody><tr><td>mapreduce.framework.name</td><td>local</td><td>value can be one of <code>local</code>、<code>classic</code> or <code>yarn</code>. yarn is recommended.</td></tr><tr><td>mapreduce.job.tracker</td><td></td><td>specifies host:port for jobtracker</td></tr><tr><td>mapreduce.jobhistory.address</td><td>0.0.0.0:10020</td><td>host:port for jobhistory server</td></tr><tr><td>mapreduce.jobhistory.webapp.address</td><td>0.0.0.0:19888</td><td>host:port for webapp of jobhistory</td></tr></tbody></table><h3 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h3><table><thead><tr><th>parameter name</th><th>defualt value</th><th>description</th></tr></thead><tbody><tr><td>yarn.resourcemanager.address</td><td>0.0.0.0:8032</td><td>host:port for client to access. client can submit job, kill job through this address.</td></tr><tr><td>yarn.resourcemanager.scheduler.address</td><td>0.0.0.0:8030</td><td>address for ApplicationMaster to apply or release resource.</td></tr><tr><td>yarn.resourcemanager.resource-tracker.address</td><td>0.0.0.0:8031</td><td>Address for NodeManager to report heartbeat, receive job tasks.</td></tr><tr><td>yarn.resourcemanager.admin.address</td><td>0.0.0.0:8033</td><td>Address for administrator to send commands.</td></tr><tr><td>yarn.resourcemanager.webapp.address</td><td>0.0.0.0:8088</td><td>Address for Web service, users can check cluster info through browser.</td></tr><tr><td>yarn.nodemanager.aux-services</td><td></td><td>User can custom some service through this option. e.g. shuffle of Map-Reduce</td></tr></tbody></table><h2 id="4-Setting-up-a-Single-node-hadoop-cluster-in-Pseudo-Distributed-Mode"><a href="#4-Setting-up-a-Single-node-hadoop-cluster-in-Pseudo-Distributed-Mode" class="headerlink" title="4. Setting up a Single node hadoop cluster in Pseudo Distributed Mode"></a>4. Setting up a Single node hadoop cluster in Pseudo Distributed Mode</h2><h5 id="core-site-xml-1"><a href="#core-site-xml-1" class="headerlink" title="core-site.xml"></a>core-site.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>io.file.buffer.size<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>131072<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Note</strong><br>Note here that we must specify a <strong>hadoop.tmp.dir</strong>, the reason is that if we don’t specify one here, hadoop will use a default tmp directory <code>/tmp/hadoo-hadoop</code>, this default directory will be deleted once the computer is restarted, therefore we have to re-format the hadoop file system.</p><h5 id="hdfs-site-xml-1"><a href="#hdfs-site-xml-1" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///home/hadoop/hadoopinfra/hdfs/namenode<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///home/hadoop/hadoopinfra/hdfs/datanode<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="mapred-site-xml-1"><a href="#mapred-site-xml-1" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="yarn-site-xml-1"><a href="#yarn-site-xml-1" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services.mapreduce.shuffle.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.mapred.ShuffleHandler<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost:8132<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost:8130<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost:8131<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.admin.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost:8133<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost:8188<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-More-configurations"><a href="#5-More-configurations" class="headerlink" title="5. More configurations"></a>5. More configurations</h2><p>Above provides only the most common configurations, if we want to better tune our hadoop cluster, we need to understand all the configuration parameters.<br>We have several ways to get more detailed configurations info</p><p>(1) Get information from official site.<br><a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/core-default.xml" target="_blank" rel="noopener">http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/core-default.xml</a><br><a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml" target="_blank" rel="noopener">http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml</a><br><a href="http://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/mapred-default.xml" target="_blank" rel="noopener">http://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/mapred-default.xml</a><br><a href="http://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-common/yarn-default.xml" target="_blank" rel="noopener">http://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-common/yarn-default.xml</a></p><p>(2) Get information from cluster tools<br>Once we have set up hadoop cluster, we can get cluster info from <a href="http://192.168.75.101:8188/conf" target="_blank" rel="noopener">http://192.168.75.101:8188/conf</a>, 192.168.75.101:8188 is the address we have set in yarn.resourcemanager.webapp.address.</p><p><strong>References</strong><br><a href="http://ercoppa.github.io/HadoopInternals/HadoopConfigurationParameters.html" target="_blank" rel="noopener">http://ercoppa.github.io/HadoopInternals/HadoopConfigurationParameters.html</a><br><a href="https://www.tutorialspoint.com/hadoop/hadoop_enviornment_setup.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/hadoop/hadoop_enviornment_setup.htm</a></p>]]></content>
      
      
      <categories>
          
          <category> BigData </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop reduce task</title>
      <link href="/BigData/hadoop-reduce-tasks/"/>
      <url>/BigData/hadoop-reduce-tasks/</url>
      
        <content type="html"><![CDATA[<p>By default, there is only one <code>reduce task</code>, this means it will output <code>part-00000</code> including all keys.</p><p>In face of huge amount of data, the reduce procedure of mapreduce program is extremely slow, we can improve the speed by increasing the number of <code>reduce task</code>.By setting <code>mapreduce.reduce.tasks = num</code>, the output will become <code>part-00000</code>, <code>part-00001</code>, <code>part-00002</code>, <code>...</code>, same number as that of <code>reduce tasks</code>.</p><p>Since <code>reduce</code> makes partition by key, same key will always in the same partition, therefore it is guaranteed that different <code>part-00000</code> will never have duplicate keys.</p><p>If we need to merge all the outputs to one final file, we can do a mapreduce to these outputs one more time.</p>]]></content>
      
      
      <categories>
          
          <category> BigData </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Job commands</title>
      <link href="/Linux/linux-job-cmd/"/>
      <url>/Linux/linux-job-cmd/</url>
      
        <content type="html"><![CDATA[<h3 id="Job-Commands"><a href="#Job-Commands" class="headerlink" title="Job Commands"></a>Job Commands</h3><table><thead><tr><th>Command</th><th>Explanation</th><th>Example</th></tr></thead><tbody><tr><td>&amp;</td><td>Run the command in the background</td><td><code>% long_cmd &amp;</code></td></tr><tr><td>Ctrl-z</td><td>Stop the foreground process</td><td><code>[Ctrl-z] Stopped</code></td></tr><tr><td>jobs</td><td>List background processes</td><td><code>% jobs [1] - Stopped vi [2] - big_job &amp;</code></td></tr><tr><td>%n</td><td>Refers to the background number n</td><td><code>% fg %1</code></td></tr><tr><td>%?str</td><td>Refers to the background job containing str</td><td><code>% fg %?ls</code></td></tr><tr><td>bg</td><td>Restart a stopped background process</td><td><code>% bg [2] big_job &amp;</code></td></tr><tr><td>fg</td><td>Bring a background process to the foreground</td><td><code>% fg %1</code></td></tr><tr><td>kill</td><td>Kill a process</td><td><code>% kill %2</code></td></tr><tr><td>~ Ctrl-z</td><td>Suspend an rlogin or ssh session</td><td><code>host2&gt;~[Ctrl-z] Stopped host1&gt;</code></td></tr><tr><td>~~ Ctrl-z</td><td>Suspend a second level rlogin or ssh session</td><td><code>host3&gt;~~[Ctrl-z] Stopped host2&gt;</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Awk Programming</title>
      <link href="/Linux/linux-awk/"/>
      <url>/Linux/linux-awk/</url>
      
        <content type="html"><![CDATA[<p>Awk is very powerful in processing delimiter-separated text in Linux.</p><h3 id="Typical-Uses-of-AWK"><a href="#Typical-Uses-of-AWK" class="headerlink" title="Typical Uses of AWK"></a>Typical Uses of AWK</h3><p>Awk can be used in many different ways, such as:</p><ul><li>Text processing,</li><li>Producing formatted text reports,</li><li>Performing arithmetic operations,</li><li>Performing string operations, and many more.</li></ul><h3 id="Program-Structure"><a href="#Program-Structure" class="headerlink" title="Program Structure"></a>Program Structure</h3><h4 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h4><p>awk [option] ‘BEGIN{} { … body … }  END{}’</p><p>Awk’s default action is print</p><p><strong>BEGIN block</strong></p><p>The syntax of the BEGIN block is as follows:</p><pre><code>BEGIN {commands}</code></pre><p>The BEGIN block gets executed at program start-up. It executes only once.<br>This is good place to initialize variables. BEGIN is an AWK keyword and hence it must be in upper-case. This block is optional.</p><p><strong>Body Block</strong><br>The syntax of the body block is as follows:</p><pre><code>/pattern/ {commands}</code></pre><p>The body block applies AWK commands on every input line. By default, AWK executes commands on every line.<br>We can restrict this by providing patterns. Note that there are no keywords for the Body block.</p><p><strong>END Block</strong></p><p>The syntax of the END block is as follows</p><pre><code>END {commands}</code></pre><p><strong>Work flow</strong></p><p>Awk will execute command in BEGIN block first, then fetch a line from input stream, execute commands in Body block according to some pattern matching result,<br>once done processing a line, it will fetch the next line, until there is no line from input stream, finally it will execute commands in END block.</p><p>Awk use <code>&#39;&#39;</code> to enclose all commands</p><p>Awk use <code>$0</code> to refer to the current line that have been read, user $1, $2, … to refer to each field in a line.</p><p>Example</p><p><strong>(1) Print all lines</strong></p><pre><code>$ awk &apos;{print $0}&apos; file</code></pre><p><strong>(2) Print matching line</strong></p><pre><code>$ awk &apos;/pattern/&apos; file  or without &apos;&apos;$ awk /pattern/ tt</code></pre><p><strong>(3) Count the number of matching lines</strong></p><pre><code>$ awk &apos;/pattern/{++cnt} END{print &quot;Count=&quot;, cnt}&apos; file</code></pre><p><strong>(4) Print the lines that have length greater than 18</strong></p><pre><code>$ awk &apos;length($0)&gt;18&apos;  file</code></pre><p><strong>(5) Access shell variable in awk</strong><br>By default, awk can only access itself variables, we can use -v to import shell variables to awk</p><pre><code>$ myvar=&quot;something&quot;$ awk -v var=&quot;$myvar&quot; &apos;{print var}&apos; file</code></pre><h3 id="Internal-variables"><a href="#Internal-variables" class="headerlink" title="Internal variables"></a>Internal variables</h3><p>Awk provides a couple of internal variables, if we execute <code>awk -d</code>, it will generate a file named <code>awkvars.out</code> in current directory,<br>this file contains all the internal variables of awk.</p><p>These internal variables are separated into two categories：</p><p><strong>1. Control awk</strong></p><p>FS                Input field separator<br>OFS               Output stream field separator<br>RS                Input record separator<br>ORS               Output record separator </p><p><strong>2. Convey Information</strong></p><p>ARGC              Number of input args<br>ARGV              Array that stores all input args<br>ENVIRON<br>FILENAME          input filename<br>FNR               the current record number in the current file，it is incremented each time a new record is read<br>NF                the number of fields in the current input record<br>NR                the number of input records awk has processed</p><p><strong>(1) ENVIRON</strong></p><pre><code>$ awk &apos;BEGIN {print ENVIRON[&quot;USER&quot;]}&quot;</code></pre><p><strong>(2) FILENAME</strong></p><pre><code>$ awk &apos;END {print FILENAME}&apos; marks.txt</code></pre><p><strong>(3) FS</strong><br>Field Separator of the input stream, by default is whitespace, can be modified using <code>-F</code> option.</p><pre><code>$ awk &apos;BEGIN {print &quot;FS = &quot; FS}&apos; | cat -vte</code></pre><p><strong>(4) NF</strong></p><p>Number of fields in a line<br>e.g. Print lines that have more than 3 fields</p><pre><code>$ awk &apos;NF &gt; 2&apos; One Two Three &lt;&lt;&lt; &quot;One Two\nOne Two Three\nOne Two Three Four&quot; </code></pre><p><strong>(5) NR</strong><br>Line number of current line</p><pre><code>$ awk &apos;NR &lt; 3&apos; &lt;&lt;&lt; &quot;One Two\nOne Two Three\nOne Two Three Four&quot;</code></pre><p><strong>(6) FNR</strong><br>Line number of current line of current file<br>This is useful when awk is process multiple files</p><p><strong>(7) OFS</strong><br>Field separator of output stream, by default is whitespace.</p><p><strong>(8) RS</strong><br>Record separator of input stream, by default is newline character <code>&#39;\n&#39;</code>.</p><p><strong>(9) ORS</strong><br>Record separator of output stream, by default is newline character <code>\n</code>.</p><p><strong>(9) RLENGTH</strong><br>The length of matched string</p><pre><code>$ awk &apos;BEGIN { if (match(&quot;One Two Three&quot;, &quot;re&quot;)) { print RLENGTH } }&apos;2</code></pre><p><strong>(11) RSTART</strong><br>The first position matched string appears</p><pre><code>$ awk &apos;BEGIN { if (match(&quot;One Two Three&quot;, &quot;Thre&quot;)) { print RSTART } }</code></pre><p><strong>(12) SUBSEP</strong><br>The separator character for array subscripts, the default value is \034</p><pre><code>$ awk &apos;BEGIN { print &quot;SUBSEP = &quot; SUBSEP }&apos; | cat -vte</code></pre><p>Regular Expression Operator</p><p><code>&#39;~&#39;</code>  denotes matched<br><code>&#39;!~&#39;</code> denotes not matched</p><pre><code>$ awk &apos;$0 ~ 9&apos; marks.txt2) Rahul   Maths    905) Hari    History  89$ awk &apos;$0 !~ 9&apos; marks.txt1) Amit     Physics   803) Shyam    Biology   874) Kedar    English   85</code></pre><p>Note: we need to use backslash to escape regular expression characters if we use <strong>awk</strong>, otherwise we should use <strong>gawk</strong>.</p><pre><code>$ tail -n 40 /var/log/nginx/access.log | awk &apos;$0 ~ /ip\[127\.0\.0\.1\]/&apos;</code></pre><p><strong>Reference</strong></p><p><a href="https://www.chemie.fu-berlin.de/chemnet/use/info/gawk/gawk_11.html" target="_blank" rel="noopener">https://www.chemie.fu-berlin.de/chemnet/use/info/gawk/gawk_11.html</a> </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Text field processing using cut and paste</title>
      <link href="/Linux/linux-cut-paste/"/>
      <url>/Linux/linux-cut-paste/</url>
      
        <content type="html"><![CDATA[<p><strong>cut</strong> and <strong>paste</strong> commands in Linux is very helpful in process text that are separated in fields, so if we need to process data that contain such text, it is recommanded to master cut and paste commands.</p><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><p>assume we have a plain text file <code>test.txt</code>:</p><pre><code>1|2|3|4|5|6|7|8|九|01|2|3|4|5|6|7|8|九|01|2|3|4|5|6|7|8|九|01|2|3|4|5|6|7|8|九|01|2|3|4|5|6|7|8|九|01|2|3|4|5|6|7|8|九|0</code></pre><h3 id="cut-basics-and-character-mode"><a href="#cut-basics-and-character-mode" class="headerlink" title="cut basics and character mode"></a>cut basics and character mode</h3><p>The basic funcationality of <code>cut</code> command is to extract out some column data from a text file. More precisely, cut accept lines from input stream, get some column out.<br>There are three modes for the column.</p><ul><li>-b      # Each column is denoted by a byte</li><li>-c      # Each column is denoted by a character</li><li>-f      # Each column is denoted by a field (each field is separated by some delimiters)</li></ul><p>As we know, each English character is a single byte in ASCII. Suppose we want to print out the third byte of each line, the expected output should be 6 twos:</p><pre><code>$ cut -b 3 cut.txt222222</code></pre><p>Correct, the result meets our expectation.</p><h3 id="Cut-Syntax"><a href="#Cut-Syntax" class="headerlink" title="Cut Syntax"></a>Cut Syntax</h3><p>cut -[b,c,f] <columns> <filename></filename></columns></p><p>cut has a very flexible sytle of specifying column or clumn range</p><pre><code>3       # 3rd column 3,5,8   # 3rd, 5th, 8th columns3-5,8   # 3rd to 5th columns, and the 8th column-3,8    # 1st to 3th colums, and the 8th column1,3-    # 1st column, 3rd to the last columns</code></pre><p>Byte mode in some cases may cause problems. e.g. If the file contains non-ASCII characters, by which means they are not single byte characters, <code>-b</code> will not work as expected.</p><pre><code>$ cut -b 17 cut.txt</code></pre><p><code>-b</code> will only print the first byte of the 17th column instead of the 17 character of the line, in another word, it print will out the first byte of <code>九</code>. The real content depends on how chinese character <code>九</code> is encoded.</p><h3 id="Character-mode-and-field-mode"><a href="#Character-mode-and-field-mode" class="headerlink" title="Character mode and field mode"></a>Character mode and field mode</h3><p><code>-c</code> specifies character mode. In order to print out <code>九</code>, we can do this:</p><pre><code>$ cut -c 17 cut.txt九九九九九九</code></pre><p>Except for this, -c and -b are completely the same.</p><p>类似的，还有域模式。与字节模式以及字符模式最大的不同是，域模式可以指定单个字符作为分隔符，逐行地将文件分成若干列。比如，这里我们可以用 | 作为分隔符，输出第三列至第五列以及第九列。注意，在列模式下，分隔符也会按需输出。</p><pre><code>$ cut -d &apos;|&apos; -f 3-5,9 cut.txt3|4|5|九3|4|5|九3|4|5|九3|4|5|九3|4|5|九3|4|5|九补集</code></pre><p><strong>cut</strong> also provides <code>--complement</code> option to get the reverted result</p><pre><code>$ cut -d &apos;|&apos; -f 3-5,9 --complement cut.txt1|2|6|7|8|01|2|6|7|8|01|2|6|7|8|01|2|6|7|8|01|2|6|7|8|01|2|6|7|8|0</code></pre><p>With <code>--complement</code>, it is easy to delete a column from a text file. </p><pre><code>$ cut -d &apos;|&apos; -f 4 --complement cut.txt1|2|3|5|6|7|8|九|01|2|3|5|6|7|8|九|01|2|3|5|6|7|8|九|01|2|3|5|6|7|8|九|01|2|3|5|6|7|8|九|01|2|3|5|6|7|8|九|0</code></pre><p>Process continuous space characters</p><p>cut will make a mess when process a serial of continuous same characters. Fortunately, we can get help from another command <strong>tr</strong> with <code>-s, --squeeze</code> option.<br><code>-s</code> option can be used to squeeze the contiguous-characters to a single occurrence.</p><pre><code>$ whojack :0           2016-11-08 00:07jack pts/0        2016-11-08 00:23 (:0.0)jack pts/1        2016-11-08 00:15 (:0.0)</code></pre><p>After using <code>tr -s</code></p><pre><code>$ who | tr -s &apos; &apos;jack :0 2016-11-08 00:07jack pts/0 2016-11-08 00:23 (:0.0)jack pts/1 2016-11-08 00:15 (:0.0)</code></pre><p>By cooperating <code>cut</code> with <code>tr -s &#39;&#39;</code>, we can get a clearer result.</p><pre><code>$ who | tr -s &apos; &apos; | cut -d &apos; &apos; -f 1,3,4jack 2016-11-08 00:07jack 2016-11-08 00:23jack 2016-11-08 00:15</code></pre><p>Using TAB as seprator, <code>cut</code> does not support multi characters as separator, so ‘\t’ will not work, to type TAB character, press <code>Ctrl+v</code>, then press <code>TAB</code> key.</p><pre><code>$ cut -f2 -d$&apos;\t&apos; file</code></pre><p>or</p><pre><code>$ cut -d &apos;    &apos; -f2 file</code></pre><h2 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h2><p>Compared to cut, <code>paste</code> command is more straight and easy. It’s main usage is to </p><p>Assume we have 3 files:</p><pre><code>$ cat paste1.txt  | $ cat paste2.txt | $ cat paste3.txt1                 | a                | A2                 | b                | B3                 | c                | C</code></pre><p>Try with <code>paste</code></p><pre><code>$ paste paste1.txt paste2.txt1    a2    b3    c$ paste paste2.txt paste1.txta    1b    2c    3$ paste paste2.txt paste1.txt paste3.txta    1    Ab    2    Bc    3    C$ paste paste2.txt paste1.txt paste3.txt | sed -n la\t1\tAb\t2\tBc\t3\tC</code></pre><p><strong>paste</strong> accepts multiple files as input, and stick them together line by line using ‘\t<code>by default. If we want to custom the delimiter in the output we can use</code>-d` option to specify.</p><pre><code>$ paste -d &apos;|&apos; paste2.txt paste1.txt paste3.txta|1|Ab|2|Bc|3|C</code></pre><h4 id="Avoid-temp-file"><a href="#Avoid-temp-file" class="headerlink" title="Avoid temp file"></a>Avoid temp file</h4><p>If we want to stick together outputs of several different applications, we may have to write them to temporary files and use <code>paste</code> command later. Fortunately, we can avoid this by using <a href="http://www.gnu.org/software/bash/manual/html_node/Process-Substitution.html" target="_blank" rel="noopener">Bash Process Substituation</a>.</p><p>In short, use <code>&lt;(command)</code> to simulate a temp file, and use it as the input of the <code>paste</code> command.</p><p>e.g.</p><pre><code>$ paste -d &apos;|&apos; &lt;(cat paste2.txt) &lt;(cat paste1.txt) &lt;(cat paste3.txt)a|1|Ab|2|Bc|3|C</code></pre><p><strong>Reference</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Commandline hotkeys make life easier</title>
      <link href="/Linux/linux-commandline-shortkeys/"/>
      <url>/Linux/linux-commandline-shortkeys/</url>
      
        <content type="html"><![CDATA[<p><strong>Shortcut</strong>    <strong>Description</strong></p><h5 id="Cursor-Movement"><a href="#Cursor-Movement" class="headerlink" title="Cursor Movement"></a>Cursor Movement</h5><p>Ctrl + a        Move cursor to start of the line<br>Ctrl + e        Move cursor to end of the line<br>Ctrl + b        Move cursor back one character<br>Ctrl + f        Move cursor back one character<br>Alt/Esc + b     Move cursor back one word<br>Alt + f         Move cursor forward one word<br>Ctrl + xx           Toggle between the end of line and current cursor position<br>Ctrl + ]　c         Move cursor to the position of charactor c on right<br>Esc + Ctrl + ]　c   Move cursor to the position of charactor c on left<br>Ctrl + r　c         Move cursor to the position of charactor c on left<br>Ctrl + s            Search on current line and move cursor to the right found charactor(need to execute <code>stty -ixon</code> to release XON/XOFF swtich)<br>Ctrl + o            Execute the command found via Ctrl+r or Ctrl+s</p><h5 id="Edit"><a href="#Edit" class="headerlink" title="Edit"></a>Edit</h5><p>Ctrl + l        Clears the Screen, similar to the clear command<br>Ctrl + u        Cut everything before the cursor position<br>Ctrl + k        Cut everything after the cursor position to the end of line<br>Ctrl + d        Delete character under the cursor<br>Ctrl + h        Delete character before the cursor (Backspace)<br>Ctrl + w        Cut the current word before the cursor<br>Alt + d         Cut the current word after the cursor<br>Ctrl + y        Paste the previous cut text<br>Alt + y         Paste the second latest cut text<br>Alt + Ctrl + y  Paste the first argument of the previous command<br>Alt + ./_       Paste the last argument of the previous command<br>Ctrl + p        Paste previous command, ↑<br>Ctrl + n        Paste next command, ↓<br>Alt  + t        Swap current word with previous<br>Ctrl + t        Swap the last two characters before the cursor (typo).<br>Esc  + t        Swap the last two words before the cursor.<br>Alt + \         Delete all blank space before the current cursor</p><h5 id="Undo-amp-amp-Redo"><a href="#Undo-amp-amp-Redo" class="headerlink" title="Undo &amp;&amp; Redo"></a>Undo &amp;&amp; Redo</h5><p>Ctrl + xu           Undo (don’t release ctrl when press x and u)<br>Ctrl + shift + -    Undo<br>Ctrl + /            Undo</p><h5 id="History"><a href="#History" class="headerlink" title="History"></a>History</h5><p>Ctrl + p        Paste previous command<br>Ctrl + n        Paste next command<br>Alt + n         Move to the next line<br>Ctrl + r        Search history<br>Ctrl + g        Abort search (and restores original line)<br>Ctrl + j        End search<br>Alt + r         Restores all changes made to line</p><h5 id="Completion"><a href="#Completion" class="headerlink" title="Completion"></a>Completion</h5><p>Tab             Auto-complete a name<br>Alt + ?         List all possible completions<br>Alt + *         Insert all possible completions<br>Ctrl + x @      Show possible hostname completions</p><h5 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h5><p>Ctrl + c        Kill whatever you are running<br>Ctrl + d        Log out of the current session, same as exit<br>Ctrl + z        Puts current process into a suspended background process(use <code>fg</code> to restores)<br>Ctrl + s        Hide command input (use <code>Ctrl + q</code> to restore)s</p><h5 id="Special-commands"><a href="#Special-commands" class="headerlink" title="Special commands"></a>Special commands</h5><p>~               Moves to the user’s home directory.<br>!!              Repeats last command<br>!abc            Run last command starting with abc<br>!abc.p          Print last command starting with abc<br>!$              Last argument of the previous command<br>ALT + ./_       Last argument of the previous command<br>^abc^123        Run previous command, replacing abc with 123<br>tput reset      Resets the terminal if terminal screen is not displaying correctly.<br>shutdown -h     now Remotely or locally shuts the system down.<br>fg [#]          brings background jobs foreground.<br><code>ps -p $$        print the current session shell</code></p><h5 id="Emacs-mode-vs-Vi-Mode"><a href="#Emacs-mode-vs-Vi-Mode" class="headerlink" title="Emacs mode vs Vi Mode"></a>Emacs mode vs Vi Mode</h5><p>All the above assume that bash is running in the default Emacs setting, if you prefer this can be switched to Vi shortcuts instead.</p><p>Set Vi Mode in bash:</p><pre><code>$ set -o vi</code></pre><p>Set Emacs Mode in bash:</p><pre><code>$ set -o emacs</code></pre><h5 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h5><p>bind -P    List all binding shortcuts</p><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p>CTRL + ALT + T  bash command line</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.skorks.com/2009/09/bash-shortcuts-for-maximum-productivity/" target="_blank" rel="noopener">https://www.skorks.com/2009/09/bash-shortcuts-for-maximum-productivity/</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原子操作和竞争</title>
      <link href="/Operating-System/os-cpu-atomic-contention-2/"/>
      <url>/Operating-System/os-cpu-atomic-contention-2/</url>
      
        <content type="html"><![CDATA[<p>本文是 RAD Game Tools 程序员 Fabian “ryg” Giesen 在其<a href="https://fgiesen.wordpress.com/2014/07/07/cache-coherency/" target="_blank" rel="noopener">博客</a>上发表的《Atomic operations and contention》一文的翻译，这是该系列文章中的第二篇。</p><p>上一篇文章讲了缓存一致性原理的基础知识。这篇文章再来谈谈基于一致的缓存构建一个有用的系统，需要哪些原语（primitive），以及它们是如何工作的。</p><br><h4 id="原子性和原子操作"><a href="#原子性和原子操作" class="headerlink" title="原子性和原子操作"></a>原子性和原子操作</h4><p>计算机操作最重要的构成单位是原子操作。这里的原子跟物理上说的原子没有任何关系，而是起源于单词atom，也就是希腊语“ἄτομος”（意为不可见的）。原子操作是一种不可再细分的操作，或者在系统中其他处理器看来是不可再分了。为了说明为什么原子操作很重要，考虑两个处理器以几乎相同的方式增加一个计数器，翻译成C语言就是counter++，此时会发生什么：</p><table><thead><tr><th>指令周期</th><th>处理器一</th><th>处理器二</th></tr></thead><tbody><tr><td>0</td><td>reg = load(&amp;counter);</td><td></td></tr><tr><td>1</td><td>reg = reg + 1;</td><td>reg = load(&amp;counter);</td></tr><tr><td>2</td><td>store(&amp;counter, reg);</td><td>reg = reg + 1;</td></tr><tr><td>3</td><td></td><td>store(&amp;counter, reg);</td></tr></tbody></table><p>在编译好的代码中，这样一个操作分为：读操作、寄存器自加，最后是一个写操作（这里用类似C语言的伪代码表示）。这三个步骤是独立且按顺序执行的（注意，对于x86来说，在更微观的架构层次上这句话是正确的，但是在指令集架构的层次上，这三步看起来可以用一条“读-修改-写（read-modify-write）”指令完成：add [memory], value）。并且因为这些操作被分成多个指令周期来执行，所以在处理器一读完counter（并且正开始把它加一）之后，把结果写回去之前的空隙，处理器二也有可能去读它。结果导致虽然两个处理器都去增加这个计数器，但最终计数器的值只被加了1，其中一个加法运算“丢失”了。</p><p>原子操作恰恰就是用来防止这个问题的。如果我们使用一个原子的自加操作（说得更通用一点，原子加法）而不是常规的自加操作，执行指令的处理器会确保上面的三个步骤（读、加、写）像一条指令那样完成，成为一个原子操作。在自加操作进行的时候，其他处理器无法插手。</p><br><h4 id="原子操作是如何实现的"><a href="#原子操作是如何实现的" class="headerlink" title="原子操作是如何实现的"></a>原子操作是如何实现的</h4><p>现在问题来了，原子操作是如何实现的呢？从理论上来说，最简单的方法就是加锁：在任何时间点上，只有一个处理器被允许执行一个原子操作。这个处理器在做原子操作之前，必须先获得锁，并且在操作完成后释放它。这就是x86的LOCK前缀的作用（大致如此；这里我略去了细节）。这里，获得锁的操作意味着向总线发送一条消息，说“好吧，我要占用总线一会儿，大家都退后”（根据我们的目的，这就意味着“请不要再做内存操作了”）。然后发出请求的处理器要先等其他处理器完成它们正在进行的内存操作，之后才会得到确认。只有等到其他所有处理器都确认了以后，请求锁的处理器才能开始处理内存操作。最后，一旦锁被释放，它还需要发送一条信息给总线上的其他处理器“我的工作完成，你们可以继续向总线发送请求了”。</p><p>这种做法没有问题，但是慢得无法想象。x86处理器依然保留了这种方式（或者类似做法），但只有当绝对紧急的情况下才会使用，也就是其他所有方法都失败时的最后一招。x86指令集架构需要这么一个办法来兜底，因为他们为了向后兼容，允许一些非常不可靠的操作，比如跨多个缓存段（cache line）的非对齐的原子操作。其他体系架构不允许对非对齐的数据进行原子操作，也不允许对“太大”的数据进行原子操作。这些限制确保了单个原子操作只会发生在单个缓存段中。并且一旦有了这个前提，我们讨论起来就方便了：上次讨论缓存一致性协议的时候我们看到，处理器之间对于同步内存的交互是以缓存段为单位的，所以原则上我们可以对单个缓存段做复杂的修改，然后通过刷新缓存段内容来把修改公之于众。而且，MESI协议状态机有两个状态（M和E，代表“已修改”和“独占”）可以保证一个缓存段被处理器独占——当一个缓存段被独占时，其他处理器无法“窥探”。我们可以用这种机制来替代加锁协议。</p><p>所以结论是这样的：在一个使用MESI（或其衍生协议）的系统中，我们为了确保针对单个缓存段的操作具有原子性，只需要做到：一、保证在正确的地方摆放内存屏障（memory barrier），使内存操作和周边的代码保持正确的执行顺序（见上一篇的文章），二、在读任何东西前先获得缓存段的所有权，三、只有当我们在整个原子操作期间一直握有独占权，才可以把操作的结果回写。这可以确保没有其他处理器能看到只完成了一半的数据。要完成第三点有好几种方法，比如我们可以开发出这样的硬件，让它可以在单个总线时钟周期内完成某些原子操作；如果我们从一个时钟周期开始的时候拥有某个缓存段的独占权，那么直到这个周期结束，我们都可以修改数据。因为一个缓存段不可能在一个时钟周期内“易手”，这样的操作是很快的。根据总线协议，我们也可以玩点花样，一致性请求可以立即响应，但如果我们正在做原子操作，真正的数据可以稍晚发送。最后，我们也可以选择根本不作弊，而是直接实现二和三：把所有正在进行原子操作的缓存段“监控”起来，在原子操作完成前，如果有其他处理器请求这个缓存段，那我们的原子操作要从头再来。<br>因为这个原因，大多数RISC处理器都有<a href="http://en.wikipedia.org/wiki/Load-link/store-conditional" target="_blank" rel="noopener">load-link/store-conditional(LL/SC)</a>指令。</p><p>顺便说一下，从总线侧（以及其他处理器通过总线）看来，正确对齐的原子操作和普通的内存更新没有什么区别。所有的工作都在处理器内部完成，其他处理器既不知道也不关心某次内存更新到底是通过原子性的比较并交换（compare-and-swap）操作加上内存屏障来完成的，还是通过一次随意写指令完成的。</p><p>这一切听起来简单而美好，至少理论上是，但魔鬼往往藏于细节中。坏消息是，如果你是一个CPU架构师，这个过程的每个细节对你来说都关系重大；你对内存操作的内部实现需要避免“饥饿”（每个想获取缓存段独占权的处理器，最终都能获得它，无论其他处理器在做什么），并且确保基本的原子操作的实现不能导致死锁或活锁。这听起来是显而易见的，但是对低层次的原语（比如原子操作、LL/SC指令）来说，这种保证不是与生俱来的。这东西实现起来挺困难的，并且CPU不但要保证有正确的实现，还要保证这种实现在“典型场景”下足够快。当然，好消息是如果你工作的公司不是设计CPU的，以上这些都不关你的事。肯定已经有人通盘考虑过这些问题，并且他们背后有一支强大的验证工程师队伍拼命地在找这些实现的纰漏。</p><br><h4 id="内存操作的开销"><a href="#内存操作的开销" class="headerlink" title="内存操作的开销"></a>内存操作的开销</h4><p>回到软件上，假设我们工作在一种典型的CPU体系结构上，并且在多核系统中运行代码。在这种环境下，一次内存操作的开销到底是什么？这将分为几个部分：</p><p><strong>&lt;1&gt; 执行</strong><br>执行一次内存操作是有开销的。现在假设我们只有一个处理器核在工作，并且正在运行单线程的代码。即便如此，内存访问还是很复杂。跟程序打交道的是虚拟地址，但是缓存和内存总线看到的却是物理地址。所以任何内存操作首先做的就是把虚拟地址转换成物理地址，这些结果本身会保存在页表缓存中（Translation Lookaside Buffer，简称TLB）。如果你运气不好，你所要访问的虚拟地址当前可能并没有映射到物理地址，并且它的内容需要从虚拟内存中载入。当这个情况发生时，操作系统会调度别的线程到当前的处理器上运行一段时间，因为从处理器看来，IO操作需要花很长时间。但是我们先假设这种情况不会发生。</p><p>所以，一切都很顺利的话，内存操作到底能跑多快？看起来非常快。通常每个时钟周期至少可以完成一次操作（读/写），很有可能更多。在3GHz单核处理器上，能高效利用缓存的代码每秒钟可以完成十亿次数量级的内存操作。</p><p><strong>&lt;2&gt; 内存屏障和原子性的“读-修改-写”操作</strong><br>下一步，假设我们的代码是多线程的，但我们还是在单核上运行它。这里我们就可以看到内存屏障和原子操作了，但是没有来自其他处理器的干扰。我们简单假设所有需要的缓存段已经被我们的处理器独占了。在这种情况下，使用一次原子的整数加法来更新内存中的一个引用计数器，代价到底有多大？</p><p>好吧，这其实取决于处理器架构的实现。一般来说，对于带有激进的内存重排序（memory reordering）策略的微架构处理器来说，使用内存屏障和原子操作的开销更大，而只支持轻度重排序或者顺序执行（in-order）内存操作的处理器则好一点。比如，在 Intel Atom处理器（顺序执行）上使用LOCK INC [mem]来增加引用计数器值的开销，本质上和使用常规INC [mem]指令是一样的。而更复杂的内存操作，如“交换（exchange）”和“交换-加(exchange-add)”花费的时间是基础的“读-修改-写”操作的两到三倍。相反，在Intel和AMD支持乱序执行（out-of-order）的桌面处理器产品线中，一次原子自加操作的开销是非原子版本的十到二十五倍，这些开销是保证正确的执行顺序所带来的。再一次重申：这仅是在单核上运行的代码，还没有涉及处理器间通讯的开销。为了使代码在多核系统上安全地运行，还会在单个处理器内引入额外的开销。</p><p><strong>&lt;3&gt; 总线流量（bus traffic）和缓存一致性（cache coherency）</strong><br>部分内存访问操作实际上会无法命中缓存，从而只能从内存中加载。一旦有些缓存段因为长时间无人访问而被丢弃，我们就要开始把它的内容回写（write-back）到内存中。所有这些事件都会导致总线上（以及内存中）发生通讯流量。而总线和内存的带宽是有限的，当容量饱和时，系统就变慢了。</p><p>而且，一旦我们在多核系统中运行多线程程序，总线上就会产生额外的通讯流量来保证缓存一致性，因为各个处理器都会不断地同步它们所看到的内存内容。如果每个线程都在自己独立的内存空间里工作，那么这种流量不会很大。如果每块内存只会被一个处理器使用，那么根本无需同步，而且我们可以很容易获取这些内存对应的缓存段的独占权，不会引起其他处理器上的缓存段失效。</p><p>相反，如果两个或多个处理器频繁地访问相同的缓存段，那么这些缓存段的内容必须保持同步。如果想更新其中一个缓存段的内容，必须先获得独占权，这意味着其他所有处理器必须先丢弃它们缓存中的同一缓存段的拷贝。这带来的结果是，下一次有另外一个处理器要访问这个缓存段，它的内容必须先通过总线来加载。所以结果就是缓存失效率（对于其他处理器来说）和总线上额外的通讯流量都增加了。这种多个处理器访问一个频繁被更新的缓存段的现象，叫做“缓存（段）竞争”。如果你想在多个处理器共用内存的环境中拖慢一个并行的程序，这也许是最简单的方法。</p><br><h4 id="缓存段竞争"><a href="#缓存段竞争" class="headerlink" title="缓存段竞争"></a>缓存段竞争</h4><p>要产生缓存段竞争，我们需要多个处理器频繁访问同一缓存段，并且其中部分的访问是写操作。私有数据（只会被一个线程访问的缓存段）从来不是问题。不变的（immutable）数据（只被写一次，其后到生命期结束都不会被修改）也不是问题。麻烦的是那些既被线程共享，又可变的数据：处理这些数据需要大量的通讯工作来使各个处理器看到的内存内容保持一致（根据内存模型的限制）。这种通讯代价很大——并且随着处理器数量的增多，开销会越来越大。</p><p>那么我们谈论的开销到底有多大？几个星期前我写了一个<a href="https://github.com/rygorous/atomic_ops_test" target="_blank" rel="noopener">测试程序</a>（针对x86/Windows）。这个测试程序用起来肯定是不方便的，也不好理解，它假设运行在四核处理器多线程环境，或者至少拥有八个逻辑处理器的类似环境下。它的要点是：上面已经解释过，把一个“读-修改-写”模式的加法操作替换为原子加法操作，将产生十到二十五倍的开销（精确数值取决于具体的微架构）。如果你需要一个经验值，算十倍就可以了（对于<a href="http://en.wikipedia.org/wiki/Fermi_problem" target="_blank" rel="noopener">费米估算</a>来说已经足够了）。</p><p>一旦有第二个处理器在读同一个缓存段，开销就会暴增。如果第二个处理器在快速循环中不停地读取这个缓存段，那么原子加法的开销会更大——大得多：典型的，增加四到六倍（这可是在我们使用原子加法而产生十倍开销的基础上再次翻倍！）。同时读取这个缓存段的处理器越多，开销就越大，而如果同时还有处理器在写这个缓存段，那么效果更甚。但是请不要把这个数据当作金科玉律，这只是人写的基准测试程序而已，它并不做任何实质性工作。为保证缓存一致性而产生的真正开销跟具体的上下文有很大关系。在这里我想做的只是让你对保证缓存一致性而产生的开销有一个粗略的直观感受（即：它是无法忽略不计的）。</p><p>其中有一些通讯流量是不必要的。比如，由于缓存一致性的最小颗粒度是段，很多不必要的同步开销是可以简化的，因为不同类型的数据——不可变的、私有的和共享的——在同一缓存段中交错分布（或者类似地，因为一个缓存段中只保存了多个线程各自的私有数据）。这种现象叫做“<a href="http://en.wikipedia.org/wiki/False_sharing" target="_blank" rel="noopener">假共享</a>”。幸运的是，这种问题可以简单通过性能评估程序来定位，通过重新组织内存数据（可能通过填充的方式，确保不同类型的数据不放在同一缓存段）的方法，可以相对直接地修复它，或者直接移除一些捣乱的数据。我的旧文“<a href="https://fgiesen.wordpress.com/2013/01/31/cores-dont-like-to-share/" target="_blank" rel="noopener">处理器不喜欢共享</a>”中给出了一个例子。</p><p>经此过滤下来的就是真正的竞争了——竞争访问共享数据。这包括了真正共享的可变数据结构，以及某些元数据（metadata），比如锁和其他同步对象。准确地说，这种竞争运行得有多流畅，取决于数据在内存中的具体布局，以及使用什么操作来访问它。</p><p>一般来说，要写出在多核处理器上具有良好可伸缩性（scalable）的代码，方法就是尽可能避免竞争，如果不能避免，则使所有竞争都尽可能快速通过。完善地考虑竞争问题，理解缓存一致性的工作原理（至少要大致上），理解处理器为了保证缓存一致性而需要交换什么信息，理解这种通讯何时会发生，这是非常重要的。我们讲完了这些基础知识，现在可以看看更上层的软件了。这篇文章已经够长了，在下篇文章中，我打算讲讲锁和无锁数据结构（lock-free data structures），并讨论其中一些取舍问题。下次见，写代码要小心哦。</p><p>英文原文：[Atomic operations and contention][]</p><p><strong>文章来源</strong><br><a href="http://www.infoq.com/cn/articles/atomic-operations-and-contention" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/atomic-operations-and-contention</a></p>]]></content>
      
      
      <categories>
          
          <category> Operating System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>The Differences between DML, DCL and DDL in Database System?</title>
      <link href="/Database/database-ddl-dml-dcl/"/>
      <url>/Database/database-ddl-dml-dcl/</url>
      
        <content type="html"><![CDATA[<p><strong>DDL</strong></p><p>Data Definition Language (DDL) statements are used to define the database structure or schema. Some examples: </p><p>CREATE - to create objects in the database<br>ALTER - alters the structure of the database<br>DROP - delete objects from the database<br>TRUNCATE - remove all records from a table, including all spaces allocated for the records are removed<br>COMMENT - add comments to the data dictionary<br>RENAME - rename an object </p><p><strong>DML</strong></p><p>Data Manipulation Language (DML) statements are used for managing data within schema objects. Some examples: </p><p>SELECT - retrieve data from the a database<br>INSERT - insert data into a table<br>UPDATE - updates existing data within a table<br>DELETE - deletes all records from a table, the space for the records remain<br>MERGE - UPSERT operation (insert or update)<br>CALL - call a PL/SQL or Java subprogram<br>EXPLAIN PLAN - explain access path to data<br>LOCK TABLE - control concurrency </p><p><strong>DCL</strong></p><p>Data Control Language (DCL) statements. Some examples: </p><p>GRANT - gives user’s access privileges to database<br>REVOKE - withdraw access privileges given with the GRANT command </p><p><strong>TCL</strong></p><p>Transaction Control (TCL) statements are used to manage the changes made by DML statements. It allows statements to be grouped together into logical transactions. </p><p>COMMIT - save work done<br>SAVEPOINT - identify a point in a transaction to which you can later roll back<br>ROLLBACK - restore database to original since the last COMMIT<br>SET TRANSACTION - Change transaction options like isolation level and what rollback segment to use </p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>curl</title>
      <link href="/Linux/linux-curl/"/>
      <url>/Linux/linux-curl/</url>
      
        <content type="html"><![CDATA[<p><strong>curl</strong> - Transfers data from or to a server, using one of the protocols: HTTP, HTTPS, FTP, FTPS, SCP, SFTP, TFTP, DICT, TELNET, LDAP or FILE. (To transfer multiple files use wget or FTP.)</p><p>Although curl is widely used, a user friendly curl utility tool called <strong><a href="https://github.com/jkbrzt/httpie" target="_blank" rel="noopener">httpie</a></strong> is open sourced and is recommanded to use.</p><h3 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h3><p>curl [options] [URL…]</p><h3 id="Comon-Options"><a href="#Comon-Options" class="headerlink" title="Comon Options"></a>Comon Options</h3><p><span class="blue">-X, –request</span> Specifies a custom request method to use when communicating with the HTTP server. The specified request method will be used instead of the method otherwise used (which defaults to GET).</p><p><span class="blue">-i, –include</span> Includes HTTP response Header information in the output</p><p>–compressed    Request a compressed response using one of the algorithms curl supports (gzip), and save the uncompressed document. If this option is used and the server sends an unsupported encoding, curl will report an error.(HTTP)</p><p class="blue">-d @file-d "string"--data "string" </p><p>Send the specified data in an (HTTP) POST request, in the same way that a web browser does. <span class="blackOnRice">This will pass the data using the content-type application/x-www-form-urlencoded. Compare to -F, –form.</span> Note that –data implies POST so –request flag can be omitted.</p><p>-d, –data is the same as –data-ascii. To post data in pure binary, use <strong>–data-binary</strong>. To URL-encode the value of a form field you may use <strong>–data-urlencode</strong>. Multiple date options will be merged together. Thus, using ‘-d name=daniel -d skill=lousy’ would generate a post that looks like ‘name=daniel&amp;skill=lousy’. If the data starts with @, the rest should be a file name to read the data from, or - if you want curl to read the data from stdin. Multiple files can also be specified. Posting data  from  a  file  named ‘foobar’ would thus be done with –data @foobar. When –data is told to read from a file like that, carriage returns and newlines will be stripped out. If you don’t want the @ character to have a special interpretation use <strong>–data-raw</strong> instead.</p><p class="blue">-F name=@file-F name=content--form name=content </p><p>Emulate a filled-in form in which a user has pressed the submit button. This will POST data using the Content-Type multipart/form-data according to <a href="https://www.ietf.org/rfc/rfc2388.txt" target="_blank" rel="noopener">RFC 2388</a>. This enables uploading of binary files etc. If the data starts with @, the rest should be a filename. To just get the content part from a file, prefix the file name with the symbol &lt;. The difference between @ and &lt; is that @ makes a file get attached in the post as a file upload, while the &lt; makes a text field and gets the contents for that text field from a file.</p><p><span class="blue">-o file, –output file</span> Write output to file instead of stdout.</p><p><span class="blue">-O, –remote-name</span></p><p>Write output to a local file named like the remote file we get. (Only the file part of the remote file is used, the path is cut off.) The remote file name to use for saving is extracted from the given URL, nothing else. Consequentially, the file will be saved in the current working directory.</p><p><span class="blue">-s, –silent</span> Silent or quiet mode. Don’t show progress meter or error messages.</p><p><span class="blue">-I, –head</span> Fetch the HTTP-header only! (HTTP/FTP/FILE) HTTP-servers feature the command HEAD which this uses to get nothing but the header of a document. When used on an FTP or FILE file, curl displays the file size and last modification time only.</p><span class="blue">-u user:password--user user:password</span><p>The username and password to use for server authentication. Overrides -n, –netrc and –netrc-optional. If you just give the user name (without entering a colon) curl will prompt for a password. If you use an SSPI-enabled curl binary and do NTLM authentication, you can force curl to pick up the username and password from your environment by specifying a single colon with this option: “-u :”. If this option is used several times, the last one will be used.</p><span class="blue">-x host:port-x [protocol://][user:password@]proxyhost[:port]--proxy [protocol://][user:password@]proxyhost[:port]   </span><p>Use the specified HTTP proxy. If the port number is not specified, it is assumed at port 1080.</p><span class="blue">-H "name: value"--header "name: value"  </span><p>Add Header when getting a web page. You may specify any number of extra headers.</p><p>-H “name:”<br>–header “name:”    </p><p>Remove Header, remove an internal header.</p><p><span class="blue">-L, –location</span>  Follow redirects if the server reports that the requested page has moved (indicated with a Location: header and a 3XX response code)</p><p><span class="blue">-v, –verbose</span>   Make more verbose/talkative. Mostly useful for debugging.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>(1) If request method is not specified, curl will send GET request. e.g.</p><pre><code>$ curl https://api.github.com/users/caspyin</code></pre><p>(2) Includes response HTTP-Header information in the output</p><pre><code>$ curl --include https://api.github.com/users/caspyin</code></pre><p>(3) Pass HTTP Authentication in cURL</p><pre><code>$ curl -u username:password URL$ curl --user &quot;caspyin:PASSWD&quot; https://api.github.com/gists/starred$ curl --user &quot;caspyin:PASSWD&quot; https://api.github.com/users/caspyin</code></pre><p>Note: By default curl uses Basic HTTP Authentication. We can specify other authentication method using –ntlm | –digest.</p><p>(4) Retrieve a web page and save to a file.</p><pre><code>$ curl http://www.gnu.org/download/gccxxx.tar.xz &gt; gcc.xz</code></pre><p>or</p><pre><code>$ curl http://www.gnu.org/download/gccxxx.tar.xz -o gcc.xz</code></pre><p>or</p><pre><code>$ curl http://www.gnu.org/download/gccxxx.tar.xz -O</code></pre><p>(5) To retrieve a web page, or its redirected target</p><pre><code>$ curl www.tutorialspoint.com/unix/ $ curl www.tutorialspoint.com/unix/ -L</code></pre><p>(6) Use Proxy to Download a File</p><pre><code>$ curl -x proxysever.test.com:3128 http://google.co.in</code></pre><p>(7) Continue/Resume a Previous Download</p><p>Start a big download using curl, and press Ctrl-C to stop it in between the download.</p><pre><code>$ curl -O http://www.gnu.org/software/gettext/manual/gettext.html##############             20.1%</code></pre><p>Now the above download was stopped at 20.1%. Using “curl -C -“, we can continue the download from where it left off earlier. Now the download continues from 20.1%.</p><pre><code>$ curl -C - -O http://www.gnu.org/software/gettext/manual/gettext.html###############            21.1%</code></pre><p>(8) List/Download using Ranges</p><p>cURL supports ranges to be given in the URL. When a range is given, files matching within the range will be downloaded. It will be helpful to download packages from the FTP mirror sites.</p><pre><code>$ curl   ftp://ftp.uk.debian.org/debian/pool/main/[a-z]/</code></pre><p>(9) POST</p><pre><code>$ curl --user &quot;caspyin&quot; -X POST --data &apos;{&quot;description&quot;:&quot;Created via API&quot;,&quot;public&quot;:&quot;true&quot;,&quot;files&quot;:{&quot;file1.txt&quot;:{&quot;content&quot;:&quot;Demo&quot;}}&apos; https://api.github.com/gists</code></pre><p>since –data implies POST there is no need to specify the –request flag</p><pre><code>$ curl --user &quot;caspyin&quot; --data &apos;{&quot;description&quot;:&quot;Created via API&quot;,&quot;public&quot;:&quot;true&quot;,&quot;files&quot;:{&quot;file1.txt&quot;:{&quot;content&quot;:&quot;Demo&quot;}}&apos; https://api.github.com/gists</code></pre><p>Tell curl to read from a file (@) to POST data</p><pre><code>$ curl --user &quot;caspyin&quot; --data @data.txt https://api.github.com/gists </code></pre><p>Or read from STDIN (@-)</p><pre><code>$ echo &apos;{&quot;text&quot;: &quot;Hello world!&quot;}&apos; | curl -d @- https://api.github.com/markdown</code></pre><h5 id="Url-encoded"><a href="#Url-encoded" class="headerlink" title="Url-encoded"></a>Url-encoded</h5><pre><code>$ curl --data &quot;brand=nike&amp;color=red&amp;size=11&quot; $URL</code></pre><h5 id="Multipart"><a href="#Multipart" class="headerlink" title="Multipart"></a>Multipart</h5><pre><code>$ curl -F &quot;image=@nikes.png&quot; -F &quot;brand=nike&quot; -F &quot;color=red&quot; -F &quot;size=11&quot; $URL</code></pre><p>Change the name field of a file upload part (nikes.png) by setting filename=NEW_NAME”</p><pre><code>$ curl -F &quot;image=@nikes.png;filename=shoes.png&quot; -F &quot;brand=nike&quot; -F &quot;color=red&quot; -F &quot;size=11&quot; $URL</code></pre><p>Specify Content-Type by using type=:</p><pre><code>$ curl -F &quot;image=@nikes.png;type=image/png&quot; -F &quot;brand=nike&quot; -F &quot;color=red&quot; -F &quot;size=11&quot; $URL</code></pre><p>More examples:</p><p>With fields:</p><pre><code>$ curl --data &quot;param1=value1&amp;param2=value2&quot; https://example.com/resource.cgi</code></pre><p>Multipart:</p><pre><code>$ curl --form &quot;fileupload=@my-file.txt&quot; https://example.com/resource.cgi</code></pre><p>Multipart with fields and a filename:</p><pre><code>$ curl --form &quot;fileupload=@my-file.txt;filename=desired-filename.txt&quot; --form param1=value1 --form param2=value2 https://example.com/resource.cgi</code></pre><p>Specifying the Content-Type while POST a file:</p><p>For XML</p><pre><code>$ curl -X POST -d @filename.txt http://example.com/path/to/resource --header &quot;Content-Type:text/xml&quot;</code></pre><p>For JSON</p><pre><code>$ curl -X POST -d @filename.txt http://example.com/path/to/resource --header &quot;Content-Type:application/json&quot;</code></pre><p>(10) Headers</p><p>Often when POSTing data you’ll need to add headers for things like auth tokens or setting the content type. You can set a header using -H.</p><pre><code>$ curl -H &quot;Content-Type: application/json&quot; -H &quot;authToken: 349ab29a-xtab-423b-a5hc-5623bc39b8c8&quot; --data &apos;{}&apos; https://api.example.com/endpoint</code></pre><p><strong>Reference</strong><br><a href="https://www.tutorialspoint.com/unix_commands/curl.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/unix_commands/curl.htm</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nc</title>
      <link href="/Linux/linux-nc/"/>
      <url>/Linux/linux-nc/</url>
      
        <content type="html"><![CDATA[<p><strong>nc</strong> is the command which runs netcat, a simple Unix utility that reads and writes data across network connections, using the TCP or UDP protocol.<br>It is designed to be a reliable “back-end” tool that can be used directly or driven by other programs and scripts.<br>At the same time, it is a feature-rich network debugging and exploration tool, since it can create almost any kind of connection<br>you would need and has several interesting built-in capabilities. Common uses include:</p><ul><li>Simple TCP proxies</li><li>Shell-script based HTTP clients and servers</li><li>Network daemon testing</li><li>A Socks or HTTP ProxyCommand for ssh</li></ul><h3 id="Common-Options"><a href="#Common-Options" class="headerlink" title="Common Options"></a>Common Options</h3><p><strong>-l</strong> Used to specify that <strong>nc</strong> should listen for an incoming connection rather than initiate a connection to a remote host.</p><p><strong>-p</strong> source_port  Specifies the source port nc should use, subject to privilege restrictions and availability.</p><p><strong>-s</strong> source   Specifies the IP of the interface which is used to send the packets. For UNIX-domain datagram sockets, specifies the local temporary socket file to create and use so that datagrams can be received. It is an error to use this option in conjunction with the -l option.</p><p><strong>-U</strong>  Specifies to use UNIX-domain sockets.<br><strong>-u</strong>  Use UDP instead of the default option of TCP. For UNIX-domain sockets, use a datagram socket instead of a stream socket. If a UNIX-domain socket is used, a temporary receiving socket is created in /tmp unless the -s flag is given.</p><p><strong>-X</strong> proxy_protocol   Requests that nc should use the specified protocol when talking to the proxy server. Supported protocols are “4” (SOCKS v.4), “5” (SOCKS v.5) and “connect” (HTTPS proxy). If the protocol is not specified, SOCKS version 5 is used.</p><p><strong>-x</strong> proxy_address[:port] Requests that nc should connect to destination using a proxy at proxy_address and port. If port is not specified, the well-known port for the proxy protocol is used (1080 for SOCKS, 3128 for HTTPS).</p><p><strong>-z</strong>  Specifies that nc should just scan for listening daemons, without sending any data to them. It is an error to use this option in conjunction with the -l option.</p><p><strong>-v</strong>  Have nc give more verbose output.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p><strong>(1) Client/Server Model</strong></p><p>It is quite simple to build a very basic client/server model using nc. On one console, start <strong>nc</strong> listening on a specific port for a connection. </p><p>For example:</p><pre><code>$ nc -l 8000</code></pre><p>nc is now listening on port 1234 for a connection. Open another console (or a second machine), connect to the machine and port being listened on:</p><pre><code>$ nc localhost 8000</code></pre><p>Now, a connection should have been set up between the ports. Anything typed at the second console will be sent to the first, and vice-versa.</p><p><strong>Execute command from client side</strong></p><p>Server side open a port and allow client connected execute arbitrary command on it could be dangerous! If we really want to do this, we can do this:</p><p><strong>On ‘server’ side:</strong></p><pre><code>$ mkfifo /tmp/f$ cat /tmp/f | /bin/sh -i 2&gt;&amp;1 | nc -l 127.0.0.1 1234 &gt; /tmp/f</code></pre><p><strong>On ‘client’ side:</strong></p><pre><code>$ nc localhost 1234</code></pre><p>By doing this, you create a fifo at <strong>/tmp/f</strong> and make nc listen at port <strong>1234</strong> of address <strong>127.0.0.1</strong> on ‘server’ side, when a ‘client’ establishes a connection successfully to that port, <strong>/bin/sh</strong> gets executed on ‘server’ side and the shell prompt is given to ‘client’ side.</p><p>When connection is terminated, <strong>nc</strong> quits as well. Use <strong>-k</strong> if you want it keep listening, but if the command quits this option won’t restart it or keep nc running. Also don’t forget to remove the file descriptor once you don’t need it anymore:</p><pre><code>$ rm -f /tmp/f</code></pre><p><strong>(2) Data Transfer</strong></p><p>The example in the previous section can be expanded to build a basic data transfer model. Any information input into one end of the connection will be output to the other end, and input and output can be easily captured in order to emulate file transfer.</p><p>Start by using <strong>nc</strong> to listen on a specific port, with output captured into a file:</p><pre><code>$ nc -l 1234 &gt; filename.out</code></pre><p>Using a second machine, connect to the listening nc process, feeding it the file which is to be transferred:</p><pre><code>$ nc host.example.com 1234 &lt; filename.in</code></pre><p><strong>(3) Port Scanning</strong></p><p>It may be useful to know which ports are open and running services on a target machine. The <strong>-z</strong> flag can be used to tell nc to report open ports, rather than initiate a connection. Usually it’s useful to turn on verbose output to stderr by use this option in conjunction with <strong>-v</strong> option.</p><p>For example:</p><pre><code>$ nc -zv host.example.com 20-30Connection to host.example.com 22 port [tcp/ssh] succeeded!Connection to host.example.com 25 port [tcp/smtp] succeeded!</code></pre><p>The port range was specified to limit the search to ports 20 - 30, and is scanned by increasing order.<br>You can also specify a list of ports to scan, for example:</p><pre><code>$ nc -zv host.example.com 80 20 22</code></pre><p>The ports are scanned by the order you given.<br>Alternatively, it might be useful to know which server software is running, and which versions. This information is often contained within the greeting banners. To retrieve these, it is necessary to first make a connection, and then break the connection when the banner has been retrieved. This can be accomplished by specifying a small timeout with the -w flag, or perhaps by issuing a “QUIT” command to the server:</p><pre><code>$ echo &quot;QUIT&quot; | nc host.example.com 20-30SSH-1.99-OpenSSH_3.6.1p2 Protocol mismatch. 220 host.example.com IMS SMTP Receiver Version 0.84 Ready</code></pre><h4 id="More-examples"><a href="#More-examples" class="headerlink" title="More examples"></a>More examples</h4><pre><code>$ nc -p 31337 -w 5 host.example.com 42</code></pre><p>Opens a TCP connection to port 42 of host.example.com, using port 31337 as the source port, with a timeout of 5 seconds.</p><pre><code>$ nc -u host.example.com 53</code></pre><p>Opens a UDP connection to port 53 of host.example.com.</p><pre><code>$ nc -s 10.1.2.3 host.example.com 42</code></pre><p>Opens a TCP connection to port 42 of host.example.com using 10.1.2.3 as the IP for the local end of the connection.</p><pre><code>$ nc -lU /var/tmp/dsocket</code></pre><p>Creates and listens on a UNIX-domain stream socket.</p><pre><code>$ nc -x10.2.3.4:8080 -Xconnect host.example.com 42</code></pre><p>Connects to port 42 of host.example.com via an HTTP proxy at 10.2.3.4, port 8080. This example could also be used by ssh.</p><pre><code>$ nc -x10.2.3.4:8080 -Xconnect -Pruser host.example.com 42</code></pre><p>The same as the above example, but this time enabling proxy authentication with username “ruser” if the proxy requires it.</p><p><strong>Reference</strong><br><a href="http://www.computerhope.com/unix/nc.htm" target="_blank" rel="noopener">http://www.computerhope.com/unix/nc.htm</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sed and regular expression</title>
      <link href="/Linux/linux-sed/"/>
      <url>/Linux/linux-sed/</url>
      
        <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>SED is a stream editing command in Linux, it is very powerful in text processing under Linux environment. </p><p>SED can be used in many different ways, such as:</p><ul><li>Text substitution,</li><li>Selective printing of text files,</li><li>In-a-place editing of text files,</li><li>Non-interactive editing of text files, and many more.</li></ul><p>SED follows a simple workflow: Read -&gt; Execute -&gt; Display </p><ul><li><p>Read: SED reads a line from the input stream (file, pipe, or stdin) and stores it in its internal buffer called pattern buffer.</p></li><li><p>Execute: All SED commands are applied sequentially on the pattern buffer. By default, SED commands are applied on all lines (globally) unless line addressing is specified.</p></li><li><p>Display: Send the (modified) contents to the output stream. After sending the data, the pattern buffer will be empty.</p></li></ul><h3 id="Points-to-Note"><a href="#Points-to-Note" class="headerlink" title="Points to Note"></a>Points to Note</h3><ul><li><p>Pattern buffer is a private, in-memory, volatile storage area used by the SED.</p></li><li><p>By default, all SED commands are applied on the pattern buffer, hence the input file remains unchanged. GNU SED provides a way to modify the input file in-a-place. We will explore about it in later sections.</p></li><li><p>There is another memory area called hold buffer which is also private, in- memory, volatile storage area. Data can be stored in a hold buffer for later retrieval. At the end of each cycle, SED removes the contents of the pattern buffer but the contents of the hold buffer remains persistent between SED cycles. However SED commands cannot be directly executed on hold buffer, hence SED allows data movement between the hold buffer and the pattern buffer.</p></li><li><p>Initially both pattern and hold buffers are empty.</p></li><li><p>If no input files are provided, then SED accepts input from the standard input stream (stdin).</p></li><li><p>If address range is not provided by default, then SED operates on each line.</p></li></ul><h3 id="Common-Options"><a href="#Common-Options" class="headerlink" title="Common Options"></a>Common Options</h3><p>Below list are options are GNU specific; and may not be supported by other variants of the SED. </p><ul><li><p><strong>-n</strong>, –silent: Suppress the default printing of the patter buffer.</p></li><li><p><strong>-e</strong> script, script is an editing command. By using this option, we can specify multiple commands.</p></li><li><p><strong>-f</strong> script_file, script_file is a file containing editing commands. </p></li><li><p>–follow-symlinks: If this option is provided, the SED follows symbolic linki while editing files in place.</p></li><li><p><strong>-i</strong>[SUFFIX], –in-place[=SUFFIX]: This option is used to edit file in place. If suffix is provided, it takes a backup of the original file, otherwise it overwrites the original file. Never use this option if you are not sure<br>what sed will do since once the original file was overwriten there is no way to revert it back. Instead, use redirect operator <code>&gt;</code> or combined use with <code>-i.bak</code>.</p></li><li><p><strong>-l N</strong>, –line-lenght=N: This option sets the line length for l command to N characters.</p></li><li><p>–posix: This option disables all GNU extensions.</p></li><li><p><strong>-r</strong>, –regexp-extended: This option allows to use extended regular expressions rather than basic regular expressions.</p></li><li><p><strong>-s</strong>, –separate: deal with multiple files</p></li><li><p><strong>-u</strong>, –unbuffered: When this option is provided, the SED loads minimal amount of data from the input files and flushes the output buffers more often. It is useful for editing the output of “tail -f” when you do not want to wait for the output.</p></li><li><p><strong>-z</strong>, –null-data: By default, the SED separates each line by a new-line character. If NULL-data option is provided, it separates the lines by NULL characters.</p></li></ul><h3 id="Pattern-Flags"><a href="#Pattern-Flags" class="headerlink" title="Pattern Flags"></a>Pattern Flags</h3><ul><li><strong>g</strong> Global</li><li><strong>I</strong> Ignore case</li></ul><h3 id="Addressing"><a href="#Addressing" class="headerlink" title="Addressing"></a><strong>Addressing</strong></h3><p>Addressing is used to restrict SED to operate only on certain lines.<br>There multiply ways to specify an address:</p><ul><li><p><strong>Exact</strong></p><p> Specifying an exact address number <strong>n</strong></p><p> <code>$ sed -n &#39;3s/pattern/abc/p&#39; file</code>  </p><p> <code>$ sed -n &#39;$ p&#39; file</code></p></li><li><p><strong>Range</strong></p><p> <strong>M, N</strong>, Specify a range starting from line <strong>M</strong> end with <strong>N</strong></p><p> <code>$ sed -n &#39;3,$ p&#39; file</code></p><p> <strong>M, /pattern/</strong>, or <strong>/pattern/, N</strong>, Specify a range using <strong>pattern range</strong></p><p> <code>$ sed -n &#39;^, /pattern/p&#39; file</code></p><p> <code>$ sed -n &#39;/pattern/,6p&#39; file</code></p><p> <code>$ sed -n &#39;/patter/, +4 p&#39; file</code></p></li></ul><ul><li><p><strong>Base + Offset</strong></p><p> <strong>M, +n</strong>, Specify a range starting from line <strong>M</strong> and end in next <strong>+N</strong> lines</p><p> <code>$ sed -n &#39;2,+4 p&#39; file</code></p></li><li><p><strong>Base + Step</strong></p><p> <strong>M~N</strong>, Specify a range starting at line number <strong>M</strong> and process every <strong>N</strong>th line</p><p> <code>$ sed -n &#39;1~2 p&#39;</code> This will print only <strong>odd</strong> lines from the file</p><p> <code>$ sed -n &#39;2~2 p&#39;</code> This will print only <strong>even</strong> lines from the file</p></li></ul><h3 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a><strong>Commands</strong></h3><ul><li><strong>p</strong>    Print</li><li><strong>=</strong>    Print line number </li></ul><p>e.g. <code>$ sed = filename</code> will print line number follow with line content (seperated by ‘\n’)</p><p>Count the total number of lines of a file</p><pre><code>$ sed -n &apos;$ =&apos; file</code></pre><ul><li><p><strong>d</strong>    Delete</p></li><li><p><strong>w</strong>    Write</p><p> If we want to <strong>backup</strong> (copy) or <strong>extract certain lines</strong> from a file, we can use this command.</p><p> <code>$ sed -n &#39;w redis.conf.bak&#39; redis.conf</code> This has exact the same effect with using <code>$ cp redis.conf redis.conf.bak</code></p><p> <code>$ sed -n &#39;2~2 w emphasis.txt&#39; book.txt</code> This will extract only even lines from book.txt</p></li><li><p><strong>a</strong> Append</p><p> <code>$ sed &#39;2 a =====&#39; book.txt</code></p></li><li><p><strong>i</strong> Insert</p><p> <code>$ sed &#39;2 i =====&#39; book.txt</code></p></li><li><p><strong>c</strong> Change</p><p> <code>$ sed &#39;2 c =====&#39; book.txt</code></p></li><li><p><strong>y</strong> Translate</p><p> Transforms the characters by position</p><p> The Syntax of the translate command <strong>y</strong></p><p> <code>[address1[,address2]]y/list-1/list-2/</code></p><p> Note that translation is based on the position of the character from list 1 to the character in the same position in list 2 and both lists must be explicit character lists. Regular expressions and character classes are unsupported. Additionally, the size of list 1 and list 2 must be same.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;1 5 15 20&quot; | sed &apos;y/151520/IVXVXX/&apos;</span><br><span class="line">I V IV XX</span><br></pre></td></tr></table></figure><ul><li><p><strong>l</strong> List</p><p> <strong>l</strong> command is used to display hidden characters in text.</p><p> Suppose we have a file containing a lot of <code>\t</code></p><p> <code>$ sed &#39;s/ /\t/g&#39; books.txt &gt; junk.txt</code></p><p> We can display the hidden characters by using <strong>l</strong> command like this:</p><p> <code>$ sed -n &#39;l&#39; junk.txt</code></p><p> <strong>l</strong> command has a very useful feature that it can be used to perform line wrap after a certain number of characters.</p><p> The following example wraps lines after 25 characters:</p><p> <code>$ sed -n &#39;l 25&#39; books.txt</code></p></li></ul><pre><code>A wrap limit of 0 means never break the line unless there is a new line character. `$ sed -n &apos;l 0&apos; books.txt`</code></pre><ul><li><p><strong>q</strong> Quit</p><p> By default, SED follows read, execute, and repeat workflow; but when the quit command is encountered, it simply stops the current execution.</p><p> <strong>q</strong> command does not accept range of addresses, it only supports a single address</p><p> <strong>q</strong> command can accept a value which can be used as the exit status</p><p> <code>$ sed &#39;3 q&#39; books.txt</code>  This will the first 3 lines from the file</p><p> <code>$ sed &#39;/pattern/ q 100&#39; books.txt</code> This command will exit with status code 100</p></li></ul><ul><li><p><strong>r</strong> Read</p><p> Read from a file</p><p> <code>$ sed &#39;3 r junk.txt&#39; books.txt</code></p></li><li><p><strong>e</strong> Execute</p><p> We can execute <strong>external commands</strong> from SED using the <strong>e</strong> command.</p><p> <strong>Syntax:</strong></p><p> [address1[,address2]]e [command]</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sed &apos;3 e date&apos; books.txt</span><br><span class="line">abc</span><br><span class="line">Fri Nov 25 21:00:00 CST 2016</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>If we have a file containing several shell commands like this:</p><pre><code>date cal uname</code></pre><p>We can use sed with <strong><code>e</code></strong> command to execute them like this:</p><pre><code>$ sed &apos;e&apos; commands.txt</code></pre><h3 id="Miscellaneous-Commands"><a href="#Miscellaneous-Commands" class="headerlink" title="Miscellaneous Commands"></a>Miscellaneous Commands</h3><ul><li><p><strong>n</strong></p><p>Clear the current <code>pattern space</code> and read the next line in.</p></li></ul><p><strong>Execution order:</strong></p><pre><code>Sed command1 Sed command2 Sed command3n command Sed command4Sed command4</code></pre><p>In this case, SED applies the first three commands on the pattern buffer, clears the pattern buffer, fetches the next line into the pattern buffer,<br>and thereafter applies the fourth and fifth commands on it. This is a very important concept. </p><ul><li><p><strong>N</strong></p><p>Keep current <code>pattern space</code> and append the next line in.</p></li><li><p><em>Explanation*</em></p><p>By default, SED operates on <strong>single line</strong>, however it can operate on <strong>multiple lines</strong> as well. Multi-line commands are denoted by uppercase letters.<br>For example, unlike the <strong>n</strong> command, the <strong>N</strong> command does not clear and print the pattern space.<br>Instead, it adds a newline <strong>\n</strong> at the end of the current pattern space and appends the next line from<br>the input-file to the current pattern space and continues with the SED’s standard flow by executing the rest of the SED commands. </p></li></ul><p>Suppose we have <code>sample.txt</code> whose content is:</p><pre><code>apple17.7egg29.0skipboard99</code></pre><p>We can convert it to the form of this:</p><pre><code>apple, 17.7egg, 29.0skipboard, 99</code></pre><p>By executing:</p><pre><code>$ sed &apos;N;s/\n/, /g&apos; sample.txt</code></pre><p><strong>Explanation</strong></p><p>Let’s see how it works.</p><p>Initially, the command <strong>N</strong> reads the first line, apple into the <code>pattern buffer</code> and appends <code>\n</code> followed by <strong>the next line</strong>. Therefore the pattern space now contains <code>apple\n17.7</code>. In the next step, we use <code>s/\n/, /</code> to replace the <code>\n</code> with a comma <code>,</code>.</p><ul><li><strong>P</strong></li></ul><p>Print all lines in a <strong>multi-line patter space</strong> until it reaches a newline character <code>\n</code> created by <strong>N</strong> command.</p><p>Let’s see how we can print only the odd lines of <code>sample.txt</code></p><pre><code>$ sed -n &apos;N;P&apos; books.txtappleeggskipboard</code></pre><ul><li><p><strong>x</strong></p><p>  <strong>Exchange</strong> the content of <strong>pattern buffer</strong> and <strong>hold buffer</strong></p></li></ul><p>Let’s see how we use <strong>x</strong> to print only the <code>even</code> line of the file</p><pre><code>$ sed -n &apos;x;n;p&apos; sample.txt17.729.099</code></pre><p>Let us understand how this command works.</p><p>Initially, SED reads the first line, i.e., <code>apple</code> into the <code>pattern buffer</code>.</p><ul><li><strong>x</strong> command moves this line to the hold buffer.</li><li><strong>n</strong> fetches the next line <code>17.7</code> into the pattern buffer.</li><li>The control passes to the command followed by n which prints the contents of the pattern buffer.</li><li>The process repeats until the file is exhausted.</li></ul><ul><li><p><strong>h</strong></p><p>  <strong>h</strong> deals with <strong>hold buffer</strong>, it <strong>copies</strong> data from the pattern buffer to <strong>overwrite</strong> everything in the hold buffer.  </p></li><li><p><strong>H</strong></p><p>  <strong>H</strong> Append a newline <code>\n</code> to the contents of the hold space, and then <strong>append</strong> the contents of the pattern space to that of the hold space</p></li></ul><h3 id="Sed-applications"><a href="#Sed-applications" class="headerlink" title="Sed applications"></a>Sed applications</h3><p><strong>1. Print</strong></p><p>(1) Print whole file, act as <code>cat</code> command</p><pre><code>$ sed &apos;&apos; a.txt</code></pre><p>(2) Print file with line number</p><pre><code>$ sed = me.txt | sed &apos;N;s/\n/ /&apos;</code></pre><p>(3) Print a specific line or a range of line</p><pre><code>$ sed &apos;4!d&apos; me.txt$ sed &apos;2,4!d&apos; me.txt</code></pre><p>(4) Print the matching line with line number</p><pre><code>$ sed -n &apos;/foo/=&apos;</code></pre><p>(5) Print only the matching line</p><pre><code>$ sed -n &apos;/pattern/p&apos; me.txt$ sed -n &apos;/pattern/{!d;p}&apos; me.txt$ sed -n &apos;s/pattern/p&apos; me.txt</code></pre><p>(6) Match ignore case</p><pre><code>$ sed &apos;/pattern/I p&apos; me.txt</code></pre><p>(6) Print the matching line preceeded with its line number</p><pre><code>$ sed &apos;/pattern/!d;=&apos; me.txt |sed &apos;N;s/\n/:/&apos;</code></pre><p>(7) Print only the matched string</p><p>Group symbol <code>()</code> of regular expression is very useful to assist operations on a matched string.</p><p>By default, sed will print the whole line, if we want to print only the matched string, we can use <strong>group</strong> symbol <code>()</code>.</p><pre><code>$ sed -nE &apos;s/.* ([0-9.]+)$/\1/p&apos; &lt;&lt;&lt; &quot;the price of egg is 12.7&quot;$ sed -E &apos;1!d;s/.* ([0-9]+)$/\1/g&apos; &lt;&lt;&lt; &quot;apple good 18901&quot;$ sed -E &apos;s/^.* \([^ ][^ ]*\)/\1/g&apos; &lt;&lt;&lt; &apos;Apple is a very nutrient-rich friut&apos;$ sed -E &apos;s/.* ([0-9]+)$/\1/;tx;d;:x&apos;　&lt;&lt;&lt; &quot;apple good 18901&quot;</code></pre><p>Also, if we want to modify the matched string, <code>()</code> is very helpful.</p><p>e.g. we have a file ‘me.txt’ like this:</p><pre><code>1.A_ A_ 1.A_                        1.A A_ 1.A_2.B_ B_ 2.B_    Modified to --&gt;     2.B B_ 2.B_     3.C_ C_ 3.C_                        3.C C_ 3.C_</code></pre><p>we can do this:</p><pre><code>$ sed sed -nE &apos;s/^([0-9]\S+)_( .*)/\1\2/;p&apos; me.txt</code></pre><p>(8) Print the <strong>last field</strong></p><pre><code>$ sed -E &apos;s/^.* \([^ ][^ ]*\)/\1/g&apos; &lt;&lt;&lt; &apos;Apple is a very nutrient-rich friut&apos;$ sed -E &apos;s/.* ([^ ]+)$/\1/g&apos; &lt;&lt;&lt; &apos;Apple is a very nutrient-rich friut&apos;$ sed -E &apos;s/^.* (\S*)/\1/&apos; &lt;&lt;&lt; &quot;this is a good day&quot;</code></pre><p><strong>2. Remove</strong></p><p>(1) Remove empty lines</p><pre><code>$ sed &apos;/^$/d&apos;</code></pre><p>(2) Remove leading whitespace of each line</p><pre><code>$ sed -E &apos;s/^\s+//g&apos; &lt;&lt;&lt; &quot;     Nice tutorial!&quot;</code></pre><p>or</p><pre><code>$ sed -n &apos;s/^ *//g&apos; &lt;&lt; &quot;    hahaha&quot;</code></pre><p>(3) Remove trailing whitespace of each line</p><pre><code>$ sed -E &apos;s/\s*$//g&apos; &lt;&lt;&lt; &quot;Nice tutorial!    &quot;</code></pre><p>(4) Remove the next blank line of matching line</p><pre><code>$ sed &apos;/pattern/n;/^$/d&apos; me.txt</code></pre><p>(5) Remove the preceeding <code>/</code> of a path</p><pre><code>$ sed &apos;s/^\///g&apos;</code></pre><p>(6) Remove all the <code>&lt;&gt;</code> tags of a html file</p><pre><code>$ sed &apos;s/&lt;[^&gt;]*&gt;//g&apos; index.html</code></pre><p>(7) Remove consecutive whitespace and replace with single whitespace</p><pre><code>$ sed -E &apos;s/\s+/ /g&apos; &lt;&lt;&lt; &quot;hello    goodbye&quot;</code></pre><p><strong>3. Edit</strong></p><p><strong>&amp;</strong> represents the matched string, we can use it repeatedly</p><p>(1) Copy the matched string</p><pre><code>$ sed &apos;s/[0-9]*/&amp; &amp;/&apos; &lt;&lt;&lt; &quot;123 abc&quot;123 123 abc</code></pre><p>(2) Prepend a line with some string</p><pre><code>$ sed &apos;s/.*/HaHa: &amp;/&apos; filenameor simpler$ sed &apos;s/^/HaHa:‘ filename  </code></pre><p>(3) Append a line with something</p><pre><code>$ sed &apos;s/$/HoHo&apos; filename</code></pre><p>(4) Uppercase, Lowercase</p><p>GNU extention provides <code>\l</code>, <code>\L</code>, <code>\u</code>, <code>\U</code> to extend the ability of sed</p><p>\U char-list  : Uppercase all char in char-list<br>\u char-list  : Uppercase only the first char in char-list<br>\L char-list  : Lowercase all char in char-list<br>\l char-list  : Lowercase only the first char in char-list</p><p><strong>Capitalize</strong> the first character of a sentence</p><pre><code>$ sed -r &apos;s/.*/\u&amp;/&apos; &lt;&lt;&lt; &quot;nick meets kim in this morning&quot;Nick meets kim in this morning</code></pre><p><strong>Capitalize</strong> each word of a sentence</p><pre><code>$ sed -r &apos;s/\w+/\u&amp;/g&apos; &lt;&lt;&lt; &quot;nick meets kim in this morning&quot;Nick Meets Kim In This Morning</code></pre><p>We can achieve the above result using <strong><code>tr</code></strong> or <strong><code>awk</code></strong></p><pre><code>$ tr &apos;[:upper:]&apos; &apos;[:lower:]&apos; &lt; input.txt &gt; output.txt$ awk &apos;{print tolower($0)}&apos; &lt;&lt;&lt; &quot;UPPER&quot;</code></pre><p>(5) Ignore case substitution</p><pre><code>$ sed &apos;s/He/xx/gI&apos; &lt;&lt;&lt; &quot;hello world&quot;xxllo world</code></pre><p>(6) Field processing</p><p>It is common that the file SED is processing is a delimiter separated file.<br>In that case, we often need to use group symbols of regular expression to assist processing.</p><p>Assume there are three fields in a line separated by whitespace, we can use <code>&#39;(.*) (.*) (.*)&#39;</code> to match all of them,<br>and then use <code>\1</code>, <code>\2</code>, <code>\3</code> to refer to each of them.</p><pre><code>$ sed -r &apos;s/(.*) (.*) (.*)/Pre1\1 Pre3\2 Pre2\3/&apos; &lt;&lt;&lt; &quot;One Two Three&quot;</code></pre><p>More generally, if fields are separated by whitespace, we can use <code>\w+</code> to match all fields, and use <code>&amp;</code> to refer to each of them.</p><pre><code>$ sed -r &apos;s/\w+/\u&amp;/g&apos; &lt;&lt;&lt; &quot;good bye&quot; </code></pre><p>We can also use a number to refer to a specific field</p><p>Assume we have a <code>friute.csv</code> file like this:</p><pre><code>name     origin    priceapple     USA      18.5orange    Vetran    26.8cherry    Mexico    50.1  </code></pre><p>We want to modify the cherry’s price to 60, we can do this:</p><pre><code>$ sed &apos;4s/\S\+/60.6/3&apos; friute.csv</code></pre><p>Another, if we want to capitalize the first column, we can do:</p><pre><code>$ sed -r &apos;s/\S+/\u&amp;/1&apos; friute.csv</code></pre><p>Remove the last field</p><pre><code>$ sed &apos;s/\w*$//&apos; &lt;&lt;&lt; &apos;apple 123 beast&apos;$ sed -r &apos;s/^.* ([^ ]*)/\1/&apos; &lt;&lt;&lt; &quot;hello world haha&quot;</code></pre><p><strong>Operations on multiple files</strong></p><p>Use <strong><code>-s</code></strong> option</p><pre><code>$ sed -s -i &apos;s/me/he/g&apos; *.txt</code></pre><p><strong>Reference</strong><br><a href="http://www.grymoire.com/Unix/Sed.html" target="_blank" rel="noopener">http://www.grymoire.com/Unix/Sed.html</a><br><a href="http://www.pement.org/sed/sed1line.txt" target="_blank" rel="noopener">http://www.pement.org/sed/sed1line.txt</a><br><a href="http://www.theunixschool.com/2013/02/sed-examples-replace-delete-print-lines-csv-files.html" target="_blank" rel="noopener">http://www.theunixschool.com/2013/02/sed-examples-replace-delete-print-lines-csv-files.html</a><br><a href="http://coolshell.cn/articles/9104.html" target="_blank" rel="noopener">http://coolshell.cn/articles/9104.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>zip and unzip in Linux</title>
      <link href="/Linux/linux-zip-unzip/"/>
      <url>/Linux/linux-zip-unzip/</url>
      
        <content type="html"><![CDATA[<p>There are many utilities that can be used to archive/extract, compress/decompress files in Linux, mainly are: <code>tar</code>, <code>gzip</code>, <code>bzip2</code>, <code>zip</code>, etc.<br>Before we use these utilities, it’s better to be clear about the differences between the meaning of archiving and compressing.</p><p><strong>Archiving</strong> simply package several files together into a single file, there is no compress procedure involved implicitly, on the other side,<br><strong>Compressing</strong> will package files together and apply some compressing algorithm to shrink the size of the resulting file.</p><h3 id="A-list-of-common-archived-files-in-Linux"><a href="#A-list-of-common-archived-files-in-Linux" class="headerlink" title="A list of common archived files in Linux"></a>A list of common archived files in Linux</h3><ul><li>.tar</li><li>.tar.gz</li><li>.tar.bz2</li><li>.tar.xz</li><li>.tar.Z</li><li>.tgz</li><li>.zip</li></ul><p><strong>Note:</strong><br><code>.tar.gz</code> and <code>tar.bz2</code> are the two most common zipped file format in Linux, <code>.gz</code> implies gzip compressed file, while <code>.bz2</code> implies bzip compressed (LZ77 algorith is applied) file.</p><p>The <code>tar</code> utility is used to create a single archive from several files and extract the files from an archinve.<br>The <code>gzip</code>, <code>bzip2</code> or <code>zip</code> utility is used to compress a single file to smaller size.</p><p><strong>tar</strong>, <strong>gzip</strong>, <strong>bzip2</strong> are provided by default in most Linux/Unix distributions, <code>zip</code> utility may need a manual installation.</p><table><thead><tr><th><strong>Compress</strong></th><th><strong>Decompress</strong></th><th><strong>List</strong></th></tr></thead><tbody><tr><td>gzip filename</td><td>gzip -d *.gz, gunzip *.gz</td><td>gzip -l *.gz</td></tr><tr><td>bzip2 filename</td><td>bzip2 -d *.bz2, gunzip data.doc.bz2`</td><td></td></tr><tr><td>zip data.zip *.doc <br> zip -r data.zip data/</td><td>unzip *.zip</td><td>unzip -l *.zip</td></tr><tr><td>tar -zcvf data.tgz *.doc <br> tar -zcvf data.tar.gz *.doc <br> tar -jcvf data.tbz2 *.doc</td><td>tar -zxvf data.tgz <br> tar -zxvf pics.tar.gz *.jpg <br> tar -jxvf data.bz2</td><td>tar -ztf *.tgz <br> tar -ztf *.bz2 <br> tar -jtf *.bz2</td></tr></tbody></table><h3 id="Common-options-of-tar"><a href="#Common-options-of-tar" class="headerlink" title="Common options of tar"></a>Common options of tar</h3><ul><li><strong>-c:</strong> create a new archive</li><li><strong>-x:</strong> extract files from an archive</li><li><strong>-t:</strong> list the contents of an archive</li><li><strong>-r:</strong> append files to the end of an archive</li><li><strong>-u:</strong> update </li></ul><p>Note that the above five options are independent and therefore any two of them can not be used together (they can be used combined with other options but not each other). </p><p><code>-c</code> or <code>-x</code> will be used when packaging or extracting.</p><ul><li><strong>-z</strong>, –gzip     use gzip compress</li><li><strong>-j</strong>, –bzip2    use bzip2 compress</li><li><strong>-Z</strong>, –compress use for *.tar.Z</li><li><strong>-v</strong>  verbose</li><li><strong>-O</strong>, –to-stdout   extract files to standard output</li><li><strong>-C</strong>, –directory Output directory</li></ul><p><strong>-f</strong> option is used to specify the archive name, this is a mandatory option for <code>tar</code>.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p><strong>1. Create an archive from a folder</strong></p><pre><code>$ tar -cf test.tar.gz mytest/</code></pre><p><strong>2. Extract files out of an archive</strong></p><pre><code>$ tar -xf test.tar.gz</code></pre><p><strong>3. Specify output directory with -C option</strong></p><pre><code>$ tar xf test.tar -C other/</code></pre><p>Note: use <code>-d</code> option if we use unzip or gunzip</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RAID notes</title>
      <link href="/Database/core-techs-storage-raid/"/>
      <url>/Database/core-techs-storage-raid/</url>
      
        <content type="html"><![CDATA[<h1 id="标题：程序员需要知道的-RAID-基本原理"><a href="#标题：程序员需要知道的-RAID-基本原理" class="headerlink" title="标题：程序员需要知道的 RAID 基本原理"></a>标题：程序员需要知道的 RAID 基本原理</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>RAID，全称为 redundant array of independent disks，是目前商用服务器常见的磁盘管理技术。作为软件开发人员，需要了解各级RAID的特性，以便根据需求做出做合适的选择。本文总结了常见的RAID级别的特性，包括如下内容：</p><ul><li>RAID 的基本作用</li><li>各级 RAID 的基本原理</li></ul><h2 id="RAID-的基本作用"><a href="#RAID-的基本作用" class="headerlink" title="RAID 的基本作用"></a>RAID 的基本作用</h2><p>RAID 的一般有如下作用：</p><ul><li>数据冗余</li><li>性能提升</li></ul><p>数据冗余是指把数据的校验信息存放在冗余的磁盘中，在某些磁盘数据损坏时，能从其他未损坏的磁盘中，重新构建数据。</p><p>性能提升是指RAID能把多块独立的磁盘组成磁盘阵列，通过把数据切成分片的方式，使得读/写数据能走多块磁盘，从而提升性能。</p><h2 id="各级-RAID-的基本原理"><a href="#各级-RAID-的基本原理" class="headerlink" title="各级 RAID 的基本原理"></a>各级 RAID 的基本原理</h2><p>根据 RAID 的冗余信息程度，切分数据的方式等不同，可以把 RAID 分成不同的级别，分别是</p><ul><li>RAID0</li><li>RAID1</li><li>RAID2</li><li>RAID3</li><li>RAID4</li><li>RAID5</li><li>RAID6</li></ul><p>接下来就讨论这些 RAID 级别的基本原理。</p><h2 id="RAID0-的基本原理"><a href="#RAID0-的基本原理" class="headerlink" title="RAID0 的基本原理"></a>RAID0 的基本原理</h2><p>RAID0 设计的目标是为了提升读写性能，但并不带数据冗余信息。</p><p><img src="/image/database/raid0.png" alt="RAID0"></p><p>如上图，RAID0会把数据切成块，分别存储在N个磁盘上。当读数据时，如果要读的数据块比较大，分布在多次磁盘上，那么能同时从多块盘读数据；当写数据时，如果要写的数据块比较大，分布式在多块磁盘上，那么同时能从多块盘写数据。</p><p>因为数据分布在多块盘上，当某块磁盘损坏时，整个RAID系统就不可用了。因此，N块盘的RAID0的特性如下：</p><p>读性能最好情况下是单块盘的N倍<br>写性能最好情况下是单块盘的N倍<br>空间利用率为100%<br>不具有冗余信息，任何一块磁盘损坏，整个RAID不可用</p><h2 id="RAID1-的基本原理"><a href="#RAID1-的基本原理" class="headerlink" title="RAID1 的基本原理"></a>RAID1 的基本原理</h2><p>RAID1 的设计目标是为每份数据都提供一份或多份冗余数据，其结构如下：</p><p><img src="/image/database/raid1.png" alt="RAID1"></p><p>如上图，RAID1中一个磁盘都有一个或多个冗余的镜像盘，所有磁盘的数据是一模一样的。RAID1读数据时，可以利用所有数据盘的带宽；写数据时，要同时写入数据盘和镜像盘，因此，需要等待最慢的磁盘写完成，写操作才完成，因此，写性能跟最慢的磁盘相当。N块盘的RAID1的特性如下：</p><p>读性能最好情况下是原来的N倍<br>写性能跟最慢的磁盘相当<br>空间利用率1/N<br>N块盘，坏掉N-1块，RAID还能正常使用</p><h2 id="RAID2-的基本原理"><a href="#RAID2-的基本原理" class="headerlink" title="RAID2 的基本原理"></a>RAID2 的基本原理</h2><p>RAID2 的设计目标是在RAID0级别的基础上，加了海明纠错码。</p><p><img src="/image/database/raid2.png" alt="RAID2"></p><p>如上图，前面四个盘是数据盘，后面三个盘是纠错码。RAID2读数据时，能同时使用多个数据盘的带宽；RAID2写数据时，除了写数据盘，还需要写校验盘，写性能会有下降。因此，N块盘的RAID2的特性如下：</p><p>读性能不到原来的N倍，因为还有一部分是校验盘<br>写性能会有下降，因为每次都要写校验盘，受限于校验盘的数量<br>空间利用率小于100%，因为海明纠错码需要的冗余盘一般比数据盘的数量少<br>根据海明纠错码位数的不同，能容忍的坏盘数不同，具体信息可以参考海明码</p><h2 id="RAID3-的基本原理"><a href="#RAID3-的基本原理" class="headerlink" title="RAID3 的基本原理"></a>RAID3 的基本原理</h2><p>RAID3 是把数据按照字节分别存在不同的磁盘中，并且最后一个磁盘提供纠错冗余，其结构如下：</p><p><img src="/image/database/raid3.png" alt="RAID3"></p><p>如上图，由于按照字节切分数据，读数据时，一定会同时从多个盘读数据，可以利用所有数据盘的带宽；写数据时，也会利用所有磁盘的带宽，但所有的写校验数据都会在一个盘，因此，写性能主要受限于校验盘。N快盘的RAID3的特性如下：</p><p>读性能是N-1倍，其中一块盘是校验盘<br>写性能受限于校验盘的写性能<br>空间利用率为(N-1)/N<br>坏掉一块盘，RAID还能正常工作</p><h2 id="RAID4"><a href="#RAID4" class="headerlink" title="RAID4"></a>RAID4</h2><p>RAID4 是把数据按照分块分别存在不同的磁盘中，并且最后一个磁盘提供纠错冗余，其结构如下：</p><p><img src="/image/database/raid4.png" alt="RAID4"></p><p>如上图，读数据时，当数据分布在多块盘时，能够利用多块数据盘的带宽；写数据时，如果数据分布在多快盘时，能利用所有磁盘带宽，但写校验数据只能在一块盘上，因此，写性能主要受限于校验盘。N块盘的RAID4的特性如下：</p><p>读性能是N-1倍，其中一块盘是校验盘<br>写性能受限于校验盘的写性能<br>空间利用率为(N-1)/N<br>坏掉一块盘，RAID还能正常工作</p><h2 id="RAID5"><a href="#RAID5" class="headerlink" title="RAID5"></a>RAID5</h2><p>RAID5 是把数据块按照分块分别存在不同的磁盘中，并且冗余信息也会分块分布在多块磁盘中，其结构如下：</p><p><img src="/image/database/raid5.png" alt="RAID5"></p><p>如上图，读数据时，当数据分布在多块盘时，能够利用多块数据盘的带宽；写数据时，如果数据分布在多块盘时，能利用所有数据盘带宽，同时写校验数据也分散在多块盘上，但因为要额外写入校验数据，因此，写数据的性能略微有所下降。N块盘的RAID5的特性如下：</p><p>读性能是N倍<br>写性能略微弱于RAID0<br>空间利用率为(N-1)/N<br>坏掉一块盘，RAID还能正常工作</p><h2 id="RAID6"><a href="#RAID6" class="headerlink" title="RAID6"></a>RAID6</h2><p>RAID6 是把数据块按照分块分别存在不同的磁盘中，并且冗余信息为两份奇偶校验码，分布在多块磁盘中，其结构如下：</p><p><img src="/image/database/raid6.png" alt="RAID6"></p><p>如上图，读数据时，当数据分布在多块盘时，能够利用多块数据盘的带宽；写数据时，如果数据分布在多块盘时，能利用多块数据盘带宽，同时写校验数据也分散在多块盘中，但因为要额外写入两份校验数据，因此，写数据的性能要略微下降。N块盘的RAID6的特性如下：</p><p>读性能是N倍<br>写性能略微弱于RAID0<br>空间利用率为(N-2)/N<br>坏掉两块盘，RAID还能正常工作</p><h2 id="各级RAID的对比"><a href="#各级RAID的对比" class="headerlink" title="各级RAID的对比"></a>各级RAID的对比</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RAID级别  读性能 写性能 空间利用率   最大能容忍的坏盘数</span><br><span class="line">RAID0   单块盘的N倍  单块盘的N倍  100%    0</span><br><span class="line">RAID1   单块盘的N倍  最慢磁盘的性能 1/N N-1</span><br><span class="line">RAID2   不到单块盘的N倍    单盘的写入速度 * 校验盘的数量    不到100%  取决于海明纠错码位数</span><br><span class="line">RAID3   单块盘的N-1倍    校验盘的写入速度    (N-1)/N 1</span><br><span class="line">RAID4   单块盘的N-1倍    校验盘的写入速度    (N-1)/N 1</span><br><span class="line">RAID5   单块盘的N倍  略微弱于单块盘的N倍  (N-1)/N 1</span><br><span class="line">RAID6   单块盘的N倍  略微弱于单块盘的N倍，差于RAID5  (N-2)/N 2</span><br></pre></td></tr></table></figure><p>一般地，RAID0容忍的坏盘数为0，风险太大，一般不常用；RAID1的信息冗余量很多，适合于对信息安全要求很高并且预算充足的场景；RAID2的控制器比较复杂，一般不常用；RAID3和RAID4由于其写入性能差，也不常用；RAID5由于读写性能、能容忍的坏盘数都比较均衡，因此，一般工业界经常使用的是RAID5；RAID6对于坏盘数容忍度较高，适合于对信息安全比较高的场景。</p><p>本文来源：<br><a href="http://oserror.com/backend/raid-principle/" target="_blank" rel="noopener">http://oserror.com/backend/raid-principle/</a></p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSD notes</title>
      <link href="/Database/core-techs-storage-ssd/"/>
      <url>/Database/core-techs-storage-ssd/</url>
      
        <content type="html"><![CDATA[<p>NAND Flash</p><p>NAND flash is a type of non-volatile storage architecture used in SSDs and memory cards. It gets its name from the type of the logic gate (NOT-AND) used to determine how digital information is stored in a flash device’s chips.</p><p>SLC<br>Single-Level Cell SSDs store one bit in each cell, a design that yields enhanced endurance, accuracy and performance. For critical enterprise applications and storage services, SLC is the go-to flash technology. Of course, it carries the highest price tag.</p><p>MLC<br>Considered the consumer-grade flavor of flash, Multi-Level Cell architectures can store two bits per cell. Although it may seem like packing more than one bit into a memory cell is a good use of space, it comes at the cost of a lower useful life and decreased reliability. MLC SSDs make it possible to economically add flash storage to PCs and laptops, relatively speaking.</p><p>eMLC<br>Enterprise Multi-Level Cell is a hardier version of MLC NAND flash that somewhat bridges the performance and endurance gap between SLC and MLC. eMLC drives costs more than MLC drives, but much less than SLC their counterparts. Although it still stores two bits per cell, an eMLC drive’s controller manages data placement, wear leveling and other storage operations in a way that extends an eMLC SSD’s useful life.</p><p>TLC<br>The least expensive of the bunch, Triple-Level Cell NAND flash stores three bits per cell and is typically used in consumer-grade electronics with comparatively low performance and endurance requirements. Best suited for read-heavy applications, TLC-based storage components were rarely, if ever, used in business environments but recent improvements in flash architectures, including 3D NAND (more on that later), and endurance-enhancing data placement and error correction techniques have earned the technology a place in read-intensive enterprise storage applications.</p><p>SSD 高速的原因是它内部有多个闪存，在读写时，多个闪存同时读取，就相当于把每个闪存的速度加起来，所以就快了，SSD 能有4、8、16、个闪存颗粒<br>SSD 是从存储单元里读写数据，而 HDD 是机械的，磁头从盘片上读写数据，电子的当然比机械的快。<br>同时HDD是靠机械的磁头在盘片上读写数据，要经过寻道读写等过程，都需要时间，而ssd是通过电路选择存储位置进行读取，电的速度是非常快的，所以ssd比hdd更快。</p><p>SSD 故事会<br><a href="https://diy.pconline.com.cn/610/6107477_all.html" target="_blank" rel="noopener">https://diy.pconline.com.cn/610/6107477_all.html</a><br><a href="https://diy.pconline.com.cn/750/7501340.html" target="_blank" rel="noopener">https://diy.pconline.com.cn/750/7501340.html</a></p><p>SSD 为什么速度那么快？看完这篇你就懂了！<br><a href="http://news.moore.ren/industry/8159.htm" target="_blank" rel="noopener">http://news.moore.ren/industry/8159.htm</a></p><p>程序员需要知道的SSD基本原理<br><a href="http://oserror.com/backend/ssd-principle/" target="_blank" rel="noopener">http://oserror.com/backend/ssd-principle/</a></p><p>引言<br>SSD是目前商用服务器上非常流行的存储介质，因此，作为软件开发人员，需要了解的SSD基本原理，以便开发时能更好地发挥其优势，规避其劣势。本文总结了作为软件开发人员需要了解的SSD基本原理，全文组织结构如下：</p><ul><li>SSD的读写速度</li><li>SSD内部芯片的简单存取原理</li><li>SSD的读写特性</li><li>SSD的over-provisioning和garbage-collection</li><li>SSD的损耗均衡控制</li><li>SSD的写放大问题</li></ul><h2 id="SSD-的读写速度"><a href="#SSD-的读写速度" class="headerlink" title="SSD 的读写速度"></a>SSD 的读写速度</h2><p>首先，从软件开发人员作为SSD的用户角度来讲，首先需要了解的是SSD和普通HDD的性能对比，如下：</p><p>先来看顺序读和顺序写</p><p><img src="/image/database/ssd_sequential_read.png" alt=""><br><img src="/image/database/ssd_sequential_write.png" alt=""></p><p>其中，Seagate ST3000DM001是HDD，其他的都是SSD。从上述两图中可以看出，HDD的顺序读速度差不多为最慢的SSD的一半，顺序写稍微好点，但也比大部分慢一倍左右的速度。</p><p>再来看随机读和随机写</p><p><img src="/image/database/ssd_random_read.png" alt=""><br><img src="/image/database/ssd_random_write.png" alt=""></p><p>可以看出，HDD的随机读的性能是普通SSD的几十分之一，随机写性能更差。</p><p>因此，SSD的随机读和写性能要远远好于HDD，本文接下来的几个小节将会讨论为什么SSD的随机读写性能要远远高于HDD？</p><p>备注：本小节测试数据全部来自于 <a href="http://www.pcgamer.com/hard-drive-vs-ssd-performance/2/" target="_blank" rel="noopener">HDD VS SSD</a>。</p><h2 id="SSD-内部芯片的简单存储原理"><a href="#SSD-内部芯片的简单存储原理" class="headerlink" title="SSD 内部芯片的简单存储原理"></a>SSD 内部芯片的简单存储原理</h2><p>SSD 内部一般使用 NAND Flash 来作为存储介质，其逻辑结构如下：</p><p><img src="/image/database/ssd_nand_flash.png" alt=""></p><p>SSD 中一般有多个 NAND Flash，每个NAND Flash包含多个Block，每个Block包含多个Page。由于NAND的特性，其存取都必须以page为单位，即每次读写至少是一个page，通常地，每个page的大小为4k或者8k。另外，NAND还有一个特性是，其只能是读或写单个page，但不能覆盖写如某个page，必须先要清空里面的内容，再写入。由于清空内容的电压较高，必须是以block为单位。因此，没有空闲的page时，必须要找到没有有效内容的block，先擦写，然后再选择空闲的page写入。</p><p>在 SSD 中，一般会维护一个 mapping table，维护逻辑地址到物理地址的映射。每次读写时，可以通过逻辑地址直接查表计算出物理地址，与传统的机械磁盘相比，省去了寻道时间和旋转时间。</p><h2 id="SSD-读写特性"><a href="#SSD-读写特性" class="headerlink" title="SSD 读写特性"></a>SSD 读写特性</h2><p>从 NAND Flash的原理可以看出，其和 HDD 的主要区别为</p><ul><li>定位数据快：HDD需要经过寻道和旋转，才能定位到要读写的数据块，而SSD通过mapping table直接计算即可</li><li>读取速度块：HDD的速度取决于旋转速度，而 SSD 只需要加电压读取数据，一般而言，要快于 HDD</li></ul><p>因此，在顺序读测试中，由于定位数据只需要一次，定位之后，则是大批量的读取数据的过程，此时，HDD 和 SSD 的性能差距主要体现在读取速度上，HDD 能到 200M 左右，而普通 SSD 是其两倍。</p><p>在随机读测试中，由于每次读都要先定位数据，然后再读取，HDD的定位数据的耗费时间很多，一般是几毫秒到十几毫秒，远远高于SSD的定位数据时间(一般0.1ms左右)，因此，随机读写测试主要体现在两者定位数据的速度上，此时，SSD的性能是要远远好于HDD的。</p><p>对于SSD的写操作，针对不同的情况，有不同的处理流程，主要是受到NAND Flash的如下特性限制</p><p>NAND Flash每次写必须以page为单位，且只能写入空闲的page，不能覆盖写原先有内容的page<br>擦除数据时，由于电压较高，只能以block为单位擦除<br>SSD的写分为新写入和更新两种，处理流程不同。</p><p>先看新写入的数据的流程，如下：</p><p><img src="/image/database/ssd_new_write.png" alt="SSD New Write"></p><p>假设新写入了一个page，其流程如下：</p><p>找到一个空闲page<br>把数据写入到空闲page中<br>更新mapping table</p><p>而更新操作的流程如下：</p><p><img src="/image/database/ssd_write_leave_idle.png" alt="SSD Leave Idle"></p><p>假设是更新了page G中的某些字节，流程如下：</p><p>由于SSD不能覆盖写，因此，先找到一个空闲页H<br>读取page G中的数据到SSD内部的buffer中，把更新的字节更新到buffer<br>把buffer中的数据写入到H<br>更新mapping table中G页，置为无效页<br>更新mapping table中H页，添加映射关系<br>可以看出，如果在更新操作比较多的情况下，会产生较多的无效页，类似于磁盘碎片，此时，需要SSD的over-provisioning和garbage-collection。</p><h2 id="SSD-的over-provisioning和garbage-collection"><a href="#SSD-的over-provisioning和garbage-collection" class="headerlink" title="SSD 的over-provisioning和garbage-collection"></a>SSD 的over-provisioning和garbage-collection</h2><p>over-provisioning是指SSD实际的存储空间比可写入的空间要大，比如，一块可用容量为120G的SSD，实际空间可能有128G。为什么需要over-provisioning呢？请看如下例子：</p><p><img src="/image/database/ssd_over_provisioning.png" alt="SSD over-provisioning"></p><p>如上图所示，假设系统中就两个 block，最终还剩下两个无效的 page，此时，要写入一个新page，根据NAND原理，必须要先对两个无效的 page 擦除才能用于写入。此时，就需要用到 SSD 提供的额外空间，才能用 garbage-collection 方法整理出可用空间。</p><p><img src="/image/database/ssd_garbage_collection.png" alt="garbage collection"></p><p>garbage collection 的整理流程如上图所示</p><ul><li>首先，从over-provisoning的空间中，找到一个空闲的block</li><li>把Block0的ABCDEFH和Block1的A复制到空闲block</li><li>擦除Block 0</li><li>把Block1的BCDEFH复制到Block0，此时Block0就有两个空闲page了</li><li>擦除BLock1</li></ul><p>有空闲page之后，就可以按照正常的流程来写入了。</p><h3 id="SSD-的-garbage-collection会带来两个问题："><a href="#SSD-的-garbage-collection会带来两个问题：" class="headerlink" title="SSD 的 garbage-collection会带来两个问题："></a>SSD 的 garbage-collection会带来两个问题：</h3><p>SSD 的寿命减少，NAND Flash中每个原件都有擦写次数限制，超过一定擦写次数后，就只能读取不能写入了<br>写放大问题，即内部真正写入的数据量大于用户请求写入的数据量<br>如果频繁的在某些 block 上做 garbage-collection，会使得这些元件比其他部分更快到达擦写次数限制，因此，需要某个算法，能使得原件的擦写次数比较平均，这样才能延长 SSD 的寿命，这就需要下面要讨论的损耗均衡控制了。</p><h2 id="SSD-损耗均衡控制"><a href="#SSD-损耗均衡控制" class="headerlink" title="SSD 损耗均衡控制"></a>SSD 损耗均衡控制</h2><p>为了避免某些 block 被频繁的更新，而另外一些 block 非常的空闲，SSD 控制器一般会记录各个 block 的写入次数，并且通过一定的算法，来达到每个 block 的写入都比较均衡。</p><p>以一个例子，说明损耗均衡控制的重要性：</p><p>假如一个NAND Flash总共有4096个block，每个block的擦写次数最大为10000。其中有3个文件，每个文件占用50个block，平均10分钟更新1个文件，假设没有均衡控制，那么只会3 * 50 + 50共200个block，则这个SSD的寿命如下：</p><p><img src="/image/database/no_wear_leveling.png" alt="no wear leveling"></p><p>大约为 278 天。而如果是完美的损耗均衡控制，即 4096 个 block 都均衡地参与更新，则使用寿命如下：</p><p><img src="/image/database/perfect_wear_leveling.png" alt="perfect wear leveling"></p><p>大约 5689 天。因此，设计一个好的损耗均衡控制算法是非常有必要的，主流的方法主要有两种：</p><ul><li>dynamic wear leveling</li><li>static wear leveling<br>这里的 dynamic 和 static 是指的是数据的特性，如果数据频繁的更新，那么数据是 dynamic 的，如果数据写入后，不更新，那么是 static 的。</li></ul><p>dynamic wear leveling 的原理是记录每个 block 的擦写次数，每次写入数据时，找到被擦除次数最小的空 block。</p><p>static wear leveling 的原理分为两块：</p><p>每次找到每擦除次数最小的可用block<br>当某个block的擦除次数小于阈值时，会将它与擦写次数较高的block的数据进行交换<br>以一个例子来说明，两种擦写算法的不同点：</p><p>假如SSD中有25%的数据是dynamic的，另外75%的数据是static的。对于dynamic wear leveling方法，每次要找的是擦除了数据的block，而static的block里面是有数据的，因此，每次都只会在dynamic的block中，即最多会在25%的block中做均衡；对于static算法，每次找的block既可能是dynamic的，也可能是static的，因此，最多有可能在全部的block中做均衡。</p><p>相对而言，static算法能使得SSD的寿命更长，但也有其缺点：</p><p>算法逻辑更复杂<br>在写入时，可能会移动数据，导致写放大，降低写入性能<br>更高的能耗</p><h2 id="SSD写放大"><a href="#SSD写放大" class="headerlink" title="SSD写放大"></a>SSD写放大</h2><p>最后，我们分析一下SSD的写放大问题，一般由如下三个方面引起：</p><p>SSD读写是以page为单位的，如果更新page中的部分数据，也需要写整个page<br>SSD的garbage collection中，会在block间移动数据<br>SSD的wear leveing中，可能也会在block间交换数据，导致写放大<br>通常的，需要在其他方面和SSD的写放大之间做权衡，例如，可以减少garbage collection的频率来减少写放大问题；可以把SSD分成多个zone，每个zone使用不同的wear leveling方法等等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>个人理解，使用SSD时，我们需要考虑如下情况：</p><p>需要充分利用其随机读写快的特性<br>尽可能在软件层面更新小块数据，减轻SSD写放大问题<br>避免频繁的更新数据，减轻SSD写放大及寿命减少的问题，尽可能使用追加的方式写数据</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Access the web server resides in Guest OS</title>
      <link href="/VirtualBox/vbox-vbox-access-server-in-guestos/"/>
      <url>/VirtualBox/vbox-vbox-access-server-in-guestos/</url>
      
        <content type="html"><![CDATA[<p>This article introduces the method to access the web server resides in Guest OS behind Virtualbox From Host’s Browser (Windows).</p><p>As we known, access to the web server behind Virtualbox in <strong>Bridge Mode</strong> is pretty straightforward and easily setup, however, there are a lot of disadvantages<br>when we use Bridge Mode to communicate between Host OS and Guest OS running on Virtualbox. For example, ip conflicts, in some environment (eg. in<br>a company internal network), dhcp is not allowed to lease a ip to a strange device (the guest OS on Virtualbox is one), and manually configure static ip will cause ip conflicts with other ips that have already be assgined, and therefore Guest OS is not able to access to the internet. In summary, Bridge Mode makes things non-trivial and cause inconveniences/problems quite often.</p><p>Instead, NAT Mode is easy to use in such circumstances, and get us away from the problems stated above. I will demonstrate the way to access the web server on Guest OS running on VirtualBox from Windows Host Browser(Chrome, Firefox, etc).</p><p>Essentialy, the technique that will be used are Port forwarding and SSH tunneling (Socks proxy).</p><ol><li>Set up VirtualBox network adapter as NAT and configure a port forwarding rule on  VirtualBox so that we can ssh into the Guest OS:</li></ol><p><img src="/image/port_fwd1.jpg" alt=""></p><ol start="2"><li>Set up a ssh tunnel between Host OS and Guest OS, this is by setting up a local socks proxy server on Host OS (Windows), and then point the web browser to connect to this server, what this socks proxy server located on Host OS do is listen on the specified local port and forwarding all the packages to the destination (the Guest OS). By this, we are able to browse the web pages on Host OS.</li></ol><p>Specifically, we can use putty as a ssh client to set up a socks proxy server on Windows:</p><p>select Dynamic, and enter a port number, e.g 2048 in Source port inputbox, press Add<br><img src="/image/putty_settings.jpg" alt=""></p><p>Go back to Session window, fill in Host name and port like below, press Open<br><img src="/image/putty_settings1.jpg" alt=""></p><p>Now, a ssh tunneling should be set up successfully!</p><p>We can go to Windows command line and type: netstat -n -a<br><img src="/image/netstat1.png" alt=""></p><p>As is shown the port 2048 is on LISTENING. This means anything that connects to 127.0.0.1:2048 will go through the ssh tunnel to reach the destination (Guest OS).</p><ol start="3"><li>Configure the browsers(Firefox, Chrome, etc.) to use Socks proxy:<br><img src="/image/firefox_settings.jpg" alt=""></li></ol><ol start="4"><li>Use Guest’s Internal IP address as the ip address that our browser connects to.<br>For example, we have set up a web server in Guest OS, and the web page on Guest OS should be look like: <a href="http://localhost:80" target="_blank" rel="noopener">http://localhost:80</a><br>here we want to access this http page on the Host OS’s browser, the actual address we will use should be <a href="http://10.0.2.15:80" target="_blank" rel="noopener">http://10.0.2.15:80</a> in broswer on Host OS.</li></ol><p><img src="/image/hadoop_web1.png" alt=""></p><p>Or<br>If we set up a Host-Only adapter also, we can use host-only ip address as well.<br>For example, the host-only ip address of the Guest OS is 192.168.56.121</p><p><img src="/image/host_only1.png" alt=""></p><p>then we can access the page of Guest OS from Host’s browser like this:</p><p><img src="/image/hadoop_web2.png" alt=""></p><p>Extra Knowledge </p><p>View Hadoop job status and history page in Windows Browser</p><p>We need to start Map Reduce Job History Server before we can view the job status on web pages:</p><pre><code>$ $HADOOP_HOME/sbin/mr-jobhistory-daemon.sh start historyserver</code></pre><p>or</p><pre><code>$ $HADOOP_HOME/sbin/mr-jobhistory-daemon.sh --config $HADOOP_CONF_DIR start historyserver</code></pre><p>then check whether historyserver has started successfully:</p><pre><code>$ jps</code></pre><p><img src="/image/joblist.png" alt=""></p><p>If we do not start job historyserver, we won’t be able to connect to 19888 prot, and we will probably see error messages like this:</p><p><img src="/image/jobhistory1.png" alt=""></p><p>Even in Guest OS itself:</p><p><img src="/image/jobhistory2.png" alt=""></p><p>$ netstat -ntlp | grep 19888<br>(Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.)<br>tcp 0 0 127.0.0.1:19888 0.0.0.0:* LISTEN 3176/java</p><p>after historyserver is started successfully, we should be able to see the page like this:</p><p><img src="/image/jobhistory4.png" alt=""></p><p><strong>参考：</strong><br><a href="http://stackoverflow.com/questions/28928193/not-able-to-see-job-historyhttp-localhost19888-page-in-web-browser-in-hadoo" target="_blank" rel="noopener">Not able to see Job History(http://localhost:19888) page in web browser in Hadoop</a></p><p><a href="http://serverfault.com/questions/136715/how-do-i-access-a-web-server-on-a-virtualbox-from-the-host-machine" target="_blank" rel="noopener">http://serverfault.com/questions/136715/how-do-i-access-a-web-server-on-a-virtualbox-from-the-host-machine</a><br><a href="http://tuxtweaks.com/2010/03/access-your-web-server-from-virtualbox/" target="_blank" rel="noopener">http://tuxtweaks.com/2010/03/access-your-web-server-from-virtualbox/</a> </p>]]></content>
      
      
      <categories>
          
          <category> VirtualBox </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ss</title>
      <link href="/Linux/linux-ss/"/>
      <url>/Linux/linux-ss/</url>
      
        <content type="html"><![CDATA[<p><strong>ss</strong> (Socket Statistics) is part of the iproute2 (utilities for controlling TCP/IP networking and traffic) package. iproute2 is intended to replace an entire suite of standard Unix networking tools (often called <code>&quot;net-tools&quot;</code>) that were previously used for the tasks of configuring network interfaces, routing tables, and managing the ARP table. The ss utility is used to dump socket statistics, it displays information similar to or even more TCP and state information as compared to netstat.</p><p>Besides, the <strong>ss</strong> command should perform faster as it gets information directly from kernel space, while <em>netstat</em> reads various /proc files to gather information (This is slow when there are lots of connections to display).</p><p>The options used with the ss commands are very similar to netstat making it an easy replacement.</p><p><strong>Note</strong><br>On Arch Linux, <code>net-tools</code> is deprecated sine 2011, see <a href="https://www.archlinux.org/news/deprecation-of-net-tools/" target="_blank" rel="noopener">this</a> for details.</p><h3 id="Syntax-and-common-options"><a href="#Syntax-and-common-options" class="headerlink" title="Syntax and common options"></a>Syntax and common options</h3><p>ss is very similar to netstat, by default it will show you a list of open non-listening TCP sockets that have established connection and you can shape the output with the following options:</p><p><strong>-n</strong> - Do now try to resolve service names.<br><strong>-r</strong> - Try to resolve numeric address/ports.<br><strong>-a</strong> - Display all sockets.<br><strong>-l</strong> - Display listening sockets.<br><strong>-p</strong> - Show process using socket.<br><strong>-s</strong> - Print summary statistics.<br><strong>-t</strong> - Display only TCP sockets.<br><strong>-u</strong> - Display only UDP sockets.<br><strong>-d</strong> - Display only DCCP sockets.<br><strong>-w</strong> - Display only RAW sockets.<br><strong>-x</strong> - Display only Unix domain sockets.<br><strong>-f FAMILY</strong> - Display sockets of type FAMILY. Currently the following families are supported: unix, inet, inet6, link, netlink.<br><strong>-A QUERY</strong> - List of socket tables to dump, separated by commas. The following identifiers are understood: all, inet, tcp, udp, raw, unix, packet, netlink, unix_dgram, unix_stream, packet_raw, packet_dgram.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p><strong>1. List all connections</strong></p><pre><code>$ ss | less</code></pre><p><strong>2. Display tcp ports and process/pid</strong></p><pre><code>$ ss -natp</code></pre><p><strong>3. Show only listening sockets with process/pid</strong></p><pre><code>$ ss -nltp</code></pre><p><strong>4. Print summary statistics</strong></p><pre><code>$ ss -s</code></pre><p><strong>5. Display timer information</strong></p><p>With the ‘-o’ option, the time information of each connection would be displayed. The timer information tells how long with</p><pre><code>$ ss -tn -oState      Recv-Q Send-Q      Local Address:Port        Peer Address:Port ESTAB      0      0             192.168.1.2:43839     108.160.162.37:80    ESTAB      0      0             192.168.1.2:36335     204.144.140.26:80     timer:(keepalive,26sec,0)ESTAB      0      0             192.168.1.2:33141      83.170.73.249:6667  ESTAB      0      0             192.168.1.2:58857      74.121.141.84:80     timer:(keepalive,23sec,0)ESTAB      0      0             192.168.1.2:42794     173.194.40.239:80     timer:(keepalive,32sec,0)</code></pre><p><strong>6. Filtering connections by tcp state</strong></p><blockquote><p>ss [ OPTIONS ] [ STATE-FILTER ] [ ADDRESS-FILTER ]</p></blockquote><p>(1) To display all Ipv4 tcp sockets that are in “connected” state.</p><pre><code>$ ss -t4 state establishedRecv-Q Send-Q         Local Address:Port             Peer Address:Port   0      0                192.168.1.2:54436          165.193.246.23:https   0      0                192.168.1.2:43386          173.194.72.125:xmpp-client 0      0                192.168.1.2:38355           199.59.150.46:https   0      0                192.168.1.2:56198          108.160.162.37:http</code></pre><p>(2) Display sockets with state time-wait</p><pre><code>$ ss -t4 state time-waitRecv-Q Send-Q         Local Address:Port             Peer Address:Port   0      0                192.168.1.2:42261           199.59.150.39:https   0      0                  127.0.0.1:43541               127.0.0.1:2633</code></pre><p>The state can be either of the following:</p><pre><code>1. established2. syn-sent 3. syn-recv 4. fin-wait-1 5. fin-wait-2 6. time-wait 7. closed 8. close-wait 9. last-ack 10. closing 11. all - All of the above states 12. connected - All the states except for listen and closed 13. synchronized - All the connected states except for syn-sent 14. bucket - Show states, which are maintained as minisockets, i.e. time-wait and syn-recv. 15. big - Opposite to bucket state.</code></pre><p>Note that many states like syn-sent, syn-recv would not show any sockets most of the time, since sockets remain in such states for a very short time. It would be ideal to use the watch command to detect such socket states in real time.</p><p>Here is an example</p><pre><code>$ watch -n 1 &quot;ss -t4 state syn-sent&quot;</code></pre><p>After running the above command, try opening some website in a browser or download something from some url. Immediately you should see socket connections appearing in the output, but for a very short while.</p><pre><code>Every 1.0s: ss -t4 state syn-sent                   Tue Apr  1 10:07:33 2014Recv-Q Send-Q           Local Address:Port               Peer Address:Port0      1                  192.168.1.2:55089            202.79.210.121:https0      1                  192.168.1.2:33733             203.84.220.80:https</code></pre><p><strong>7. Filter connections by address and port number</strong></p><p>Apart from tcp socket states, the ss command also supports filtering based on address and port number of the socket. The following examples demonstrate that.</p><p>Display all socket connections with source or destination port of ssh.</p><pre><code>$ ss -at &apos;( dport = :ssh or sport = :ssh )&apos;State      Recv-Q Send-Q    Local Address:Port        Peer Address:Port   LISTEN     0      128                   *:ssh                    *:*       LISTEN     0      128                  :::ssh                   :::*</code></pre><p>Sockets with destination port 443 or 80</p><pre><code>$ ss -nt &apos;( dst :443 or dst :80 )&apos;State      Recv-Q Send-Q      Local Address:Port        Peer Address:Port ESTAB      0      0             192.168.1.2:58844      199.59.148.82:443   ESTAB      0      0             192.168.1.2:55320     165.193.246.23:443   ESTAB      0      0             192.168.1.2:56198     108.160.162.37:80    ESTAB      0      0             192.168.1.2:54889    192.241.177.148:443   ESTAB      0      0             192.168.1.2:39893      173.255.230.5:80    </code></pre><p>The following syntax would also work</p><pre><code>$ ss -nt dst :443 or dst :80</code></pre><p>Display All Established <strong>HTTP</strong> Connections</p><pre><code>$ ss -o state established &apos;( dport = :http or sport = :http )&apos;</code></pre><h4 id="Matches-Remote-Address-And-Port-Numbers"><a href="#Matches-Remote-Address-And-Port-Numbers" class="headerlink" title="Matches Remote Address And Port Numbers?"></a>Matches Remote Address And Port Numbers?</h4><blockquote><p>ss dst ADDRESS_PATTERN </p></blockquote><p><strong>(1) Show all ports connected from remote 192.168.1.5</strong></p><pre><code>$ ss dst 192.168.1.5</code></pre><p><strong>(2) show all ports connected from remote 192.168.1.5:http port</strong></p><pre><code>$ ss dst 192.168.1.5:http$ ss dst 192.168.1.5:smtp$ ss dst 192.168.1.5:443</code></pre><p><strong>(3) Find out connection made by remote 123.1.2.100:http to our local virtual servers</strong></p><pre><code>$ ss dst 123.1.2.100:httpState   Recv-Q Send-Q   Local Address:Port    Peer Address:Port   ESTAB   0      0        75.126.153.206:http   123.1.2.100:35710   ESTAB   0      0        75.126.153.206:http   123.1.2.100:35758 </code></pre><h4 id="Matches-Local-Address-And-Port-Numbers"><a href="#Matches-Local-Address-And-Port-Numbers" class="headerlink" title="Matches Local Address And Port Numbers?"></a>Matches Local Address And Port Numbers?</h4><blockquote><p>ss src ADDRESS_PATTERN</p></blockquote><p><strong>(1) Show all ports connected to local host</strong></p><pre><code>$ ss src localhost</code></pre><p><strong>(2) http (80) port only</strong></p><pre><code>$ ss src localhost:80</code></pre><p>or </p><pre><code>$ ss src localhost:http</code></pre><p>More examples</p><pre><code># Filter by address$ ss -nt dst 74.125.236.178# CIDR notation is also supported$ ss -nt dst 74.125.236.178/16# Address and Port combined$ ss -nt dst 74.125.236.178:80</code></pre><p>Ports can also be filtered with dport/sport options. Port numbers must be prefixed with a “:”.</p><pre><code>$ ss -nt dport = :80State      Recv-Q Send-Q      Local Address:Port        Peer Address:Port ESTAB      0      0             192.168.1.2:56198     108.160.162.37:80    ESTAB      0      0             192.168.1.2:39893      173.255.230.5:80    ESTAB      0      0             192.168.1.2:55043     74.125.236.178:80</code></pre><p>The above is same as &gt; ss -nt dst :80</p><p>Some more examples of filtering</p><pre><code># source address is 127.0.0.1 and source port is greater than 5000$ ss -nt src 127.0.0.1 sport gt :5000# local smtp (port 25) sockets$ sudo ss -ntlp sport eq :smtp# port numbers greater than 25$ sudo ss -nt sport gt :1024# sockets with remote ports less than 100$ sudo ss -nt dport \&lt; :100# connections to remote port 80$ sudo ss -nt state connected dport = :80</code></pre><p>The following operators are supported when comparing port numbers</p><p>[high]<br>&lt;= or le : Less than or equal to port &gt;= or ge : Greater than or equal to port<br>== or eq : Equal to port<br>!= or ne : Not equal to port<br>&lt; or gt : Less than to port &gt; or lt : Greater than to port<br>[/high]</p><h3 id="ss-vs-netstat-speed-comparison"><a href="#ss-vs-netstat-speed-comparison" class="headerlink" title="ss vs netstat speed comparison"></a>ss vs netstat speed comparison</h3><p>Use the time command to run both programs and summarize system resource usage. Type the netstat command as follows:</p><pre><code>$ time netstat -atreal    2m52.254suser    0m0.178ssys     0m0.170s</code></pre><p>Now, try ss:</p><pre><code>$ time ss -atrreal    2m11.102suser    0m0.124ssys     0m0.068s</code></pre><p><strong>Reference</strong><br><a href="http://www.binarytides.com/linux-ss-command/" target="_blank" rel="noopener">http://www.binarytides.com/linux-ss-command/</a><br><a href="https://dougvitale.wordpress.com/2011/12/21/deprecated-linux-networking-commands-and-their-replacements/" target="_blank" rel="noopener">https://dougvitale.wordpress.com/2011/12/21/deprecated-linux-networking-commands-and-their-replacements/</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>find and xargs</title>
      <link href="/Linux/linux-find-xargs/"/>
      <url>/Linux/linux-find-xargs/</url>
      
        <content type="html"><![CDATA[<p><strong>find</strong> is one of the most frequently used command in Linux.<br>The main purpose of <code>find</code> is to find files with specified condition like filename, file type, etc.<br>By default, <code>find</code> will search files in specified directory recursively.</p><ul><li>Classic usage pattern</li><li>Common options</li><li>find and xargs</li></ul><h3 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h3><pre><code>find [path.] [-options] [file_pattern] [-action]</code></pre><p><strong>example</strong></p><pre><code>$ find /data -type f -print</code></pre><p><strong>Dissection of a find expression:</strong></p><pre><code>find start_dir     -options      matching_criteria      -action_to_perform_on_results</code></pre><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p><strong>1. List all files in current and sub directories</strong></p><pre><code>$ find../abc.txt./subdir./subdir/main.php./test.php</code></pre><p><strong>Note:</strong> the command is same as <code>find .</code> or <code>find . -print</code>, when <code>.</code> is omitted, <code>find</code> will search in current directory.</p><p><strong>2. List all files in specific directories</strong></p><pre><code>$ find /data</code></pre><p><strong>3. Searches file by name</strong></p><pre><code>$ find /data -name sql.dat</code></pre><p><strong>4. Searches file by name and ignore case</strong></p><pre><code>$ find /data -iname &quot;*.ExE&quot;</code></pre><p><strong>5. Invert match</strong></p><pre><code>$ find ./project -not -name &quot;*.log&quot;</code></pre><p>or</p><pre><code>$ ind ./project ! -name &quot;*.log&quot;</code></pre><p><strong>6. Combine multiple search criterias</strong></p><pre><code>-a: and -o: or -not:</code></pre><ul><li>And <code>$ find ./project -name &#39;test*&#39; ! -name &#39;*.php&#39;</code></li><li>Or  <code>$ find -name &#39;*.php&#39; -o -name &#39;*.txt&#39;</code></li></ul><p><strong>7. Search hidden files:</strong></p><pre><code>$ find ~ -type f -name &quot;.*&quot;</code></pre><p><strong>8. List out the found files</strong></p><pre><code>$ find . -exec ls -ld {} \;</code></pre><p><code>-exec</code> command must be terminated with a ; to avoid interpretion by the shell (usually we need to type ; or +;)</p><p><strong>9. Redirect error message to /dev/null</strong></p><p>This is useful when you don’t want to see those error messages:</p><p>e.g. If you search files using your account in root directory /, you will be prompted a lot of error message telling you <code>Permission denied</code>.</p><p>like this:</p><pre><code>$ find / -name &quot;*.conf&quot; /sbin/generate-modprobe.conf find: /tmp/orbit-root: Permission denied find: /tmp/ssh-gccBMp5019: Permission denied find: /tmp/keyring-5iqiGo: Permission denied find: /var/log/httpd: Permission denied find: /var/log/ppp: Permission denied </code></pre><p>We can avoid those messages by redirecting them to /dev/null</p><pre><code>$ find / -name &quot;*.conf&quot; 2 &gt; /dev/null </code></pre><p>Or, we can use GNU’s <code>-readable</code> option:</p><pre><code>$ find / -type d -name ! -readable -prune -o -print</code></pre><p>If you want keep other errors but not ‘permission denied’:</p><pre><code>$ find . -name &quot;openssl&quot; 2&gt;&amp;1 | sed &apos;/Permission denied/d;&apos;/or$ find . 2&gt;&amp;1 &gt; files_and_folders | grep -v &apos;Permission denied&apos; &gt;&amp;2</code></pre><h3 id="Common-Options"><a href="#Common-Options" class="headerlink" title="Common Options"></a>Common Options</h3><p><strong>-name</strong>   Find files with filename</p><p>(1) Find filename in /dir and its subdir</p><pre><code>$ find /dir -name filename</code></pre><p>(2) Find all files with .c extension in current dir and its subdir</p><pre><code>$ find . -name &quot;*.c&quot;</code></pre><p>(3) Limit find in specified directories</p><pre><code>$ find /usr /home -name some.conf -type f </code></pre><p><strong>-perm</strong>   </p><p>Find files with certain permission</p><pre><code>$ find . -perm 755 –print </code></pre><p>Find readonly files</p><pre><code>$ find /etc -maxdepth 1 -perm /u=r/etc/opt/etc/aliases/etc/localtime/etc/apparmor.d/etc/cron.hourly</code></pre><p>Find executable files</p><pre><code>$ find /bin -maxdepth 2 -perm /a=x/bin/ping/bin/less/bin/zcat/bin/ps/bin/chmod</code></pre><p><strong>-maxdepth</strong></p><p>Limit depth of directory traversal</p><pre><code>$ find ./test -maxdepth 2 -name &quot;*.png&quot;./app/img/avatar.png./app/main.png$ find ./test -maxdepth 1 -name *.png&quot;./app/main.png</code></pre><p><strong>-user</strong></p><p>Find files belongs to a spesific user</p><pre><code>$ find ~ -user nick</code></pre><p><strong>-group</strong></p><p>Find files belongs to a spesific group</p><pre><code>$ find /data -group gem</code></pre><p><strong>-mtime -n +n</strong></p><p>Find files modified in a range of days, <code>-n</code> means mtime is within n days, <code>-m</code> means mtime is before m days.</p><pre><code>$ find / -mtime +50 –mtime -100</code></pre><p>Find files changed in last N minutes</p><pre><code>$ find /home/alex -cmin -60</code></pre><p>Files modified in last hour</p><pre><code>$ find /home/alex -mmin -60</code></pre><p>Find Accessed Files in Last 1 Hour</p><pre><code>$ find /home/alex -amin -60</code></pre><p><strong>-nogroup</strong></p><p>Find files that have no group, this means the files are not in /etc/groups.</p><pre><code>find / –nogroup -print</code></pre><p><strong>-nouser</strong></p><p>Find files that have no user, this means the files are not in /etc/passwd</p><pre><code>find /home -nouser –print</code></pre><p><strong>-newer file1 ! file2</strong></p><p>Find files that are newer than files1 but older than file2</p><p><strong>-type</strong></p><p>Find files that are a specific type, e.g.</p><p>b - block<br>d - directory<br>c - character<br>p - named pipe<br>l - symbolic link<br>f - regular file<br>s - socket</p><p><strong>Examples:</strong></p><p>(1) List all sub directories in /etc</p><pre><code>find /etc -type d –print </code></pre><p>(2) List all files in current directory, do not list directories. </p><pre><code>find . ! -type d –print</code></pre><p>(3) Find all symbolic links in /etc</p><pre><code>find /etc -type l –print</code></pre><p>(4) Search only files (not directories with the name matched) &amp; only directory (not files with the name matched)</p><p>e.g. </p><p>If we have a file named <code>abc.txt</code> and a directory named <code>abc</code> in current directory, use <code>find -name abc*</code> will list both of them.</p><p>If we want only the file to be listed:</p><pre><code>$ find -type f -name &quot;abc*&quot;</code></pre><p>If we want only the directories to be listed:</p><pre><code>$ find -type d -name &quot;abc*&quot;</code></pre><p><strong>-size</strong></p><p>Find files that have n block size (c means bytes)</p><p>(1) Find files of given size</p><pre><code>$ find / -size 50M</code></pre><p>(2) Find files in a size range</p><pre><code>$ find / -size +50M -size -100M</code></pre><p>(3) Find largest and smallest files</p><pre><code>// display the 5 largest file in the current directory and its subdirectory$ find . -type f -exec ls -s {} \; | sort -n -r | head -5// The 5 smallest files$ find . -type f -exec ls -s {} \; | sort -n | head -5</code></pre><p>(4) Find empty files and directories</p><pre><code>// empty files$ find ~ -type f -empty// empty directories$ find ~ -type d -empty</code></pre><p><strong>-depth:</strong></p><p>When finding files, process each directory’s contents before the directory itself</p><pre><code>$ find / -name &quot;CON.FILE&quot; -depth –print</code></pre><h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p><strong>-delete</strong></p><p>Find files named core in or below the directory /tmp and delete them, but more efficiently than<br><code>find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f</code><br>(because we avoid the need to use fork(2) and exec(2) to launch rm and we don’t need the extra xargs process)</p><pre><code>$ find /tmp -depth -name core -type f -delete</code></pre><p><strong>-exec command ;</strong><br><strong>-exec command {} +</strong></p><p><code>-exec</code> is used to execute commands on the found files, must be terminated with <code>\;</code>.</p><pre><code>$ find * -exec sh -c &apos;echo &quot;{}&quot;&apos; \;$ find . -type f -name &quot;*.jpg&quot; -exec rm -f {} +or $ find . -type f -name &quot;*.jpg&quot; -exec rm -f {} \;</code></pre><p>Rename all files that have spaces in their filename and replace it with <code>_</code></p><pre><code>$ find . -type f -iname “*.mp3″ -exec rename “s/ /_/g” {} \; </code></pre><p><strong>-fls file</strong></p><p>like -ls but write to file like -fprint.</p><p><strong>-ls</strong></p><p>list  current file in ls -dils format on standard output</p><p><strong>-print</strong></p><p>print the full file name on the standard output, followed by a null newline</p><p><strong>-print0</strong></p><p>print the full file name on the standard output, followed by a null character</p><p><strong>-prune</strong></p><p>if the file is a directory, do not descend into it. If -depth is given, false; no effect.<br>Since -delete implies -depth, -prune will have no effect when -delete specified.</p><p>e.g. Exclude a directory when searching (If specify -depth, -prune will be ignored).</p><pre><code>$ find /apps -path &quot;/apps/bin&quot; -prune -o –print$ find /usr/sam -path &quot;/usr/sam/dir1&quot; -prune -o –print</code></pre><p><strong>-quit</strong></p><p>Exit  immediately</p><br><h4 id="find-and-exclude-specific-directories"><a href="#find-and-exclude-specific-directories" class="headerlink" title="find and exclude specific directories"></a>find and exclude specific directories</h4><p>&lt;1&gt; use “-prune -o -print”</p><pre><code>$ find . -type f -name &quot;*.cpp&quot; -path &quot;./tmp/*&quot; -o -print | xargs wc -l</code></pre><p>&lt;2&gt; use “! -path”</p><pre><code>$ find . -type f -name &quot;*.cpp&quot; ! -path &quot;./tmp/*&quot; ! -path &quot;./test/*&quot;</code></pre><p>&lt;3&gt; use “grep -v”</p><pre><code>$ find . -name &quot;*.go&quot; | egrep -v &quot;_vendor&quot; | xargs wc -l</code></pre><p>or</p><pre><code>$ find . -name &quot;*.go&quot; | egrep -v &quot;_vendor|test&quot; | xargs wc -l</code></pre><h3 id="find-and-xargs"><a href="#find-and-xargs" class="headerlink" title="find and xargs"></a>find and xargs</h3><p>When we use find command combined with <code>-exec</code>, find will send all matched files together to the commands following the <code>-exec</code>. This may cause problem as there is a limit to the length of the parameter that exec can accept in some system, in that case,<br>after a couple of minitue that find has run, it get overflowed. A common error for this is <code>argument list is too long</code> or <code>arguments are overflowed</code>.</p><p>Also, in some system <code>-exec</code> will load a process (<code>fork</code>) for each matched file instead of fetching all files together as an argument to the command,<br>therefore reduce the system performance.</p><p>This the situation where <strong><code>xargs</code></strong> command comes for rescue.</p><p><strong><code>xargs</code></strong> is extremely powerful when cooperated with <code>find</code> command, it fetch only a part of the matched filed from <code>find</code><br>(not like <code>-exec</code> which will fetch all at a time), process them, and then fetch another part, until there are no files left.</p><p><strong>Examples</strong></p><p>(1) Find all files and print the file info</p><pre><code>find . -type f | xargs file </code></pre><p>(2) Find core dump info and save to a fild</p><pre><code>find / -name &quot;core&quot; -print | xargs echo &quot;&quot; &gt;/tmp/core.log</code></pre><p>(3) Used combined with grep</p><pre><code>find . -type f -print | xargs grep &quot;hostname&quot;</code></pre><p>(4) Delete all files that are modified 3 days before</p><pre><code>find ./ -mtime +3 -print | xargs rm -f –r</code></pre><p>(5) Delete all files that have size 0</p><pre><code>find ./ -size 0 | xargs rm -f &amp;</code></pre><h3 id="More-about-xargs"><a href="#More-about-xargs" class="headerlink" title="More about xargs"></a>More about xargs</h3><p><code>xargs</code> can also work with other commands, e.g. ls</p><p>Delete all files that contain digit</p><pre><code>$ ls | grep -E &apos;[0-9]&apos; | xargs rm</code></pre><p>Note this wouldn’t work if there are too many files produced by <code>ls</code> and the combined length of the filenames exceeds 128 KiB,<br>use <code>find</code> command to go round the limit.</p><p><strong>Common options:</strong></p><pre><code>-a file             Read file from file instead of standard input-0                  same with --null, Input items are terminated by a null character instead of by whitespace, and the quotes and backslash are not special                    (every character is taken literally).-d delim            Input items are terminated by the specified character. Quotes and backslash are not special; every character in  the input is taken literally.-I replace-str      Replace occurrences of replace-str in the initial-arguments with names read from standard input.-i                  Deprecated, use -I instead.-x                  Exit if the size (see the -s option) is exceeded.</code></pre><p><strong>Examples:</strong></p><p><strong><code>-0</code></strong> If the filename contains a special character, xargs will fail, in that case we should use <code>-0</code> option</p><pre><code>$ find -name &apos;*.bak&apos; -print0 | xargs -0 rm</code></pre><p>Generates a compact listing of all the users on the system</p><pre><code>$ cut -d: -f1 &lt; /etc/passwd | sort | xargs echo</code></pre><p>When we use the <code>-I</code> option, each line read from the input is buffered internally.<br>This means that there is an upper limit on the length of input line that xargs will accept when used with the <code>-I</code> option.<br>To work around this limitation, we can use the <code>-s</code> option to increase the amount of buffer space that xargs uses,<br>and we can also use an extra invocation of xargs to ensure that very long lines do not occur.  </p><p>For example:</p><pre><code>ls | xargs -s 50000 echo | xargs -I &apos;{}&apos; -s 100000 rm &apos;{}&apos;</code></pre><p>Here, the first invocation of xargs has no input line length limit because it doesn’t use the -i option.<br>The second invocation of xargs does have such a limit, but we have ensured that the it never encounters a line which is longer than it can handle.</p><p>This is not an ideal solution. Instead, the <code>-i</code> option should not impose a line length limit, which is why this discussion appears in the BUGS section.<br>The problem doesn’t occur with the output of find(1) because it emits just one filename per line.</p><p><strong>Invoking the shell from xargs</strong></p><pre><code>$ find . -type f | xargs bash -c &apos;exec vim &quot;$@&quot; &lt; /dev/tty&apos; vim$ find /foo -maxdepth 1 -atime +366 -print0 | xargs -r0 sh -c &apos;mv &quot;$@&quot; /archive&apos; move</code></pre><p><strong>Explanations:</strong></p><p>Here, a shell is being invoked. There are two shell instances to think about.<br>The first is the shell which launches the <code>xargs</code> command.<br>The second is the shell launched by xargs (in fact it will probably launch several, one after the other, depending on how many files need to be archived).<br>We’l refer to this second shell as a subshell.</p><p>We use the <code>-c</code> option of sh, its argument is a shell command to be executed by the subshell.<br>Along with the rest of that command, the <code>$@</code> is enclosed by single quotes to make sure it is passed to the subshell without being expanded<br>by the parent shell. It is also enclosed with double quotes so that the subshell will expand <code>$@</code> correctly even if one of the file names contains a space or newline.</p><p>Another reason to use the sh -c construct could be to perform redirection:</p><pre><code>$ find /usr/include -name &apos;*.h&apos; | xargs grep -wl mode_t | xargs -r sh -c &apos;exec vim &quot;$@&quot; &lt; /dev/tty&apos; vim</code></pre><p>Notice that we use the shell builtin exec here. That’s simply because the subshell needs to do nothing once <code>Vim</code> has been invoked.<br>Therefore instead of keeping a sh process around for no reason, we just arrange for the subshell to exec <code>Vim</code>, saving an extra process creation.</p><p>Sometimes, though, it can be helpful to keep the shell process around:</p><pre><code>$ find /foo -maxdepth 1 -atime +366 -print0 | xargs -r0 sh -c &apos;mv &quot;$@&quot; /archive || exit 255&apos; move</code></pre><p>Here, the shell will exit with status 255 if any mv failed. This causes xargs to stop immediately.</p><p><strong>parallel</strong></p><p><a href="https://www.gnu.org/software/parallel/" target="_blank" rel="noopener">GNU parallel</a> help utilize multi CPU cores to speed the processing when cooperate with <code>xargs</code> command. </p><p>Assume we want to compressing files, we know that compressing a bounch of files could be time consuming operation.<br>You may want to compress several files at the same time, to make better use of the multiple CPU cores,<br>For this, you can use the GNU <code>parallel</code> tool.</p><pre><code>$ find -name &apos;*.bak&apos; -print0 | xargs -0 parallel gzip --</code></pre><p>This example takes a bit of unravelling:</p><ul><li>find writes the pathnames of matching files, delmited by NUL bytes, to its stdout</li><li>xargs reads files from its stdin, and assumes NUL delimiters</li><li>the command to run is parallel gzip –</li><li>the – tells parallel that it should run gzip on any arguments following the –, or in other words,<br>the – separates the command to be run from the filenames to give  the command as arguments</li><li>parallel starts an instances of the command for each CPU core, and gives each instance the next filename argument;<br> when an instance terminates, it starts a new instance with the next filename argument, until it’s run the command for each argument</li></ul><p>This should be much more efficient than running one gzip at a time. </p><p><strong>Reference</strong></p><p><a href="http://www.th7.cn/system/lin/201404/53421.shtml" target="_blank" rel="noopener">http://www.th7.cn/system/lin/201404/53421.shtml</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Consensus - Leader Election Algorithms</title>
      <link href="/Distributed-System/distributed-system-consensus/"/>
      <url>/Distributed-System/distributed-system-consensus/</url>
      
        <content type="html"><![CDATA[<p>在分布式系统中，需要在多个节点之间保持数据的一致性，通常需要有一个协调者，这个协调者（Coodinator）作为整个集群的出口单独对外提供服务。<br>通常，我们需要在集群中的所有节点中选出这么一个节点，作为所有节点的 Leader 来承担这个工作。Leader 只能有一个，其他节点为 Follower。</p><p>Leader election 需要满足两点：</p><ul><li>Safety   每一个节点要么不知道结果，要么就知道正确结果。不存在中间结果。</li><li>Liveness 选举过程最终会结束，每一个节点都清晰的知道选举结果。</li></ul><br><h3 id="几种不同的选举算法简介"><a href="#几种不同的选举算法简介" class="headerlink" title="几种不同的选举算法简介"></a>几种不同的选举算法简介</h3><br>#### Ring leader election环算法 processes组成了一个环，第i个 process `p_i` 可以和 `p_(i+1)` modN 通信。<p>如果进程 i 发现原来的 leader 挂了，它就会发起选举，发送一个包含自己 ID a_i “Election” 的信息。<br>然后当某个进程 j 收到了这个信息的时候，会将这个 <code>a_i</code> 与自己的 ID <code>a_j</code> 比，如果 <strong>a_i &gt; a_j</strong>，继续转发这条消息，如果 <strong>a_i &lt; a_j</strong> 且它之前没有转发过消息，就把 a_i 取代掉然后把消息发送出去。<br>如果发现收到的标识符和自己的一样，代表自己成为 leader，然后把自己当选的信息发送出去。</p><p>最坏情况分析：一个进程发起选举，如果它的上一个进程具有最大标识符，则选举消息到达上一个进程需要（N—1）次传递，然后消息又要 N 次才能宣布它当选，最后需要N个消息告诉大家它当选了，所以需要（3N-1）个消息。最好情况就是发起选举的进程就是 leader，只需要（2N）个消息。<br>如果有多个进程同时发起选举，那么只有具有最大ID的进程会完成选举。</p><p>上述的环算法实用价值很少，因为在选举过程中如果有进程崩溃，选举就无法完成，不符合 liveness 的要求。</p><p>实际生产环境中的 Leader Election 使用 Paxos 或者 Raft 的方式来选举。</p><br>#### Google Chubby A system for locking每个 process 最多选举一次，得到最多选票且大于某一数值的 process 当选。 chubby 中的锁服务使用 paxos 作为 chubby cell 中的一致性算法<br>#### Zookeeper Atomic Broadcas<p>Paxos的变种Zab (Zookeeper Atomic Broadcast)。必须始终保持有leader。<br>每个进程都向ZK文件系统中写入自己的ID,只要保证写入是原子性的，就把最大ID的进程选为 leader.<br>每个进程都监视着正好比自己ID高的进程，如果那个进程是leader然后挂掉了，那么它就成为新的 leader.<br>Apache Zookeeper Centralized service for maintaining configuration information</p><br>#### Bully Algorithm 霸道算法 假设系统是同步的，所有进程都可以互相通信。<p>当某一进程发现 leader 挂掉，如果自己 ID 最大，就宣布自己是 leader，否则向 ID 比自己高的进程发起选举。<br>发起选举如果没有收到回应，就宣布自己是 leader，收到了回应就等待比自己ID大的进程宣布结果。当一个进程收到从ID比自己低的进程发来的选举消息时，就向更高的进程发起选举。</p><p>最坏时间复杂度分析：只需5个消息传递时间</p><ul><li>最小ID进程发起选举</li><li>第二大ID进程回应</li><li>第二大ID进程向最大ID进程发起选举</li><li>最大ID进程无回应，timtout</li><li>第二大ID进程宣布当选</li></ul>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Multi Raft</title>
      <link href="/Distributed-System/distributed-system-multi-raft/"/>
      <url>/Distributed-System/distributed-system-multi-raft/</url>
      
        <content type="html"><![CDATA[<p>As the number of cluster node increasing, single raft will suffer performance penalty as the more nodes participate in the leader election and decision making the more time will be consumed for<br>the cluster to operate.</p><p>Multi-Raft is therefore be developed to scale the original raft consensus algorithm.</p><p>Todo:</p><p><a href="https://www.cockroachlabs.com/blog/scaling-raft/" target="_blank" rel="noopener">https://www.cockroachlabs.com/blog/scaling-raft/</a></p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MVCC</title>
      <link href="/Distributed-System/distributed-system-mvcc/"/>
      <url>/Distributed-System/distributed-system-mvcc/</url>
      
        <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control" target="_blank" rel="noopener">MVCC</a> (Multi-Version Concurrency Control) 多版本并发控制在分布式系统中是一个很重要的技术手段。<br>在传统的分布式并发读写一个共享数据时，如果要保证读写的一致性，需要加锁来控制单一时间只有一个访问者在读写数据，然而当遇到一个长时间的读操作时，这时候写入操作将不得不进行长时间的等待。<br>这种模式下，数据库的读写性能非常的低效。在 MVCC 中，通过对原数据进行多个拷贝，用版本号来标记读或写的先后顺序，从而有效地提升整个系统的性能。</p><p>具体场景如下：<br>每当想要更改或者删除某个数据对象时，DBMS 不会在原地去删除或这修改这个已有的数据对象本身，而是创建一个该数据对象的新的版本，这样的话同时并发的读取操作仍旧可以读取老版本的数据，而写操作就可以同时进行。这个模式的好处在于，可以让读取操作不再阻塞，事实上根本就不需要锁。这种特性非常的高效，以至于在很多主流的数据库中都采用了 MVCC 的实现，比如说 PostgreSQL，Oracle，Microsoft SQL Server 等。</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Raft</title>
      <link href="/Distributed-System/distributed-system-raft/"/>
      <url>/Distributed-System/distributed-system-raft/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr><p>Raft 是分布式一致性协议 Paxos 的一个变种，最早是在 2013 年由斯坦福大学 的 PhD 学生 Diego Ongaro 和他的导师 John Ousterhout 在论文“In Search of an Understandable Consensus Algorithm”中提出。根据论文中的介绍，其主要目的就是为了阐述一种易于理解的分布式一致性算法，把易于理解放于作为最主要的目标，因此，借于 Raft 协议的易于理解的特性，这篇论文得到了大量的赞誉和推崇。目前，基于 Raft 协议所产生的变种协议也很多（比如：Multi-Raft 等），而在工业界，基于 Raft 原理所实现的一致性协议更是得到了广泛的应用（比如 etcd）。</p><p>Raft 协议天生简单而易与理解，这篇文章我将根据其原始论文来详细解读 Raft 协议，由于是采用论文导读的方式，因此我会大量引用论文原句来进行解析。</p><h3 id="Raft-协议"><a href="#Raft-协议" class="headerlink" title="Raft 协议"></a>Raft 协议</h3><p>一个 Raft 集群包含若干个服务器节点。假如服务器节点数为n个（n通常是&gt;=3的奇数），这允许整个系统容忍个(n-1)/2节点的失效。</p><p>Raft 协议的理论部分主要分为三个方面：</p><ul><li>Leader Election</li><li>Log Replication</li><li>Safty</li></ul><br><h4 id="1-Leader-Election-领导者选举"><a href="#1-Leader-Election-领导者选举" class="headerlink" title="1. Leader Election 领导者选举"></a>1. Leader Election 领导者选举</h4><p>Raft 把时间分为terms. 每一个 term 开始时都进行一次选举. 每一个 term 期间最多有一个leader, 或者没有 leader。</p><p><img src="http://daizuozhuo.github.io/images/server-states.png" alt=""></p><p>Raft servers communicate using remote procedure calls (RPCs), and the basic consensus algorithm requires only two types of RPCs.  </p><p><strong>(1). RequestVote</strong>           由 <strong>Candidate</strong> 在 选举期间发起<br><strong>(2). AppendEntries</strong>         由 <strong>Leader</strong> 发起，用于 replicate log entries 和 发送心跳</p><p>还有一个 RPC 请求，作用是在节点之间传输快照信息（transferring snapshots between servers）。<br>并发的重试 RPC 请求 Servers retry RPCs if they do not receive a response in a timely manner, and they issue RPCs in parallel for best performance.</p><p>Leaders send <strong>periodic heartbeats</strong> (<strong>AppendEntries RPCs</strong> that carry no log entries) to all followers in order to maintain their authority.</p><p>Followers only respond to requests from other servers.<br>If a follower receives no communication in a period of time (e.g. 150ms - 300ms), it becomes a candidate and initiates an election.<br>If a follower receives no communication over a period of time called the <strong>election timeout</strong>, then it assumes there is no viable leader and <strong>begins an election to choose a new leader</strong>.</p><h5 id="1-选举过程"><a href="#1-选举过程" class="headerlink" title="(1) 选举过程"></a>(1) 选举过程</h5><p>先把自己的 term ID 加1，然后从 Follower 状态变为 Candidate 状态，每个 Candidate 都会获得一个随机的 term timeout 在 150 到 300 ms 之间。<br>当一个 Candidate 在 Timeout 到期前收到了大多数人的 Votes，就赢得这次选举。 每个 Candidate 在自己的 term 期间只能 vote 一票，先收到谁的 request 就先投票给谁。<br>一旦一个 Candidate 赢得选举，它就开始发送心跳信息给其他所有 servers 来维持统治。</p><p>在选举期间，Candidate 可能会收到其他也宣称是 leader 的 Server 发来 AppendEntries rpc 请求。<br>如果这个 rpc 请求中所附的 term id 大于等于当前 Candidate 的 term id，那么认为那个 leader 是合法的，并立即把自己置为 Follower 状态。<br>如果这个 rpc 请求所附的 term id 小于当前 Candidate 的 term id，那么就拒绝那个请求，并把自己继续维持在 Candidate 状态。 简单来说，Term ID 越大表示状态越新。</p><h5 id="2-选举结果"><a href="#2-选举结果" class="headerlink" title="(2) 选举结果"></a>(2) 选举结果</h5><p>如果没有任何节点赢得当前 term 的选举（这种情况可能会在很多 followers 同时变成 candidates 时发生，因为 votes 可能被 split（平分），导致没有 candidate 赢得多数票），<br>这种情况发生的时候，每个 candidate 都会 timeout（随机 Timeout 值），并且开始一轮新的选举： 把自己的 term id 加1，发送新的 RequestVote RPCs。<br>Raft 使用了一个随机的 timeout 时间 150 ms - 300 ms，这样可以在大多数情况下，选举失败时只有一个 server 会 timeout。</p><br><h4 id="2-Log-Replication"><a href="#2-Log-Replication" class="headerlink" title="2. Log Replication"></a>2. Log Replication</h4><p>选举结束之后，Leader 就开始接受 Clients’ requests。<br>Leader 每接受一个 request，就在 Log 中写一条记录（appends the command to its log as a new entry, then issues AppendEntries RPCs in parallel to each of the other servers to replicate the entry.）。<br>一旦 log entry 被安全的 replicated，leader 就 applies the entry to its state machine and returns the result of that execution to the client. 如果这时候 follower 崩溃了，那么 leader 会无限地发送 AppendEntries RPC 请求。</p><p>Log 的格式：<br>Each log entry stores a state machine command along with the term number.<br>Each log entry also has an integer index identifying its position in the log.</p><p><strong>什么时候认为 log 是 commited 的呢？</strong><br>A log entry is committed once the leader that created the entry has replicated it on a majority of the servers<br>一旦当前这条 log 被认为是 commited，那么这条 log 之前记录的所有 log 都会被 commited，包括由其他 leader 所记录的 log。</p><p><strong>如何消除 leader  的 log 和 follower 的 log 不一致的情况？</strong></p><p>log 的 index 是按照数字从0开始顺序递增的，下一个将要插入的 log entry 的位置称为 nextIndex。<br>当一个新 leader 即位之后，他会发送 AppendEntries RPC Check 来检查 follower 的 log entry 是否跟 leader 的一致，<br>如果不一致，那么 follower 会 reject。然后 leader 会递减当前 index 然后继续发送 check，直到两者一直，然后 Leader 就把从该一致点的 index 到后面所有的 log entries 都发送给 follower，覆盖 follower 后面所有的 log entries，从而保证 leader 和 follower 的 log entries 一致。</p><p>一步一步递减 index 的方式可能会导致大量的 rejects，非常低效。如何减少被 reject 的次数？<br>Leader 发送 AppendEntries RPC check 时，带上 term Id 和 这个 term 期间的第一条 log 的 index。这样的话就可以一次性跳过整个 term 的 entries。</p><p><strong>注意：</strong>Leader 永远不会覆盖或者删除自己的 log entries。</p><br><h4 id="3-Safety"><a href="#3-Safety" class="headerlink" title="3. Safety"></a>3. Safety</h4><p>安全性的意思是指一致性协调的最终结果必须是有效的，并且在所有节点都能达到一致的结果。<br>虽然前面描述了 Raft 算法是如何选举和复制日志的。然而，到目前为止上面所描述的机制并不能充分的保证每一个状态机会按照相同的顺序执行相同的指令。</p><p>例如，一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。</p><p>针对这种情况，Raft 使用了一种简单的方法，它可以保证所有之前的任期号中已经提交的日志条目在选举的时候都会出现在新的领导人中，不需要传送这些日志条目给领导人。</p><p>这意味着日志条目的传送是单向的，只从领导人传给跟随者，并且领导人从不会覆盖本地日志中已经存在的条目。</p><p>下面就具体分析几个例子来阐述 Raft 协议为何能在各种情况下都保证 Safety。</p><p><strong>（1） Leader Crash</strong></p><p>可能出现的情况，leader crash 之后，new leader 不包含前一个 leader 所有的 commited entries，从而导致不一致。</p><p>Raft 提出了一些 restriction 去保证 new leader 包含上一个 leader 所有的 commited entries。<br>The restriction ensures that the leader for any given term contains all of the entries committed in previous terms<br>把这个 restriciton 称为：<strong>Leader Completeness Property</strong>。</p><p>Raft uses the voting process to prevent a candidate from winning an election unless its log contains all committed entries.<br>一个 Candidate 要想选举成为 new leader，那么它必然需要联系大多数 servers，那么至少有一个 server 会包含所有的 commited entries。<br>如果这个 Candidate 的 log 比这个 marjority 中所有的 server 的 log 都要新，那么它就包含了所有的 committed log entries。</p><p><strong>这个 restriction 的具体流程就是：</strong><br>Candidate 发送 RequestVote  RPC 时会把自己的 log 信息附上，收到请求的 server 会检查 log 是否比自己当前的 log 更加 up-to-date，如果不，则否决，反之同意。</p><p><strong>如何判定两个 log 谁更 up-to-date？</strong><br>比较 last entry 所在的 term id 以及 index。</p><p>当 leader crash 时，还有可能出现的一种情况是：<br><img src="/image/464e4104-a67a-486c-8fbd-939665becdc7.png" alt=""></p><p>根据 raft commit 原则，只有当 log 被大多数 server 确认 replicated 之后，才认为可以 commit了，这时候 leader 才会 apply。如果在 apply 之前正好 crash 了。那么就会出现如上图所示的情况。<br>如果所示，S1 是 Term T 的 leader，称之为 leader T，当它 crash 时，log entries 已经 replicated 到了大部分节点中（s1, s2, s3）<br>这时候 S5 参加选举，在 term U 中被选举为 new leader，我们称之为 leader U。</p><p>这时候有一个关键信息，S5 需要获得多数 server 才有可能成为 leader，那么必然包含一个 server，这个 server 有上次 committed log 信息。比如上图中的 S3 节点。<br>而且，这个 committed log entry 必然在它同意投票给 S5 之前发生，因为只有这样它（S3）的 term id 才不会大于 S5 的 term id，如果 S3 的 term id 大于 S5 的，必然会拒绝 S5 的 RequestVote RPC。</p><p>这里有个矛盾的地方就是，new leader 必须包含所有 up-to-date 的 entry，而 S5 却比 S3 少了一个 log entry (AE)。<br>所以，显然，S5 不可能被选举为 leader。这就保证了上述的 <strong>Leader Completeness Property</strong> 的正确性。也即 Safty 得到了保证。</p><p><strong>（2） Candidate or Follower crashes</strong></p><p>这种情况比 leader 发生 crash 要简单很多，follower 和 candidate（采用的是相同的处理方法） 一旦 crash，其他 server 会 indefinitely 发送 RequestVote 或 AppendEntries 给它。<br>如果 crash 的 server 重启了，那么 RPC 请求就能够完成。<br>如果 Follower 成功收到 RPC 请求, 但是在其 respond 之前 crash 了，那么它重启之后还会收到相同的 RPC 请求。<br>根据论文所述，由于 Raft RPC 是幂等（idempotent）的，因此这种情况下的 crash has no harm。Safty 不会被违背。</p><p><strong>Timing and Availability</strong></p><p><strong>Cluster MemberShip changes</strong></p><h4 id="4-Log-Compaction"><a href="#4-Log-Compaction" class="headerlink" title="4. Log Compaction"></a>4. Log Compaction</h4><p>In a practical system, it cannot grow without bound. As the log grows longer, it occupies more space and takes more time to replay.<br>log 太多最终会导致 avaliability 问题，必须要想办法丢弃那些过时的 log。</p><p>Raft 采用了 snapshotting 的方式去压缩/减少日志。<br>In snapshotting, the entire current system state is written to a snapshot on stable storage, then the entire log up to that point is discarded.</p><p><img src="/image/663a7241-a835-4c09-a18a-01cc93043ebc.png" alt=""></p><p><strong>Snapshotting technique is also used in Chubby and ZooKeeper</strong></p><p>以上就是 Raft 算法的整个运转机制。</p><h5 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h5><p>一些 Raft 相关的资料:</p><p><a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">raft original paper</a><br><a href="https://github.com/maemual/raft-zh_cn" target="_blank" rel="noopener">raft 中文版</a><br><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">visualization</a><br><a href="https://raft.github.io/" target="_blank" rel="noopener">a list a open source implementation</a></p><p>[0] - <a href="https://ramcloud.stanford.edu/~ongaro/userstudy/" target="_blank" rel="noopener">https://ramcloud.stanford.edu/~ongaro/userstudy/</a><br>Raft Video - <a href="https://www.youtube.com/watch?v=YbZ3zDzDnrw" target="_blank" rel="noopener">https://www.youtube.com/watch?v=YbZ3zDzDnrw</a><br>Paxos Video - <a href="http://www.youtube.com/watch?v=JEpsBg0AO6o&amp;feature=youtu.be" target="_blank" rel="noopener">http://www.youtube.com/watch?v=JEpsBg0AO6o&amp;feature=youtu.be</a><br>Results: <a href="https://ramcloud.stanford.edu/~ongaro/userstudy/graphs.pdf" target="_blank" rel="noopener">https://ramcloud.stanford.edu/~ongaro/userstudy/graphs.pdf</a><br><a href="http://www.shsnc.com/show-109-1017-1.html" target="_blank" rel="noopener">http://www.shsnc.com/show-109-1017-1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>grep and regular expression</title>
      <link href="/Linux/linux-grep/"/>
      <url>/Linux/linux-grep/</url>
      
        <content type="html"><![CDATA[<p><strong>grep</strong> command is used to list all files that contain the searching pattern.</p><h3 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h3><p>grep -[acinv] ‘pattern’ filename</p><h3 id="Common-Options"><a href="#Common-Options" class="headerlink" title="Common Options"></a>Common Options</h3><p><strong>-c</strong>, –count                 Output number of matched line<br><strong>-i</strong>, –ignore-case           Ignore case<br><strong>-n</strong>, –line-number           Prefix each line of output with the 1-based line number within its input file<br><strong>-q</strong>, –quiet                 Do not write anything to standard output.  Exit immediately with zero status if any match is found<br><strong>-s</strong>, –no-messages           Suppress error messages about nonexistent or unreadable files.<br><strong>-h</strong>, –no-filename           Suppress the filename for each match</p><p><strong>-o</strong>, –only-matching         Print only the matched part of a matchging line<br><strong>-l</strong>, –files-with-matches    Print only the matched filename<br><strong>-L</strong>, –files-without-match   Print only the non-matched filename<br><strong>-v</strong>, –invert-match          Output non-mathed lines<br><strong>-r</strong>, –recursive             Read all files under each directory, recursively.<br>–color[=WHEN]              Display the matched string in color. WHEN is never, always, or auto.</p><p><strong>Examples:</strong></p><pre><code>$ grep -c pattern filename                   Count how many lines contain the pattern$ grep -n pattern filename                   Display the matched line prefixed with line number, same as nl files | grep &apos;pattern&apos;$ grep -v pattern filename                   List lines that do not contain the pattern$ grep -i pattern filename                   Search all lines for pattern, ignoring cases$ grep -l pattern filename                   List only filenames that have matched pattern. e.g grep -l &apos;main&apos; *.c will list file name whose contents main() function$ grep -L pattern filename                   List filenames that do not have matched pattern$ grep -w pattern filename                   Match the whole word instead of only a part of string$ grep -C number pattern filename            Display above and below `number` of lines for the matched line$ grep pattern1 | pattern2 filename          Display lines that have match for pattern1 or pattern2$ grep pattern1 filename | grep pattern2     Display lines that have match for pattern1 and pattern2$ grep &apos;pattern&apos; d*                          Search for pattern in all files whose name beging with d $ grep &apos;pattern&apos; file1 file2 file3           Search for pattern in file1, file2 and file3</code></pre><h3 id="More-options"><a href="#More-options" class="headerlink" title="More options"></a>More options</h3><p><strong>-d Action, –directories=Action</strong>, Here Action can have 3 values: <strong>read</strong>, <strong>skip</strong>, <strong>recurse</strong></p><ul><li>read  default action</li><li>skip  directories are skipped</li><li>recurse reads all files under each directory recursively</li></ul><p><strong>–exclude=Glob</strong> Skip files whose base name matches GLOB (using wildcard matching).<br><strong>–exclude-dir=DIR</strong> Exclude directories matching the pattern DIR from recursive searches.<br><strong>–include=GLOB</strong> Search only files whose base name matches GLOB</p><h4 id="How-to-search-a-pattern-in-a-directory-recursively"><a href="#How-to-search-a-pattern-in-a-directory-recursively" class="headerlink" title="How to search a pattern in a directory recursively?"></a>How to search a pattern in a directory recursively?</h4><p>Since grep use pattern matching to search files, if the directory we are searching does not contain any sub directories, we can simply use <code>*</code> to match all files in current directories:</p><pre><code>$ grep &apos;pattern&apos; *</code></pre><p>However, if the directory contains any sub directory, grep will fail and prompt error messages like <span class="myfont">‘grep: bin: Is a directory’</span>, We can use <strong>-r</strong> options or <strong>-d recurse</strong> to search recursively in sub directories</p><pre><code>$ grep -r &apos;pattern&apos; * $ grep -d recurse &apos;pattern&apos; *</code></pre><p>or we can use <code>find</code> command to cooperate with <code>grep</code>.</p><pre><code>$ find . -type f | xargs grep -i &apos;pattern&apos;</code></pre><h2 id="Regular-expressions"><a href="#Regular-expressions" class="headerlink" title="Regular expressions"></a>Regular expressions</h2><p>Although <code>-E</code> option or <code>egrep</code> command provides <code>Regular expression extensions</code> for grep, it is recommaned to use <code>grep -P</code> to process regular expression matching as it<br>provides even more features.</p><p>for example, <code>\d</code> is supported in <code>grep -P</code> while not supported in <code>grep -E</code>.to use digit pattern with <code>-E</code> we have to use <code>[0-9]</code> or <code>[:digit:]</code>.</p><p>Below is a list of posix character classes:</p><pre><code>[:alnum:][:alpha:][:cntrl:][:digit:][:graph:][:lower:][:print:][:punct:][:space:][:upper:][:xdigit:]</code></pre><p><strong>Example:</strong></p><pre><code>$ echo -e &quot;One\n123\n\t&quot; | sed -n &apos;/[[:alpha:]]/ p&apos;</code></pre><h3 id="Standard-Regular-Expression-Symbols"><a href="#Standard-Regular-Expression-Symbols" class="headerlink" title="Standard Regular Expression Symbols"></a><strong>Standard Regular Expression Symbols</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">^           Match beginning of input</span><br><span class="line">$           Match end of input</span><br><span class="line">[]          Match a set of characters</span><br><span class="line">[^]         Match characters that are not in this set</span><br><span class="line">[-]         Character range</span><br><span class="line">.           Match any single character except line terminators: \n, \r</span><br><span class="line">*           Match zero or more occurrence of the preceding character</span><br><span class="line">?           Match zero or one occurrence of the preceding character</span><br><span class="line">+           Match one or more of the preceding character</span><br><span class="line">&#123;n&#125;         Match exact n occurrences of the preceding character</span><br><span class="line">&#123;n,&#125;        Match at least &quot;n&quot; occurrences of the preceding character</span><br><span class="line">&#123;m, n&#125;      Match at least &quot;m&quot; and at most &quot;n&quot; occurrences of the preceding character.</span><br><span class="line">|           The Pipe character represents logical `OR` operation</span><br><span class="line">\(..\)      Group the mathcing pattern</span><br><span class="line">\&lt;          Anchor the beging of a word</span><br><span class="line">\&gt;          Anchor the end of a word</span><br></pre></td></tr></table></figure><h3 id="Meta-characters"><a href="#Meta-characters" class="headerlink" title="Meta characters"></a><strong>Meta characters</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\b          Word Boundary. e.g. <span class="string">"\the\b"</span> matches only the word <span class="string">"the"</span>, but not <span class="string">"there"</span>, <span class="string">"wether"</span>, etc. </span><br><span class="line">\B          Non-word Boundary. e.g. <span class="string">"\the\B"</span> matches <span class="string">"these"</span>, <span class="string">"their"</span>, etc. but not <span class="string">"the"</span></span><br><span class="line">\s          Single Whitespace</span><br><span class="line">\S          Single Non-Whitespace</span><br><span class="line">\w          Single Word Character, i.e. alphabetical characters, digits, and underscore _</span><br><span class="line">\W          Single Non-Word Character.</span><br></pre></td></tr></table></figure><p><strong>Example:</strong></p><pre><code>`$ echo -e &quot;One\n123\n1_2\n&amp;;#&quot; | sed -n &apos;/\W/ p&apos;`&amp;;#</code></pre><h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions:"></a><strong>Extensions:</strong></h3><p>In basic regular expressions the meta-characters ?, +, {, |, (, and ) lose their special meaning, instead they have to be used after escaped ?, +, {, |, (, and ).However, in extension definition, they can be used naturally without escaping.</p><h3 id="Perl-Extensions"><a href="#Perl-Extensions" class="headerlink" title="Perl Extensions"></a><strong>Perl Extensions</strong></h3><p><code>grep -P</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\d  [0-9]           digit</span><br><span class="line">\D  [^0-9]          nondigit</span><br></pre></td></tr></table></figure><p><code>grep -F</code> Literal matching<br>Interpret PATTERN as a list of fixed strings (rather than regular expressions), separated by newlines, any of which is to be matched.</p><p>This is used to search a raw string with some characters (e.g. <code>*</code>, <code>+</code>, etc.) that have special meaning in a regular expression when use <code>grep</code>.Characters like <code>*</code> or <code>?</code> will not be interpreted as the meta symbols in <code>fgrep</code> or <code>grep -F</code>.</p><p>e.g.</p><pre><code>$ grep -F &apos;*&apos; /etc/profileoutput:for i in /etc/profile.d/*.sh; do</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git log</title>
      <link href="/Git/git-git-log/"/>
      <url>/Git/git-git-log/</url>
      
        <content type="html"><![CDATA[<p><strong>1. Display overall log info in a pretty way</strong></p><pre><code>$ git log --pretty=oneline</code></pre><p>more detailed</p><pre><code>$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;</code></pre><p>Useful options for <code>git log --pretty=format</code></p><table><thead><tr><th>Option</th><th>Description of Output</th></tr></thead><tbody><tr><td>%H</td><td>Commit hash</td></tr><tr><td>%h</td><td>Abbreviated commit hash</td></tr><tr><td>%T</td><td>Tree hash</td></tr><tr><td>%t</td><td>Abbreviated tree hash</td></tr><tr><td>%P</td><td>Parent hashes</td></tr><tr><td>%p</td><td>Abbreviated parent hashes</td></tr><tr><td>%an</td><td>Author name</td></tr><tr><td>%ae</td><td>Author email</td></tr><tr><td>%ad</td><td>Author date (format respects the –date=option)</td></tr><tr><td>%ar</td><td>Author date, relative</td></tr><tr><td>%cn</td><td>Committer name</td></tr><tr><td>%ce</td><td>Committer email</td></tr><tr><td>%cd</td><td>Committer date</td></tr><tr><td>%cr</td><td>Committer date, relative</td></tr><tr><td>%s</td><td>Subject</td></tr></tbody></table><p>Print log info with graph</p><pre><code>$ git log --pretty=format:&quot;%h %s&quot; --graph</code></pre><p><strong>2. Check detailed info for all commits</strong></p><pre><code>$ git log --stat$ git show --stat ${commit_hash}$ git diff ${commit_hash} $(commint_hash)^</code></pre><p>show last commit info</p><pre><code>$ git log --stat -1</code></pre><p>show last two commits info:</p><pre><code>$ git log --stat -2</code></pre><p><strong>3. Check detailed commit info of a specific file</strong></p><pre><code>$ git log -p filename</code></pre><br>##### More---<p>git log has abundant format settings, to simplify the usage, we can </p><pre><code>$ vim ~/.gitconfig[alias]    ll = log --pretty=format:&quot;%C(yellow)%h%Cred%d\\ %Creset%s%Cblue\\ [%cn]&quot; --decorate --numstat    ld = log --pretty=format:&quot;%C(yellow)%h\\ %C(green)%ad%Cred%d\\ %Creset%s%Cblue\\ [%cn]&quot; --decorate --date=short --graph    ls = log --pretty=format:&quot;%C(green)%h\\ %C(yellow)[%ad]%Cred%d\\ %Creset%s%Cblue\\ [%cn]&quot; --decorate --date=relative</code></pre><p>use <code>git diff --cached</code> to inspect changes in the cache/index (i.e. staged changes) against the current HEAD. <code>--staged</code> is a synonym for <code>--cached</code>.</p><br><br><br><h6 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h6><p><a href="https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History" target="_blank" rel="noopener">https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Manage multiple remotes for one local repository</title>
      <link href="/Git/git-multiple-remotes/"/>
      <url>/Git/git-multiple-remotes/</url>
      
        <content type="html"><![CDATA[<ol><li><p>If the local branch is same as the remote branch, we can simply do:</p><p> git push coding master<br> git push github master</p></li></ol><p>Note: this is the recommended way.</p><ol start="2"><li><p>If the local branch has a different name of remote branch, we can do:</p><p> git push coding localbranch:master<br> git push github localbranch:master</p></li></ol><p>Caution: it’s not recommended to have a different local branch name of the remote branch name.</p><ol start="3"><li><p>We can synchronize the local changes to all remote repositories by one command</p><p> git remote add all <a href="http://github.com" target="_blank" rel="noopener">http://github.com</a><br> git remote set-url origin –push –add <a href="http://coding.net" target="_blank" rel="noopener">http://coding.net</a><br> git remote set-url origin –push –add <a href="http://github.com" target="_blank" rel="noopener">http://github.com</a></p></li></ol><p>Now, we can simply exit <code>git push all branch</code> to push local commits to all remote repositories.</p><p>Syntax:</p><pre><code>git push [remote alias] [local branch] : [remote branch]</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Check the difference of file between local and repository</title>
      <link href="/Git/git-git-diff-local-repo/"/>
      <url>/Git/git-git-diff-local-repo/</url>
      
        <content type="html"><![CDATA[<p>git diff master<br>or<br>git diff HEAD</p><p><img src="/image/git_areas.png" alt=""></p><p><img src="/image/git_diff.png" alt=""></p><p><strong>git diff</strong><br>Shows the changes between the working directory and the index. This shows what has been changed, but is not staged for a commit.</p><p><strong>git diff –staged</strong> or <strong>git diff –cached</strong><br>Shows the changes between the index and the HEAD(which is the last commit on this branch). This shows what has been added to the index and staged for a commit.</p><p><strong>git diff HEAD</strong><br>Shows all the changes between the working directory and HEAD (which includes changes in the index). This shows all the changes since the last commit, whether or not they have been staged for commit or not.</p><p><img src="/image/git_diff_simple.png" alt=""></p><br><br><br><br>##### Referencehttp://365git.tumblr.com/post/474079664/whats-the-difference-part-1]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git init and remote branch</title>
      <link href="/Git/git-git-init/"/>
      <url>/Git/git-git-init/</url>
      
        <content type="html"><![CDATA[<br>#### 本地目录与远程库的区别---如果已经在本地建好了一个目录，比如 myproj，同时，在 github.com 上也已经建了一个项目 `proj_test`，那么想把这个 `proj_test` 里的内容**拉下来**放到本地的 myproj 目录中，同时本地的 myproj 目录中原有的文件还继续能存在，并且 myproj 目录成为 proj_test 这个目录在本地的 clone 的话，如下设置即可：<pre><code>$ git remote add origin http://github.com/myproj.git$ git pull origin master</code></pre><p>上面 origin 的意思其实就是作为 <span><a href="http://github.com/myproj.git" target="_blank" rel="noopener">http://github.com/myproj.git</a></span> 的一个别名（相当于 <code>origin=http://github.com/myproj.git</code>），master 则是本地分支名</p><pre><code>$ git push origin master</code></pre><p>语句的含义就是： 把本地 master 分支中的内容提交到 origin 中。（对应远程的 origin 中的也是 master 分支）</p><br>#### 创建远程分支----从远程分支克隆出的本地分支，称为跟踪分支(tracking branch)。跟踪分支是一种和远程分支有直接联系的本地分支。比如：在跟踪分支里输入 git push，git 会自行推断应该向哪个服务器的哪个分支推送数据。反过来，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来.<pre><code>$ git remote add origin ssh://git@github.com/juniway.git$ git push origin master$ git push ssh://git@github.com/juniway.git master          // 把本地仓库提交到远程仓库的master分支中</code></pre><p>我从 master 分支创建了一个 <strong>issue5560</strong> 分支，做了一些修改后，使用 <code>git push origin master</code> 提交，但是显示的结果却是’Everything up-to-date’，<br>发生问题的原因是 git push origin master 会默认的把本地 master 分支中的内容提交到 remote repo 中的 master 分支(因为本地的 master 分支默认指向了origin master 分支)，<br>而不是把新建的 那个 issue5560 分支 提交。</p><p>如果想实现把本地 issue5560 分支提交到远程的 master 分支，可以这样：<br>使用 <code>git push origin issue5560</code><br>这样就可以把本地 issue5560 分支推送到远程的 master 分支了（远程的 origin 默认是 master 分支）。</p><p>这时候可以通过切换到本地 master 分支上 执行 git pull 拉取下来，如果还有其他同事也在 master 分支上进行了其他提交工作，那么需要 merge。<br>当然，也可以先把 issue5560 merge 到本地 master 再提交到远程库。</p><p>如果想把本地的某个分支 test 提交到远程仓库，并作为远程仓库的 master 分支，或者作为另外一个名叫 test 的分支，那么可以这么做:</p><pre><code>$ git push origin test:master         // 提交本地 test 分支作为远程的 master 分支$ git push origin test:test           // 提交本地 test 分支作为远程的 test 分支</code></pre><p>如果想删除远程的分支呢？类似于上面，如果冒号 : 左边的分支为空，那么将删除冒号 : 右边的远程的分支。</p><pre><code>$ git push origin :test               // 刚提交到远程的 test 将被删除，但是本地还会保存的，不用担心</code></pre><br>###### 补充：---<p>添加远端 repo：</p><pre><code>$ git remote add upstream git://github.com/pjhyett/github-services.git</code></pre><p>重命名远端 repo：</p><pre><code>$ git://github.com/pjhyett/github-services.git 为 “upstream”</code></pre><br><br><br><br>##### Referencehttps://gitshell.com/help/#faqhttp://www.cnblogs.com/wangkangluo1/archive/2011/09/02/2164313.html]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>scp</title>
      <link href="/Linux/linux-scp/"/>
      <url>/Linux/linux-scp/</url>
      
        <content type="html"><![CDATA[<p><strong>SCP</strong> command is used to transfer files over computers in Linux.</p><h3 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h3><pre><code>scp src_file username@dest_host:dest_folder</code></pre><h3 id="Common-Options"><a href="#Common-Options" class="headerlink" title="Common Options"></a>Common Options</h3><ul><li><strong>-v</strong> Provide detail information of scp process</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp -v abc.txt username@192.169.1.7:.</span><br></pre></td></tr></table></figure><ul><li><p><strong>-p</strong> Provide modification times, access times, and modes from original files</p></li><li><p><strong>-C</strong> <strong>Compress</strong> file when transferring.</p></li></ul><p>“-C” parameter wil compress your files on the fly. The compression is only happen in the network. When the file is arrived to the destination server, it will be unzipped.</p><ul><li><strong>-c</strong> Select another <strong>cipher</strong> to encrypt files</li></ul><p>By default SCP uses “AES-128” to encrypt files. If you want to change to another cipher to encrypt it, you can use “-c” parameter.</p><pre><code>$ scp -c 3des abc.txt username@192.168.1.7</code></pre><p>Above command tells SCP to use 3-DES algorithm to encrypt file. Please be careful that this parameter using “-c” not “-C”.</p><ul><li><strong>-l</strong> <strong>Limit</strong> bandwidth usage</li></ul><p>The ‘-l’ parameter will limit the bandwidth usage. If you don’t want the bandwidth is drained by the SCP proces when you execute automation script to copy a lot of files, ‘-l’ option will be helpful.</p><pre><code>$ scp -l 400 abc.txt username@192.168.1.7:.</code></pre><p>The 400 value behind “-l” parameter means that the limitation of the bandwidth for SCP process is at maximum 50 KB/sec. Note that bandwidth is measured in Kilobits/sec (kbps) in SCP. It is mean that 8 bits equal with 1 byte.</p><p>therefore, if you want to limit your bandwidth for SCP maximum only 50 KB/s, you need to set it into 50 x 8 = 400. </p><ul><li><strong>-P</strong> Specify <strong>specific port</strong> to use with SCP</li></ul><p>Usually SCP is using port 22 as a default port. But for security reason, you may change the port into another port. For example, we are using port 2249. Then the command should be like this.</p><pre><code>$ scp -P 2249 abc.txt username@192.168.1.7:.</code></pre><ul><li><strong>-r</strong> Copy files inside directory <strong>recursively</strong></li></ul><p>Sometimes we need to copy directory and all files / directories inside it. It will be better if we can do it in 1 command. SCP support that scenario using “-r” parameter.</p><pre><code>$ scp -r documents abc.txt username@192.168.1.7:.</code></pre><p>When the copy process is done, at the destination server you will found a directory named “documents” with all it’s files. The folder “documents” is automatically created.</p><h3 id="Exclude-some-directories-or-files-when-use-scp"><a href="#Exclude-some-directories-or-files-when-use-scp" class="headerlink" title="Exclude some directories or files when use scp?"></a>Exclude some directories or files when use scp?</h3><pre><code>$ sudo -u search scp -r ~/project/[!.]* 192.168.1.7:.</code></pre><p>or</p><pre><code>$ sudo -u search rsync -rav -e ssh --include=&apos;~/project&apos; --exclude=&apos;~/project/.svn&apos; 192.168.56.177:$ rsync -av --exclude=&apos;path1/to/exclude&apos; --exclude=&apos;path2/to/exclude&apos; source destination</code></pre><p><strong>Note</strong> that using source and source/ are different. A trailing slash means to copy the contents of the folder source into destination. Without the trailing slash, it means copy the folder source into destination.</p><p>For a svn managed project directory, all the sub-directories will have a hidden .svn directory, if we want to cp the project without these .svn directories, the best way is<br>us find with -prune option.</p><pre><code>$ find . -type d -path &apos;*/\.*&apos; -prune -o -not -name &apos;.svn&apos; -print  </code></pre><p>or if we want to search some file in all sub-directories but not in <code>.svn</code> directories, we can do this:</p><pre><code>$ find . -type d -path &apos;*/\.*&apos; -prune -o -not -name &apos;.svn&apos; -type f -name &apos;*filename*&apos; -print</code></pre><p>Now we can use <code>scp</code> command cooperate with <code>find</code> and <code>grep</code> to exclude all the <code>.svn</code> sub directories.</p><pre><code>sudo -u search scp $(find ~/project -type d -path &apos;*/\.*&apos; -prune -o -type f -not -name &apos;.svn&apos;| grep -v .svn) 192.168.1.7:.</code></pre><ul><li><strong>-q</strong> Disable progress meter and warning / diagnostic message</li></ul><p>If you choose not to see progress meter and warning / diagnostic messages from SCP, you may disable it using “-q” parameter. </p><h3 id="Copy-files-using-SCP-through-Proxy"><a href="#Copy-files-using-SCP-through-Proxy" class="headerlink" title="Copy files using SCP through Proxy"></a>Copy files using SCP through Proxy</h3><p>Proxy server is usually used in office environment. Natively, SCP is not proxy configured.<br>Therefore, when our environment using proxy, we have to “tell” SCP to communicate with the proxy.</p><p>Take an example, suppose the proxy address is 10.0.96.6 and the proxy port is 8080. The proxy also implemented user authentication.<br>To use proxy we need to make sure we have installed <code>corkscrew</code> tool.</p><pre><code>$ apt-get install corkscrew</code></pre><p>or</p><pre><code>$ yum install corkscrew</code></pre><p>Here is the procedure:</p><p>Create “~/.ssh/config” file.<br>Put the below command inside it.<br>ProxyCommand /usr/bin/corkscrew 10.0.96.6 8080 %h %p ~/.ssh/proxyauth</p><p>Create file “~/.ssh/proxyauth” which contain.<br>myusername:mypassword</p><p>After that we can execute <code>scp</code> transparently as usual.</p><p>Another thing that since “~/.ssh/proxyauth” file contain your “username” and “password” in clear-text format, please make sure that the file can be accessed by you only.</p><p><strong>Reference</strong><br><a href="http://www.tecmint.com/scp-commands-examples/" target="_blank" rel="noopener">http://www.tecmint.com/scp-commands-examples/</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cut, tr, cat, etc...</title>
      <link href="/Linux/linux-others/"/>
      <url>/Linux/linux-others/</url>
      
        <content type="html"><![CDATA[<p>This article introduces the usages of Linux commands cut, tr, cat, etc. </p><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><p>cut is used to divide a file into several parts (columns)</p><p>cut writes selected parts of each line of each input stream (from file or stdin) to standard output </p><h3 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h3><p>cut [OPTION]… [FILE]…</p><h3 id="Common-OPTIONS"><a href="#Common-OPTIONS" class="headerlink" title="Common OPTIONS"></a>Common OPTIONS</h3><ul><li><strong>-f</strong> FIELD-LIST –fields=FIELD-LIST<br>Print only the fields listed in FIELD-LIST. Fields are separated by a TAB character by default.</li><li><strong>-d</strong> INPUT_DELIM_BYTE –delimiter=INPUT_DELIM_BYTE<br>For ‘-f’, fields are separated in the input by the first character in INPUT_DELIM_BYTE (default is TAB).</li><li><strong>-s</strong> –only-delimited<br>For ‘-f’, do not print lines that do not contain the field separator character.</li><li>–output-delimiter=OUTPUT_DELIM_STRING<br>For ‘-f’, output fields are separated by OUTPUT_DELIM_STRING The default is to use the input delimiter.</li></ul><p><strong>Example</strong></p><pre><code>$ cat me.txt1;2;3;4;5;6;7;8;9</code></pre><p>(1) Print field 2</p><pre><code>$ cat sample.txt | cut -d \; -f 22</code></pre><p>(2) Specify output format</p><pre><code>$ cat ct | cut -d \; -f 1-5 --output-delimiter=&quot;-&quot;</code></pre><p><strong>Note:</strong> <code>;</code> needs to be escaped as it is a command separator character in command line</p><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>Cat command concatenate files or stdin, to standard output. When file is not specified, or specified as <code>-</code>, cut will read standard input.</p><h3 id="Syntax-1"><a href="#Syntax-1" class="headerlink" title="Syntax"></a>Syntax</h3><p>cat [Options] [File]…</p><h3 id="Common-Options"><a href="#Common-Options" class="headerlink" title="Common Options"></a>Common Options</h3><ul><li><strong>-v</strong>, –show-nonprinting   use <code>^</code> and <code>M-</code> notation, except for LFD and TAB. display this help and exit</li><li><strong>-T</strong>, –show-tabs          display TAB characters as ^I</li><li><strong>-E</strong>, –show-ends          display $ at end of each line</li><li><strong>-n</strong>, –number             number all output lines</li><li><strong>-s</strong>, –squeeze-blank      squeeze multiple blank line as one</li></ul><h2 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h2><p><strong>tr</strong> (translate) is used to rranslate, squeeze, and/or delete characters from standard input, writing to standard output</p><p><strong>tr</strong> can be used to accomplish basic functionalities of <code>sed</code>, it translate or delete characters in <code>SET 2</code> according to <code>SET 1</code>.We can use <code>tr</code> command as a <code>mini sed</code> to fullfill some work.</p><p><strong>tr</strong> command is act as a filter, it reads characters from the standard input, and writes results to the standard output, characters in SET2 be translated if if appears in SET1</p><h3 id="Syntax-2"><a href="#Syntax-2" class="headerlink" title="Syntax"></a>Syntax</h3><p>tr [options] set1 set2</p><h3 id="Common-Options-1"><a href="#Common-Options-1" class="headerlink" title="Common Options"></a>Common Options</h3><ul><li><strong>-c</strong>, -C, –complement    use the complement of SET1, usually cooperat with -d, -s</li><li><strong>-d</strong>, –delete            delete characters in SET1, do not translate</li><li><strong>-s</strong>, –squeeze-repeats   replace each input sequence of a repeated character that is listed in SET1 with a single occurrence of that character</li><li><strong>-t</strong>, –truncate-set1     truncate SET1 to length of SET2</li></ul><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>(1) Squeeze all consecutively repeated characters in me.txt</p><pre><code>$ tr -s &quot;[a-z]&quot; &lt; me.txt</code></pre><p>(2) Remove all blank line</p><pre><code>$ tr -s &quot;[\012]&quot; &lt; me.txt</code></pre><p>or</p><pre><code>$ tr -s [&quot;\n&quot;] &lt; me.txt</code></pre><p>(3) Remove all ^M with <code>\n</code></p><pre><code>$ tr -s &quot;[\015]&quot; &quot;[\n]&quot; &lt; me.txt</code></pre><p>or</p><pre><code>$ tr -s &quot;[\r]&quot; &quot;[\n]&quot; &lt; me.txt</code></pre><p>(4) Uppercase Lowercase convertion</p><pre><code>$ cat a.txt |tr &quot;[a-z]&quot; &quot;[A-Z]&quot; &gt; b.txt</code></pre><p>(5) Delete specified characters</p><p>e.g. In a schedule containing date (Uppercases and lowercases included) and digits, we want to keep the date but remove all digits</p><pre><code>$ tr -cs &quot;[a-z][A-Z]&quot; &quot;[\012*]&quot; &lt; diary.txt</code></pre><p><strong>PS:</strong> <code>-s</code> squeezes all blank lines, -c keep all alphabetical character unchanges.</p><p>(6) Convert control characters</p><p>tr is often used to convert control character between dos and Unix, use <code>cat -v filename</code> to display control characters.</p><pre><code>$ cat -v stat.txtbox aa^^^^^12^Mapple bbas^^^^23^M^Z</code></pre><p><strong>Note:</strong> we can use ctrl + v, ctrl + M to type ^M in unix command line.</p><p>(7) Translate all colon <code>:</code> to <code>TAB</code> to emprove readability</p><pre><code>$ tr -s &quot;[:]&quot; &quot;[\011]&quot; &lt; /etc/passwd 或 tr -s &quot;[:]&quot; &quot;[\t]&quot; &lt; /etc/passwd</code></pre><p>(8) Separate $PATH to lines to display path more clearly</p><pre><code>$ echo $PATH | tr &quot;:&quot; &quot;\n&quot; </code></pre><p>(9) We can use <code>!</code> to execute <code>tr</code> in vim like this:</p><pre><code>1,$!tr -d &apos;\t&apos;</code></pre><p><strong>Note</strong></p><p><code>tr</code> can not use <strong>two characters</strong> to replace <strong>one character</strong>, we should use <strong>awk</strong> or <strong>sed</strong> in that case.</p><pre><code>$ awk &apos;{ print $0&quot;\r&quot; }&apos;&lt;unixfile &gt; dosfile</code></pre><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><h3 id="Syntax-3"><a href="#Syntax-3" class="headerlink" title="Syntax"></a>Syntax</h3><p>sort [OPTION]… [FILE]…<br>sort [OPTION]… –files0-from=F</p><h3 id="Common-Options-2"><a href="#Common-Options-2" class="headerlink" title="Common Options"></a>Common Options</h3><p><strong>-b</strong>, –ignore-leading-blanks Ignore leading blanks.<br><strong>-d</strong>, –dictionary-order  Consider only blanks and alphanumeric characters.<br><strong>-f</strong>, –ignore-case   Fold lower case to upper case characters.<br><strong>-g</strong>, –general-numeric-sort  Compare according to general numerical value.<br><strong>-i</strong>, –ignore-nonprinting    Consider only printable characters.<br><strong>-M</strong>, –month-sort    Compare (unknown) &lt; <code>JAN&#39; &lt; ... &lt;</code>DEC’.<br><strong>-h</strong>, –human-numeric-sort    Compare human readable numbers (e.g., “2K”, “1G”).<br><strong>-n</strong>, –numeric-sort  Compare according to string numerical value.<br><strong>-R</strong>, –random-sort   Sort by random hash of keys.<br>–random-source=FILE    Get random bytes from FILE.<br><strong>-r</strong>, –reverse   Reverse the result of comparisons.<br>–sort=WORD Sort according to WORD: general-numeric -g, human-numeric -h, month -M, numeric -n, random -R, version -V.<br><strong>-V</strong>, –version-sort  Natural sort of (version) numbers within text.</p><h4 id="Other-Options"><a href="#Other-Options" class="headerlink" title="Other Options"></a>Other Options</h4><p>–batch-size=NMERGE Merge at most NMERGE inputs at once; for more use temp files.<br><strong>-c</strong>, –check, –check=diagnose-first Check for sorted input; do not sort.<br><strong>-C</strong>, –check=quiet, –check=silent   Like -c, but do not report first bad line.<br>–compress-program=PROG Compress temporaries with PROG; decompress them with PROG -d.<br>–debug Annotate the part of the line used to sort, and warn about questionable usage to stderr.<br>–files0-from=F Read input from the files specified by NUL-terminated names in file F; If F is - then read names from standard input.<br><strong>-k</strong>, –key=POS1[,POS2]   Start a key at POS1 (origin 1), end it at POS2 (default end of line). See POS syntax below.<br><strong>-m</strong>, –merge Merge already sorted files; do not sort.<br><strong>-o</strong>, –output=FILE   Write result to FILE instead of standard output.<br><strong>-s</strong>, –stable    Stabilize sort by disabling last-resort comparison.<br><strong>-t</strong>, –field-separator=SEP   Use SEP instead of non-blank to blank transition.<br><strong>-T</strong>, –temporary-directory=DIR   Use DIR for temporaries, not $TMPDIR or /tmp; multiple options specify multiple directories.<br>–parallel=N    Change the number of sorts run concurrently to N.<br><strong>-u</strong>, –unique    With -c, check for strict ordering; without -c, output only the first of an equal run.<br><strong>-z</strong>, –zero-terminated   End lines with 0 byte, not newline.<br>–help  Display a help message, and exit.<br>–version   Display version information, and exit.</p><h3 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h3><p><strong>1. Sort In Reverse Order</strong></p><pre><code>$ sort -r data.txt</code></pre><p><strong>2. Check whether a file is in order</strong></p><pre><code>$ sort -c data.txt</code></pre><p><strong>3. Sort in field</strong></p><p>fields in <code>sort</code> uses 1-based index, and are separated by whitespace by default, use <code>-t</code> option to specify other delimiters.</p><p><strong>Syntax:</strong></p><p><code>-k POS1</code> or <code>-k POS1,POS2</code></p><pre><code>$ sort -k 2 data.txt</code></pre><p><strong>4. Sort in field and specific position of character in this field</strong></p><p><strong>Syntax:</strong></p><p><strong><code>-k POS.i</code></strong> <code>POS</code> is the field position number, and <code>i</code> is the <strong>ith</strong> character in this field</p><p><strong>5. Sort and merge multiple file</strong></p><p>use <strong><code>find</code></strong> to produces a <strong>NUL-terminated</strong> file list as its output, and to pipe that output into sort using the <code>--files0-from</code> option.</p><pre><code>$ find -name &quot;data?.txt&quot; -print0 | sort --files0-from=-</code></pre><p><strong>Explanation:</strong> By defualt, find outputs one file on each line; in other words, it inserts a line break after each filename it outputs.<br>It would be nice if we could use this output to tell the sort command, “sort the data in any files found by find as if they were all one big file.” The problem with the standard find output is, even though it’s easy for humans to read, it can cause problems for other programs that need to read it in. This is because filenames can include non-standard characters, so in some cases, this format will be read incorrectly by another program.<br>The correct way to format find’s output to be used as a file list for another program is to use the -print0 option when running find. This terminates each filename with the NUL character (ASCII character number zero), which is universally illegal to use in filenames. This makes things easier for the program reading the file list, since it knows that any time it sees the NUL character, it can be sure it’s at the end of a filename.</p><p>Once we execute <code>find -name &quot;data?.txt&quot; -print0</code>, it will produce the following output: <code>./data1.txt./data3.txt./data2.txt</code>, although we can’t see NUL character as it is non-printable character, it is actually appended by <code>-print0</code>. </p><p>Now we should specify the <code>--files0-from</code> option in the sort command, and specify the file as a dash (“-“), so that it will read from the standard input. </p><p>The final effect is that sort command will sort the data of all files located by find command, as if they were all one file and output, and output the merge sorted data to<br>standard output.</p><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><h3 id="Syntax-4"><a href="#Syntax-4" class="headerlink" title="Syntax"></a>Syntax</h3><p>wc [option] filename </p><p><strong>-l</strong> print line counts<br><strong>-w</strong> print word counts<br><strong>-m</strong> print char counts</p><h2 id="rev"><a href="#rev" class="headerlink" title="rev"></a>rev</h2><p><strong>rev</strong> reverses lines characterwise</p><h3 id="Syntax-5"><a href="#Syntax-5" class="headerlink" title="Syntax"></a>Syntax</h3><p>rev [option] [file…]</p><h2 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h2><p>The paste command displays the corresponding lines of multiple files side-by-side.</p><p>paste writes lines consisting of the sequentially corresponding lines from each FILE, separated by tabs, to the standard output.<br>With no FILE, or when FILE is a dash (“-“), paste reads from standard input.</p><h3 id="Syntax-6"><a href="#Syntax-6" class="headerlink" title="Syntax"></a>Syntax</h3><p>paste [OPTION]… [FILE]…</p><h3 id="Common-Options-3"><a href="#Common-Options-3" class="headerlink" title="Common Options"></a>Common Options</h3><p><strong>-d</strong>, –delimiters=LIST   reuse characters from LIST instead of tabs.<br><strong>-s</strong>, –serial    paste one file at a time instead of in parallel.</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Display the contents of file1.txt and file2.txt, side-by-side, with the corresponding lines of each file separated by a tab.</p><pre><code>$ paste file1.txt file2.txt</code></pre><h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><p><strong>split</strong> and <strong>join</strong> commands are very helpful when manipulating large files.</p><p><strong>split</strong> outputs fixed-size pieces of input INPUT to files named PREFIXaa, PREFIXab, …<br>The default size for each split file is 1000 lines, and default PREFIX is “x”. With no INPUT, or when INPUT is a dash (“-“), read from standard input.</p><h3 id="Syntax-7"><a href="#Syntax-7" class="headerlink" title="Syntax"></a>Syntax</h3><p>join [OPTION]… FILE1 FILE2  </p><h3 id="Common-Options-4"><a href="#Common-Options-4" class="headerlink" title="Common Options"></a>Common Options</h3><p><strong>-a</strong> N, –suffix-length=N Use suffixes of length N (default 2)<br><strong>-b</strong> SIZE, –bytes=SIZE   Write SIZE bytes per output file.<br><strong>-C</strong> SIZE, –line-bytes=SIZE  Write at most SIZE bytes of lines per output file.<br><strong>-d</strong>, –numeric-suffixes  Use numeric suffixes instead of alphabetic.<br><strong>-e</strong>, –elide-empty-files Do not generate empty output files with “-n”<br>–filter=COMMAND    Write to shell command COMMAND; file name is $FILE<br><strong>-l</strong> NUMBER, –lines=NUMBER   Put NUMBER lines per output file.<br><strong>-n</strong> CHUNKS, –number=CHUNKS  Generate CHUNKS output files. (See below.)<br><strong>-u</strong>, –unbuffered    Immediately copy input to output with “-n r/…”.<br>–verbose   Print a verbose diagnostic just before each output file is opened.<br>–help  Display a help message and exit.<br>–version   Output version information and exit.<br>SIZE may be one of the following, or an integer optionally followed by one of following multipliers:</p><table><thead><tr><th>suffix -</th><th>multiplier</th></tr></thead><tbody><tr><td>KB</td><td>1000</td></tr><tr><td>K</td><td>1024</td></tr><tr><td>MB</td><td>1000 x 1000</td></tr><tr><td>M</td><td>1024 x 1024</td></tr></tbody></table><p>… so on for G (gigabytes), T (terabytes), P (petabytes), E (exabytes), Z (zettabytes), Y (yottabytes).</p><p>CHUNKS may be:</p><ul><li>N: split into N files based on size of input  </li><li>K/N: output Kth of N to standard output  </li><li>l/N: split into N files without splitting lines  </li><li>l/K/N: output Kth of N to standard output without splitting lines  </li><li>r/N: like “l” but use round robin distribution r/K/N likewise but only output Kth of N to standard output</li></ul><h3 id="Examples-2"><a href="#Examples-2" class="headerlink" title="Examples"></a>Examples</h3><p>(1) Basic Split </p><pre><code>$ split split.zip$ lsxab  xad  xaf  xah  xaj  xal  xan  xap  xar  xat  xav  xax  xaz  xbb  xbd  xbf  xbh  xbj  xbl  xbnxaa  xac  xae  xag  xai  xak  xam  xao  xaq  xas  xau  xaw  xay  xba  xbc  xbe  xbg  xbi  xbk  xbm</code></pre><p>(2) Customize Split File Size using -b option</p><pre><code>$ split -b200000 split.zip</code></pre><p>(3) Customize output filenames with Numeric Suffix using -d option</p><pre><code>$ split -d split.zip$ lsx01  x03  x05  x07  x09  x11  x13  x15  x17  x19  x21  x23  x25  x27  x29  x31  x33  x35  x37  x39x00  x02  x04  x06  x08  x10  x12  x14  x16  x18  x20  x22  x24  x26  x28  x30  x32  x34  x36  x38</code></pre><p>(4) Split the file newfile.txt into files beginning with the name new, each containing 300 lines of text.</p><pre><code>$ split -l 300 file.txt new</code></pre><p>(5) Customize the Number of Split Chunks using -C option (e.g. create 50 chunks of split files)</p><pre><code>$ split -n50 split.zip</code></pre><p>(6) Avoid Zero Sized Chunks using -e option</p><pre><code>$ split -n50 -e testfile</code></pre><p>(7) Split file based on Number of Lines using -l option (e.g. split a file every 200 lines)</p><pre><code>$ split -l200 split.zip</code></pre><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>Joins the lines of two files which share a <strong>common field</strong> of data.</p><h3 id="Common-Options-5"><a href="#Common-Options-5" class="headerlink" title="Common Options"></a>Common Options</h3><p>split [OPTION]… [INPUT [PREFIX]]</p><h3 id="Examples-3"><a href="#Examples-3" class="headerlink" title="Examples"></a>Examples</h3><p>(1) suppose we have file1 and file2 containing contents like this:</p><pre><code>$ cat file11 India2 US3 Ireland4 UK5 Canada$ cat file21 NewDelhi2 Washington3 Dublin4 London5 Toronto</code></pre><p>After join, we can get result like this:</p><pre><code>$ join file1 file21 India NewDelhi2 US Washington3 Ireland Dublin4 UK London5 Canada Toronto</code></pre><p><strong>Note</strong> that the matching field should be in exact order, the non-ordered matching field will not be joined.</p><p>(2) Print Only Unpaired Lines using -v option</p><pre><code>$ join -v1 file1 file2f Australia</code></pre><p>(3) Join Based on Different Columns from Both Files using -1 and -2 option</p><p>By default the first columns in both the files is used for comparing before joining. You can change this behavior using -1 and -2 option.</p><pre><code>$ cat testfile1a Indiab USc Irelandd UKe Canada$ cat testfile2NewDelhi aWashington bDublin cLondon dToronto e$ join -1 1 -2 2 testfile1 testfile2a India NewDelhib US Washingtonc Ireland Dublind UK Londone Canada Toronto</code></pre><h2 id="csplit"><a href="#csplit" class="headerlink" title="csplit"></a>csplit</h2><p>Split a file into sections determined by context lines.</p><h3 id="Syntax-8"><a href="#Syntax-8" class="headerlink" title="Syntax"></a>Syntax</h3><p>csplit [OPTION]… FILE PATTERN…</p><h3 id="Common-Options-6"><a href="#Common-Options-6" class="headerlink" title="Common Options"></a>Common Options</h3><p><strong>-b</strong>, –suffix-format=FORMAT  use sprintf FORMAT instead of %02d.<br><strong>-f</strong>, –prefix=PREFIX use PREFIX instead of ‘xx’.<br><strong>-k</strong>, –keep-files    do not remove output files on errors.<br><strong>-n</strong>, –digits=DIGITS use specified number of digits instead of 2.<br><strong>-s</strong>, –quiet, –silent   do not print counts of output file sizes.<br><strong>-z</strong>, –elide-empty-files remove empty output files.<br>–help  display a help message and exit.<br>–version   output version information and exit.</p><p>csplit reads standard input if FILE is specified as a dash (“-“). Each PATTERN may be:</p><p>INTEGER copy up to but not including specified line number.<br>/REGEXP/[OFFSET]    copy up to but not including a matching line.<br>%REGEXP%[OFFSET]    skip to, but not including a matching line.<br>{INTEGER}   repeat the previous pattern specified number of times.<br>{*} repeat the previous pattern as many times as possible.  </p><p>A line OFFSET is a required ‘+’ or ‘-‘ followed by a positive integer.</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>netstat</title>
      <link href="/Linux/linux-netstat/"/>
      <url>/Linux/linux-netstat/</url>
      
        <content type="html"><![CDATA[<p><code>netstat</code> is the most frequently used commands for network analysis and troubleshooting in Linux. </p><h3 id="Common-Options"><a href="#Common-Options" class="headerlink" title="Common Options"></a>Common Options</h3><p><strong>-a</strong> (all) Show all sockets, including both listening and non-listening sockets<br><strong>-t</strong> (tcp) Show TCP sockets<br><strong>-u</strong> (udp) Show UDP sockets<br><strong>-n</strong> Show addresses as numerical format<br><strong>-l</strong> Show sockets that are in listening status</p><p><strong>-p</strong> Show pid and process name<br><strong>-r</strong> Show routing table info<br><strong>-e</strong> Show extension info, e.g. uid<br><strong>-s</strong> Statistic for all protocols<br><strong>-c</strong> Execute netstat command at a interval</p><p><strong>The output format</strong></p><p>Proto Recv-Q Send-Q Local-Address Foreign-Address State PID/ProgramName</p><p><strong>Here is a list of some common situations that <code>netstat</code> can be very useful:</strong></p><p><strong>1. List all processes with tcp sockets that are in listening</strong></p><pre><code>$ netstat -nltp | less</code></pre><p><strong>2. Check whether a process is listening a port</strong></p><pre><code>$ netstat -nltp | grep process_name</code></pre><p><strong>3. Show all ports that a process are using</strong></p><pre><code>$ netstat -ap | grep process_name</code></pre><p><strong>4. Show statistic info of <code>TCP</code> and <code>UDP</code></strong></p><pre><code>$ netstat -st</code></pre><p>or</p><pre><code>$ netstat -su</code></pre><p><strong>5. Show all network interfaces</strong></p><pre><code>$ netstat -ior$ netstat -ie  # will display extended information</code></pre><p><strong>One thing need to be noted</strong> is that netstat will only list the processes belong to the current account,<br>if we want to query processes of other accounts, we should use sudo.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p><strong>Real world IP/TCP Analysis of netstat command</strong></p><p><strong>1. View connections to our service</strong></p><p>we can use it to view all connections to a specific service and find the IP that has the most connections to our service.<br>e.g. we have ssh service open on port 22, and we want to see from which ip has most connections, we can do this:</p><pre><code>$ netstat -nat | grep &quot;192.168.1.15:22&quot; |awk &apos;{print $5}&apos;|awk -F: &apos;{print $1}&apos;|sort|uniq -c|sort -nr|head -20 18 221.136.168.363 154.74.45.2422 78.173.31.2362 62.183.207.982 192.168.1.142 182.48.111.215</code></pre><p><strong>2. Show statistic infomation of all Status</strong></p><pre><code>$ netstat -nat |awk &apos;{print $6}&apos;|sort|uniq -c|sort -rn143 ESTABLISHED1 FIN_WAIT11 Foreign1 LAST_ACK36 LISTEN6 SYN_SENT113 TIME_WAIT1 established</code></pre><p><strong>Alternative solutions:</strong></p><pre><code>$ netstat -n | awk &apos;/^tcp/ {++S[$NF]};END {for(a in S) print a, S[a]}&apos;$ netstat -n | awk &apos;/^tcp/ {++state[$NF]}; END {for(key in state) print key,&quot;\t&quot;,state[key]}&apos;$ netstat -n | awk &apos;/^tcp/ {++arr[$NF]};END {for(k in arr) print k,&quot;\t&quot;,arr[k]}&apos;$ netstat -n |awk &apos;/^tcp/ {print $NF}&apos;|sort|uniq -c|sort -rn$ netstat -ant | awk &apos;{print $NF}&apos; | grep -v &apos;[a-z]&apos; | sort | uniq -c</code></pre><p><strong>3. Get the process’s pid according to its binding port</strong></p><pre><code>$ netstat -ntlp | grep 80 | awk &apos;{print $7}&apos; | cut -d/ -f1</code></pre><p><strong>4. Get the top 20 ip who has most connections to the service</strong></p><pre><code>$ netstat -anlp|grep 80|grep tcp|awk &apos;{print $5}&apos;|awk -F: &apos;{print $1}&apos;|sort|uniq -c|sort -nr|head -n20</code></pre><p>or</p><pre><code>$ netstat -ant |awk &apos;/:80/{split($5,ip,&quot;:&quot;);++A[ip[1]]}END{for(i in A) print A[i],i}&apos; |sort -rn|head -n20</code></pre><p><strong>5. Find the IPs that has most time_wait state</strong></p><pre><code>$netstat -n|grep TIME_WAIT|awk &apos;{print $5}&apos;|sort|uniq -c|sort -rn|head -n20</code></pre><p><strong>6. Find the IPs that has most SYN connection state</strong></p><pre><code>$ netstat -an | grep SYN | awk &apos;{print $5}&apos; | awk -F: &apos;{print $1}&apos; | sort | uniq -c | sort -nr | more</code></pre><p><strong>7. Check how many active PHP-CGI processes</strong></p><pre><code>$ netstat -anp | grep php-cgi | grep ^tcp | wc -l</code></pre><p><strong>8. Check the amount of memory that PHP-CGI has used</strong></p><pre><code>$ total=0; for i in `ps -C php-cgi -o rss=`; do total=$(($total+$i)); done; echo &quot;PHP-CGI Memory usage: $total kb&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Change the virtual hard disk size of a VM</title>
      <link href="/VirtualBox/vbox-vbox-resize-hd/"/>
      <url>/VirtualBox/vbox-vbox-resize-hd/</url>
      
        <content type="html"><![CDATA[<h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps:"></a>Steps:</h2><h3 id="1-Clone-HD-file-“-vdi”"><a href="#1-Clone-HD-file-“-vdi”" class="headerlink" title="1. Clone HD file “.vdi”"></a>1. Clone HD file “.vdi”</h3><p>1). Show VDI information about the current disk.</p><pre><code>$ vboxmanage showhdinfo &quot;D:\Ubuntu_clang.vdi&quot;</code></pre><p>2). Clone the old VDI file to a new VDI file. (Syntax: <code>$ vboxmanage clonehd src dest</code>)</p><pre><code>$ vboxmanage clonehd D:\Ubuntu_clang.vdi D:\tmp\outputfile.vdi</code></pre><p>Show VDI information about the cloned disk.</p><pre><code># vboxmanage showhdinfo path\inputfile_clone.vdi</code></pre><p>3). Resizing the cloned disk.</p><pre><code>$ vboxmanage modifyhd D:\Ubuntu_clang.vdi --resize 51200</code></pre><p>Show VDI information about the resized clone disk.</p><pre><code>$ vboxmanage.exe showhdinfo path\inputfile_clone.vdi</code></pre><p>You can either delete the old “fixed” file, or leave it as a backup. Make sure you test the new VDI file before you delete the original one.</p><p><strong>Note:</strong> </p><ul><li>You will not immediately see the new size of the cloned disk.</li><li>You have to boot the VM with it, and then you have to use your partition management tool to expand your partition to fill the virtual disk (or create more partitions).</li><li>For Windows host, just run <code>diskmgmt.msc</code> and you’ll be able to expand the partition in there.</li></ul><h3 id="2-Partition"><a href="#2-Partition" class="headerlink" title="2. Partition"></a>2. Partition</h3><p>Use GParted<br><a href="https://www.youtube.com/watch?v=ikSIDI535L0&amp;feature=iv&amp;src_vid=r_UyKufXR3c&amp;annotation_id=annotation_4072520487" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ikSIDI535L0&amp;feature=iv&amp;src_vid=r_UyKufXR3c&amp;annotation_id=annotation_4072520487</a></p><p>If you dont’ have a live CD because you are using VBox, just search for Ubuntu Live CD Gparted, download the iso file and use it as your optical - remember to check your boot order.<br>Follow this instructions</p><p>Move <code>.vdi</code> file to another place or directory</p><h4 id="1-GUI-way"><a href="#1-GUI-way" class="headerlink" title="(1) GUI way"></a>(1) GUI way</h4><p>Below method doesn’t require removing your virtual machines and mucking up their settings.<br>1) Copy your Virtualbox VMs folder to a new drive.<br>2) Run the Virtual Box Machine Manager. Run the media Manager File -&gt; Virtual Media Manager<br>    2a. Right click VM, choose the Release button and then click the Remove button.<br>        On the next dialog, you can either remove or keep the virtual drive.<br>        Close the manager leaving you in your Virtualbox Machine Manager.<br>3) Move your VM(.vdi file) to a new location, say D:\tmp\vm_moved.vid<br>4) In virtualbox, select the vm that you just moved, click the Settings button,<br>   Click the Storage section. Add a controller for the media (SATA usually)<br>   and then add a hard drive and choose existing disk and select the .vdi file at your new location.<br>   Repeat for each machine you’re moving<br>4) Fire off your virtual machine at the new location to check.<br>   Next time you visit the Virtual Media Manager, hovering over the VM entry<br>   will show you where the VD is stored.<br>Make sure you change your snapshots folders to point to the new drive if you’re using them.<br>Each machine has a snapshot folder setting and the VM Manager has a Default Machine folder setting<br>in File -&gt; Settings that needs to be changed as well.</p><p>In addition I had to also modify path in xml file. After that it worked flawlessly.<br>NOTE: Things have changed a bit since this was written, see Rob’s answer. It’s extremely simple now.</p><h4 id="2-commandline-way"><a href="#2-commandline-way" class="headerlink" title="(2) commandline way"></a>(2) commandline way</h4><p>1) List existing VMs via <code>VBoxManage list vms</code>.2) Next to the names of the VMs, inside curly brackets, their UUIDs are referenced.<br>Copy the one of interest. Details about it can be retrieved via <code>VBoxManage showvminfo UUID</code>.3) Unregister the VM of interest via VBoxManage unregistervm UUID.<br>4) Move the directory of the VM of interest.<br>5) Finally, register the machine via VBoxManage register NameOfVM.vbox – obviously,<br>   where NameOfVM is meant the actual name of the VMs .vbox file to be registered.</p><p>For those who are unsure about the exact procedure, the command which clones an entire machine (including snapshots) is:</p><pre><code>$ VBoxManage clonevm --mode all --name &quot;Cloned_VM&quot; --basefolder /new/path/ --register Cloned_VM</code></pre><p>If necessary, quote path and name.</p><p>Finally, check if all is well and remove the original.<br>That’s all, really. No need to bother with xml files or a hex editor. No need to use a GUI, either.</p><p>While there is no way to actually switch a VDI between fixed-size and dynamic,<br>you can clone the existing VDI into a new one with different settings with VBoxManage.</p><pre><code>VBoxManage clonehd [old-VDI] [new-VDI] --variant StandardVBoxManage clonehd [old-VDI] [new-VDI] --variant Fixed</code></pre><p>If you want to expand the capacity of a VDI, you can do so with</p><pre><code>VBoxManage modifyhd [VDI] --resize [megabytes]</code></pre><p><strong>Resizing only works for dynamic VDI images.</strong> However, you can combine the resize information with the conversion information to expand fixed-size VDIs. (E.g., convert a fixed-size image to dynamic, expand it, and then convert the dynamic image back to a fixed-size image.)</p><p>If you want to compact the image as much a possibly, be sure to zero out the free space. This can be done in Linux by using the dd command to write endless zeros to a file and then deleting that file. (With the caveat of the reserved space of EXT and other file systems.)</p><p><strong>NOTE:</strong><br>variant option specifies what type of the new .vdi file will be. by default, it is Standard, this is a dynamic format.</p><p>Here’s a fairly simple process that worked for me to resize a VirtualBox (v. 4.3.16) fixed size disk<br>to a 60GB dynamic disk on my Mac (OS X 10.9.4) with Linux (Ubuntu 14.04) running as the guest OS:</p><p>In shell on MAC in directory with vdi:</p><p>(1) clone fixed-size vdi to a dynamic-size vdi<br>VBoxManage showhdinfo mydisk.vdi<br>VBoxManage clonehd mydisk.vdi mydisk_clone.vdi –format vdi –variant Standard<br>VBoxManage modifyhd mydisk_clone.vdi –resize 61440<br>VBoxManage showhdinfo mydisk_clone.vdi</p><p>(2) format newly enlarged partition<br>now boot a live cd ubuntu<br>open gparted(gparted is usually installed in the Live-CD by defaul) Ubuntu 15.10 Desktop<br>delete linux-swap extended partition<br>if it has a lock sign, then right click swap off to unlock so that we can delete the extended partition<br>enlarge the origial parition, leave some space for linux-swap extended partition we will create later<br>right click New partition to create linux-swap extended partition<br>apply all changes, turn down the Live-CD<br>boot into the new enlarged vm<br>df -h to check the resulting disk space</p><p>(3) clone dynamic-size vdi back to fixed-size vdi<br>VBoxManage clonehd mydisk_clone.vdi mydisk_clone_fixed.vdi –format vdi –variant Fixed</p><p>(4) 上一步完成之后就是已经是fixed 分区了</p><p>启动ubuntu系统的话会以下 Warning 信息:<br>A start job is running for dev-disk-by\x2duuid-db1d2b48\x2d0cfb\x2d4bdf\x2dabe8\x2db86b9b08dff9.device(1min 22s / 1min 30s)<br>持续1分30秒的时间，导致启动速度非常慢</p><p>网卡没启动成功：</p><p>A start job is running for Wait on all “auto” /etc/network/interfaces to be up for network-online.target</p><p>这个错误的意思是说，等待所有在 /etc/network/interfaces 中配置的网卡 interface 启动，<br>但是如果没有这块网卡（比如没有 enp0s8 (Host-Only)，这种情况通常发生在clone一个系统时，<br>clone出的vm 的网卡的配置跟原vm 的网卡配置不同，所以就导致了网卡不同，但/etc/network/interface又相同）<br>从而在 /etc/network/interfaces 中配置了一块没有的网卡，那么就会出现这个错误。</p><p>这个错误直接就会导致服务 ifup-wait-all-auto.service 失败。</p><p>解决方案：</p><p>ifconfig -a 或者ifquery –list 命令找出已有的的网卡，手工修改 /etc/network/interfaces， 把没有的网卡配置信息删除掉。<br>修改完成之后， 重启网络服务，service networking restart 或者 sudo /etc/init.d/networking restart 或者 systemctl restart networking</p><p>以下是 debug 过程：</p><p>$ systemctl list-units –type=service<br>UNIT                                     LOAD    ACTIVE  SUB      Description<br>ifup-wait-all-auto.service  loaded   failed      failed    Wait for all “auto” /etc/network/interfaces to be up for network-online.target</p><p>$ systemctl list-unit-files | grep network</p><p>$ systemctl –all | grep ifup<br>● ifup-wait-all-auto.service loaded failed failed Wait for all “auto” /etc/network/interfaces to be up for network-online.target<br><a href="mailto:ifup@enp0s17.service" target="_blank" rel="noopener">ifup@enp0s17.service</a> loaded active exited ifup for enp0s17<br><a href="mailto:ifup@enp0s8.service" target="_blank" rel="noopener">ifup@enp0s8.service</a> loaded active exited ifup for enp0s8<br>system-ifup.slice loaded active active system-ifup.slice</p><p>$ sudo find / -name “<a href="mailto:ifup@enp0s17.service" target="_blank" rel="noopener">ifup@enp0s17.service</a>“/sys/fs/cgroup/systemd/system.slice/system-ifup.slice/ifup@enp0s17.service<br>$ ls /sys/fs/cgroup/systemd/system.slice/system-ifup.slice/ifup@enp0s17.service<br>cgroup.clone_children  cgroup.procs  notify_on_release  tasks</p><p>$ sudo find / -name “network-online.target”<br>/lib/systemd/system/network-online.target</p><p>$ systemctl list-dependencies network-online.target<br>network-online.target<br>● ├─ifup-wait-all-auto.service<br>● └─NetworkManager-wait-online.service</p><p>$ sudo find / -name “ifup-wait-all-auto.service”<br>/lib/systemd/system/network-online.target.wants/ifup-wait-all-auto.service<br>/lib/systemd/system/ifup-wait-all-auto.service<br>/sys/fs/cgroup/devices/system.slice/ifup-wait-all-auto.service<br>/sys/fs/cgroup/systemd/system.slice/ifup-wait-all-auto.service</p><p>$ sudo vim /lib/systemd/system/ifup-wait-all-auto.service<br>[Unit]<br>Description=Wait for all “auto” /etc/network/interfaces to be up for network-online.target<br>Documentation=man:interfaces(5) man:ifup(8)<br>DefaultDependencies=no<br>After=local-fs.target<br>Before=network-online.target<br>[Service]<br>Type=oneshot<br>RemainAfterExit=yes<br>TimeoutStartSec=2min            改成 5sec<br>ExecStart=/bin/sh -ec ‘<br>for i in $(ifquery –list –exclude lo –allow auto); do INTERFACES=”$INTERFACES$i “; done; <br>[ -n “$INTERFACES” ] || exit 0; <br>while ! ifquery –state $INTERFACES &gt;/dev/null; do sleep 1; done; <br>for i in $INTERFACES; do while [ -e /run/network/ifup-$i.pid ]; do sleep 0.2; done; done’</p><p>use systemd-analyze blame  to see if there is a service that takes a long time to start.</p><p>By masking the specific service can reduce  getting the startup time down to mere seconds:</p><p>systemctl mask ifup-wait-all-auto.service</p><p>List all network interfaces:<br>$ ifquery –list</p><p>原因：<br>输入下列命令查看(链接:<a href="https://donnutcompute.wordpress.com/2014/04/19/a-start-job-is-running-for-dev-disk-by/" target="_blank" rel="noopener">https://donnutcompute.wordpress.com/2014/04/19/a-start-job-is-running-for-dev-disk-by/</a>)$ journalctl -b<br>Feb 01 12:28:36 ub1510alx systemd[679]: Startup finished in 74ms.<br>Feb 01 12:28:36 ub1510alx systemd[1]: Started User Manager for UID 1000.<br>Feb 01 12:28:39 ub1510alx systemd[1]: dev-disk-by\x2duuid-bc922c81\x2d9c9f\x2d4461\x2dadcf\x2db86b9b08dff9.device: Job dev-disk-by\x2duuid-bc922c81\x2d9c9f\x2d4461\x2da<br>Feb 01 12:28:39 ub1510alx systemd[1]: Timed out waiting for device dev-disk-by\x2duuid-bc922c81\x2d9c9f\x2d4461\x2dadcf\x2db86b9b08dff9.device.<br>Feb 01 12:28:39 ub1510alx systemd[1]: Dependency failed for /dev/disk/by-uuid/bc922c81-9c9f-4461-adcf-b86b9b08dff9.<br>Feb 01 12:28:39 ub1510alx systemd[1]: dev-disk-by\x2duuid-bc922c81\x2d9c9f\x2d4461\x2dadcf\x2db86b9b08dff9.swap: Job dev-disk-by\x2duuid-bc922c81\x2d9c9f\x2d4461\x2dadc<br>Feb 01 12:28:39 ub1510alx systemd[1]: Startup finished in 9.433s (kernel) + 3min 2.537s (userspace) = 3min 11.971s.<br>Feb 01 12:28:39 ub1510alx systemd[1]: dev-disk-by\x2duuid-bc922c81\x2d9c9f\x2d4461\x2dadcf\x2db86b9b08dff9.device: Job dev-disk-by\x2duuid-bc922c81\x2d9c9f\x2d4461\x2d</p><p>什么是 swap status?<br>$ cat /proc/swaps<br>Filename                                Type            Size    Used    Priority<br>There is nothing there!</p><p>Is fstab right?<br>$ cat /etc/fstab</p><h1 id="etc-fstab-static-file-system-information"><a href="#etc-fstab-static-file-system-information" class="headerlink" title="/etc/fstab: static file system information."></a>/etc/fstab: static file system information.</h1><p>#</p><h1 id="Use-‘blkid’-to-print-the-universally-unique-identifier-for-a"><a href="#Use-‘blkid’-to-print-the-universally-unique-identifier-for-a" class="headerlink" title="Use ‘blkid’ to print the universally unique identifier for a"></a>Use ‘blkid’ to print the universally unique identifier for a</h1><h1 id="device-this-may-be-used-with-UUID-as-a-more-robust-way-to-name-devices"><a href="#device-this-may-be-used-with-UUID-as-a-more-robust-way-to-name-devices" class="headerlink" title="device; this may be used with UUID= as a more robust way to name devices"></a>device; this may be used with UUID= as a more robust way to name devices</h1><h1 id="that-works-even-if-disks-are-added-and-removed-See-fstab-5"><a href="#that-works-even-if-disks-are-added-and-removed-See-fstab-5" class="headerlink" title="that works even if disks are added and removed. See fstab(5)."></a>that works even if disks are added and removed. See fstab(5).</h1><p>#</p><h1 id=""><a href="#" class="headerlink" title="                                 "></a><file system="">                   <mount point="">  <type>  <options>        <dump>  <pass></pass></dump></options></type></mount></file></h1><h1 id="was-on-dev-sda1-during-installation"><a href="#was-on-dev-sda1-during-installation" class="headerlink" title="/ was on /dev/sda1 during installation"></a>/ was on /dev/sda1 during installation</h1><p>UUID=96f31591-dcd7-4e89-b50d-b8a62a4776db    /        ext4  errors=remount-ro     0      1</p><h1 id="swap-was-on-dev-sda5-during-installation"><a href="#swap-was-on-dev-sda5-during-installation" class="headerlink" title="swap was on /dev/sda5 during installation"></a>swap was on /dev/sda5 during installation</h1><p>UUID=bc922c81-9c9f-4461-adcf-b86b9b08dff9   none       swap    sw             0      0</p><p>What is Swap UUID?<br>$ lsblk -f<br>NAME   FSTYPE  LABEL                       UUID                                 MOUNTPOINT<br>sda<br>├─sda1 ext4                              96f31591-dcd7-4e89-b50d-b8a62a4776db /<br>├─sda2<br>└─sda5 swap                              04080eae-5988-4f53-a362-796c3408dd08<br>sr0    iso9660 VBOXADDITIONS_5.0.12_104815 2015-12-18-16-03-06-00</p><p>这里显示的分区后的各个分区的真实UUID，显然fstab表里的Swap UUID还是原来删除的那个swap分区的UUID，<br>显然是错的。Swap UUID in fstab is incorrect!</p><p>分析：删除老的swap分区之后，新建的swap分区的UUID没有更新到fstab表里，fstab表里存的还是之前的老的swap分区的UUID，<br>所以导致了启动的时候花很多时间去检查</p><p>解决办法：<br>Solution<br>更新fstab表里的Swap分区的UUID(即/dev/sda5 swap下的UUID)<br>$ vim /etc/fstab</p><p>把 UUID 改成 lsblk -f 里显示的正确的</p><h1 id="dev-sda5"><a href="#dev-sda5" class="headerlink" title="/dev/sda5"></a>/dev/sda5</h1><p>UUID=da7fa69a8-31bd-448c-98de-55de4aa6f06a       none            swap            defaults        0 0</p><p><strong>References</strong><br>印象笔记: <a href="https://app.yinxiang.com/Home.action#n=01862315-0296-4ebf-8360-b1ca3241ec18&amp;b=6ac15670-a7da-4bb7-b91d-9bdedaf2583e&amp;ses=4&amp;sh=1&amp;sds=5&amp;" target="_blank" rel="noopener">https://app.yinxiang.com/Home.action#n=01862315-0296-4ebf-8360-b1ca3241ec18&amp;b=6ac15670-a7da-4bb7-b91d-9bdedaf2583e&amp;ses=4&amp;sh=1&amp;sds=5&amp;</a><br><a href="http://boluns.blog.163.com/blog/static/69845968201411691347597/" target="_blank" rel="noopener">http://boluns.blog.163.com/blog/static/69845968201411691347597/</a><br><a href="https://cnzhx.net/blog/resizing-lvm-centos-virtualbox-guest/" target="_blank" rel="noopener">https://cnzhx.net/blog/resizing-lvm-centos-virtualbox-guest/</a><br><a href="http://www.cnblogs.com/codemood/p/3142848.html" target="_blank" rel="noopener">http://www.cnblogs.com/codemood/p/3142848.html</a></p>]]></content>
      
      
      <categories>
          
          <category> VirtualBox </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Use VBoxManage to manage VirtualBox</title>
      <link href="/VirtualBox/vbox-vboxmanage/"/>
      <url>/VirtualBox/vbox-vboxmanage/</url>
      
        <content type="html"><![CDATA[<p>VBoxManage is the command-line interface (CLI) to VirtualBox. With it, we can completely control VirtualBox from the command line of our host operating system. VBoxManage supports all the features that the graphical user interface gives you access to, but it supports a lot more than that. It exposes really all the features of the virtualization engine, even those that cannot (yet) be accessed from the GUI.</p><p>It is extremely helpful when we are manage the VirtualBox VMs from remotely but only have access to a terminal on a remote host machine.</p><p>Other reasons that we may need VBoxManage is:</p><ul><li>Use a different user interface than the main GUI (for example, <code>VBoxSDL</code> or the VBoxHeadless server);</li><li>Control some of the more advanced and experimental configuration settings for a VM.</li></ul><p><strong>VBoxManage</strong> is provided as an executable (<code>&quot;C:\Program Files\Oracle\VirtualBox\VBoxManage.exe&quot;</code>) in Windows, we can execute this program like any other utility in <strong>Windows Command Line</strong>. By default, it is not in PATH environment variable, so we should add it to PATH so that we can execute it directly.</p><h5 id="VBoxManage-syntax"><a href="#VBoxManage-syntax" class="headerlink" title="VBoxManage syntax"></a>VBoxManage syntax</h5><pre><code>$ VBoxManage [-options] subcommand target</code></pre><h3 id="Observing-Existing-Virtual-Machines"><a href="#Observing-Existing-Virtual-Machines" class="headerlink" title="Observing Existing Virtual Machines"></a>Observing Existing Virtual Machines</h3><p>Assume we already have VMs registered in VirtualBox (say, with the help of the GUI), the first thing you we most likely want to do with VBoxManage is look through the list of those VMs:</p><pre><code>$ VBoxManage list vms&quot;Ubuntu 12.04&quot; {774c5e04-a35b-49c5-a406-305f1a887295}&quot;Ubuntu 17.10&quot; {0d41ebff-4c96-48ec-a65a-233b4e21c10e}&quot;CentOS 7&quot; {ad697671-713f-4704-9c46-882dd931c254}</code></pre><p>If the command outputs nothing, you either currently have no VMs registered with Oracle VM VirtualBox or you’re running VBoxManage as a user different from the user who created those VMs.</p><p>To view the VMs that are running at the moment, you might use the runningvms subcommand of VBoxManage list:</p><pre><code>$ VBoxManage list runningvms&quot;Oracle Developer Days&quot; {c465cc52-dc11-4153-82d8-b5718182c117}</code></pre><p>The VBoxManage list command can be used with option -l, which instructs the list command to output a detailed list (truncated below to save space):</p><pre><code>$ VBoxManage list -l running vmsName:            Ubuntu_16.10Groups:          /Guest OS:        Ubuntu (64-bit)UUID:            ad697671-713f-4704-9c46-882dd931c254Config file:     C:\Users\shichunhui\VirtualBox VMs\Ubuntu_16.10\Ubuntu_16.10.vboxSnapshot folder: C:\Users\shichunhui\VirtualBox VMs\Ubuntu_16.10\SnapshotsLog folder:      C:\Users\shichunhui\VirtualBox VMs\Ubuntu_16.10\LogsHardware UUID:   ad697671-713f-4704-9c46-882dd931c254Memory size:     4096MBPage Fusion:     offVRAM size:       16MBCPU exec cap:    100%HPET:            offChipset:         piix3Firmware:        BIOSNumber of CPUs:  3PAE:             off...</code></pre><h3 id="Creating-a-VM"><a href="#Creating-a-VM" class="headerlink" title="Creating a VM"></a>Creating a VM</h3><hr><p>Use VBoxManage to create a VM in VirtualBox not only free us from manage the GUI interface, but also provides us an automated way to simplify the process. </p><pre><code>$ VBoxManage createvm --name &quot;Ubuntu17.10&quot; --ostype Ubuntu --register</code></pre><p>The process of creating a VM is to build a VM definition in XML file. We can add the –register option to register the VM’s definition into the VirtualBox directly, or we can register it later with the help of the <code>VBoxManage registervm</code> command.</p><p>In fact, the name of the VM is the only mandatory parameter of the createvm command. The details can be specified later through the various parameters of the <strong>modifyvm</strong> command. Both modifyvm and createvm, however, support the ostype optional parameter that you can use to give VirtualBox an idea of what guest operating system will be installed into the VM.</p><p>To get a complete list of supported operating systems we can do:</p><pre><code>$ VBoxManage list ostypes</code></pre><h3 id="Setting-Up-a-VM’s-Properties"><a href="#Setting-Up-a-VM’s-Properties" class="headerlink" title="Setting Up a VM’s Properties"></a>Setting Up a VM’s Properties</h3><p>Once the VM is created, we may want to inspect its current properties:</p><pre><code>$ VBoxManage showvminfo Ubuntu17.10Name:            Ubuntu_16.10Groups:          /Guest OS:        Ubuntu (64-bit)UUID:            ad697671-713f-4704-9c46-882dd931c254Config file:     C:\Users\juniway\VirtualBox VMs\Ubuntu17.10\Ubuntu17.10.vboxSnapshot folder: C:\Users\juniway\VirtualBox VMs\Ubuntu17.10\SnapshotsLog folder:      C:\Users\juniway\VirtualBox VMs\Ubuntu17.10\LogsHardware UUID:   ad697671-713f-4704-9c46-882dd931c254Memory size:     4096MBPage Fusion:     offVRAM size:       16MBCPU exec cap:    100%HPET:            offChipset:         piix3Firmware:        BIOSNumber of CPUs:  3PAE:             offLong Mode:       onTriple Fault Reset: offAPIC:            onX2APIC:          onCPUID Portability Level: 0CPUID overrides: NoneBoot menu mode:  message and menuBoot Device (1): FloppyBoot Device (2): DVDBoot Device (3): HardDiskBoot Device (4): Not AssignedACPI:            onIOAPIC:          onBIOS APIC mode:  APIC</code></pre><p>Beside, we might need to modify its properties to meet our personal needs and to comply with the requirements of the guest OS that we are going to install in the VM.</p><pre><code>$ VBoxManage modifyvm Ubuntu17.10 --cpus 2 --memory 2048 --vram 12 --acpi on --boot1 dvd --nic1 nat</code></pre><p>When setting the amount of RAM and CPUs for a VM, we should take into account the requirements of the guest OS, make sure that the host will have enough memory left to operate properly after we start all the VMs that are supposed to work simultaneously. Don’t assign more virtual CPUs than the number of physical cores on the host computer.</p><p>Since <code>VBoxManage showvminfo</code> displays VM’s complete infomation (too much), we can use <code>grep</code> to filter the output:</p><pre><code>$ VBoxManage showvminfo Ubuntu17.10 | grep &quot;Memory size&quot;Memory size:     2048MB</code></pre><h3 id="Configuring-a-Virtual-Network-Adapter"><a href="#Configuring-a-Virtual-Network-Adapter" class="headerlink" title="Configuring a Virtual Network Adapter"></a>Configuring a Virtual Network Adapter</h3><p>Network setting is very important when we set up a VM, we can configure a <strong>virtual network card</strong> over a physical network interface of the host system to provide your VM with the ability to interact with the outside world.<br>By default, VirtualBox configures one virtual adapter for a VM, setting it to operate in the NAT networking mode, in most case, this will satisfiy our need, the former command with option <code>--nic1 nat</code> explicitly specifies the networking mode to be NAT.</p><p>If we want to the mode of that adapter, nic1, to another mode (say bridged, for bridged networking), we can do this:</p><pre><code>$ VBoxManage modifyvm Ubuntu17.10 --nic1 bridged --bridgeadapter1 eth0</code></pre><p>To list the available interfaces on the host system, we can use <code>ipconfig</code> in Windows.</p><h3 id="Attaching-Virtual-Media-to-a-VM"><a href="#Attaching-Virtual-Media-to-a-VM" class="headerlink" title="Attaching Virtual Media to a VM"></a>Attaching Virtual Media to a VM</h3><p>Like a real computer, VM needs a storage device, such as a hard disk, to boot from and for storing and retrieving system and user data. it’s time to create a virtual hard disk for the VM. </p><p>This is actually a three-step process.<br>As the first step, you create a new virtual hard disk image. With the following command, you create a disk image file in VirtualBox’s VDI format. </p><pre><code>$ VBoxManage createhd --filename /path/to/hard_drive_image/Ubuntu17.10.vdi --size 100000 --variant Standard0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%Disk image created. UUID: c69e22d2-1560-44cc-85f6-d81979c81990</code></pre><p>Here we create a virtual hard disk image with the size of 10 GB, the option <strong>–variant Standard</strong> means we create a dynamically allocated image file, if we want a fixed-size image, we could use <strong>–variant Fixed</strong>. In whichever case, we’ll be able to expand the image capacity anytime later with the <strong>VBoxManage modifyhd</strong> command.</p><p>The next step is to add a storage controller to be used with that hard disk:</p><pre><code>$ VBoxManage storagectl Ubuntu17.10 --name &quot;SATA Controller&quot; --add sata --bootable on</code></pre><p>Note: When choosing Serial ATA (SATA) as the controller type, make sure the guest OS has device support for Advanced Host Controller Interface (AHCI), which is the standard interface for SATA controllers. Be warned that older operating systems, such as Windows XP, do not support AHCI. In that case, use an Integrated Drive Electronics (IDE) controller.</p><p>Finally, we need to attach the hard disk to the controller:</p><pre><code>$ VBoxManage storageattach Ubuntu17.10 --storagectl &quot;SATA Controller&quot; --port 0 --device 0 --type hdd --medium /path/to/hard_drive_image/Ubuntu17.10.vdi</code></pre><p>We can connect up to 30 virtual hard drives to a VM through a single SATA controller. In the case of an IDE controller, you’re limited to just 4 virtual storage devices, where one of them is normally the virtual CD/DVD drive.</p><p>Now a VM and the correspoding hardware device are set up completely, we are ready to install a Guest OS into the VM.</p><h3 id="Install-Guest-OS-in-VM"><a href="#Install-Guest-OS-in-VM" class="headerlink" title="Install Guest OS in VM"></a>Install Guest OS in VM</h3><p>Assume we have already have a ISO image file for the OS we want to install, we need to configure the VM to boot from the it, to do that we need to create a virtual CD/DVD drive and connect it to the installation media. Like virtual hard drives, virtual CD/DVD drives also require a storage controller. While this can be done using a SATA controller for many operating systems, the following example illustrates adding an IDE controller for the CD/DVD drive.</p><pre><code>$ VBoxManage storagectl Ubuntu17.10 --name &quot;IDE Controller&quot; --add ide --controller PIIX4</code></pre><p>Suppose we have a installation DVD disk. Insert the installation disk into the host’s CD/DVD drive and then issue the following command, connecting the VM’s virtual CD/DVD drive to the physical CD/DVD drive on the host computer:</p><pre><code>$ VBoxManage storageattach Ubuntu17.10 --storagectl &quot;IDE Controller&quot; --port 0  --device 0 --type dvddrive --medium /full/path/to/unbuntu17.10_server.iso</code></pre><p><img src="/image/vbox_storage_cd_hd.png" alt=""></p><p>We can use <strong>vboxmanage showviminfo</strong> command to inspect whether we have IDE or SATA controller installed correctly:</p><pre><code>$ VBoxManage showvminfo Ubuntu17.10 | grep &quot;IDE&quot;Storage Controller Name (0):            IDEIDE (0, 0): D:\Program Files\VBoxGuestAdditions_5.0.17.iso (UUID: 94ae2d78-c3b3-4d7f-86f7-389311e8d9fa)$ VBoxManage showvminfo Ubuntu17.10 | grep &quot;SATA&quot;Storage Controller Name (1):            SATASATA (0, 0): D:\Program Files\VDIs\ub1710.vdi (UUID: 31482d54-a73e-42ed-84be-ddde20546d9c)</code></pre><p>Now you can boot the VM and start the guest installation using the following command, which starts in GUI mode by default, taking you through a standard guest OS installer:</p><pre><code>$ VBoxManage startvm Ubuntu17.10 </code></pre><h3 id="Things-to-do-after-we-have-successfully-installed-the-Guest-OS"><a href="#Things-to-do-after-we-have-successfully-installed-the-Guest-OS" class="headerlink" title="Things to do after we have successfully installed the Guest OS"></a>Things to do after we have successfully installed the Guest OS</h3><p>Once we have completed the OS installation, we shut down the VM from within the guest, which causes VirtualBox to power off the VM was well.<br>The below command is equivalent to briefly pressing the power button on a physical computer.</p><pre><code>$ VBoxManage controlvm Ubuntu17.10 acpipowerbutton</code></pre><p>We can forcibly shut down a VM using the following command, which is equivalent to pressing and holding a computer’s power button:</p><pre><code>$ VBoxManage controlvm Ubuntu17.10 poweroff</code></pre><p>Finally, since the OS is already installed in the guest, we can remove the DVD from the VM configuration:</p><pre><code>$ VBoxManage storageattach Ubuntu17.10 --storagectl &quot;IDE Controller&quot; --port 0 --device 0 --type dvddrive --medium none$ VBoxManage modifyvm &quot;Ubuntu17.10&quot; --dvd none</code></pre><h3 id="Guest-Additions-and-Shared-Folders"><a href="#Guest-Additions-and-Shared-Folders" class="headerlink" title="Guest Additions and Shared Folders"></a>Guest Additions and Shared Folders</h3><p>(1) Mount Guest Addition </p><pre><code>$ VBoxManage storageattach &quot;Ubuntu17.10&quot; --storagectl &quot;IDE Controller&quot; --port 1 --device 0 --type hdd --medium /path/to/VBoxGuestAdditions.iso</code></pre><p>(2) Adding/removing shared folders</p><pre><code>$ vboxmanage sharedfolder add &quot;Ubuntu17.10&quot; --name shared_dir --hostpath /path/to/folder/ --automount$ vboxmanage sharedfolder remove &quot;io&quot; --name share_dir</code></pre><h3 id="Export-and-Import-VM"><a href="#Export-and-Import-VM" class="headerlink" title="Export and Import VM"></a>Export and Import VM</h3><p>Oracle offers a number of <a href="http://www.oracle.com/technetwork/community/developer-vm/index.html" target="_blank" rel="noopener">prebuilt developer VMs for Oracle VM VirtualBox</a>, providing a quick way to install and experience entire software stacks packaged into deployable appliances. The VBoxManage import command allows you to import such appliances packaged in OVA format into Oracle VM VirtualBox.<br>Also, if we want clone/package our local VM onto other Host Computer (System), we can export the VM out to a VirtualBox <code>.ovf</code> file and then import this file on other Host Computer.</p><p>Now, suppose we want to import <em>Oracle Linux 7.2</em> into our VirtualBox from the <code>OracleLinux72.ova</code> package, which you have downloaded to your system from <a href="http://www.oracle.com/technetwork/systems/hands-on-labs/index.html" target="_blank" rel="noopener">Oracle Linux Hands-on Labs</a>. First, we might want to check the options available for the appliance to be imported. This can be done with the <code>--dry-run</code> option of the VBoxManage import command:</p><pre><code>$ VBoxManage import /path/to/OracleLinux72.ova --dry-run </code></pre><p>Below command import an VM and pecify the amount of RAM and the number of CPUs to be allocated, also, use <code>--eula accept</code> option to accept the license agreement.</p><pre><code>$ VBoxManage import /path/to/OracleLinux72.ova --vsys 0 --memory 1024 --cpus 2 --eula accept </code></pre><p>Once the import has successfully been completed, the Oracle Virtual Sysadmin Days VM icon should appear in the left pane of VirtualBox Manager. And, of course, you’ll be able to manipulate the VM from the command line using the VBoxManage commands.</p><p>Export has similar syntax, we can use <code>--output</code> to specify a file name</p><pre><code>$ VBoxManage export &quot;Ubuntu17.10&quot; --output ub1710_clone.ovf</code></pre><p><strong>Reference</strong><br><a href="https://www.virtualbox.org/manual/ch08.html" target="_blank" rel="noopener">https://www.virtualbox.org/manual/ch08.html</a><br><a href="https://community.oracle.com/docs/DOC-890092" target="_blank" rel="noopener">https://community.oracle.com/docs/DOC-890092</a><br><a href="http://nakkaya.com/2012/08/30/create-manage-virtualBox-vms-from-the-command-line/" target="_blank" rel="noopener">http://nakkaya.com/2012/08/30/create-manage-virtualBox-vms-from-the-command-line/</a></p>]]></content>
      
      
      <categories>
          
          <category> VirtualBox </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Paxos</title>
      <link href="/Distributed-System/distributed-system-paxos/"/>
      <url>/Distributed-System/distributed-system-paxos/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr><p>Paxos 协议是分布式系统中最著名的一致性协议，最早由 Lamport 在 1989 年发表，根据 Lamport 自己介绍，Paxos 名称来源与希腊的一个岛名。由于当时发表的 Paper 描述太过晦涩没有被人所注意，直到 1998 年在期刊上再次发表一篇论文 “The Part-Time Parliament” 才最终被业界所重视才流传开来。虽然如此，Paxos 还是不易理解，因此，后来 Lamport 又用白话文再写了一篇 “Paxos Made Simple” 的论文发表，人们才渐渐真正理解 Paxos 的原理。</p><p>我在美国念研究生的时候，专业核心方向便是分布式系统算法，那时候的课程几乎全是在学习这些大神的论文，课后的很多的 Projects 便是根据论文来实现他们论文中所描述的算法，这些基础性的论文大量来自于 Leslie Lamport 教授。</p><h3 id="Paxos-协议"><a href="#Paxos-协议" class="headerlink" title="Paxos 协议"></a>Paxos 协议</h3><p>Paxos 协议其实真正理解起来不难，难的地方在我看来主要是很难与工程或者实践联系起来，造成了理解和体会上的分割。</p><p>这篇文章主要简单阐述 Paxos 的协议原理</p><p>Paxos 协议中一共有 3 中角色： Proposers, Acceptors, Learners</p><p>整个协议的过程分为两个阶段</p><h5 id="第一阶段（Prepare-Phase-："><a href="#第一阶段（Prepare-Phase-：" class="headerlink" title="第一阶段（Prepare Phase)："></a>第一阶段（Prepare Phase)：</h5><p>（a）Proposer 选择一个 Number 和一个 Value，发送一个 Prepare Request 给大多数 Acceptors<br>（b）Acceptor 收到 Prepare Request 之后<br>如果当前 Number 小于已经 Promise 过的 Proposal 的 number，那么忽略请求（或者更好的处理是告知对方当前已经 Promise 过的 Number，以便对方下次可以提出一个更高的 Number 提高下次的通过概率）<br>如果当前 Number 大于已经 Promise 过的 Proposal 的 number， 或者没有 Promise 过任何 Proposal，那么直接同意，Acceptor 做出 Promise，并且立刻告知对方。</p><p>总结，Prepare 有两个作用: </p><ol><li><p>大的 proposal id 会 block 未完成的小的 proposal id 达成一致的过程，所以为了减少无效的 Prepare 请求，每次都选择比自己以往见过的 proposal id 更大的id。 </p></li><li><p>一旦某个 value 达成一致，那么后续的 Prepare 都会找到这个 value 作为 accept 阶段的值可以看出，一次 Paxos 达成一致至少需要两次网络交互。 </p></li></ol><p>注意，Acceptor 需要记住两个值：<br>第一个是在 Prepare 阶段，需要记住 Promise 过的最高的 Number<br>第二个是在 Accept 阶段，需要记住已经 accept 过的最高的 Number，一旦有 accept request 过来的 number 小于之前已经 accept 过的最高 Number， 就忽略或拒绝。</p><h5 id="第二阶段（Accept-Phase）"><a href="#第二阶段（Accept-Phase）" class="headerlink" title="第二阶段（Accept Phase）"></a>第二阶段（Accept Phase）</h5><p>Propose 在提出 Prepare request 并收到大多数 acceptors 的 response 消息之后，就发送 accept request 给大多数的 Acceptors（这些 Acceptors 没必要都是上一阶段接收 prepare requests 的那些 Acceptors），并把所有收到的 resonse 中的 Number 值最大的对应的 Value 发送过去。<br>Acceptor 收到一个 accept request，如果该 number 的值大于等于之前回复过的 prepare request 中的 number 的值，就立刻接受，并且通知 Learners 去学习。 </p><p>value 被大多数接受之前，每个Acceptor可以accept多个不同的值。但是，一旦一个value被majority accept(即value达成一致)，那么这个value就不会变了。因为Prepare阶段会将该value给找出来，随后Accept阶段会使用这个value，后续的所有的提案都会选择这个value。</p><p>最后还有个阶段，就是<strong>学习阶段</strong>，其流程非常简单：</p><p>一旦 accept 某个 proposal， 就把该 proposal 告诉所有 learners，让他们学习这个 chosen value。<br>由于要告诉所有 learners，效率比较低，所以考虑一个专门（distinguished）的 learners group。</p><h3 id="Paxos-的开源实现"><a href="#Paxos-的开源实现" class="headerlink" title="Paxos 的开源实现"></a>Paxos 的开源实现</h3><p><a href="https://github.com/cocagne/paxos" target="_blank" rel="noopener">https://github.com/cocagne/paxos</a></p><br>##### 参考：[paxos made simple][]]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Multi Paxos</title>
      <link href="/Distributed-System/distributed-system-multi-paxos/"/>
      <url>/Distributed-System/distributed-system-multi-paxos/</url>
      
        <content type="html"><![CDATA[<p>Basic paxos 一轮协议只决定一个值，而 Multi paxos 可以决定多个值（有序）</p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VirtualBox Headless Server</title>
      <link href="/VirtualBox/vbox-vbox-headless/"/>
      <url>/VirtualBox/vbox-vbox-headless/</url>
      
        <content type="html"><![CDATA[<p>It makes no senses that we open a VirtualBox GUI but never work in Guest OS provided in it, becasue it is common that we use a third party SSH client to connect to the Guest OS and do everything in the Interface it provided, so we actually don’t need to VirtualBox GUI interface to displacy the Guest OS locally, we only need the VM to run in background, by another word, <strong>headless</strong>!.</p><p>VirtualBox provides a front-end called <strong>VBoxHeadless</strong>, it has no GUI and produces no visible output on the host at all, it works completely in background siliently.</p><p>There three ways to start a virtual machine with VBoxHeadless</p><h5 id="1-use-type-headless-option"><a href="#1-use-type-headless-option" class="headerlink" title="(1) use --type headless option"></a>(1) use <code>--type headless</code> option</h5><pre><code>$ VBoxManage startvm &quot;VM name&quot; --type headless</code></pre><p>Note the extra <code>--type</code> option causes VirtualBox to use VBoxHeadless as the front-end to the internal virtualization engine instead of the Qt front-end. Beside, there are actually 4 types of front-end are supported in VirtualBox: <code>--type gui|sdl|headless|separate</code>.</p><h5 id="2-VBoxHeadless-is-provided-as-an-executable-so-we-can-execute-it-directly"><a href="#2-VBoxHeadless-is-provided-as-an-executable-so-we-can-execute-it-directly" class="headerlink" title="(2) VBoxHeadless is provided as an executable, so we can execute it directly"></a>(2) VBoxHeadless is provided as an executable, so we can execute it directly</h5><pre><code>$ VBoxHeadless --startvm &lt;uuid|name&gt;</code></pre><p>This way of starting the VM helps troubleshooting problems reported by <code>VBoxManage startvm ...</code>, because it provides more detailed error messages, especially for early failures before the VM execution is started. </p><h5 id="3-In-VirtualBox-Manager-GUI-hold-the-Shift-key-when-starting-a-virtual-machine-or-selecting-Headless-Start-from-the-Machine-menu"><a href="#3-In-VirtualBox-Manager-GUI-hold-the-Shift-key-when-starting-a-virtual-machine-or-selecting-Headless-Start-from-the-Machine-menu" class="headerlink" title="(3) In VirtualBox Manager GUI, hold the Shift key when starting a virtual machine or selecting Headless Start from the Machine menu"></a>(3) In VirtualBox Manager GUI, hold the Shift key when starting a virtual machine or selecting Headless Start from the Machine menu</h5><p><img src="/image/start_vbox_headless.png" alt=""></p><p>We can automate the starting/poweroff of VMs in a script file so that we never need to Open a VirtualBox Manager GUI or type <code>vboxmanage startvm ...</code> command each time we start or poweroff the VMs.</p><p>Below are two scripts of Windows command Line that can do the job.</p><p>(1) <em><code>unbuntu17.10_start.cmd</code></em></p><pre><code>@echo off&quot;VBoxManage.exe&quot; -nologo startvm &quot;Ubuntu17.10&quot; --type headless 2&gt;NUL</code></pre><p>(2) <em><code>unbuntu17.10_start.cmd</code></em></p><pre><code>@echo offVBoxManage.exe controlvm Ubuntu_16.10 poweroff 2&gt;NUL  2&gt;NUL</code></pre><br><br><br><br><h6 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h6><p><a href="https://www.virtualbox.org/manual/ch07.html" target="_blank" rel="noopener">https://www.virtualbox.org/manual/ch07.html</a></p>]]></content>
      
      
      <categories>
          
          <category> VirtualBox </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fish Shell Programming</title>
      <link href="/Linux/linux-fish-programming/"/>
      <url>/Linux/linux-fish-programming/</url>
      
        <content type="html"><![CDATA[<p>Fish shell 是我个人开发环境中最喜爱的 shell 环境，因此一些 fish 下的命令有必要掌握，方便我更高效的在 fish 下进行工作。</p><p>Fish shell 下与 bash 有很多不同，这里主要列出编写 fish shell 下脚本常用的命令</p><p>在 bash 中是通过 back-tick 符号或者 $() 来获取执行一条 shell 命令的结果的，如 dir=<code>pwd</code> 或者 dir=$(pwd)<br>在 fish 中， 则直接通过 () 来获取执行一条 shell 命令的结果， 如 dir=(pwd)<br><img src="/image/fish_subshell.png" alt=""></p><p><strong>判断上条语句是否执行成功（在bash中是 $?）：</strong><br>echo $status</p><p><strong>一组连续命令：</strong><br>begin; ls; ls; end | wc<br>注意： 在 bash 中是通过 semi colon 来连接的，比如 {ls; ls;} | wc</p><p><strong>Subshell</strong><br>fish -c ‘ls; ls’ | wc<br>注意： 在 bash 中是 通过 圆括号() 来启动 subshell 的， 比如 (ls; ls) | wc</p><p><strong>变量设置：</strong><br>set -g var “hello”<br>参数：<br>-g global<br>-x export<br>-e erase</p><p><strong>列出所有 export 了的变量</strong><br>set -x </p><p><strong>撤销 export</strong><br>set -gu var $var</p><p><strong>编辑某变量</strong><br>vared  – interactively edit the value of an environment variable</p><p><strong>特殊变量(Special Variables)：</strong><br>shell 名字：                     (status -f)<br>command line arguments ：        $argv[1], $argv[2], …         （bash 中是 $1, $2, …）<br>umber of command line args：    (count $argv)                   （bash 中是 $#）<br>每个args依次输入：               $argv                           （bash 中是 “$@”）<br>所有 args 作为整体输入：         “$argv”                         （bash 中是 “$*”）<br>本进程名：                       %self                           （bash 中是 $$）<br>exit status of last non-asynchronous command:  $status           （bash 中是 $?）</p><p><strong>List:</strong><br>echo {foo,bar}</p><p><strong>数组：</strong><br>literal: set a do re mi<br>上述 set 语句实际上是把 一个数组（元素分别为 do, re, mi 赋值给了变量 a<br>可以通过 访问数组元素的方式访问每个元素，index 从 1 开始<br>$a[1] 是 do<br>负索引：         $a[-1] 是数组最后一个元素<br>slice：                     $a[(seq 2 3)]<br>update：                  set a[1] do<br>数组大小：       count $a<br>遍历数组index：  seq (count $a)<br>删除数组元素：   set -e a[1]<br>删除数组：       set -e a<br>把数组元素依次做参数传给cmd： cmd $a              （对应bash中的： cmd “${a[@]}”）<br>把整个数组做为一个参数传给cmd： cmd “$a”           （对应bash中的： cmd “${a[*]}”）</p><p><strong>流程控制：</strong><br>not 代替 bash 中的 !</p><p><strong>for</strong></p><pre><code>for var in arg …  cmd  …end                    注意：  这里是 end 结尾，在 bash 中则是 done 结尾！</code></pre><p><strong>while</strong></p><pre><code>while test  cmd  …end                     注意：  这里是 end 结尾，在 bash 中则是 done 结尾！</code></pre><p><strong>if</strong></p><pre><code>if test  cmdelse if test            注意：这里 else if 没有连在一起， 在 bash 中则是 elseif  cmdelse  cmdend                     注意：  这里是 end 结尾，在 bash 中则是 fi 结尾！</code></pre><p><strong>switch case</strong></p><pre><code>switch arg  case pattern …    cmd  case &apos;*&apos;    cmdend </code></pre><p><strong>条件测试：</strong><br>[ -e /etc ]<br>test -e /etc</p><p>在命令行中写 条件测试语句，用 ；分割每个命令，用 and/or 来做条件逻辑</p><p>例子：</p><pre><code>$ set testa hello$ [ {$testa}==&quot;hello&quot; ] ; or echo &quot;ok&quot;</code></pre><p>算数判断：<br>-eq -ne -lt -gt -le -ge</p><p>字符串判断：<br>== !=</p><p>数学运算：<br>math ‘1 + 1’<br>math ‘1.1 + 1.1’</p><p>循环语句：<br>while true<br>  read cmd<br>  eval $cmd<br>end</p><p>逻辑判断：<br>&amp;&amp; || !</p><p><strong>fish prompt:</strong><br><strong>left prompt</strong></p><pre><code>function fish_prompt  echo -n &apos;$ &apos;end</code></pre><p><strong>right prompt</strong></p><pre><code>function fish_right_prompt  dateend</code></pre><p><strong>More programming examples:</strong><br><a href="https://butterflyprogramming.neoname.eu/programming-with-fish-shell/" target="_blank" rel="noopener">https://butterflyprogramming.neoname.eu/programming-with-fish-shell/</a> </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Shell Variables</title>
      <link href="/Linux/linux-shell-variables/"/>
      <url>/Linux/linux-shell-variables/</url>
      
        <content type="html"><![CDATA[<p>Bash 变量只有两种类型，字符串和数组。</p><p>变量的赋值与引用</p><p>变量通过等于号<code>=</code> (左右两边无空格)来赋值，通过 <code>$</code> 来引用, 引用未定义过的变量，那么会以空字符取代。</p><p>数组变量的赋值：</p><ul><li>Arr[index]=value</li><li>declare -a Arr</li><li>Arr=(value1 value2 … valueN) 注意：每个 value 以空格隔开<br>e.g.<br>ch=(1 2 3 4)<br>echo “${ch[0]}”</li></ul><p>注：数组下标的范围没有任何限制,同时也不必使用连续的分量.</p><p>关联数组：</p><ul><li>declare -A Map</li></ul><p>关联数组赋值：</p><pre><code>Map=([x]=a, [y]=b)</code></pre><p>往现有数组批量添加元素：</p><pre><code>Arr+=(a b c)Map+=([a]=1 [b]=2)</code></pre><p>取值（引用）</p><pre><code>${Arr[INDEX]}${Map[KEY]}</code></pre><p>${A[@]} 展开成所有的变量，而<strong>获取数组长度</strong>使用 ${#A[@]}</p><p>切片：</p><pre><code>${ARY[@]:N:M}   注：N 是 offset，M 是 length</code></pre><p>返回索引，相当于keys()：</p><pre><code>${!MAP[@]}</code></pre><p>More examples:</p><pre><code>declare -a Arrdeclare -A MapMap+=([a]=1 [b]=2)Arr+=(a b c)echo ${Arr[1]}echo ${Map[a]}echo &quot;${Arr[@]}&quot;echo &quot;${Map[@]}&quot;echo &quot;${Arr[@]:0:1}&quot;echo &quot;${!Map[@]}&quot;Arr[4]=aecho ${Arr[@]}echo ${Arr[3]}</code></pre><p><strong>与变量有关的内建命令（关键字）</strong></p><p>(1) declare 和 typeset.两者具有一样的功能.其选项有:</p><p>[-/+]a    设置/撤消变量的数组属性<br>[-/+]i    设置/撤消变量的整数属性<br>[-/+]r    设置/撤消变量的只读属性<br>[-/+]x    设置/撤消变量的输出属性<br>-p var    显示变量属性</p><p>(2) export 和 local.</p><p>export 把变量输出到环境中,用法为:</p><pre><code>export nameexport name=value</code></pre><p>export 的作用: 当Bash shell执行一个 程序时,将首先为该程序建立一个新的执行环境,称为子shell,<br>在Bash Shell中变量都是局部的,即它们只是在创建它们的子 Shell中是有意义的,使用export后,变量被设置为全局变量,这时可以被其它子Shell所识别</p><p>local 标记变量为局部的(如只能被函数内部使用),用法为:</p><pre><code>local namelocal name=value</code></pre><p>(3) readonly.</p><p>指定变量为只读,执行后,改变量不能被再次赋值,用法为:</p><pre><code>readonly name</code></pre><h4 id="位置变量-或-Shell-参数"><a href="#位置变量-或-Shell-参数" class="headerlink" title="位置变量 或 Shell 参数"></a>位置变量 或 Shell 参数</h4><p>Bash Shell 在解释用户命令时，会把命令行的第一元素（也即脚本或者命令本身）个作为 $0, 而其它字作为参数通过位置变量传递给程序.$1,…,$9分别代表第一,…,九个参数.<br>其中1-9是真正的参数名，”$”符只是用来标识变量的替换。</p><p>其它的还有:<br>$#    送给命令的参数个数<br>$@    所有的参数，每个用双括号括起<br>$*    所有的参数作为一个整体，用双括号括起</p><p>(1) 与 Shell 自身有关的常用变量<br>LINENO       正在执行的命令在脚本中的行号<br>PWD          用户当前目录的全名<br>OLDPWD       最近一次执行cd之前，用户当前目录的全名<br>PPID         父进程ID<br>$            当前进程ID<br>RANDOM       随机数(范围0-32767)<br>SECONDS      Bash Shell的运行时间,单位是秒<br>REPLY        select和read命令使用,以后会讲到<br>OPTARG<br>ORTIND       这两个变量由getopt命令设置<br>UID          当前用户的User ID<br>_            上一条命令使用的最后一个参数</p><p>(2) 影响Shell行为的一些常用环境变量:</p><p>PATH         命令搜索路径,以冒号为分隔符.注意与DOS下不同的是, 当前目录不在系统路径里<br>HOME         用户home目录的路径名,是cd命令的默认参数<br>COLUMNS      定义了命令编辑模式下可使用命令行的长度<br>EDITOR       默认的行编辑器<br>VISUAL       默认的可视编辑器<br>FCEDIT       命令fc使用的编辑器<br>HISTFILE     命令历史文件<br>HISTSIZE     命令历史文件中最多可包含的命令条数<br>HISTFILESIZE 命令历史文件中包含的最大行数<br>IFS          定义SHELL使用的分隔符<br>LOGNAME      用户登录名<br>MAIL         指向一个需要SHELL监视其修改时间的文件.当该文件修改后, SHELL将发消息You hava mail给用户<br>MAILCHECK    SHELL检查MAIL文件的周期,单位是秒<br>MAILPATH     功能与MAIL类似.但可以用一组文件,以冒号分隔,每个文件后 可跟一个问号和一条发向用户的消息<br>SHELL        SHELL的路径名<br>TERM         终端类型<br>TMOUT        SHELL自动退出的时间,单位为秒,若设为0则禁止SHELL自动退出<br>PROMPT_COMMAND       指定在主命令提示符前应执行的命令<br>PS1          主命令提示符<br>PS2          二级命令提示符,命令执行过程中要求输入数据时用<br>PS3          select的命令提示符<br>PS4          调试命令提示符<br>MANPATH      寻找手册页的路径,以冒号分隔<br>LD_LIBRARY_PATH      寻找库的路径,以冒号分隔</p><h4 id="Bash中对变量的操作"><a href="#Bash中对变量的操作" class="headerlink" title="Bash中对变量的操作"></a>Bash中对变量的操作</h4><p>Bash Shell可以进行变量的条件替换，即只有某种条件发生时才进行替换，替换条件放在{}中.<br>(1) ${value:-word}<br>    当变量未定义或者值为空时,返回值为word的内容,否则返回变量的值.<br>(2) ${value:=word}<br>    与前者类似,只是若变量未定义或者值为空时,在返回word的值的同时将 word赋值给value<br>(3) ${value:?message}<br>若变量已赋值的话,正常替换.否则将消息message送到标准错误输出(若此替换出现在Shell程序中,那么该程序将终止运行)</p><p>Bash中有一项特性，你可以方便地检查某个变量是否设置了，如果没有设置，就赋予一个默认值。尤其在处理环境变量的时候，这项特性会非常有用。<br>语法是 ${VAR:=VALUE}。此外，还有一个相似的语法，${VAR:=VALUE}和${VAR：=VALUE}。</p><p>下面展示下两者的区别</p><pre><code># expand to default variableecho ${NULL-&quot;Not null&quot;} # Not nullecho ${NULL} ## set default variableecho ${NIL=&quot;Not nil&quot;} # Not nilecho ${NIL} # Not nil</code></pre><p>最后介绍一个，当目标变量不存在时，指定报错信息的语法。</p><pre><code>echo ${TARGET?Not Found} # 当$TARGET不存在时，显示TARGET: Not Found，并结束程序。</code></pre><p><strong>大小写变换</strong></p><pre><code>HI=HellOecho &quot;$HI&quot; # HellOecho ${HI^} # HellOecho ${HI^^} # HELLOecho ${HI,} # hellOecho ${HI,,} # helloecho ${HI~} # hellOecho ${HI~~} #hELLo</code></pre><p>^大写，,小写， ~大小写切换<br>重复一次只修改首字母，重复两次则应用于所有字母。</p><h3 id="Advance-Variable-Operations"><a href="#Advance-Variable-Operations" class="headerlink" title="Advance Variable Operations"></a>Advance Variable Operations</h3><ol><li>Variable Extension （变量扩展)</li></ol><p>基本形式:${var_name}<br>变量扩展含义:一种简易的条件判断,对不同的条件赋予变量不同的值替换.它和变量存在与否的关系很大.</p><p>1.1 测试变量是否存在的基本用法<br>语法: ${待测变量-默认值}<br>说明:若待测变量不存在则符合判断条件,以传回默认值作为处置.<br>解析:若待测变量不存在则返回默认值,否则返回变量的值</p><p>实例:</p><pre><code>$ unset a$ echo ${a-&apos;default&apos;}default</code></pre><p>1.2 测试变量不存在或其值为空时传回一个默认值<br>语法:${a:-default}<br>实例:</p><pre><code>$ a=$ echo ${a:-&apos;default&apos;}default</code></pre><p>1.3 测试变量不存在或其值为空给变量赋予一个默认值<br>语法:${待测变量:=默认值}<br>实例:</p><pre><code>$ a=$ echo ${a:=&apos;default&apos;}default$ echo $adefault</code></pre><p>1.4 测试变量不存在或其值为空,输出一个提示信息<br>语法:${待测变量:?提示信息}<br>实例:</p><pre><code>$ a=$ echo r={a:?Not Found}Not Found</code></pre><p>1.5 测试变量存在且为非空则返回真值<br>语法:${待测变量:+真值}<br>实例:</p><pre><code>$ a=hello$ echo ${a:+world}world</code></pre><dl><dt><strong>总结：</strong><br>符号     作用</dt><dd>判断变量是否为空，若为空则为真</dd></dl><ul><li>正向，判断变量是否存在且不为空，若存在且不为空则为真</li></ul><ul><li>反向，判断变量是否不存在，若不存在则为空<br>=       赋值，<br>?       提示信息</li></ul><p>2.取字符串切片，获得字符串长度</p><p>2.1 取字符串切片<br>语法:<br>[1].${变量:开始的位置索引}<br>作用：截取从指定的位置开始到字符串结束的所有字符,开始字符的索引为0<br>实例：</p><pre><code>$ str=&quot;hello world&quot;$ echo ${str:6}world</code></pre><p>[2].${变量:起始位置:长度}<br>作用：截取从指定的起始位置开始的指定长度的字符串。<br>实例：</p><pre><code>$ str=&quot;hello world&quot;$ echo ${str:6:2}wo</code></pre><p>2.2 计算字符串长度<br>语法：${ #变量名称 }<br>实例:</p><pre><code>$ str=&quot;hello world&quot;$ echo ${ #str }11</code></pre><p>3.对比样式<br>目的:截取变量值(字符串)的某一个部分<br>做法:将符合样式的部分字符串删除或替换</p><p>3.1 由字符串前面开始对比删除最短的相符者<br>语法:${待测变量#样式}<br>说明:从待测变量的值的左边开始对比，删除最短符合样式的字符串<br>实例：</p><pre><code>$ filename=&quot;/usr/sbin/ntpdate&quot;$ echo ${filename#/*/}sbin/ntpdate</code></pre><p>3.2 由字符串前面开始对比删除最长的相符者<br>语法:${待测变量##样式}<br>实例:</p><pre><code>$ filename=&quot;/usr/sbin/ntpdate&quot;$ echo ${filename##/*/}ntpdate</code></pre><p>3.3 由字符串后面开始对比删除最短的相符者<br>语法:${待测变量%样式}<br>实例:</p><pre><code>$ filename=&quot;/usr/sbin/ntpdate&quot;$ echo ${filename%/*}/usr/sbin</code></pre><p>3.4 由字符串后面开始对比删除最长的相符者<br>语法:${待测变量%%样式}<br>实例:</p><pre><code>$ filename=&quot;hello/usr/sbin/ntpdate&quot;$ echo ${filename%%/*}hello</code></pre><p>4.替换或删除部分字符串<br>4.1 只替换找到的第一个字符串<br>语法:${待测变量/样式/替换}<br>实例：</p><pre><code>$ str=&quot;hello hello&quot;$ echo ${str/hello/world}world hello</code></pre><p>4.2 替换找到的所有样式字符串<br>语法:${待测变量//样式/替换}<br>实例：</p><pre><code>$ str=&quot;hello hello&quot;$ echo ${str/hello/world}world world</code></pre><p>4.3 删除第一个指定的字符串<br>语法:${待测变量/要删除的字符串/}<br>实例:</p><pre><code>$ str=&quot;hello hello&quot;$ echo ${str/hello/}hello</code></pre><p>4.4 删除所有指定的字符串<br>语法:${待测变量//要删除的变量/}<br>实例:</p><pre><code>$ str=&quot;hello world hello&quot;$ echo ${str//hello/}world</code></pre><p>5.命令扩展<br>语法:$(命令)<br>实例: time=$(date) 等价 time=<code>date</code></p><p>6.算术扩展<br>语法:$((算术))<br>实例：</p><pre><code>$ echo &quot;a=$((5*5))&quot;a=25</code></pre><p><strong>Reference</strong><br><a href="http://blog.chinaunix.net/uid-338594-id-2131863.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-338594-id-2131863.html</a><br><a href="http://blog.csdn.net/shallowgrave/article/details/12423239" target="_blank" rel="noopener">http://blog.csdn.net/shallowgrave/article/details/12423239</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>How to perform stress test?</title>
      <link href="/Programming/test-stress-test/"/>
      <url>/Programming/test-stress-test/</url>
      
        <content type="html"><![CDATA[<p>Linux 下测试一个服务程序的并发性能，最简便的是采用系统自带的 Apache Bench，简称 <strong>ab</strong>。 </p><p>ab 是通过模拟发送 http 请求的方式对服务程序进行测试，通过模拟多个进程在单位时间内发送多个请求，<br>测试服务程序的响应速度和并发吞吐量。</p><p>最常见的 ab 做压力测试的例子：</p><pre><code>ab -n 1000 -c 100 http://www.example.com/</code></pre><p>这里模拟的是同时启动 100 个进程（concurrency），总共发起 1000个请求去访问对应的服务程序。</p><p>A more complex example:<br>ab -n 1000 -c 10 -k -H “Accept-Encoding: gzip, deflate” <a href="http://www.example.com/" target="_blank" rel="noopener">http://www.example.com/</a></p><p><strong>参数解释：</strong></p><p><strong>-n</strong> 1000 is the total number of requests to make.</p><p><strong>-c</strong> 100 tells AB to do 10 requests at a time, instead of 1 request at a time, to better simulate concurrent visitors (vs. sequential visitors).</p><p><strong>-k</strong> sends the KeepAlive header, which asks the web server to not shut down the connection after each request is done, but to instead keep reusing it.</p><p>We can also send the extra header Accept-Encoding: gzip, deflate because mod_deflate is almost always used to compress the text/html output 25%-75%,<br>the effects of which should not be dismissed due to it’s impact on the overall performance of the web server (i.e., can transfer 2x the data in the same amount of time, etc).</p><p><span class="blueBold">QPS = total number of requests / total elapsed time</span></p><p><strong>AB 的缺陷</strong><br>由于 ab 只能发送 http 请求，因此要求被测试的服务程序提供 http 服务，否则无法使用 ab 进行 load test。<br>对于一些系统内部的服务比如 dao 服务，不对外提供 http 服务，而是对内提供 rpc 服务的话，没法使用 ab 来进行压力测试。<br>这时候需要我们自己手动发起多个来客户端进程来进行测试。</p><p>可以使用 mapred 来模拟启动多个进程，这些进程从 stdio 来读入数据（比如请求），最后计算完成这些请求所花费的时间，从而计算出 qps。</p><p><strong>例子：</strong><br>准备好一个数据文件， 里面有很多条请求（每行是一个请求）， 写好一个客户端程序（比如叫 client_program），<br>把这个数据文件作为输入，不断读取这个数据文件中的每一行并发送请求到数据库进行（增删改查）。</p><pre><code>$ cat request.dat | head -1000 | ./mapred --mapper=client_program --count=100 &gt; output</code></pre><p>或者</p><pre><code>$ cat request.dat | head -1000 | ./mapred -m client_program -c 100 &gt; output</code></pre><p>在 client_program 中，每完成一个请求，应该打印一个完成这次请求所花费的时间。</p><p>在最终的输出文件中，会记录每个请求所花费的时间，每行一个。<br>花费时间最长的 减去 花费时间最短的就得到总时间。</p><p>qps = 总请求数 / 总时间</p><p>参考：<br><a href="http://stackoverflow.com/questions/12732182/ab-load-testing" target="_blank" rel="noopener">http://stackoverflow.com/questions/12732182/ab-load-testing</a></p><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tags </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Coding Style Guide</title>
      <link href="/Programming/python-coding-standards/"/>
      <url>/Programming/python-coding-standards/</url>
      
        <content type="html"><![CDATA[<p>遵循良好的编码风格，可以有效的提高代码的可读性，降低出错几率和维护难度。在团队开发中，使用（尽量）统一的编码风格，还可以降低沟通成本。<br>网上有很多版本的编码规范，基本上都是遵循 PEP8 的规范：</p><ul><li><a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP 0008 – Style Guide for Python Code</a></li><li><a href="http://zh-google-styleguide.readthedocs.org/en/latest/google-python-styleguide/contents/" target="_blank" rel="noopener">Google 的 Python 风格指南</a></li><li><a href="http://docs.python-guide.org/en/latest/writing/style/" target="_blank" rel="noopener">Python Guide - Code Style</a></li><li><a href="http://flask.pocoo.org/docs/0.10/styleguide/" target="_blank" rel="noopener">Pocoo Styleguide</a></li></ul><p>除了在编码时主动遵循规范，还有很多有用的工具：</p><ul><li>IntelliJ IDEA 和 PyCharm 的格式化代码功能</li><li>Google 开源的 Python 文件格式化工具：<a href="https://github.com/google/yapf" target="_blank" rel="noopener">yapf</a></li><li>pyflakes, pylint 等工具及各种编辑器的插件</li></ul><p>本文的内容主要摘自互联网上的内容，总结整理了一份相对合理的编码规范。</p><br>#### 缩进---- 不要使用 tab 缩进- 使用任何编辑器写 Python，请把一个 tab 展开为 4 个空格- 绝对不要混用 tab 和空格，否则容易出现 IndentationError<br>#### 空格---- 在 list, dict, tuple, set, 参数列表的 , 后面加一个空格- 在 dict 的 : 后面加一个空格- 在注释符号 # 后面加一个空格，但是 #!/usr/bin/python 的 # 后不能有空格- 操作符两端加一个空格，如 +, -, *, /, |, &, =- 接上一条，在参数列表里的 = 两端不需要空格- 括号（(), {}, []）内的两端不需要空格<br>#### 空行---- function 和 class 顶上两个空行- class 的 method 之间一个空行- 函数内逻辑无关的段落之间空一行，不要过度使用空行- 不要把多个语句写在一行，然后用 ; 隔开- if/for/while 语句中，即使执行语句只有一句，也要另起一行<br>#### 换行- 每一行代码控制在 80 字符以内- 使用 \ 或 () 控制换行，举例：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def foo(first, second, third, fourth, fifth,</span><br><span class="line">        sixth, and_some_other_very_long_param):</span><br><span class="line">    user = User.objects.filter_by(first=first, second=second, third=third) \</span><br><span class="line">        .skip(<span class="number">100</span>).limit(<span class="number">100</span>) \</span><br><span class="line">        .all()</span><br><span class="line"></span><br><span class="line">text = (<span class="string">'Long strings can be made up '</span></span><br><span class="line">        <span class="string">'of several shorter strings.'</span>)</span><br></pre></td></tr></table></figure><br>#### 命名---- 使用有意义的，英文单词或词组，绝对不要使用汉语拼音- package/module 名中不要出现 -- 各种类型的命名规范：<table><thead><tr><th>Type</th><th>Public</th><th>Internal</th></tr></thead><tbody><tr><td>Modules</td><td>lower_with_under</td><td>_lower_with_under</td></tr><tr><td>Packages</td><td>lower_with_under</td><td></td></tr><tr><td>Classes</td><td>CapWords</td><td>_CapWords</td></tr><tr><td>Exceptions</td><td>CapWords</td><td></td></tr><tr><td>Functions</td><td>lower_with_under()</td><td>_lower_with_under()</td></tr><tr><td>Global/Class Constants</td><td>CAPS_WITH_UNDER</td><td>_CAPS_WITH_UNDER</td></tr><tr><td>Global/Class Variables</td><td>lower_with_under</td><td>_lower_with_under</td></tr><tr><td>Instance Variables</td><td>lower_with_under</td><td>_lower_with_under (protected) or __lower_with_under (private)</td></tr><tr><td>Method Names</td><td>lower_with_under()</td><td>_lower_with_under() (protected) or __lower_with_under() (private)</td></tr><tr><td>Function/Method Parameters</td><td>lower_with_under</td><td></td></tr><tr><td>Local Variables</td><td>lower_with_under</td><td></td></tr></tbody></table><br>#### import---- 所有 import 尽量放在文件开头，在 docstring 下面，其他变量定义的上面- 不要使用 `from foo imort *`- import 需要分组，每组之间一个空行，每个分组内的顺序尽量采用字典序，分组顺序是： - 标准库 - 第三方库 - 本项目的 package 和 module- 不要使用隐式的相对导入（implicit relative imports），可是使用显示的相对导入（explicit relative imports），如 `from ..utils import validator`，**最好**使用全路径导入（absolute imports）- 对于不同的 package，一个 import 单独一行，同一个 package/module 下的内容可以写一起：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># bad</span><br><span class="line"><span class="keyword">import</span> sys, os, time</span><br><span class="line"></span><br><span class="line"># good</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"># ok</span><br><span class="line">from flask <span class="keyword">import</span> Flask, render_template, jsonify</span><br></pre></td></tr></table></figure><ul><li>为了避免可能出现的命名冲突，可以使用 as 或导入上一级命名空间</li><li>不要出现循环导入(cyclic import)</li></ul><br>#### 注释---- 文档字符串 docstring, 是 package, module, class, method, function 级别的注释，可以通过 __doc__ 成员访问到，注释内容在一对 """ 符号之间- function, method 的文档字符串应当描述其功能、输入参数、返回值，如果有复杂的算法和实现，也需要写清楚- 不要写错误的注释，不要无谓的注释<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># bad 无谓的注释</span><br><span class="line">x = x + <span class="number">1</span>       # increase x by <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># bad 错误的注释</span><br><span class="line">x = x - <span class="number">1</span>       # increase x by <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>优先使用英文写注释，英文不好全部写中文，否则更加看不懂</li></ul><br>#### 异常---- 不要轻易使用 `try/except`- except 后面需要指定捕捉的异常，裸露的 except 会捕捉所有异常，意味着会隐藏潜在的问题- 可以有多个 except 语句，捕捉多种异常，分别做异常处理- 使用 finally 子句来处理一些收尾操作- try/except 里的内容不要太多，只在可能抛出异常的地方使用，如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># bad</span><br><span class="line">try:</span><br><span class="line">    user = User()</span><br><span class="line">    user.name = <span class="string">"leon"</span></span><br><span class="line">    user.age = <span class="keyword">int</span>(age) # 可能抛出异常</span><br><span class="line">    user.created_at = datetime.datetime.utcnow()</span><br><span class="line"></span><br><span class="line">    db.session.add(user)</span><br><span class="line">    db.session.commit() # 可能抛出异常</span><br><span class="line">except:</span><br><span class="line">    db.session.rollback()</span><br><span class="line"></span><br><span class="line"># better</span><br><span class="line">try:</span><br><span class="line">    age = <span class="keyword">int</span>(age)</span><br><span class="line">except (TypeError, ValueError):</span><br><span class="line">    <span class="keyword">return</span> # 或别的操作</span><br><span class="line"></span><br><span class="line">user = User()</span><br><span class="line">user.name = <span class="string">"leon"</span></span><br><span class="line">user.age = age</span><br><span class="line">user.created_at = datetime.datetime.utcnow()</span><br><span class="line">db.session.add(user)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    db.session.commit()</span><br><span class="line">except sqlalchemy.exc.SQLAlchemyError: # 或者更具体的异常</span><br><span class="line">    db.session.rollback()</span><br><span class="line">finally:</span><br><span class="line">    db.session.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><ul><li>从 Exception 而不是 BaseException 继承自定义的异常类</li></ul><br>#### Class（类）---- 显示的写明父类，如果不是继承自别的类，就继承自 object 类- 使用 super 调用父类的方法- 支持多继承，即同时有多个父类，建议使用 Mixin<br>#### 编码建议---<p><strong>字符串</strong></p><ul><li>使用字符串的 join 方法拼接字符串</li><li>使用字符串类型的方法，而不是 string 模块的方法</li><li>使用 startswith 和 endswith 方法比较前缀和后缀</li><li>使用 format 方法格式化字符串</li></ul><p><strong>比较</strong></p><ul><li><p>空的 list, str, tuple, set, dict 和 0, 0.0, None 都是 False</p></li><li><p>使用 if some_list 而不是 if len(some_list) 判断某个 list 是否为空，其他类型同理</p></li><li><p>使用 is 和 is not 与单例（如 None）进行比较，而不是用 == 和 !=</p></li><li><p>使用 if a is not None 而不是 if not a is None</p></li><li><p>用 isinstance 而不是 type 判断类型</p></li><li><p>不要用 == 和 != 与 True 和 False 比较（除非有特殊情况，如在 sqlalchemy 中可能用到）</p></li><li><p>使用 in 操作：</p><ul><li><p>用 key in dict 而不是 dict.has_key()，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> # bad</span><br><span class="line"><span class="keyword">if</span> d.has_key(k):</span><br><span class="line">    do_something()</span><br><span class="line"></span><br><span class="line"># good</span><br><span class="line"><span class="keyword">if</span> k in d:</span><br><span class="line">    do_something()</span><br></pre></td></tr></table></figure></li><li><p>用 set 加速 “存在性” 检查，list 的查找是线性的，复杂度 O(n)，set 底层是 hash table, 复杂度 O(1)，但用 set 需要比 list 更多内存空间</p></li></ul></li></ul><br>#### 其他---- 使用列表表达式（[list comprehension][]），字典表达式([dict comprehension][], Python 2.7+) 和生成器(generator)- dict 的 get 方法可以指定默认值，但有些时候应该用 [] 操作，使得可以抛出 KeyError- 使用 for item in list 迭代 list, for index, item in enumerate(list) 迭代 list 并获取下标- 使用内建函数 sorted 和 list.sort 进行排序- 适量使用 map, reduce, filter 和 lambda，使用内建的 all, any 处理多个条件的判断- 使用 defaultdict (Python 2.5+), Counter(Python 2.7+) 等 “冷门” 但好用的标准库算法和数据结构- 使用装饰器(decorator)- 使用 with 语句处理上下文- 有些时候不要对类型做太过严格的限制，利用 Python 的鸭子类型（Duck Type）特性- 使用 logging 记录日志，配置好格式和级别- 了解 Python 的 Magic Method：[A Guide to Python’s Magic Methods][], [Python 魔术方法指南][]- 阅读优秀的开源代码，如 [Flask 框架][], [Requests for Humans][]- 不要重复造轮子，查看标准库、PyPi、Github、Google 等使用现有的优秀的解决方案]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Use Ninja to replace make</title>
      <link href="/Tools-and-Build/tool-and-build-ningja/"/>
      <url>/Tools-and-Build/tool-and-build-ningja/</url>
      
        <content type="html"><![CDATA[<br>#### Introduction---As stated in the [official site][], Ninja is a small build system with a focus on speed.<p>There are multiplay ways to install ninja on our system, the simplest way is to download Ninja binary from <a href="https://github.com/ninja-build/ninja/releases" target="_blank" rel="noopener">here</a> and place it in a system PATH.</p><p>This article introduces how to build ninja from source.<br>There are some dependencies before we can build ninja from source, the dependencies are: graphviz, gtest, git, re2c and python2.7+.</p><br>#### Fetch the source---Once we have install these dependencies, follow the below steps:<pre><code>$ git clone git://github.com/ninja-build/ninja.git &amp;&amp; cd ninja$ git checkout release$ cat README$ lsCOPYING  HACKING.md  README  RELEASING  bootstrap.py  configure.py  doc/  misc/  src/</code></pre><p>For more details see <code>HACKING.md</code>. </p><br>#### Build ninja---To build, it is sufficient to just run:<pre><code>$ ./configure.py --bootstrap</code></pre><p>The above command will generate a binary Ninja in current directory, installation is not necessary because the Ninja binary is all we need, there is not extra installation process, the above command is all done and complete, we can place the binary into any directory that are in system path environment. (e.g. copy ninja to <code>/usr/bin</code> to make it globally accessible)</p><p><strong>More options</strong></p><p>–bootstrap bootstrap a ninja binary from nothing<br>–verbose enable verbose build<br>–platform choose known platforms<br>–host choose host known_platforms<br>–debug enable debugging extras<br>–profile enable profiling<br>–with-gtest<br>–with-python use EXE as the Python interpreter<br>–force-pselect ppoll() is used by default where available</p><p>Note that, if we to enable features like Bash completion or Emacs and Vim editing modes, some files in misc/ must be copied to appropriate locations.</p><br>#### Test ninja----Before we test ninja, we can take a glance at `ninja.build` file, this is a file similar to Makefile, it declares build rules according to what we need. For example, it declares rules **`all`**, and **`ninja_test`**. <pre><code>build ninja_test: link $builddir/build_log_test.o $builddir/build_test.o $    $builddir/clean_test.o $builddir/clparser_test.o $    $builddir/depfile_parser_test.o $builddir/deps_log_test.o $    $builddir/disk_interface_test.o $builddir/edit_distance_test.o $    $builddir/graph_test.o $builddir/lexer_test.o $    $builddir/manifest_parser_test.o $builddir/ninja_test.o $    $builddir/state_test.o $builddir/subprocess_test.o $builddir/test.o $    $builddir/util_test.o | $builddir/libninja.a   libs = -lninjabuild all: phony ninja ninja_test build_log_perftest canon_perftest $    depfile_parser_perftest hash_collision_bench manifest_parser_perftest</code></pre><p>In this case, we can simply run <code>./ninja ninja_test</code> to generate a executable binary <code>ninja_test</code>, and we run <code>./ninja_test</code> to finish the test.</p><pre><code>$ ./ninja_test[214/226] SubprocessTest.SetWithLotsRaise [ulimit -n] above 1025 (currently 1024) to make this test go[226/226] ElideMiddle.ElideInTheMiddlepassed</code></pre><p>also, we can run:</p><pre><code>$ ./ninja all[10/10] LINK canon_perftest</code></pre><p>after all test is done, we copy the ninja to a system path to finish the installation</p><pre><code>$ sudo cp ninja /usr/bin</code></pre><br>#### build.ninja---**build.ninja** has similar rules to Makefile, we can write it manually after we get a bit grasp of its syntax, or we can use a simple [Python based generator][] to generate it.<p>e.g.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ninja_syntax <span class="keyword">import</span> Writer</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"build.ninja"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> buildfile:</span><br><span class="line">    n = Writer(buildfile)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> platform.is_msvc():</span><br><span class="line">        n.rule(<span class="string">"link"</span>,</span><br><span class="line">                command=<span class="string">"$cxx $in $libs /nologo /link $ldflags /out:$out"</span>,</span><br><span class="line">                description=<span class="string">"LINK $out"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        n.rule(<span class="string">"link"</span>,</span><br><span class="line">                command=<span class="string">"$cxx $ldflags -o $out $in $libs"</span>,</span><br><span class="line">                description=<span class="string">"LINK $out"</span>)</span><br></pre></td></tr></table></figure><p>Besides, Ninja is already supported by some of the most popular meta build systems like <a href="http://www.cmake.org/" target="_blank" rel="noopener">CMake</a> and <a href="https://code.google.com/p/gyp" target="_blank" rel="noopener">Gyp</a>. If we have a CMake based project and Ninja is also available in system PATH, all we need to do is to choose Ninja as the generator:</p><pre><code>$ cd myproj$ mkdir build &amp;&amp; cd build$ cmake -GNinja ../$ ninja</code></pre><p>When we execute ninja to build the project, there’s no need to specify the number of parallel jobs (<code>-j [jobs]</code>) because Ninja automatically chooses the value based on the number of cores available.</p><br><br><br><br><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="https://github.com/ninja-build/ninja" target="_blank" rel="noopener">Ninja, a small build system with a focus on speed</a><br><a href="http://www.aosabook.org/en/posa/ninja.html" target="_blank" rel="noopener">The Performance of Open Source Software | Ninja</a><br><a href="http://neugierig.org/software/chromium/notes/2011/02/ninja.html" target="_blank" rel="noopener">Ninja, a new build system</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>File and multi windows in Vim</title>
      <link href="/Vim/vim-file-and-window/"/>
      <url>/Vim/vim-file-and-window/</url>
      
        <content type="html"><![CDATA[<h3 id="Editing-multiple-files"><a href="#Editing-multiple-files" class="headerlink" title="Editing multiple files"></a>Editing multiple files</h3><p><strong>1) Open multiple files at the same time</strong></p><ul><li>vi a.txt b.txt c.txt</li><li>:n, :next edit next file</li><li>:2n edit next two files </li><li>:N, :previous edit previous file</li><li>:wnext save current file then edit next file</li><li>:wprevious save current file, then edit previous file</li><li>:args list args (args are a sequence of filenames)</li><li>:n filenames, :args filenames specifies file list</li><li>vi -o filenames Edit multiple files in horizontally splitted windows</li><li>vi -O filenames Edit multiple files in vertically splitted windows</li></ul><p><strong>2) Editing multiple files in Tabs</strong></p><ul><li>vim -p files        Open multiple files in tabs</li><li>:tabe, tabnew       Open new file in tab</li><li>^w gf               Open file with filename under the current cursor in new tab</li><li>:tabn               Switch to the next tab (can also achieved by <code>Ctrl + PageDown</code>)</li><li>:tabp               Switch to the previous tab (can also be achieved by <code>Ctrl + PageUp</code>)</li><li>[n] gt              Switch to the next nth tab, tab number is 1-based</li><li>:tab split          Open current buffer content in new tab</li><li>:tabc[lose]         Close current tab</li><li>:tabo[nly]          Close all other tabs</li><li>:tabs               List all open tabs</li><li>:tabm[ove] [N]      Move tab, if <code>tabm 0</code>, current tab will become the first tab</li></ul><h3 id="Vim-Buffer"><a href="#Vim-Buffer" class="headerlink" title="Vim Buffer"></a>Vim Buffer</h3><ul><li>:buffers, :ls, :files list buffers</li><li>ctrl+^                Switch between the most recent buffers</li><li>:bn                   Switch to the next buffer</li><li>:bp                   Switch to the previous buffer</li><li>:bl                   Switch to the last buffer</li><li>:b[n]/[n]b            Switch to the next nth buffer</li><li>:nbw(ipeout)          Delete the nth buffer completely</li><li>:nbd(elete)           Delete the nth buffer, but still it in unlisted</li><li>:ba[ll]               Open all buffers in current tab, split window for each buffer</li></ul><h3 id="Spliting-Windows"><a href="#Spliting-Windows" class="headerlink" title="Spliting Windows"></a>Spliting Windows</h3><p><strong>1) Editing multiple files in splitted windows</strong></p><ul><li>vim -o file1 file2: open file in horizontally splitted windows</li><li>vim -O file1 file2: open file in vertically splitted windows</li></ul><p><strong>2) Split current window horizontally</strong></p><ul><li>:sp, :split   Split current into two windows, up and down (same as <code>CTRL-w s</code>, or <code>CTRL-w CTRL-s</code>) Note <code>CTRL-S</code> might freeze the terminal, press <code>CTRL-Q</code> to continue</li><li>:split filename  Open new file in a newly splitted window, locate right of the current window.</li><li>:nsplit(:nsp)     Split a window in above with 3-line height</li><li>:[N]new            Split a new window in above, and edit new file in that window. ( same as <code>CTRL-w n</code> or <code>CTRL-w CTRL-n</code>)</li><li>ctrl+w f            Split a new window in above, and open file under the cursor in that window.</li><li>C-w C-^            Edit the file in a newly horizontally splitted window</li></ul><p><strong>2) Split current window horizontally</strong></p><ul><li>:vsp, :vsplit               Vertically split current window into two. ( same as <code>CTRL-w v</code>, or <code>CTRL CTRL-V</code>)</li><li>:[N]vne[w]               Vertically split a new window</li><li>:vertical</li></ul><p><strong>Close windows</strong></p><ul><li><strong>:qall</strong>  close all windows</li><li><strong>:wall</strong>  close all modified windows</li><li><strong>:only</strong>  close all other windows</li><li><strong>:close</strong>  close current window (same as <code>CTRL-w c</code>)</li></ul><h3 id="Resize-window"><a href="#Resize-window" class="headerlink" title="Resize window"></a>Resize window</h3><ul><li>ctrl+w +               Increase current file by one line, use <code>n</code> for <code>n lines</code></li><li>ctrl+w -               Decrease current file by one line, use <code>n</code> for <code>n lines</code></li><li>ctrl+w _               Maximize current window height</li><li>:resize n               Set height of current file</li><li>ctrl+w =               Resize all windows to the same height</li><li>n ctrl+w _               Set height of current file to n lines</li><li>ctrl+w &lt;               Decrease current window by one column, use <code>n</code> for <code>n lines</code></li><li>ctrl+w &gt;               Increase current window by one column, use <code>n</code> for <code>n lines</code></li><li>ctrl+w |               Maximize current window width</li></ul><h3 id="Switch-cursor-between-windows"><a href="#Switch-cursor-between-windows" class="headerlink" title="Switch cursor between windows"></a>Switch cursor between windows</h3><ul><li>ctrl+w ctrl+w: Switch to the next window ( same as <code>Ctrl+w w</code>)</li><li>ctrl+w p: Switch to the previous window</li><li>ctrl+w h(l,j,k): Switch to the left, right, below, or above window</li><li>ctrl+w t(b): Switch to the top/bottom window</li><li>ctrl+w H(L,K,J): Move current to left, right, below, or above</li><li>ctrl+w r：Rotate windows clockwise</li><li>ctrl+w T: Move current window onto a new tab</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Edit fast in Vim</title>
      <link href="/Vim/vim-vim-edit-fast/"/>
      <url>/Vim/vim-vim-edit-fast/</url>
      
        <content type="html"><![CDATA[<h3 id="Insert-Change"><a href="#Insert-Change" class="headerlink" title="Insert/Change"></a>Insert/Change</h3><table><thead><tr><th>Keys</th><th>Function</th></tr></thead><tbody><tr><td>a</td><td>append after cursor</td></tr><tr><td>A</td><td>append at the end of line</td></tr><tr><td>i</td><td>insert before the cursor</td></tr><tr><td>I</td><td>insert before the first non-blank character of line</td></tr><tr><td>o/O</td><td>open a new line below/above the current.</td></tr><tr><td>C, c$</td><td>change to the end of line</td></tr><tr><td>c^</td><td>change to the first non-blank character of line</td></tr><tr><td>s, cl</td><td>change one character</td></tr><tr><td>S, cc</td><td>change a whole line</td></tr><tr><td>ct<char></char></td><td>change to char, not include char</td></tr><tr><td>r</td><td>replace current char, e.g ra will replace char under cursor to character ‘a’</td></tr><tr><td>R</td><td>Enter insert mode, replacing characters(starting from cursor) instead of inserting</td></tr><tr><td>vu/vU</td><td>uppercase/lowercase the current char</td></tr><tr><td>viu/viU</td><td>uppercase/lowercase the current word</td></tr><tr><td>~</td><td>Switch case of character under cursor</td></tr><tr><td>g<del>, g</del>g~</td><td>Switch case of whole line</td></tr><tr><td>gUU/guu</td><td>Change whole line to uppercase/lowercase</td></tr><tr><td>gUw/guw</td><td>Change word to uppercase/lowercase</td></tr><tr><td>J</td><td>Join Lines without space</td></tr><tr><td>gJ</td><td>Join Lines with space</td></tr></tbody></table><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><table><thead><tr><th>Keys</th><th>Function</th></tr></thead><tbody><tr><td>x, DEL</td><td>delete character under cursor</td></tr><tr><td>X</td><td>delete character before cursor</td></tr><tr><td>nx/nX</td><td>delete forward/backword n characters</td></tr><tr><td>dl/dh</td><td>delete character under/after cursor, l means forward, h means backward</td></tr><tr><td>dk/dj</td><td>delete sentence above/below</td></tr><tr><td>dnl/dnh</td><td>delete forward/backword n characters</td></tr><tr><td>df<char>, dF<char></char></char></td><td>delete forward/backward to char, but include char</td></tr><tr><td>dt<char>, dt<char></char></char></td><td>delete forward/backward to char, but exclude char</td></tr><tr><td>D</td><td>delete to the end of line</td></tr><tr><td>dw</td><td>delete to the end of current word (dw, 3dw, d3w, 3d2w,i d$, d^, df)</td></tr><tr><td>dW</td><td>delete to the end of current space separated word</td></tr><tr><td>diw</td><td>delete current word (excluding whitespace)</td></tr><tr><td>daw</td><td>delete current word (including whitespace)</td></tr><tr><td>dG/dgg</td><td>delete until the end/begining of file</td></tr><tr><td>dd</td><td>delete current line</td></tr><tr><td>dnj</td><td>delete below n lines</td></tr><tr><td>dnk</td><td>delete above n lines</td></tr></tbody></table><p><strong>Note</strong><br>In keys, <code>n</code> represents count.<br><code>d{motion}</code> : delete text that {motion} moves over. e.g: <code>dl</code> delete current char, <code>dh</code> delete before char</p><h3 id="Copy-Yank"><a href="#Copy-Yank" class="headerlink" title="Copy/Yank"></a>Copy/Yank</h3><table><thead><tr><th>Keys</th><th>Function</th></tr></thead><tbody><tr><td>ynw</td><td>yank n words</td></tr><tr><td>yy, Y</td><td>yank whole line</td></tr><tr><td>ynl</td><td>yank n characters</td></tr><tr><td>y$</td><td>yank to the end of the line</td></tr><tr><td>nyy</td><td>yank n lines</td></tr></tbody></table><h3 id="Undo-Redo"><a href="#Undo-Redo" class="headerlink" title="Undo/Redo"></a>Undo/Redo</h3><table><thead><tr><th>Keys</th><th>Function</th></tr></thead><tbody><tr><td>u</td><td>undo, in Normal mode</td></tr><tr><td>U</td><td>undo all changes in current line</td></tr><tr><td>Ctrl-r</td><td>redo</td></tr><tr><td>:earlier 4m –</td><td>step back 4 minutes</td></tr><tr><td>:later 55s –</td><td>step forward 55 seconds</td></tr></tbody></table><h3 id="Fold-Indent"><a href="#Fold-Indent" class="headerlink" title="Fold, Indent"></a>Fold, Indent</h3><table><thead><tr><th>Keys</th><th>Function</th></tr></thead><tbody><tr><td>zf</td><td>fold</td></tr><tr><td>zo</td><td>unfold</td></tr><tr><td>zc</td><td>close</td></tr><tr><td>==</td><td>Fix line indent</td></tr><tr><td>VG=</td><td>Indent the whole file</td></tr><tr><td>=%</td><td>Indent the code between parenthesis</td></tr><tr><td>ctrl-t, ctrl-d</td><td>Indent/un-indent in insert mode</td></tr></tbody></table><p><strong>Note</strong><br>:set autoindent     Turn on auto-indent<br>:set smartindent    Turn on intelligent auto-indent<br>:set shiftwidth=4   Defines 4 spaces as indent size</p><h3 id="File-operations"><a href="#File-operations" class="headerlink" title="File operations"></a>File operations</h3><table><thead><tr><th>commands</th><th>Function</th></tr></thead><tbody><tr><td>:e [file]</td><td>edit <code>file</code> or current file if <code>file</code> is not specified</td></tr><tr><td>:e! [file]</td><td>edit <code>file</code> or current file if <code>file</code> is not specified, discard all changes</td></tr><tr><td>:r [file]</td><td>insert <code>file</code> into current cursor position</td></tr><tr><td>:w</td><td>Save file</td></tr><tr><td>:q</td><td>Exit Vim</td></tr><tr><td>:q!</td><td>Quit without saving</td></tr><tr><td>:x</td><td>Save and quit</td></tr><tr><td>:sav filename</td><td>Saves file as filename</td></tr><tr><td>.</td><td>Repeats the last change made in normal mode</td></tr><tr><td>5.</td><td>Repeats 5 times the last change made in normal mode</td></tr><tr><td>ZZ</td><td>Save and quit</td></tr><tr><td>:1,10 w</td><td>outfile Saves lines 1 to 10 in outfile</td></tr><tr><td>:1,10 w &gt;&gt; outfile</td><td>Appends lines 1 to 10 to outfile</td></tr><tr><td>:r infile</td><td>Insert the content of infile</td></tr><tr><td>:23r infile</td><td>Insert the content of infile under line 23</td></tr></tbody></table><h3 id="File-Explorer"><a href="#File-Explorer" class="headerlink" title="File Explorer"></a>File Explorer</h3><table><thead><tr><th>Commands</th><th>Function</th></tr></thead><tbody><tr><td>:e .</td><td>Open integrated file explorer</td></tr><tr><td>:Sex</td><td>Split window and open integrated file explorer</td></tr><tr><td>:Sex!</td><td>Same as :Sex but split window vertically</td></tr><tr><td>:browse e</td><td>Graphical file explorer</td></tr><tr><td>:ls</td><td>List buffers</td></tr><tr><td>:cd ..</td><td>Move to parent directory</td></tr><tr><td>:args</td><td>List files</td></tr><tr><td>:args *.txt</td><td>Open file list</td></tr><tr><td>:grep expression *.cpp</td><td>Returns a list of .cpp files contening expression</td></tr><tr><td>gf</td><td>Open file name under cursor</td></tr></tbody></table><h3 id="Interaction-with-Unix-Linux-commands"><a href="#Interaction-with-Unix-Linux-commands" class="headerlink" title="Interaction with Unix/Linux commands"></a>Interaction with Unix/Linux commands</h3><table><thead><tr><th>Commands</th><th>Function</th></tr></thead><tbody><tr><td>:!pwd</td><td>Execute the pwd unix command, then returns to Vi</td></tr><tr><td>!!pwd</td><td>Execute the pwd unix command and insert output in file</td></tr><tr><td>:sh</td><td>Temporary returns to Unix</td></tr><tr><td>$exit</td><td>Retourns to Vi</td></tr></tbody></table><h3 id="Auto-completion"><a href="#Auto-completion" class="headerlink" title="Auto completion"></a>Auto completion</h3><table><thead><tr><th>Keys</th><th>Function</th></tr></thead><tbody><tr><td>Ctrl+n, Ctrl+p</td><td>(in insert mode)  Complete word</td></tr><tr><td>Ctrl+x, Ctrl+l</td><td>Complete line</td></tr><tr><td>:set dictionary=dict</td><td>Define dict as a dictionnary</td></tr><tr><td>Ctrl+x Ctrl+k</td><td>Complete with dictionnary</td></tr></tbody></table><p><strong>1) File encription</strong></p><table><thead><tr><th>Commands</th><th>Function</th></tr></thead><tbody><tr><td>vim -x file</td><td>start to edit a encripted file</td></tr><tr><td>:X –</td><td>Set a password for current file</td></tr><tr><td>:set key= –</td><td>remove password of current file</td></tr></tbody></table><p><strong>2) File encoding</strong></p><table><thead><tr><th>Commands</th><th>Function</th></tr></thead><tbody><tr><td>:e ++enc=utf8 filename</td><td>open file using utf-8 encoding</td></tr><tr><td>:w ++enc=gbk</td><td>convert to gbk encoding regardless of the encoding of the file</td></tr><tr><td>:set fenc</td><td>checking encoding of current file</td></tr><tr><td>:set fileencoding</td><td>same as above</td></tr></tbody></table><p><strong>Note</strong><br>If we set fileencoding=ucs-bom,utf-8,cp936 in <code>.vimrc</code>, vim will open file according to the appropriate encoding, note that there are no spaces between each encodings.<br>cp936 is for gbk, ucs-bom is the encoding format in windows.</p><p><strong>3) File format</strong><br>Noteable there are mainly three type of files: dos, unix, mac.<br>Their major differences are the representations of line ending</p><table><thead><tr><th>format</th><th>symbols</th><th>desc</th></tr></thead><tbody><tr><td>dos</td><td>\r\n</td><td>carriage return (CR) + line feed (LF)</td></tr><tr><td>unix</td><td>\n</td><td>line feed (LF)</td></tr><tr><td>mac</td><td>\r</td><td>carriage return (CR)</td></tr></tbody></table><ul><li>:e ++ff=dos filename  open file in dos format</li><li>:w ++ff=mac filename  open file in mac format</li><li>:set ff  display format of current file</li></ul><p>Add <code>set fileformats=unix,dos,mac</code> in <code>.vimrc</code> so that vim can detect file format automatically.</p><p><strong>Reference</strong><br><a href="http://linux.chinaunix.net/techdoc/desktop/2009/07/06/1122020.shtml" target="_blank" rel="noopener">http://linux.chinaunix.net/techdoc/desktop/2009/07/06/1122020.shtml</a><br><a href="http://blog.csdn.net/scaleqiao/article/details/45153379" target="_blank" rel="noopener">http://blog.csdn.net/scaleqiao/article/details/45153379</a></p>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Move fast in Vim</title>
      <link href="/Vim/vim-vim-move-fast/"/>
      <url>/Vim/vim-vim-move-fast/</url>
      
        <content type="html"><![CDATA[<h3 id="Move-in-line"><a href="#Move-in-line" class="headerlink" title="Move in line"></a>Move in line</h3><table><thead><tr><th>Keys</th><th>Function</th></tr></thead><tbody><tr><td>0/HOME/&#124;</td><td>jump to the beginning of line</td></tr><tr><td>^/==</td><td>jump to the first non-blank character of line</td></tr><tr><td>_</td><td>jump to the first non-blank character of current line</td></tr><tr><td>g_</td><td>jump to the last non-blank character of current line</td></tr><tr><td>$/END</td><td>jump to the end of line</td></tr><tr><td>-</td><td>jump to the first non-blank character of previous line</td></tr><tr><td>+/<cr></cr></td><td>move to first non-blank character of next line</td></tr><tr><td>*</td><td>search forward for the word</td></tr><tr><td>#</td><td>search backward for the current word</td></tr><tr><td>w</td><td>move to the beging of the next word</td></tr><tr><td>W</td><td>move to the next space-separated word</td></tr><tr><td>b</td><td>move to the begin of the current word. (B for space separated only)</td></tr><tr><td>e</td><td>move to the end of the current word. (E for space separated only)</td></tr><tr><td>ge</td><td>move the the end of previous word (not supported in Vintage mode of Sublime Text)</td></tr><tr><td>gE</td><td>move the the end of previous space separated word (not supported in Vintage mode of Sublime Text)</td></tr><tr><td>number + &#124;</td><td>move to the nth character of current line</td></tr><tr><td>f<char></char></td><td>jump to the next occurring char of the current line, use <strong>;</strong> and <strong>,</strong> to repeat forward/backward</td></tr><tr><td>F<char></char></td><td>jump to the previous occurring char of the current line, use <strong>;</strong> and <strong>,</strong> to repeat forward/backward</td></tr><tr><td>t<char></char></td><td>jump to one position before the next occurring char of the current line, use <strong>;</strong> and <strong>,</strong> to repeat forward/backward</td></tr><tr><td>T<char></char></td><td>jump to one position before the previous occurring char of the current line, and <strong>;</strong> and <strong>,</strong> to repeat forward/backward</td></tr><tr><td>Ctrl-g</td><td>print where I am in the file</td></tr></tbody></table><h3 id="Move-vertically"><a href="#Move-vertically" class="headerlink" title="Move vertically"></a>Move vertically</h3><table><thead><tr><th>Keys</th><th>Function</th></tr></thead><tbody><tr><td>gg, G</td><td>move to the begin/end of the file</td></tr><tr><td>H</td><td>move to the top of file</td></tr><tr><td>M</td><td>move to the middle file</td></tr><tr><td>L</td><td>move to the end file</td></tr><tr><td>[[</td><td>jump to the beging of the current file</td></tr><tr><td>]]</td><td>jump to the end of the current file</td></tr><tr><td>{</td><td>jump to the previous blank line</td></tr><tr><td>}</td><td>jump to the next blank line</td></tr></tbody></table><h3 id="Move-in-block"><a href="#Move-in-block" class="headerlink" title="Move in block"></a>Move in block</h3><table><thead><tr><th>Keys</th><th>Function</th></tr></thead><tbody><tr><td>[{</td><td>jump to the previous {</td></tr><tr><td>[}</td><td>jump to the next }</td></tr><tr><td>[(</td><td>jump to the previous (</td></tr><tr><td>[)</td><td>jump to the next )</td></tr><tr><td>[/</td><td>jump to the begining of comment block</td></tr><tr><td>]/</td><td>jump to the end of comment block</td></tr><tr><td>gd</td><td>jump to the declaration of local variable</td></tr><tr><td>gD</td><td>jump to the declaration of global variable (search from the begining of the file)</td></tr></tbody></table><h3 id="Move-in-page"><a href="#Move-in-page" class="headerlink" title="Move in page"></a>Move in page</h3><table><thead><tr><th>Keys</th><th>Function</th></tr></thead><tbody><tr><td><ctrl-d>/<ctrl-u></ctrl-u></ctrl-d></td><td>down/up half page</td></tr><tr><td><ctrl-f>/<ctrl-b></ctrl-b></ctrl-f></td><td>forward/backward full page</td></tr></tbody></table><h3 id="Move-in-matching-braces"><a href="#Move-in-matching-braces" class="headerlink" title="Move in matching braces"></a>Move in matching braces</h3><table><thead><tr><th>Keys</th><th>Function</th></tr></thead><tbody><tr><td>%</td><td>hop between the matching {}, () or [] of the line, or between C-style comment: /* */, or matching #if, #ifdef, #else, #elif, #endif.</td></tr></tbody></table><p>Note:<br>If <code>showmatch</code> option is enabled, the cursor will briefly jump to the matching brace when you insert one.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:set showmatch</span><br><span class="line">:set matchtime=3</span><br></pre></td></tr></table></figure><h3 id="Move-in-Marks"><a href="#Move-in-Marks" class="headerlink" title="Move in Marks"></a>Move in Marks</h3><table><thead><tr><th>Keys</th><th>Function</th></tr></thead><tbody><tr><td>m {a-z}</td><td>Marks current position as {a-z}</td></tr><tr><td>‘ {a-z}</td><td>Move to position {a-z}</td></tr><tr><td>‘’</td><td>Move to previous position</td></tr></tbody></table><h3 id="Move-to-old-positions"><a href="#Move-to-old-positions" class="headerlink" title="Move to old positions"></a>Move to old positions</h3><table><thead><tr><th>Keys</th><th>Description</th></tr></thead><tbody><tr><td>Ctrl + o</td><td>jump back to the previous (older) position</td></tr><tr><td>Ctrl + i</td><td>jump back to the next (newer) position</td></tr><tr><td>g;</td><td>jump to previous edited position.</td></tr><tr><td>gi</td><td>jump to previous edited position and enter into Insert Mode.</td></tr><tr><td>`.</td><td>jump to the last edited <strong>cursor position</strong></td></tr><tr><td>``</td><td>jump to the previous <strong>cursor position</strong></td></tr><tr><td>‘.</td><td>jump to the last edited <strong>line</strong> begining</td></tr><tr><td>‘’</td><td>jump to the previous <strong>line</strong> begining</td></tr></tbody></table><h3 id="Move-in-selections"><a href="#Move-in-selections" class="headerlink" title="Move in selections"></a>Move in selections</h3><table><thead><tr><th>Keys</th><th>Description</th></tr></thead><tbody><tr><td>o</td><td>when we use v to select a block, we can use o to o to hop between the begin and end of the selection</td></tr></tbody></table><h3 id="Move-in-Insert-Mode"><a href="#Move-in-Insert-Mode" class="headerlink" title="Move in Insert Mode"></a>Move in Insert Mode</h3><table><thead><tr><th>Keys</th><th>Function</th><th>key mapping</th></tr></thead><tbody><tr><td>Alt + ;</td><td>move to the line end</td><td>inoremap <esc>; <esc>A</esc></esc></td></tr><tr><td>Alt + ,</td><td>move to the line begin</td><td>inoremap <esc>, <esc>I</esc></esc></td></tr><tr><td>Ctrl + /</td><td>comment current line</td><td>inoremap <c-_> <esc>I//</esc></c-_></td></tr></tbody></table><p><strong>explanations</strong><br>For some reason, vim registers <c-> as <c-_> (you can see it in insert mode using <c-v><c->). It can be the terminal or a historical design thing that terminal apps have to suffer.</c-></c-v></c-_></c-></p><p>And Gvim doesn’t even try to recognize <c->. Sees it as single /.</c-></p><h3 id="Screen-movement"><a href="#Screen-movement" class="headerlink" title="Screen movement"></a>Screen movement</h3><table><thead><tr><th>Keys</th><th>Function</th></tr></thead><tbody><tr><td>zz, z-</td><td>center the screen on the cursor</td></tr><tr><td>zt, z-Enter</td><td>top the screen on the cursor (the line will at the top of the screen)</td></tr><tr><td>zb</td><td>bottom the screen on the cursor (the line will at the bottom of the screen)</td></tr><tr><td>Ctrl-y</td><td>Moves screen up one line</td></tr><tr><td>Ctrl-e</td><td>Moves screen down one line</td></tr><tr><td>Ctrl-u</td><td>Moves screen up ½ page</td></tr><tr><td>Ctrl-d</td><td>Moves screen down ½ page</td></tr><tr><td>Ctrl-b</td><td>Moves screen up one page</td></tr><tr><td>Ctrl-f</td><td>Moves screen down one page</td></tr></tbody></table><p>Leave some lines above the <code>top</code> or below the <code>bottom</code>.</p><pre><code>:set scroll=10:set scrolljump=5:set scrolloff=3</code></pre><h3 id="Movement-in-Visual-Mode"><a href="#Movement-in-Visual-Mode" class="headerlink" title="Movement in Visual Mode"></a>Movement in Visual Mode</h3><p>o/O Hop between begin and end of the selection.</p><h3 id="Selection-in-Visual-Mode"><a href="#Selection-in-Visual-Mode" class="headerlink" title="Selection in Visual Mode"></a>Selection in Visual Mode</h3><ul><li>v select any range</li><li>V select entire line</li><li>Ctrl-v select columns</li><li>gv select previous selected block</li></ul><h3 id="Operations-on-selected-text-Visual-Mode"><a href="#Operations-on-selected-text-Visual-Mode" class="headerlink" title="Operations on selected text Visual Mode"></a>Operations on selected text Visual Mode</h3><p>After selecting the text, try d to delete, or y to copy, or :s/match/replace/, or :center, or !sort, or…</p><ul><li>Select all text in (),  {}, [], &lt;&gt;, ‘’, “”, etc. block, vi&lt;(&gt;, ( could be any of those characters.</li><li>Especially, for () and {}, we can use vib and viB to select text in these blocks if our cursor is in the block.</li><li>If cursor is just on ( or ), v% will select text between and also ( and )</li><li>vap selects the entire paragraph</li><li>ggVG  selects the entire file</li><li>v {select} x/d delete selected text</li><li>v {select} X/D delete selected lines</li><li>Delete Selected Block: v<selectedblock> d.</selectedblock></li><li>Delete Selected Block and then Insert from here: v<selectedblock> di. A much quicker way of doing this is v<selected_block>c</selected_block></selectedblock></li></ul><p>Especially, if you are going to change the text between (),  {}, [] &lt;&gt;, ‘’, “”, it is more straightforward to just do ci&lt;(&gt; , here ( can be any of the above characters. No need to select first if you are going to replace it.</p><h3 id="Summary-of-Visual-Mode-Selection"><a href="#Summary-of-Visual-Mode-Selection" class="headerlink" title="Summary of Visual Mode Selection:"></a>Summary of Visual Mode Selection:</h3><p>vi(, vi[, vi{, vi”, vi’, viw: all these will not include<br>va(, va[, va{, va”, va’, vaw: all these will include</p><p><strong>What is meta key?</strong><br>The Meta key is a modifier key on certain keyboards where it is labeled “META”, On keyboards that lack a physical Meta key (or keys), its functionality may be invokable by other keys such as the Alt key, the Windows key, etc.</p><p>If no Meta key function is available, some software will accept alternate keybindings using, for example, the Esc key as a prefix key (as, for example, inEmacs).</p><p><strong>How to type a meta key?</strong><br>Start by viewing the key code your terminal is sending to vim:</p><pre><code>$ sed -n l^[[1;9D</code></pre><p>In the above example, i ran the sed command and pressed Alt + Left.<br>The ^[[1;9D is the escaped sequence being sent to vim, so we can user that for our mapping.</p><p>e.g. Add this to .vimrc <code>map &lt;Esc&gt;[1;9D :tabn&lt;CR&gt;</code></p><p>Now we can cycle through vim tabs by using <code>Alt + Left</code>.BTW, in cygwin ALT+Left output is \033[1;3D$, here \033 is <esc>, and we need to remove the ‘$’</esc></p>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>listen 和 accept 的套接字之间的关系</title>
      <link href="/Programming/network-programming-listen-accept/"/>
      <url>/Programming/network-programming-listen-accept/</url>
      
        <content type="html"><![CDATA[<p>在进行网络编程时，服务端的过程通常是：socket()-&gt;bind()-&gt;listen()，当有客户端程序 connect() 时，服务端调用 accept() 来获得一个连接。下面是几个常见的问题：</p><h5 id="问题1：客户端和服务端的-socket-是怎么通信的？"><a href="#问题1：客户端和服务端的-socket-是怎么通信的？" class="headerlink" title="问题1：客户端和服务端的 socket 是怎么通信的？"></a>问题1：客户端和服务端的 socket 是怎么通信的？</h5><p>我们知道，socket 有一个四元组:(目的 ip, 目的 port、源 ip，源 port)。这个四元组就可以保证客户端和服务端之间可以通信。<br>比如服务端是个80的 web 服务，ip是1.1.1.1。服务端启动时会生成一个 socket 绑定到 80 端口监听。这时一个 ip 为 2.2.2.2的客户端要去访问这个服务端时，先要生成一个 socket 。系统会为这个 socket 选择一个端口，比如 65535，那么客户端通个 (1.1.1.1, 80, 2.2.2.2, 65535) 通过 connect() 访问服务端。</p><h5 id="问题2：accept-中的-socket-和-listen-监听的-socket-的端口相同吗？"><a href="#问题2：accept-中的-socket-和-listen-监听的-socket-的端口相同吗？" class="headerlink" title="问题2：accept 中的 socket 和 listen 监听的 socket 的端口相同吗？"></a>问题2：accept 中的 socket 和 listen 监听的 socket 的端口相同吗？</h5><p>客户端通过 connect() 访问服务端80，通过3次握手后，进入 accept 队列。服务端调用 accept() 时，会生成一个新的 socket 和客户端通信，之前的 socket 仍然继续监听 80 端口。那么这个新生成的端口还是 80 吗？答案是肯定的，否则客户端那边的 socket 就无法和新生成的 socket 通信。看 accept 源码，会发现新生成的 socket 会拷贝监听 socket 的信息。因此两者的端口号相同。</p><h5 id="问题3：服务端是怎么区分客户端的信息是给-listen-的-socket-还是-accept-的-socket-的？"><a href="#问题3：服务端是怎么区分客户端的信息是给-listen-的-socket-还是-accept-的-socket-的？" class="headerlink" title="问题3：服务端是怎么区分客户端的信息是给 listen 的 socket 还是 accept 的 socket 的？"></a>问题3：服务端是怎么区分客户端的信息是给 listen 的 socket 还是 accept 的 socket 的？</h5><p>如果监听的 socket 和新生成的 socket 都是使用 80 端口，那么客户端发给 80 端口的信息，怎么区分是给哪个 socket ？是通过客户端 port 做路由的。listen 使用的 socket 是没有客户端信息的，它的客户端端口为*；而 accept 时新生成的 socket 是有客户端端口号。如下图，第一行是监听的 socket ，第二行是 accept 后生成的 socket 。因此通过四元组中的客户端 port 就可将客户端信息路由到了正确的 socket 上。</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>connect()、listen() 和 accept() 三者之间的关系</title>
      <link href="/Programming/network-programming-listen-connect-accept/"/>
      <url>/Programming/network-programming-listen-connect-accept/</url>
      
        <content type="html"><![CDATA[<p>基于 TCP 的网络编程开发分为服务器端和客户端两部分，常见的核心步骤和流程如下：<br><img src="http://upload-images.jianshu.io/upload_images/1452123-e46e2c70a5ebbb69?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>connect()函数</strong><br>对于客户端的 connect() 函数，该函数的功能为客户端主动连接服务器，建立连接是通过<a href="http://blog.csdn.net/tennysonsky/article/details/45622395" target="_blank" rel="noopener">三次握手</a>，而<strong>这个连接的过程是由内核完成</strong>，不是这个函数完成的，这个函数的作用仅仅是通知 Linux 内核，让 Linux 内核自动完成 <a href="http://blog.csdn.net/tennysonsky/article/details/45622395" target="_blank" rel="noopener">TCP 三次握手</a>连接（<a href="http://blog.csdn.net/tennysonsky/article/details/45622395" target="_blank" rel="noopener">三次握手详情，请看《浅谈 TCP 三次握手》</a>），最后把连接的结果返回给这个函数的返回值（成功连接为0， 失败为-1）。</p><p>通常的情况，客户端的 connect() 函数默认会一直阻塞，直到<a href="http://blog.csdn.net/tennysonsky/article/details/45622395" target="_blank" rel="noopener">三次握手</a>成功或超时失败才返回（正常的情况，这个过程很快完成）。</p><p>listen()函数<br>对于服务器，它是被动连接的。举一个生活中的例子，通常的情况下，移动的客服（相当于服务器）是等待着客户（相当于客户端）电话的到来。而这个过程，需要调用listen()函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><p>listen() 函数的主要作用就是将套接字 sockfd 变成被动的连接监听套接字（被动等待客户端的连接），至于参数 backlog 的作用是设置内核中连接队列的长度（这个长度有什么用，后面做详细的解释），<strong>TCP 三次握手也不是由这个函数完成，listen()的作用仅仅告诉内核一些信息。</strong><br><strong>这里需要注意的是</strong>，listen() 函数不会阻塞，它主要做的事情为，将该套接字和套接字对应的连接队列长度告诉 Linux 内核，然后，listen() 函数就结束。</p><p>这样的话，当有一个客户端主动连接 connect()，Linux 内核就自动完成<a href="http://blog.csdn.net/tennysonsky/article/details/45622395" target="_blank" rel="noopener">TCP 三次握手</a>，将建立好的链接自动存储到队列中，如此重复。</p><p>所以，只要 TCP 服务器调用了 listen()，客户端就可以通过 connect() 和服务器建立连接，而<strong>这个连接的过程是由内核完成</strong>。<img src="http://upload-images.jianshu.io/upload_images/1452123-36cb315844274d43?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>下面为测试的服务器和客户端代码，运行程序时，要先运行服务器，再运行客户端：<br>服务器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建通信端点：套接字</span></span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">my_addr</span>;</span></span><br><span class="line">    bzero(&amp;my_addr, <span class="keyword">sizeof</span>(my_addr));</span><br><span class="line">    my_addr.sin_family = AF_INET;</span><br><span class="line">    my_addr.sin_port   = htons(port);</span><br><span class="line">    my_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err_log = bind(sockfd, (struct sockaddr*)&amp;my_addr, <span class="keyword">sizeof</span>(my_addr));</span><br><span class="line">    <span class="keyword">if</span>( err_log != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"binding"</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err_log = listen(sockfd, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(err_log != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"listen"</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"listen client @port=%d...\n"</span>,port);</span><br><span class="line">    sleep(<span class="number">10</span>);  <span class="comment">// 延时10s</span></span><br><span class="line">    system(<span class="string">"netstat -an | grep 8000"</span>);  <span class="comment">// 查看连接状态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> port = <span class="number">8000</span>;             <span class="comment">// 服务器的端口号</span></span><br><span class="line">    <span class="keyword">char</span> *server_ip = <span class="string">"10.221.20.12"</span>;       <span class="comment">// 服务器ip地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">// 创建通信端点：套接字</span></span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    bzero(&amp;server_addr,<span class="keyword">sizeof</span>(server_addr)); <span class="comment">// 初始化服务器地址</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, server_ip, &amp;server_addr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err_log = connect(sockfd, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));      <span class="comment">// 主动连接服务器</span></span><br><span class="line">    <span class="keyword">if</span>(err_log != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"connect"</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"netstat -an | grep 8000"</span>);  <span class="comment">// 查看连接状态</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行程序时，要先运行服务器，再运行客户端</strong>，运行结果如下：<br><img src="http://upload-images.jianshu.io/upload_images/1452123-505f528c2893e499?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>三次握手的连接队列<br>这里详细的介绍一下 listen() 函数的第二个参数（ backlog）的作用：告诉内核连接队列的长度。</p><p>为了更好的理解 backlog 参数，我们必须认识到内核为任何一个给定的监听套接口维护两个队列：<br>1、未完成连接队列（incomplete connection queue），每个这样的 SYN 分节对应其中一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的 TCP <a href="http://blog.csdn.net/tennysonsky/article/details/45622395" target="_blank" rel="noopener">三次握手</a>过程。这些套接口处于 SYN_RCVD 状态。<br>2、已完成连接队列（completed connection queue），每个已完成 TCP <a href="http://blog.csdn.net/tennysonsky/article/details/45622395" target="_blank" rel="noopener">三次握手</a>过程的客户对应其中一项。这些套接口处于 ESTABLISHED 状态。</p><p><img src="http://upload-images.jianshu.io/upload_images/1452123-8b0d7d58536aaaef?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>当来自客户的 SYN 到达时，TCP 在未完成连接队列中创建一个新项，然后响应以三次握手的第二个分节：服务器的 SYN 响应，其中稍带对客户 SYN 的 ACK（即 SYN + ACK），这一项一直保留在未完成连接队列中，直到三次握手的第三个分节（客户对服务器 SYN 的 ACK ）到达或者该项超时为止（曾经源自Berkeley的实现为这些未完成连接的项设置的超时值为75秒）。</p><p>如果三次握手正常完成，该项就从未完成连接队列移到已完成连接队列的队尾。</p><p><strong>backlog 参数</strong>历史上被定义为上面两个队列的大小之和，大多数实现默认值为 5，当服务器把这个完成连接队列的某个连接取走后，这个队列的位置又空出一个，这样来回实现动态平衡，但在高并发 web 服务器中此值显然不够。</p><p>accept()函数<br>accept()函数功能是，从处于 established 状态的连接队列头部取出一个已经完成的连接，如果这个队列没有已经完成的连接，accept()函数就会阻塞，直到取出队列中已完成的用户连接为止。</p><p>如果，服务器不能及时调用 accept() 取走队列中已完成的连接，队列满掉后会怎样呢？UNP（《unix网络编程》）告诉我们，服务器的连接队列满掉后，服务器不会对再对建立新连接的syn进行应答，所以客户端的 connect 就会返回 ETIMEDOUT。<strong>但实际上Linux的并不是这样的！</strong></p><p>下面为测试代码，服务器 listen() 函数只指定队列长度为 2，客户端有 6 个不同的套接字主动连接服务器，同时，保证客户端的 6 个 connect()函数都先调用完毕，服务器的 accpet() 才开始调用。</p><p>服务器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> port = <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">my_addr</span>;</span></span><br><span class="line">    bzero(&amp;my_addr, <span class="keyword">sizeof</span>(my_addr));</span><br><span class="line">    my_addr.sin_family = AF_INET;</span><br><span class="line">    my_addr.sin_port   = htons(port);</span><br><span class="line">    my_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err_log = bind(sockfd, (struct sockaddr*)&amp;my_addr, <span class="keyword">sizeof</span>(my_addr));</span><br><span class="line">    <span class="keyword">if</span>( err_log != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"binding"</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err_log = listen(sockfd, <span class="number">2</span>);    <span class="comment">// 等待队列为2</span></span><br><span class="line">    <span class="keyword">if</span>(err_log != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"listen"</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after listen\n"</span>);</span><br><span class="line">    sleep(<span class="number">20</span>);  <span class="comment">//延时 20秒</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"listen client @port=%d...\n"</span>,port);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">        <span class="keyword">char</span> cli_ip[INET_ADDRSTRLEN] = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">socklen_t</span> cliaddr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> connfd;</span><br><span class="line">        connfd = accept(sockfd, (struct sockaddr*)&amp;client_addr, &amp;cliaddr_len);</span><br><span class="line">        <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"accept"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inet_ntop(AF_INET, &amp;client_addr.sin_addr, cli_ip, INET_ADDRSTRLEN);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-----------%d------\n"</span>, ++i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client ip=%s,port=%d\n"</span>, cli_ip,ntohs(client_addr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> recv_buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>( recv(connfd, recv_buf, <span class="keyword">sizeof</span>(recv_buf), <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"recv data ==%s\n"</span>,recv_buf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        close(connfd);     <span class="comment">//关闭已连接套接字</span></span><br><span class="line">        <span class="comment">//printf("client closed!\n");</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);         <span class="comment">//关闭监听套接字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> port = <span class="number">8000</span>;             <span class="comment">// 服务器的端口号</span></span><br><span class="line">    <span class="keyword">char</span> *server_ip = <span class="string">"10.221.20.12"</span>;       <span class="comment">// 服务器ip地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">// 创建通信端点：套接字</span></span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    bzero(&amp;server_addr,<span class="keyword">sizeof</span>(server_addr)); <span class="comment">// 初始化服务器地址</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, server_ip, &amp;server_addr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err_log = connect(sockfd, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));      <span class="comment">// 主动连接服务器</span></span><br><span class="line">    <span class="keyword">if</span>(err_log != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"connect"</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"err_log ========= %d\n"</span>, err_log);</span><br><span class="line">    <span class="keyword">char</span> send_buf[<span class="number">100</span>]=<span class="string">"this is for test"</span>;</span><br><span class="line">    send(sockfd, send_buf, <span class="built_in">strlen</span>(send_buf), <span class="number">0</span>);   <span class="comment">// 向服务器发送信息</span></span><br><span class="line">    system(<span class="string">"netstat -an | grep 8000"</span>);             <span class="comment">// 查看连接状态</span></span><br><span class="line">    <span class="comment">//close(sockfd);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == pid)&#123;</span><br><span class="line">        test_connect();     <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == pid)&#123;</span><br><span class="line">            test_connect(); <span class="comment">// 2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            test_connect(); <span class="comment">// 3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        test_connect(); <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == pid)&#123;</span><br><span class="line">            test_connect(); <span class="comment">// 5</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            test_connect(); <span class="comment">// 6</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是先运行服务器，在运行客户端，服务器 accept()函数前延时了 20 秒， 保证了客户端的 connect() 全部调用完毕后再调用 accept(),运行结果如下：<br>服务器运行效果图：<br><img src="http://upload-images.jianshu.io/upload_images/1452123-f5b002c769b0ada2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/1452123-2e0b7d37172491b0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>客户端运行效果图：<br><img src="http://upload-images.jianshu.io/upload_images/1452123-6d0f9fa7a1ba8176?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>按照 UNP 的说法，连接队列满后（这里设置长度为 2，发了 6 个连接），以后再调用 connect() 应该统统超时失败，但实际上测试结果是：有的 connect()立刻成功返回了，有的经过明显延迟后成功返回了。对于服务器 accpet() 函数也是这样的结果：有的立马成功返回，有的延迟后成功返回。</p><p>对于上面服务器的代码，我们把lisen()的第二个参数改为 0 的数，重新运行程序，发现：<br>客户端 connect() 全部返回连接成功（有些会延时）：<br><img src="http://upload-images.jianshu.io/upload_images/1452123-e96b7ecfac8bf5ae?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>服务器 accpet() 函数却不能把连接队列的所有连接都取出来：<br><img src="http://upload-images.jianshu.io/upload_images/1452123-56bc97db0580ba51?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于上面服务器的代码，我们把lisen()的第二个参数改为大于 6 的数(如 10)，重新运行程序，发现，客户端 connect() 立马返回连接成功， 服务器 accpet() 函数也立马返回成功。</p><p><strong>TCP 的连接队列满后，Linux 不会如书中所说的拒绝连接</strong>，只是有些会延时连接，<strong>而且</strong>accept()未必能把已经建立好的连接全部取出来（如：当队列的长度指定为 0 ），写程序时服务器的 listen() 的第二个参数最好还是根据需要填写，写太大不好（具体可以看cat /proc/sys/net/core/somaxconn，默认最大值限制是 128），浪费资源，写太小也不好，延时建立连接。</p><p><a href="http://download.csdn.net/detail/tennysonsky/8685543" target="_blank" rel="noopener">测试代码下载请点此处</a></p><p>本文来源：<br><a href="http://blog.csdn.net/tennysonsky/article/details/45621341" target="_blank" rel="noopener">http://blog.csdn.net/tennysonsky/article/details/45621341</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vimrc settings</title>
      <link href="/Vim/vim-vimrc-setting/"/>
      <url>/Vim/vim-vimrc-setting/</url>
      
        <content type="html"><![CDATA[<br><h5 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h5><hr><p>set nocp<br>该命令指定让 VIM 工作在不兼容模式下。在 VIM 之前，出现过一个非常流行的编辑器叫 vi。VIM 许多操作与 vi 很相似，但也有许多操作与 vi 是不一样的。如果使用“:set cp”命令打开了兼容模式开关的话，VIM 将尽可能地模仿 vi 的操作模式。<br>也许有许多人喜欢“最正统的 vi”的操作模式，对于初学者来说，vi 里许多操作是比较不方便的。<br>举一个例子，VIM 里允许在 Insert 模式下使用方向键移动光标，而 vi 里在 Insert 模式下是不能移动光标的，必须使用 ESC 退回到 Normal 模式下才行。<br>再举一个例子，vi 里使用 u 命令可以撤消一次先前的操作，再次按下 u 时，将撤消“撤消”这个动作本身，也就是我们常说的“重复”(redo)。而 VIM 里可以使用 u 命令撤消多步操作，“重复”使用的快捷键是 Ctrl + R。<br>使用兼容模式后，VIM 将放弃这些新的功能，尽量模仿 vi 的各种操作方式。只有在不兼容模式下，才能更好地发挥 VIM 自身的特点。Bram 爷爷强烈推荐大家使用 VIM 的不兼容模式，滇狐也是这样推荐的。请务必在你的 .vimrc 中的第一行写上：“set nocp”。</p><p>set ru<br>该命令打开 VIM 的状态栏标尺。默认情况下，VIM 的状态栏标尺在屏幕底部，它能即时显示当前光标所在位置在文件中的行号、列号，以及对应的整个文件的百分比。打开标尺可以给文件的编辑工作带来一定方便。</p><p>set hls<br>搜索时高亮显示被找到的文本。该指令的功能在 vimtutor 中已经有过介绍，这里就不多说了。其实似乎许多人并不喜欢这个功能。</p><p>set is<br>搜索时在未完全输入完毕要检索的文本时就开始检索。vimtutor 对该命令也有过介绍，滇狐并不喜欢这个功能，因此滇狐自己的配置文件里是没有这条命令的。但是周围有朋友很喜欢这个，因此滇狐还是将它列在这里。</p><p>syntax on<br>打开关键字上色。进行程序设计的朋友应该都知道关键字上色是什么东西，因此这里就不多说了。不进行程序设计的朋友不妨也打开这个功能，虽然不一定能够用得着，但这个功能其实也是很好玩的。</p><p>set backspace=indent,eol,start<br>设想这样一个情况：当前光标前面有若干字母，我们按下 i 键进入了 Insert 模式，然后输入了 3 个字母，再按 5 下删除(Backspace)。默认情况下，VIM 仅能删除我们新输入的 3 个字母，然后喇叭“嘟嘟”响两声。如果我们“set backspace=start”，则可以在删除了新输入的 3 个字母之后，继续向前删除原有的两个字符。<br>再设想一个情况：有若干行文字，我们把光标移到中间某一行的行首，按 i 键进入 Insert 模式，然后按一下 Backspace。默认情况下，喇叭会“嘟”一声，然后没有任何动静。如果我们“set backspace=eol”，则可以删除前一行行末的回车，也就是说将两行拼接起来。<br>当我们设置了自动缩进后，如果前一行缩进了一定距离，按下回车后，下一行也会保持相同的缩进。默认情况下，我们不能在 Insert 模式下直接按 Backspace 删除行首的缩进。如果我们“set backspace=indent”，则可以开启这一项功能。<br>上述三项功能，你可以根据自己的需要，选择其中一种或几种，用逗号分隔各个选项。建议把这三个选项都选上。</p><p>set whichwrap=b,s,&lt;,&gt;,[,]<br>默认情况下，在 VIM 中当光标移到一行最左边的时候，我们继续按左键，光标不能回到上一行的最右边。同样地，光标到了一行最右边的时候，我们不能通过继续按右跳到下一行的最左边。但是，通过设置 whichwrap 我们可以对一部分按键开启这项功能。如果想对某一个或几个按键开启到头后自动折向下一行的功能，可以把需要开启的键的代号写到 whichwrap 的参数列表中，各个键之间使用逗号分隔。以下是 whichwrap 支持的按键名称列表：</p><p>b 在 Normal 或 Visual 模式下按删除(Backspace)键。<br>s 在 Normal 或 Visual 模式下按空格键。<br>h 在 Normal 或 Visual 模式下按 h 键。<br>l 在 Normal 或 Visual 模式下按 l 键。<br>&lt; 在 Normal 或 Visual 模式下按左方向键。<br><span>&gt; 在 Normal 或 Visual 模式下按右方向键。</span><br><span>~ 在 Normal 模式下按 ~ 键(翻转当前字母大小写)。<span><br><span>[ 在 Insert 或 Replace 模式下按左方向键。<span><br><span>] 在 Insert 或 Replace 模式下按右方向键。<span></span></span></span></span></span></span></p><p>set encoding=utf-8<br>设置当前字符编码为 UTF-8。UTF-8 是支持字符集最多的编码之一，在 UTF-8 下进行工作，会带来许多方便之处。由于 VIM 在运行过程中切换 encoding 会造成许多问题，如提示信息乱码、register 丢失等，因此强烈建议大家在启动 VIM 的时候把 encoding 设置为 UTF-8，在编辑非 UTF-8 的文件时，通过 fileencoding 来进行转码。</p><p>set langmenu=zh_CN.UTF-8<br>使用中文菜单，并使用 UTF-8 编码。如果没有这句的话，在非 UTF-8 的系统，如 Windows 下，用了 UTF-8 的 encoding 后菜单会乱码。</p><p>language message zh_CN.UTF-8<br>使用中文提示信息，并使用 UTF-8 编码。如果没有这句的话，在非 UTF-8 的系统，如 Windows 下，用了 UTF-8 的 encoding 后系统提示会乱码。</p><p>set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1<br>设置编码的自动识别。关于这条设置的详细含义，请参看这篇文章。</p><p>set ambiwidth=double<br>防止特殊符号无法正常显示。在 Unicode 中，许多来自不同语言的字符，如果字型足够近似的话，会把它们放在同一个编码中。但在不同编码中，字符的宽度是不一样的。例如中文汉语拼音中的 ā 就很宽，而欧洲语言中同样的字符就很窄。当 VIM 工作在 Unicode 状态时，遇到这些宽度不明的字符时，默认使用窄字符，这会导致中文的破折号“——”非常短，五角星“★”等符号只能显示一半。因此，我们需要设置 ambiwidth=double 来解决这个问题。</p><p>filetype plugin indent on<br>开启文件类型自动识别，启用文件类型插件，启用针对文件类型的自动缩进。</p><br><h5 id="文本编辑设置"><a href="#文本编辑设置" class="headerlink" title="文本编辑设置"></a>文本编辑设置</h5><hr><p>set sw=4<br>自动缩进的时候，缩进尺寸为 4 个空格。</p><p>set ts=4<br>Tab 宽度为 4 个字符。</p><p>set et<br>编辑时将所有 Tab 替换为空格。<br>该选项只在编辑时将 Tab 替换为空格，如果打开一个已经存在的文件，并不会将已有的 Tab 替换为空格。如果希望进行这样的替换的话，可以使用这条命令“:retab”。</p><p>set smarttab<br>当使用 et 将 Tab 替换为空格之后，按下一个 Tab 键就能插入 4 个空格，但要想删除这 4 个空格，就得按 4 下 Backspace，很不方便。设置 smarttab 之后，就可以只按一下 Backspace 就删除 4 个空格了。</p><p>set spell<br>打开拼写检查。拼写有错的单词下方会有红色波浪线，将光标放在单词上，按 z= 就会出现拼写建议，按 ]s 可以直接跳到下一个拼写错误处。</p><br><h5 id="断行设置"><a href="#断行设置" class="headerlink" title="断行设置"></a>断行设置</h5><hr><p>set tw=78<br>设置光标超过 78 列的时候折行。</p><p>set lbr<br>不在单词中间断行。设置了这个选项后，如果一行文字非常长，无法在一行内显示完的话，它会在单词与单词间的空白处断开，尽量不会把一个单词分成两截放在两个不同的行里。</p><p>set fo+=mB<br>打开断行模块对亚洲语言支持。m 表示允许在两个汉字之间断行，即使汉字之间没有出现空格。B 表示将两行合并为一行的时候，汉字与汉字之间不要补空格。该命令支持的更多的选项请参看用户手册。</p><br><h5 id="C-C-编码设置"><a href="#C-C-编码设置" class="headerlink" title="C/C++ 编码设置"></a>C/C++ 编码设置</h5><hr><p>set sm<br>显示括号配对情况。打开这个选项后，当输入后括号(包括小括号、中括号、大括号) 的时候，光标会跳回前括号片刻，然后跳回来，以此显示括号的配对情况。</p><p>set cin<br>打开 C/C++ 风格的自动缩进。打开了自动缩进后，在编码的时候我们可以使用“V”命令选中一段文本后，按“=”将这段文本重新调整缩进格式，在一定程度上起到代码美化的作用。<br>另外，打开了自动缩进后，在使用 TERM 下的 vim 的时，粘贴代码时常常会出现版式混乱的现象。那是因为 TERM 并不知道你现在正在粘贴代码，它直接“粘贴”动作向 vim 解释为键入，因此 vim 便按照设置的自动缩进格式为你的代码调整了缩进。不幸的是，粘贴进去的代码中本身已经包含了缩进，因此便出现了版式混乱的情况。在 gvim 中就不会出现这个问题，因为它能够知道你现在正在粘贴。<br>知道了这个症状的来由，解决方案也就显而易见了：在粘贴的时候把所有自动缩进都关闭，粘贴完毕之后再打开。一个个手工关闭自动缩进未免过于繁琐，vim 为我们提供了一个很好用的命令，只要输入“:set paste”，就可以关闭所有自动缩进。粘贴完毕后再输入“:set nopaste”就可以重新打开原有的自动缩进设置了。</p><p>set cino=:0g0t0(sus<br>设定 C/C++ 风格自动缩进的选项，这里简要介绍一下这段代码里用到的选项的含义，cino 支持的选项还很多，更多选项请看用户手册。</p><p>set ai<br>打开普通文件类型的自动缩进。该自动缩进不如 cindent 智能，但它可以为你编辑非 C/C++ 文件提供一定帮助。</p><h5 id="其它设置"><a href="#其它设置" class="headerlink" title="其它设置"></a>其它设置</h5><hr><p>set selectmode=<br>不使用 selectmode。</p><p>set keymodel=<br>不使用“Shift + 方向键”选择文本，“Shift + 方向键”代表向指定方向跳一个单词。如果你喜欢这项功能的话，可以使用“set keymodel=startsel,stopsel”打开它。</p><p>set selection=inclusive<br>指定在选择文本时，光标所在位置也属于被选中的范围。如果指定 selection=exclusive 的话，可能会出现某些文本无法被选中的情况。</p><p>set wildmenu<br>在命令模式下使用 Tab 自动补全的时候，将补全内容使用一个漂亮的单行菜单形式显示出来。</p><p>colo torte<br>选择 torte 配色方案。VIM 里内置了许多关键字上色的配色方案，另外你还可以到网上下载更多配色方案，或是自己编写。点击“编辑”→“调色板”，就能列出所有支持的配色方案。你可以把“调色板”子菜单剪下来，然后慢慢选择，挑出一个你最喜欢的配色方案来。</p><br><h5 id="图形界面设置"><a href="#图形界面设置" class="headerlink" title="图形界面设置"></a>图形界面设置</h5><hr><p>set nowrap<br>指定不折行。如果一行太长，超过屏幕宽度，则向右边延伸到屏幕外面。如果使用图形界面的话，指定不折行视觉效果会好得多。</p><p>set mousemodel=popup<br>当右键单击窗口的时候，弹出快捷菜单。</p><p>set guioptions+=b<br>添加水平滚动条。如果你指定了不折行，那为窗口添加一个水平滚动条就非常有必要了。</p><p>set guifont=Bitstream\ Vera\ Sans\ Mono\ 9<br>设置图形界面下的字体。你可以点“编辑”→“选择字体”，然后在对话框中选出你喜欢的字体与字号，选择完毕后，先按几下 ESC 确认处在 Normal 模式下，然后输入这条命令：“:set guifont?”回车后 gvim 屏幕最下方会显示出你当前所用的字体的名称与字号。将获得的结果写到配置文件里面就可以了，需要注意一点，如果字体名称里面含有空格的话，在抄的时候需要在所有空格前面加一个斜杠。</p><br><h5 id="条件选择"><a href="#条件选择" class="headerlink" title="条件选择"></a>条件选择</h5><hr><p>同一个配色方案，在 gvim 下和字符界面的 vim 下效果大相径庭，滇狐个人的习惯是，在 gvim 下使用 torte 配色方案，在 vim 下使用 ron 配色方案。因此我们有必要针对 gvim 和 vim 进行不同的设置。</p><p>另外，前面我们在 gvim 下不使用折行，开启水平滚动条，但在 vim 下，是没有滚动条可用的，因此还是有必要为 vim 保留自动折行。</p><p>条件选择设置的格式如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">has</span>(<span class="string">"gui_running"</span>))</span><br><span class="line"><span class="comment">" 图形界面下的设置</span></span><br><span class="line">    <span class="keyword">set</span> nowrap</span><br><span class="line">    <span class="keyword">set</span> guioptions+=<span class="keyword">b</span></span><br><span class="line">    <span class="keyword">colo</span> torte</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">" 字符界面下的设置</span></span><br><span class="line">    <span class="keyword">set</span> wrap</span><br><span class="line">    <span class="keyword">colo</span> ron</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><br><h5 id="示例配置文件"><a href="#示例配置文件" class="headerlink" title="示例配置文件"></a>示例配置文件</h5><hr><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> fileencoding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">set</span> fileencodings=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">set</span> termencoding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">set</span> fileformats=unix</span><br><span class="line"><span class="keyword">set</span> encoding=prc</span><br><span class="line"><span class="keyword">set</span> ffs=unix,dos,mac</span><br><span class="line"></span><br><span class="line"><span class="comment">" 基础配置</span></span><br><span class="line"><span class="keyword">filetype</span> <span class="keyword">on</span>                                 <span class="comment">"检测文件类型</span></span><br><span class="line"><span class="keyword">filetype</span> <span class="built_in">indent</span> <span class="keyword">on</span>                          <span class="comment">"针对不同的文件类型采用不同的缩进格式</span></span><br><span class="line"><span class="keyword">filetype</span> plugin <span class="keyword">on</span>                          <span class="comment">"允许插件</span></span><br><span class="line"><span class="keyword">filetype</span> plugin <span class="built_in">indent</span> <span class="keyword">on</span>                   <span class="comment">"启动自动补全</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"autocmd! bufwritepost _vimrc source %      "</span>vimrc文件修改之后自动加载。 windows。</span><br><span class="line"><span class="string">"autocmd! bufwritepost .vimrc source %      "</span>vimrc文件修改之后自动加载。 linux。</span><br><span class="line"><span class="keyword">syntax</span> enable <span class="comment">"开启代码高亮</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span> <span class="comment">"打开高亮</span></span><br><span class="line"><span class="keyword">set</span> completeopt=longest,<span class="keyword">menu</span>                <span class="comment">"自动补全配置,让Vim的补全菜单行为与一般IDE一致(参考VimTip1228)</span></span><br><span class="line"><span class="string">"set relativenumber number                  "</span>相对行号，可用Ctrl+n在相对/绝对行号间切换</span><br><span class="line"><span class="keyword">set</span> cursorcolumn                            <span class="comment">"突出显示当前列，可用Ctrl+m切换是否显示</span></span><br><span class="line"><span class="string">"set cursorline                             "</span>突出显示当前行，可用Ctrl+<span class="keyword">m</span>切换是否显示</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">history</span>=<span class="number">3000</span>                            <span class="comment">"history存储长度</span></span><br><span class="line"><span class="keyword">set</span> nocompatible                            <span class="comment">"非兼容vi模式,避免以前版本的一些bug和局限</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">nu</span>                                      <span class="comment">"显示行数 </span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span>                            <span class="comment">"换行时行间交错使用4空格</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">cindent</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span>                    <span class="comment">"自动缩进4空格</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span>                               <span class="comment">"让一个tab等于4个空格</span></span><br><span class="line"><span class="keyword">set</span> vb t_vb=</span><br><span class="line"><span class="keyword">set</span> showmatch                               <span class="comment">"显示括号配对情况</span></span><br><span class="line"><span class="string">"set autoread                               "</span>当文件在外部被改变时，Vim自动更新载入</span><br><span class="line"><span class="keyword">set</span> nowrap                                  <span class="comment">"设置不自动换行</span></span><br><span class="line"><span class="keyword">set</span> writebackup                             <span class="comment">"设置无备份文件</span></span><br><span class="line"><span class="keyword">set</span> nobackup                                <span class="comment">"取消备份。 视情况自己改</span></span><br><span class="line"><span class="keyword">set</span> noswapfile                              <span class="comment">"关闭交换文件</span></span><br><span class="line"><span class="keyword">set</span> showmode                                <span class="comment">"开启模式显示  </span></span><br><span class="line"><span class="keyword">set</span> cmdheight=<span class="number">1</span>                             <span class="comment">"命令部分高度为1 </span></span><br><span class="line"><span class="string">"set shortmess=atI                          "</span>启动的时候不显示那个援助索马里儿童的提示</span><br><span class="line"><span class="keyword">set</span> t_ti= t_te=                             <span class="comment">"退出vim后，内容显示在终端屏幕 设置 退出vim后，内容显示在终端屏幕,</span></span><br><span class="line">                                            <span class="comment">"可以用于查看和复制好处：误删什么的，如果以前屏幕打开，可以找回去掉输入错误的提示声音</span></span><br><span class="line"><span class="keyword">set</span> title                                   <span class="comment">"change the terminal's title</span></span><br><span class="line"><span class="keyword">set</span> novisualbell                            <span class="comment">"don't beep</span></span><br><span class="line"><span class="keyword">set</span> noerrorbells                            <span class="comment">"don't beep</span></span><br><span class="line"><span class="keyword">set</span> t_vb=</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">tm</span>=<span class="number">500</span></span><br><span class="line"></span><br><span class="line"><span class="string">"set backup                                 "</span>备份</span><br><span class="line"><span class="comment">"set backupext=.bak</span></span><br><span class="line"><span class="comment">"set backupdir=/tmp/vimbk/</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">mat</span>=<span class="number">4</span>                                   <span class="comment">"Blink times every second when matching brackets</span></span><br><span class="line"><span class="keyword">set</span> hidden                                  <span class="comment">"A buffer becomes hidden when it is abandoned</span></span><br><span class="line"><span class="keyword">set</span> wildmode=lis<span class="variable">t:longest</span></span><br><span class="line"><span class="keyword">set</span> ttyfast</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> wildignore=*.swp,*.bak,*.pyc,*.class</span><br><span class="line"><span class="keyword">set</span> scrolloff=<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> selection=old</span><br><span class="line"><span class="comment">"set selectmode=mouse,key</span></span><br><span class="line"><span class="keyword">set</span> viminfo^=%                              <span class="comment">"Remember info about open buffers on close</span></span><br><span class="line"><span class="keyword">set</span> viminfo+=!                              <span class="comment">" 保存全局变量</span></span><br><span class="line"><span class="keyword">set</span> magic                                   <span class="comment">"正则表达式匹配形式</span></span><br><span class="line"><span class="keyword">set</span> backspace=eol,start,<span class="built_in">indent</span>              <span class="comment">"Configure backspace so it acts as it should act</span></span><br><span class="line"><span class="string">"set backspace=indent,eol,start whichwrap+=&lt;,&gt;,[,] "</span>允许退格键的使用</span><br><span class="line"><span class="string">"set iskeyword+=_,$,@,%,#,-                 "</span>带有如下符号的单词不要被换行分割 </span><br><span class="line"><span class="keyword">set</span> iskeyword+=_,$,@,%,#                    <span class="comment">"带有如下符号的单词不要被换行分割 </span></span><br><span class="line">                                            <span class="comment">" 字符间插入的像素行数目</span></span><br><span class="line"><span class="comment">"au BufRead,BufNewFile *.&#123;md,mdown,mkd,mkdn,markdown,mdwn&#125;   </span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">filetype</span>=mkd   <span class="comment">"markdown配置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"set go=                                    "</span>不要图形按钮  </span><br><span class="line"><span class="keyword">set</span> cul                                     <span class="comment">"高亮光标所在行</span></span><br><span class="line"><span class="string">"autocmd InsertEnter * se cul               "</span>用浅色高亮当前行  </span><br><span class="line"><span class="keyword">set</span> ruler                                   <span class="comment">"显示标尺  </span></span><br><span class="line"><span class="string">"set showcmd                                "</span>输入的命令显示出来，看的清楚些  </span><br><span class="line"></span><br><span class="line"><span class="keyword">au</span> BufReadPost * <span class="keyword">if</span> <span class="built_in">line</span>(<span class="string">"'\""</span>) &gt; <span class="number">0</span>|<span class="keyword">if</span> <span class="built_in">line</span>(<span class="string">"'\""</span>) &lt;= <span class="built_in">line</span>(<span class="string">"$"</span>)|<span class="keyword">exe</span>(<span class="string">"norm '\""</span>)|<span class="keyword">else</span>|<span class="keyword">exe</span> <span class="string">"norm $"</span>|<span class="keyword">endif</span>|<span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span></span><br><span class="line"><span class="comment">" F1 - F6 设置</span></span><br><span class="line"><span class="comment">" F1 废弃这个键,防止调出系统帮助</span></span><br><span class="line"><span class="comment">" F2 行号开关，用于鼠标复制代码用</span></span><br><span class="line"><span class="comment">" F3 换行开关</span></span><br><span class="line"><span class="comment">" F4 调出listbar函数列表</span></span><br><span class="line"><span class="comment">" F5 粘贴模式paste_mode开关,用于有格式的代码粘贴</span></span><br><span class="line"><span class="comment">" F6 语法开关，关闭语法可以加快大文件的展示</span></span><br><span class="line"><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;F1&gt;</span> <span class="symbol">&lt;Esc&gt;</span><span class="comment">"</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F2&gt;</span> :<span class="keyword">set</span> nonumber! <span class="keyword">number</span>?<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F3&gt;</span> :<span class="keyword">set</span> wrap! wrap?<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;F4&gt;</span> :TagbarToggle<span class="symbol">&lt;CR&gt;</span>        <span class="comment">"按下F4就可以呼出文件的函数列表及变量</span></span><br><span class="line"><span class="keyword">set</span> pastetoggle=<span class="symbol">&lt;F5&gt;</span> </span><br><span class="line"><span class="keyword">au</span> InsertLeave * <span class="keyword">set</span> nopaste</span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F6&gt;</span> :exec <span class="built_in">exists</span>(<span class="string">'syntax_on'</span>) ? <span class="string">'syn off'</span> : <span class="string">'syn on'</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" 命令行模式增强，ctrl - a到行首， -e 到行尾</span></span><br><span class="line"><span class="keyword">cnoremap</span> <span class="symbol">&lt;C-a&gt;</span> <span class="symbol">&lt;Home&gt;</span></span><br><span class="line"><span class="keyword">cnoremap</span> <span class="symbol">&lt;C-e&gt;</span> <span class="symbol">&lt;End&gt;</span></span><br><span class="line"><span class="comment">" 去掉搜索高亮</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;leader&gt;</span>/ :nohls<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">"Use arrow key to change buffer"</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;left&gt;</span> :<span class="keyword">bp</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;right&gt;</span> :<span class="keyword">bn</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">tn</span> :<span class="keyword">tabnew</span><span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">to</span> :<span class="keyword">tabonly</span><span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">tc</span> :<span class="keyword">tabclose</span><span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">tm</span> :<span class="keyword">tabmove</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Opens a new tab with the current buffer's path</span></span><br><span class="line"><span class="comment">" Super useful when editing files in the same directory</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">te</span> :<span class="keyword">tabedit</span> <span class="symbol">&lt;c-r&gt;</span>=<span class="built_in">expand</span>(<span class="string">"%:p:h"</span>)<span class="symbol">&lt;cr&gt;</span>/</span><br><span class="line"></span><br><span class="line"><span class="comment">"共享剪贴板  </span></span><br><span class="line"><span class="keyword">set</span> clipboard+=unnamed</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> &amp;bg == <span class="string">"dark"</span>   <span class="comment">" 根据你的背景色风格来设置不同的书签颜色</span></span><br><span class="line"> <span class="keyword">highlight</span> SignColor ctermfg=white ctermbg=blue guifg=wheat guibg=peru</span><br><span class="line"><span class="keyword">else</span>               <span class="comment">" 主要就是修改guibg的值来设置书签的颜色</span></span><br><span class="line"> <span class="keyword">highlight</span> SignColor ctermbg=white ctermfg=blue guibg=grey guifg=RoyalBlue3</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> $TERM =~ <span class="string">'^xterm'</span> || $TERM =~ <span class="string">'^screen'</span> || $TERM=~ <span class="string">'256color$'</span></span><br><span class="line">    <span class="keyword">set</span> t_Co=<span class="number">256</span></span><br><span class="line">    <span class="keyword">set</span> background=dark</span><br><span class="line"><span class="keyword">colorscheme</span> darkblue</span><br><span class="line"><span class="keyword">elseif</span> <span class="built_in">has</span>(<span class="string">'gui_running'</span>)</span><br><span class="line">    <span class="keyword">set</span> background=light</span><br><span class="line">    <span class="keyword">colorscheme</span> solarized</span><br><span class="line"><span class="keyword">elseif</span> $TERM =~ <span class="string">'cons256'</span></span><br><span class="line">    <span class="keyword">colorscheme</span> default</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><br><br><br><p><strong>Reference</strong><br><a href="https://github.com/amix/vimrc" target="_blank" rel="noopener">https://github.com/amix/vimrc</a><br><a href="http://www.cnblogs.com/ma6174/archive/2011/12/10/2283393.html" target="_blank" rel="noopener">http://www.cnblogs.com/ma6174/archive/2011/12/10/2283393.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Vim </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Use lsof in Linux</title>
      <link href="/Linux/linux-lsof/"/>
      <url>/Linux/linux-lsof/</url>
      
        <content type="html"><![CDATA[<p>lsof（list open files）是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。 </p><br><h4 id="lsof输出信息含义"><a href="#lsof输出信息含义" class="headerlink" title="lsof输出信息含义"></a>lsof输出信息含义</h4><p>在终端下输入lsof即可显示系统打开的文件，因为 lsof 需要访问核心内存和各种文件，所以必须以 root 用户的身份运行它才能够充分地发挥其功能。 </p><pre><code>COMMAND    PID      USER   FD      TYPE     DEVICE     SIZE       NODE      NAMEinit       1         root  cwd      DIR       3,3       1024       2         /init       1         root  rtd      DIR       3,3       1024       2         /init       1         root  txt      REG       3,3       38432      1763452  /sbin/initinit       1         root  mem      REG       3,3       106114     1091620  /lib/libdl-2.6.soinit       1         root  mem      REG       3,3       7560696    1091614  /lib/libc-2.6.soinit       1         root  mem      REG       3,3       79460      1091669  /lib/libselinux.so.1init       1         root  mem      REG       3,3       223280     1091668  /lib/libsepol.so.1init       1         root  mem      REG       3,3       564136     1091607  /lib/ld-2.6.soinit       1         root  10u      FIFO      0,15                 1309     /dev/initctl</code></pre><p>每行显示一个打开的文件，若不指定条件默认将显示所有进程打开的所有文件。lsof输出各列信息的意义如下：<br>COMMAND：进程的名称<br>PID：    进程标识符<br>USER：   进程所有者<br>FD：     文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等<br>TYPE：   文件类型，如DIR、REG等<br>DEVICE： 指定磁盘的名称<br>SIZE：   文件的大小<br>NODE：   索引节点（文件在磁盘上的标识）<br>NAME：   打开文件的确切名称</p><p>其中FD 列中的文件描述符cwd 值表示应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改。<br>txt 类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序。其次数值表示应用<br>程序的文件描述符，这是打开该文件时返回的一个整数。如上的最后一行文件/dev/initctl，其文件描述符为 10。u 表示该<br>文件被打开并处于读取/写入模式，而不是只读 ® 或只写 (w) 模式。同时还有大写 的W 表示该应用程序具有对整个文件的写<br>锁。该文件描述符用于确保每次只能打开一个应用程序实例。初始打开每个应用程序时，都具有三个文件描述符，从 0 到 2，<br>分别表示标准输入、输出和错误流。所以大多数应用程序所打开的文件的 FD 都是从 3 开始。<br>与 FD 列相比，Type 列则比较直观。文件和目录分别称为 REG 和 DIR。而CHR 和 BLK，分别表示字符和块设备；<br>或者 UNIX、FIFO 和 IPv4，分别表示 UNIX 域套接字、先进先出 (FIFO) 队列和网际协议 (IP) 套接字。 </p><br><h4 id="lsof常用参数"><a href="#lsof常用参数" class="headerlink" title="lsof常用参数"></a>lsof常用参数</h4><p>lsof 常见的用法是查找应用程序打开的文件的名称和数目。可用于查找出某个特定应用程序将日志数据记录到何处，或者正在跟踪某个问题。<br>例如，linux限制了进程能够打开文件的数目。通常这个数值很大，所以不会产生问题，并且在需要时，应用程序可以请求更大的值（直到某<br>个上限）。如果你怀疑应用程序耗尽了文件描述符，那么可以使用 lsof 统计打开的文件数目，以进行验证。lsof语法格式是：<br>lsof ［options］ filename</p><p><strong>常用的参数列表</strong></p><p>lsof  filename 显示打开指定文件的所有进程<br>lsof -a 表示两个参数都必须满足时才显示结果<br>lsof -c string   显示COMMAND列中包含指定字符的进程所有打开的文件<br>lsof -u username  显示所属user进程打开的文件<br>lsof -g gid 显示归属gid的进程情况<br>lsof +d /DIR/ 显示目录下被进程打开的文件<br>lsof +D /DIR/ 同上，但是会搜索目录下的所有目录，时间相对较长<br>lsof -d FD 显示指定文件描述符的进程<br>lsof -n 不将IP转换为hostname，缺省是不加上-n参数<br>lsof -i 用以显示符合条件的进程情况<br>lsof -i[46] [protocol][@hostname|hostaddr][:service|port]<br>            46 –&gt; IPv4 or IPv6<br>            protocol –&gt; TCP or UDP<br>            hostname –&gt; Internet host name<br>            hostaddr –&gt; IPv4地址<br>            service –&gt; /etc/service中的 service name (可以不只一个)<br>            port –&gt; 端口号 (可以不只一个)<br>例如： 查看22端口现在运行的情况 </p><pre><code>$ lsof -i :22COMMAND  PID USER   FD   TYPE DEVICE SIZE NODE NAMEsshd    1409 root    3u  IPv6   5678       TCP *:ssh (LISTEN)</code></pre><p>查看所属root用户进程所打开的文件类型为txt的文件: </p><pre><code>$ lsof -a -u root -d txtCOMMAND    PID USER  FD      TYPE DEVICE    SIZE    NODE NAMEinit       1    root txt       REG    3,3   38432 1763452 /sbin/initmingetty  1632 root txt       REG    3,3   14366 1763337 /sbin/mingettymingetty  1633 root txt       REG    3,3   14366 1763337 /sbin/mingettymingetty  1634 root txt       REG    3,3   14366 1763337 /sbin/mingettymingetty  1635 root txt       REG    3,3   14366 1763337 /sbin/mingettymingetty  1636 root txt       REG    3,3   14366 1763337 /sbin/mingettymingetty  1637 root txt       REG    3,3   14366 1763337 /sbin/mingettykdm        1638 root txt       REG    3,3  132548 1428194 /usr/bin/kdmX          1670 root txt       REG    3,3 1716396 1428336 /usr/bin/Xorgkdm        1671 root txt       REG    3,3  132548 1428194 /usr/bin/kdmstartkde  2427 root txt       REG    3,3  645408 1544195 /bin/bash... ...  </code></pre><br><h4 id="lsof使用实例"><a href="#lsof使用实例" class="headerlink" title="lsof使用实例"></a>lsof使用实例</h4><p><strong>一、查找谁在使用文件系统</strong><br>在卸载文件系统时，如果该文件系统中有任何打开的文件，操作通常将会失败。那么通过lsof可以找出那些进程在使用当前要卸载的文件系统，如下： </p><pre><code>$ lsof  /GTES11/COMMAND  PID USER   FD   TYPE DEVICE SIZE NODE NAMEbash    4208 root  cwd    DIR    3,1 4096    2 /GTES11/vim     4230 root  cwd    DIR    3,1 4096    2 /GTES11/</code></pre><p>在这个示例中，用户root正在其/GTES11目录中进行一些操作。一个 bash是实例正在运行，并且它当前的目录为/GTES11，另一个则显示的是vim正在编辑/GTES11下的文件。要成功地卸载/GTES11，应该在通知用户以确保情况正常之后，中止这些进程。 这个示例说明了应用程序的当前工作目录非常重要，因为它仍保持着文件资源，并且可以防止文件系统被卸载。这就是为什么大部分守护进程（后台进程）将它们的目录更改为根目录、或服务特定的目录（如 sendmail 示例中的 /var/spool/mqueue）的原因，以避免该守护进程阻止卸载不相关的文件系统。 </p><p><strong>二、恢复删除的文件</strong><br>当Linux计算机受到入侵时，常见的情况是日志文件被删除，以掩盖攻击者的踪迹。管理错误也可能导致意外删除重要的文件，比如在清理旧日志时，意外地删除了数据库的活动事务日志。有时可以通过lsof来恢复这些文件。<br>当进程打开了某个文件时，只要该进程保持打开该文件，即使将其删除，它依然存在于磁盘中。这意味着，进程并不知道文件已经被删除，它仍然可以向打开该文件时提供给它的文件描述符进行读取和写入。除了该进程之外，这个文件是不可见的，因为已经删除了其相应的目录索引节点。<br>在/proc 目录下，其中包含了反映内核和进程树的各种文件。/proc目录挂载的是在内存中所映射的一块区域，所以这些文件和目录并不存在于磁盘中，因此当我们对这些文件进行读取和写入时，实际上是在从内存中获取相关信息。大多数与 lsof 相关的信息都存储于以进程的 PID 命名的目录中，即 /proc/1234 中包含的是 PID 为 1234 的进程的信息。每个进程目录中存在着各种文件，它们可以使得应用程序简单地了解进程的内存空间、文件描述符列表、指向磁盘上的文件的符号链接和其他系统信息。lsof 程序使用该信息和其他关于内核内部状态的信息来产生其输出。所以lsof 可以显示进程的文件描述符和相关的文件名等信息。也就是我们通过访问进程的文件描述符可以找到该文件的相关信息。 </p><p>当系统中的某个文件被意外地删除了，只要这个时候系统中还有进程正在访问该文件，那么我们就可以通过lsof从/proc目录下恢复该文件的内容。 假如由于误操作将/var/log/messages文件删除掉了，那么这时要将/var/log/messages文件恢复的方法如下：<br>首先使用lsof来查看当前是否有进程打开/var/logmessages文件，如下： </p><pre><code>$ lsof |grep /var/log/messagessyslogd   1283      root    2w      REG        3,3  5381017    1773647 /var/log/messages (deleted)</code></pre><p>从上面的信息可以看到 PID 1283（syslogd）打开文件的文件描述符为 2。同时还可以看到/var/log/messages已经标记被删除了。因此我们可以在 /proc/1283/fd/2 （fd下的每个以数字命名的文件表示进程对应的文件描述符）中查看相应的信息，如下： </p><pre><code>$ head -n 10 /proc/1283/fd/2Aug  4 13:50:15 holmes86 syslogd 1.4.1: restart.Aug  4 13:50:15 holmes86 kernel: klogd 1.4.1, log source = /proc/kmsg started.Aug  4 13:50:15 holmes86 kernel: Linux version 2.6.22.1-8 (root@everestbuilder.linux-ren.org) (gcc version 4.2.0) #1 SMP Wed Jul 18 11:18:32 EDT 2007Aug  4 13:50:15 holmes86 kernel: BIOS-provided physical RAM map:Aug  4 13:50:15 holmes86 kernel:  BIOS-e820: 0000000000000000 - 000000000009f000 (usable)Aug  4 13:50:15 holmes86 kernel:  BIOS-e820: 000000000009f000 - 00000000000a0000 (reserved)Aug  4 13:50:15 holmes86 kernel:  BIOS-e820: 0000000000100000 - 000000001f7d3800 (usable)Aug  4 13:50:15 holmes86 kernel:  BIOS-e820: 000000001f7d3800 - 0000000020000000 (reserved)Aug  4 13:50:15 holmes86 kernel:  BIOS-e820: 00000000e0000000 - 00000000f0007000 (reserved)Aug  4 13:50:15 holmes86 kernel:  BIOS-e820: 00000000f0008000 - 00000000f000c000 (reserved)</code></pre><p>从上面的信息可以看出，查看 <code>/proc/8663/fd/15</code> 就可以得到所要恢复的数据。如果可以通过文件描述符查看相应的数据，那么就可以使用 I/O 重定向将其复制到文件中，如: </p><pre><code>$ cat /proc/1283/fd/2 &gt; /var/log/messages </code></pre><p>对于许多应用程序，尤其是日志文件和数据库，这种恢复删除文件的方法非常有用。 </p><br><h4 id="常见用法列举"><a href="#常见用法列举" class="headerlink" title="常见用法列举"></a>常见用法列举</h4><p>lsof +d /usr/local　　显示当前目录下被进程打开的文件<br>lsof +D /usr/local　　显示当前目录下被进程打开的文件，包括其他目录下的文件<br>lsof file　　　　　　 显示开启file的进程<br>lsof -c abc　　　　　 显示abc进程打开的文件<br>lsof -p 123　　　　　 显示pid为123的进程所打开的文件<br>lsof -g gid　　　　　 显示归属gid的进程情况<br>lsof -u root　　　　　显示用户root的进程所打开的文件<br>lsof -u ^root　　　　 显示不是用户root的进程所打开的文件<br>lsof -u 1000　　　　　显示uid为1000的用户的进程所打开的文件<br>lsof -i　　　　　　　 显示所有打开的端口<br>lsof -i:80　　　　　　显示所有打开80端口的进程<br>lsof -i <a href="mailto:udp@192.168.129.126" target="_blank" rel="noopener">udp@192.168.129.126</a>:5060　　　显示哪些进程使用udp打开了192.168.129.126的5060端口<br>lsof -i <a href="mailto:tcp@192.168.129.126" target="_blank" rel="noopener">tcp@192.168.129.126</a>:ftp -r　　显示哪些进程使用tcp打开了192.168.129.126的ftp服务，-r不断查看</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Module in Linux</title>
      <link href="/Linux/linux-module/"/>
      <url>/Linux/linux-module/</url>
      
        <content type="html"><![CDATA[<p>和 linux 中加载模块有关的几个程序分别如下：</p><ul><li>lsmod</li><li>modprobe</li><li>depmod</li></ul><p>lsmod显示当前加载的所有模块，相当于cat /proc/modules,假设你没有设定开机加载某个模块，比如ntfs，那么开机后执行lsmod，列表里不会有ntfs这个模块的，这时你再执行mount -t ntfs xxx后，执行lsmod后列表里就会有ntfs这个模块了。<br>还要注意的是lsmod显示的是模块名，而不是别名(alias)。<br>这里最重要的是modprobe.<br>man modprobe<br>节选如下：</p><p>modprobe – program to add and remove modules from the Linux Kernel<br>从linux核心中添加或删除模块。</p><p>modprobe intelligently adds or removes a module from the Linux kernel:  note  that  for  convenience,there  is  no  difference  between  _  and - in module names.  modprobe looks in the module directory /lib/modules/<code>uname -r</code> for all the modules and  other  files,  except  for  the  optional  /etc/modprobe.conf configuration file and /etc/modprobe.d directory (see modprobe.conf(5)).  All files in the /etc/modprobe.d/arch/ directory are ignored.</p><p>为了一致性，模块名字中包含的_和-是没有任何区别的。modprobe会检查/lib/modules/<code>uname -r</code>下的所有模块，除了/etc/modprobe.conf配置文件和/etc/modprobe.d目录以外。所有/etc/modprobe.d/arch/目录下的文件将被忽略。</p><p>Note that this version of modprobe does not do anything to the module itself: the work  of  resolving symbols  and  understanding  parameters  is  done  inside the kernel.  So module failure is sometimes accompanied by a kernel message: see dmesg(8).</p><p>值得注意的是现在modprobe不会对模块本身进行操作，解析symbols和理解参数的工作都交由kernel来作，所以模块加载等错误有时将会包含在内核信息中，利用dmesg可以查看到。</p><p>modprobe expects an up-to-date modules.dep file, as generated by depmod (see depmod(8)).   This  file<br>lists  what  other  modules each module needs (if any), and modprobe uses this to add or remove these<br>dependencies automatically.  See modules.dep(5)).</p><p>modprobe会根据modules.dep来添加或者删除模块。</p><p>If any arguments are given after the modulename, they are passed to the kernel (in  addition  to  any<br>options listed in the configuration file).<br>如果指定模块名称的话，这些模块将会被传到核心中，当然还有它们对应的参数（记录在配置文件中）.</p><p>OPTIONS<br>-l –list List all modules matching the given wildcard (or “*” if no wildcard is given).  This option<br>                 is provided for backwards compatibility: see find(1) and basename(1) for  a  more  flexible<br>                 alternative.<br>用来列出所有模块或者符合指定条件的所有模块，可以使用wildcard。</p><p>-r –remove<br>删除模块。</p><p>BACKWARDS COMPATIBILITY(向下兼容性)<br>This  version  of  modprobe is for kernels 2.5.48 and above.  If it detects a kernel with support for old-style modules (for which much of the work was done in userspace), it will  attempt  to  run  modprobe.modutils in its place, so it is completely transparent to the user.</p><p>现在版本的modprobe只支持2.5.48及以上的内核，如果它发现内核支持老的模块或者内核本身就低于2.5.48，它将尝试运行modprobe.modutils来代替自己。</p><p>通过了解modprobe的manpage我们知道，我可以通过modprobe -l来显示可以当前可以加载的模块，所谓<br>当前可以加载的模块，实际上就是modules.dep文件中包含的那些模块，而不是manpage里说的modprobe会加载/lib/modules/<code>uname -r</code>下的所有模块(也许是我理解错误)，下面我们将会证明这一点.<br>modprobe xxx.ko        #加载某个模块<br>modprobe -r xxx.ko     #卸载某个模块<br>上面提到modprobe加载某个模块是根据/lib/modules/<code>uname -r</code>目录下的modules.dep文件中的模块列表，这个文件中有的模块modprobe会正确加载，否则就会出错。<br>我们还拿ntfs这个模块来举例:<br>vi /lib/modules/<code>uname -r</code>/modules.dep<br>注释掉/lib/modules/2.6.18-4-k7/kernel/fs/ntfs/ntfs.ko这一行,就是加个#号.<br>这个修改是即使生效的。<br>modinfo ntfs<br>modinfo: could not find module ntfs<br>modprobe ntfs<br>FATAL: Module ntfs not found.<br>重启机器，执行同样的命令会得到同样的结果，说明开机不会自动执行depmod的，而<br>locate ntfs.ko<br>/lib/modules/2.6.18-4-k7/kernel/fs/ntfs/ntfs.ko<br>证明我们并没有转移ntfs模块。<br>注意如果重启机器之前进行mount还是可以的，重启之后就会报错了，而上边的都是即时生效的。<br>还有如果modules.dep里注释掉了ntfs，那么在/etc/modules里写上也是不起作用的，说明这个和mount一样都是依赖modprobe来完成加载模块命令的。而insmod是可以的，因为insmod后面跟的是绝对路径，它和modules.dep没什么关系。insmod比较重要的用途是用来测试模块的正确性，加载一般都是依靠modprobe。(这个可能也不起作用了，都用modprobe吧)<br>这一切只是因为我们注释掉了modules.dep中关于ntfs.ko的那一行，而模块并没有删除或转移。既然modules.dep文件如此重要，那么它是怎么生成的呢？这就和下一个命令有关了，depmod。</p><p>man depmod<br>depmod – program to generate modules.dep and map files. Blank lines, and lines starting with a ‘#’ (ignoring spaces) are ignored in modules.dep.<br>depmod是一个用来产生modules.dep和map文件的程序。在modules.dep文件中空白行和以’#’开头的行将被忽略.</p><p>Linux kernel modules can provide services (called “symbols”) for  other<br>modules  to  use (using EXPORT_SYMBOL in the code).<br>linux核心模块可以提供服务给其他模块，称之为”symbols”</p><p>depmod  creates  a  list of module dependencies, by reading each module<br>under /lib/modules/version and determining what symbols it exports, and<br>what  symbols it needs.<br>depmod通过读取/lib/modules/version目录下的每一个模块来创建一个记录模块相依性<br>的列表。这个列表就是/lib/modules/version目录下的modules.dep。</p><p>If a version is provided, then that kernel version’s  module  directory<br>is  used, rather than the current kernel version (as returned by “uname<br>-r”).<br>如果给定version的话，那么depmod会检查这个version对应的modules目录而不是<br>当前运行的kernel对应的modules目录。</p><p>depmod will also generate various map files in this directory, for  use<br>by the hotplug infrastructure.<br>depmod也会在/lib/modules/version目录下创建许多map文件,这些文件将会被hotplug用到。</p><p>OPTIONS:<br>-a –all  Probe  all  modules.  This option is enabled by default if no<br>            file names are given in the command-line.<br>检查所有的模块，这个命令是默认的如果你没有指定模块名字的话。</p><p>-A –quick  This option scans to see if any modules are  newer  than  the<br>                 modules.dep file before any work is done: if not, it silently<br>                 exits rather than regenerating the files.<br>只检查那些比modules.dep文件里记录新的模块的相依性，如果没有则退出，并不重建modules.dep.</p><p>-e –errsyms<br>                 When  combined  with  the -F option, this reports any symbols<br>                 which a module needs which are not supplied by other  modules<br>                 or the kernel.  Normally, any symbols not provided by modules<br>                 are assumed to be provided by the  kernel  (which  should  be<br>                 true in a perfect world).<br>如果和下面的-F选项合用的话，将会报告模块需要却又不存在的symbols。通常，模块不提供的symbols<br>会由kernel来提供。</p><p>-F –filesyms System.map<br>                 Supplied  with  the  System.map  produced when the kernel was<br>                 built, this allows the -e option to  report  unresolved  sym-<br>                 bols.<br>System.map是在kernel被创建的时候建立的，-F选项可以利用System.map文件，这时-e选项才可以使用。</p><p>-n –dry-run<br>                 This  sends  the  resulting modules.dep, then the various map<br>                 files, to standard output, rather than writing them into  the<br>                 module directory.<br>只把结果显示在屏幕上而不是写到modules.dep中。</p><p>BACKWARDS COMPATIBILITY(向下兼容性)</p><p>This version of depmod is for kernels 2.5.48 and above.  If it detects a kernel with support for old style modules, or the version specified is before 2.5.48, it will attempt to run  depmod.modutils  in its place, so it is completely transparent to the user.</p><p>现在版本的depmod只支持2.5.48及以上的内核，如果它发现内核支持老的模块或者内核本身就低于2.5.48，<br>它将尝试运行depmod.modutils来代替自己。</p><p>通常我们安装一个新的模块,先是编译出相应的ko文件，然后移动/lib/modules/<code>uname -r</code>/目录或者某个子<br>目录下，locate xxx.ko确定该模块确实在上面提到的目录下面，执行depmod -aeF，depmod将会检查<br>/lib/modules/<code>uname -r</code>/目录及其子目录中的所有模块文件，并根据相依性生成新的modules.dep文件，这时我们执行modprobe xxx.ko，该模块就会被正常加载了。<br>所以这时我们重新执行depmod -aeF会生成新的modules.dep，刚才注释掉了的那个#也消失了。<br>这里我们还要提两个文件：<br>1./etc/modules<br>vi /etc/modules</p><h1 id="etc-modules-kernel-modules-to-load-at-boot-time"><a href="#etc-modules-kernel-modules-to-load-at-boot-time" class="headerlink" title="/etc/modules: kernel modules to load at boot time."></a>/etc/modules: kernel modules to load at boot time.</h1><p>#</p><h1 id="This-file-contains-the-names-of-kernel-modules-that-should-be-loaded"><a href="#This-file-contains-the-names-of-kernel-modules-that-should-be-loaded" class="headerlink" title="This file contains the names of kernel modules that should be loaded"></a>This file contains the names of kernel modules that should be loaded</h1><h1 id="at-boot-time-one-per-line-Lines-beginning-with-“-”-are-ignored"><a href="#at-boot-time-one-per-line-Lines-beginning-with-“-”-are-ignored" class="headerlink" title="at boot time, one per line. Lines beginning with “#” are ignored."></a>at boot time, one per line. Lines beginning with “#” are ignored.</h1><p>loop</p><p>说明我们如果在这里写上模块名字，比如ntfs(注意不要写ntfs或者ntfs对应的alias)，开机时就会自动加载，<br>即开机后lsmod后就会看到ntfs而不用等mount或者modprobe ntfs等命令。<br>man modprobe.conf<br>modprobe.conf – Configuration file/directory for modprobe<br>modprobe.conf 传递给modprobe的配置文件或目录。</p><p>Because  the  modprobe  command can add or remove extra more than one module, due to module dependen-<br>cies, we need a method of specifying what options are to  be  used  with  those  modules.   /etc/mod-<br>probe.conf  (or,  if  that  does  not exist, all files under the /etc/modprobe.d directory) specifies<br>those options, as required.  It can also be used to create convenient aliases: alternate names for  a<br>module.   Finally,  it can override the normal modprobe behavior altogether, for those with very spe-<br>cial requirements (such as inserting more than one module).<br>modprobe可以根据相依性来添加或删除模块，所以我们需要一种方法来指定特殊的选项给特定的某些模块。<br>/etc/modprobe.conf(如果不存在就是在/etc/modprobe.d目录下的所有文件)将会指定这些需要的选项。也可以<br>指定别名给一个模块。</p><p>The  format  of  modprobe.conf and files under modprobe.d is simple: one command per line, with blank<br>lines and lines starting with # ignored (useful for adding comments).  A  at the end of a line causes<br>it to continue on the next line, which makes the file a bit neater.<br>格式：每行一个命令，空白行和行首有‘#’的将被忽略。行尾有A代表下一行是这行的继续。</p><p>The syntax is a simplification of modules.conf, used in 2.4 kernels and earlier.<br>modules.conf只被2.4或更早的内核使用。</p><p>alias wildcard modulename<br>                 This  allows  you  to  give  alternate  names  for  a  module.   For example: “alias my-mod<br>                 really_long_modulename”  means  you  can  use  “modprobe  my-mod”  instead   of   “modprobe<br>                 really_long_modulename”.   You  can  also  use  shell-style  wildcards,  so  “alias my-mod*                 really_long_modulename” means that “modprobe my-mod-something” has the  same  effect.   You<br>                 can’t  have aliases to other aliases (that way lies madness), but aliases can have options,<br>                 which will be added to any other options.<br>指定别名，也可以利用shell中的wildcard来指定。例子：<br>alias my-mod really_long_modulename<br>这意味着你可以用modprobe  my-mod”来代替”modprobe really_long_modulename.<br>不可以给别名指定别名。但是别名可以有选项。</p><p>Note that modules can also contain their own aliases, which  you  can  see  using  modinfo.<br>These  aliases  are used as a last resort (ie. if there is no real module, install, remove,<br>or alias       command in the configuration).</p><p>模块可以有它们自带的别名，你可以利用modinfo看到。这些别名将被作为最后一着。配置文件里的别名优先，如果<br>没有指定的话，这些自带的别名将被用到。</p><p>options modulename option…<br>                 This command allows you to add options to the module modulename (which might be  an  alias)<br>                 every  time it is inserted into the kernel: whether directly (using modprobe modulename, or<br>                 because the module being inserted depends on this module.</p><pre><code>All options are added together: they can come from an option for the module itself, for  analias, and on the command line.</code></pre><p>这个命令允许你加一些条件给模块（模块名或者是别名），当模块被加载到内核中时。所有的条件选项可以被叠加。</p><p>install modulename command…<br>                 This is the most powerful primitive in modprobe.conf: it tells modprobe to run your command<br>                 instead of inserting the module in the kernel as normal.  The command can be any shell com-<br>                 mand: this allows you to do any kind of complex processing you might wish.  For example, if<br>                 the module “fred” worked better with the module “barney” already installed (but  it  didn’t<br>                 depend  on  it,  so  modprobe  won’t  automatically  load  it), you could say “install fred<br>                 /sbin/modprobe barney; /sbin/modprobe –ignore-install  fred”,  which  would  do  what  you<br>                 wanted.   Note  the  –ignore-install,  which stops the second modprobe from re-running the<br>                 same install command.  See also remove below.<br>这是modprobe.conf中最原始最有效的命令：它告诉modprobe运行你的命令来取代modprobe通常的行为（加载一个模块到内核中)。<br>这个命令可以是shell命令，这将允许你做任何你西王做的复杂的事情。例子：<br>假定fred模块和barney模块一起工作时效果比较好，但是由于fred并不依赖于barney模块，所以加载fred时并不会加载barney。<br>这是我们可以加如下的命令到配置文件中去。<br>install fred /sbin/modprobe barney; /sbin/modprobe –ignore-install  fred.<br>install fred 是指定modprobe在加载fred这个模块之前要运行后面的这个命令来替代本来的动作（modprobe fred）。也就是:<br>/sbin/modprobe barney; /sbin/modprobe –ignore-install  fred 代替了modprobe fred<br>这里–ignore-install表示加载时不要考虑配置文件中install选项，这是为了避免又运行一遍同样的shell命令。</p><pre><code>You can also use install to make up modules which  don&apos;t  otherwise  exist.   For  example:&quot;install  probe-ethernet  /sbin/modprobe  e100  || /sbin/modprobe eepro100&quot;, which will tryfirst the e100 driver, then the eepro100 driver, when you do &quot;modprobe probe-ethernet&quot;.</code></pre><p>你可以组合模块。例子：<br>install  probe-ethernet  /sbin/modprobe  e100  || /sbin/modprobe eepro100<br>当你下达modprobe probe-ethernet的命令时，将会先尝试加载e100driver，如果不行再加载eepro100driver。</p><pre><code>If you use the string &quot;$CMDLINE_OPTS&quot; in the command, it will be replaced  by  any  optionsspecified  on the modprobe command line.  This can be useful because users expect &quot;modprobefred opt=1&quot; to pass the &quot;opt=1&quot; arg to the module, even if there&apos;s an  install  command  inthe  configuration file.  So our above example becomes &quot;install fred /sbin/modprobe barney;/sbin/modprobe --ignore-install fred $CMDLINE_OPTS&quot;</code></pre><p>如果你在配置文件中的命令行里使用了$CMDLINE_OPTS这个字符串，那么你可以从shell命令行里直接下达你希望传递给模块<br>的条件，这个条件将取代配置文件中的这个$CMDLINE_OPTS.例子：<br>如果上边的例子改为：<br>install fred /sbin/modprobe barney;/sbin/modprobe –ignore-install fred $CMDLINE_OPTS<br>那么当你下达modprobe fred opt=1时，这个opt=1参数将被传递给模块，它将取代$CMDLINE_OPTS.</p><p>remove modulename command…<br>                 This is similar to the install command above, except it is invoked when  “modprobe  -r”  is<br>                 run.   The removal counterparts to the two examples above would be: “remove fred /sbin/mod-<br>                 probe -r –ignore-remove fred &amp;&amp; /sbin/modprobe  -r  barney”,  and  “remove  probe-ethernet<br>                 /sbin/modprobe -r eepro100 || /sbin/modprobe -r e100”.<br>这个命令和install类似，只不过它只在modprobe -r时才起作用。上边的例子对应：<br>“remove fred /sbin/modprobe -r –ignore-remove fred &amp;&amp; /sbin/modprobe  -r  barney”,  and<br>“remove  probe-ethernet/sbin/modprobe -r eepro100 || /sbin/modprobe -r e100”.</p><p>blacklist modulename<br>                 Modules  can  contain  their  own aliases: usually these are aliases describing the devices<br>                 they support, such as “pci:123…”.  These “internal” aliases can be overridden  by  normal<br>                 “alias”  keywords,  but  there  are  cases  where two or more modules both support the same<br>                 devices, or a module invalidly claims to support a device: the blacklist keyword  indicates<br>                 that all of that particular module’s internal aliases are to be ignored.</p><p>模块可以有自己的别名。通常这些别名描述了它们支持的设备，比如：pci:123…<br>这些内部别名会被通常我们指定的别名推翻。但是有些情况下，两个或更多的模块同时支持同一个设备，或者模块实际不能支持它宣称支持的设备:这时黑名单上的模块意味着这些特殊模块的内部别名将会被忽略。</p><p>Backwards Compatibility<br>       Although the syntax is similar to the older  /etc/modules.conf,  there  are  many  features  missing.<br>       There  are two reasons for this: firstly, install and remove commands can do just about anything, and secondly, the module-init-tools modprobe is designed to be  simple  enough  that  it  can  be  easily replaced.<br>虽然和老的/etc/modules.conf很像，但是老的/etc/modules.conf还是缺少很多的特性.</p><p>modprobe.conf就是modprobe某个模块时用到的配置文件，这个我不是很懂，转贴鸟哥私房菜上的一段说明：<br><a href="http://linux.vbird.org/linux_basic/0510osloader.php#kernel" target="_blank" rel="noopener">http://linux.vbird.org/linux_basic/0510osloader.php#kernel</a><br>核心與核心模組：<br>談完了整個開機的流程，您應該會知道，在整個開機的過程當中，是否能夠成功的驅動我們主機的硬體配備，是核心 (kernel) 的工作！而核心一般都是壓縮檔，因此在使用核心之前，就得要將他解壓縮後，才能載入主記憶體當中。</p><p>另外，為了應付日新月異的硬體，目前的核心都是具有『可讀取模組化驅動程式』的功能，亦即是所謂的『 modules (模組化)』的功能啦！所謂的模組化可以將他想成是一個『外掛程式』，該外掛程式可能由硬體開發廠商提供，也有可能我們的核心本來就支援～不過，較新的硬體，通常都需要硬體開發商提供驅動程式模組啦！</p><p>那麼核心與核心模組放在哪？<br>核心： /boot/vmlinuz 或 /boot/vmlinuz-version；<br>核心解壓縮所需 RAM Disk： /boot/initrd (/boot/initrd-version)；<br>核心模組： /lib/modules/version/kernel 或 /lib/modules/<code>uname -r</code>/kernel；<br>核心原始碼： /usr/src/linux (要安裝才會有！否則預設不安裝的！)<br>如果該核心被順利的載入系統當中了，那麼就會有幾個資訊紀錄下來：<br>核心版本： /proc/version<br>系統核心功能： /proc/sys/kernel<br>問題來啦，如果我有個新的硬體，偏偏我的作業系統不支援，該怎麼辦？很簡單啊！<br>重新編譯核心，並加入最新的硬體驅動程式原始碼；<br>將該硬體的驅動程式編譯成為模組，在開機時載入該模組<br>上面第一點還很好理解，反正就是重新編譯核心就是了。不過，核心編譯很不容易啊！我們會在後續章節約略介紹核心編譯的整個程序。比較有趣的則是將該硬體的驅動程式編譯成為模組啦！關於編譯的方法，可以參考後續的 原始碼與 tarball 那一章的介紹。我們這個章節僅是說明一下，如果想要載入一個已經存在的模組時，該如何是好？</p><p>小標題的圖示核心模組與相依性：<br>既然要處理核心模組，自然就得要瞭解瞭解我們核心提供的模組之間的相關性啦！基本上，核心的放置處是在 /lib/modules/<code>uname -r</code>/kernel 當中，裡面主要還分成幾個目錄：<br>arch    ：與硬體平台有關的項目，例如 CPU 的等級等等；<br>crypto  ：核心所支援的加密的技術，例如 md5 或者是 des 等等；<br>drivers ：一些硬體的驅動程式，例如顯示卡、網路卡、PCI 相關硬體等等；<br>fs  ：核心所支援的 filesystems ，例如 vfat, reiserfs, nfs 等等；<br>lib ：一些函式庫；<br>net ：與網路有關的各項協定資料，還有防火牆模組 (net/ipv4/netfilter/*) 等等；<br>sound   ：與音效有關的各項模組；<br>如果要我們一個一個的去檢查這些模組的主要資訊，然後定義出他們的相依性，我們可能會瘋掉吧！所以說，我們的 Linux 當然會提供一些模組相依性的解決方案囉～對啦！那就是檢查 /lib/modules/<code>uname -r</code>/modules.dep這個檔案啦！他記錄了在核心支援的模組的各項相依性。</p><p>那麼這個檔案如何建立呢？挺簡單！利用 depmod 這個指令就可以達到建立該檔案的需求了！<br>[root@linux ~]# depmod [-Ane]<br>參數：<br>-A  ：不加任何參數時， depmod 會主動的去分析目前核心的模組，並且重新寫入<br>      /lib/modules/<code>uname -r</code>/modules.dep 當中。若加入 -A 參數時，則 depmod<br>      會去搜尋比 modules.dep 還要新的模組，如果真找到新模組，才會更新。<br>-n  ：不寫入 modules.dep ，而是將結果輸出到螢幕上(standard out)；<br>-e  ：顯示出目前已載入的不可執行的模組名稱<br>範例：</p><p>範例一：若我已經做好一個網路卡驅動程式，假設檔名為 a.ko，該如何更新核心相依性？<br>[root@linux ~]# cp /full/path/a.ko /lib/modules/<code>uname -r</code>/kernel/drivers/net<br>[root@linux ~]# depmod<br>難就難在將那個新的驅動程式模組編譯出來，如果編譯出來之後，依據核心模組放置的目錄去放置好，然後輸入 depmod 後，去更新好 modules.dep ，如此一來，核心就能夠認識該模組囉！夠簡單吧！ ^_^ (關於核心模組的編譯，請參考核心編譯 一文！)</p><p>小標題的圖示核心模組的觀察： lsmod, modinfo<br>那你到底曉不曉得目前核心載入了多少的模組呢？粉簡單啦！利用 lsmod 即可！<br>[root@linux ~]# lsmod<br>Module                  Size  Used by<br>loop                   18121  0<br>ipt_state               1857  2<br>ipt_MASQUERADE          3265  2<br>iptable_filter          2881  1<br>ip_nat_irc              2753  0<br>ip_conntrack_irc       72401  1 ip_nat_irc<br>ip_nat_ftp              3393  0<br>ip_conntrack_ftp       73297  1 ip_nat_ftp<br>….中間省略…..<br>8139too                30017  0<br>mii                     5441  1 8139too<br>floppy                 65141  0<br>ext3                  132681  4<br>jbd                    86233  1 ext3<br>使用 lsmod 之後，系統會顯示出目前已經存在於核心當中的模組，顯示的內容包括有：<br>模組名稱(Module)；<br>模組的大小(size)；<br>此模組是否被其他模組所使用 (Used by)。<br>舉例來說，上面的表格當中，我的 ip_conntrack_ftp 模組其實還被 ip_nat_ftp 模組所使用呢！也就是說，這兩個模組之間應該是有相關性的！所以囉，如果我載入 ip_nat_ftp 勢必還得要載入ip_conntrack_ftp 才行～而這個相依性就是被紀錄在上個小節提到的 modules.dep 檔案內囉！ ^_^</p><p>那麼除了顯示出目前的模組外，我還可以查閱每個模組的資訊嗎？當然可以啦！就用 modinfo 即可：<br>[root@linux ~]# modinfo [-adln] [module_name|filename]<br>參數：<br>-a  ：僅列出作者名稱；<br>-d  ：僅列出該 modules 的說明 (description)；<br>-l  ：僅列出授權 (license)；<br>-n  ：僅列出該模組的詳細路徑。<br>範例：</p><p>範例一：由上個表格當中，請列出 8139too 這個模組的相關資訊：<br>[root@linux ~]# modinfo 8139too<br>filename:       /lib/modules/2.6.12-1.1398_FC4/kernel/drivers/net/8139too.ko<br>author:         Jeff Garzik<br>description:    RealTek RTL-8139 Fast Ethernet driver<br>license:        GPL<br>version:        0.9.27<br>parmtype:       multicast_filter_limit:int<br>parmtype:       media:array of int<br>parmtype:       full_duplex:array of int<br>parmtype:       debug:int<br>parm:           debug:8139too bitmapped message enable number<br>parm:           media:8139too: Bits 4+9: force full duplex, bit 5: 100Mbps<br>parm:           full_duplex:8139too: Force full duplex for board(s) (1)<br>vermagic:       2.6.12-1.1398_FC4 686 REGPARM 4KSTACKS gcc-4.0<br>depends:        mii<br>alias:          pci:v000010ECd00008139sv<em>sd</em>bc<em>sc</em>i*</p><p>範例二：我有一個模組名稱為 a.ko ，請問該模組的資訊為？<br>[root@linux ~]# modinfo a.ko<br>…….省略……<br>事實上，這個 modinfo 除了可以『查閱在核心內的模組』之外，還可以檢查『某個模組檔案』，因此，如果你想要知道某個檔案代表的意義為何，利用 modinfo 加上完整檔名吧！看看就曉得是啥玩意兒囉！ ^_^</p><p>小標題的圖示核心模組的載入與移除：insmod, modprobe, rmmod<br>好了，如果我想要自行手動載入模組，又該如何是好？有很多方法啦，最簡單而且建議的，是使用 modprobe 這個指令來載入模組，這是因為 modprobe 會主動的去搜尋 modules.dep 的內容，先克服了模組的相依性後，才決定需要載入的模組有哪些，很方便。至於 insmod 則完全由使用者自行載入一個完整檔名的模組，並不會主動的分析模組相依性啊！<br>[root@linux ~]# insmod [/full/path/module_name] [parameters]</p><p>範例一：請嘗試載入 /lib/modules/<code>uname -r</code>/kernel/fs/smbfs/smbfs.ko<br>[root@linux ~]# insmod /lib/modules/<code>uname -r</code>/kernel/fs/smbfs/smbfs.ko<br>[root@linux ~]# lsmod | grep smbfs<br>smbfs                  67897  0<br>對吧！他立刻就將該模組載入囉～這個需要加入完整檔名啦！那如何移除這個模組呢？<br>[root@linux ~]# rmmod [-fw] module_name<br>參數：<br>-f  ：強制將該模組移除掉，不論是否正被使用；<br>-w  ：若該模組正被使用，則 rmmod 會等待該模組被使用完畢後，才移除他！<br>範例：</p><p>範例一：將剛剛載入的 smbfs 模組移除！<br>[root@linux ~]# rmmod smbfs<br>帥吧！移除掉了。不過，如前所述的， insmod 實在不怎麼人性化，近年來，我們都建議直接使用 modprobe 來處理模組載入的問題，這個指令的用法是：<br>[root@linux ~]# modprobe [-lcf] module_name<br>參數：<br>-c  ：列出目前系統所有的模組！(更詳細的代號對應表)<br>-l  ：列出目前在 /lib/modules/<code>uname -r</code>/kernel 當中的所有模組完整檔名；<br>-f  ：強制載入該模組；<br>-r  ：類似 rmmod ，就是移除某個模組囉～<br>範例：</p><p>範例一：載入 smbfs 模組<br>[root@linux ~]# modprobe smbfs</p><h1 id="很方便吧！不需要知道完整的模組檔名，這是因為該完整檔名已經記錄到"><a href="#很方便吧！不需要知道完整的模組檔名，這是因為該完整檔名已經記錄到" class="headerlink" title="很方便吧！不需要知道完整的模組檔名，這是因為該完整檔名已經記錄到"></a>很方便吧！不需要知道完整的模組檔名，這是因為該完整檔名已經記錄到</h1><h1 id="lib-modules-uname-r-modules-dep-當中的緣故啊！如果要移除的話："><a href="#lib-modules-uname-r-modules-dep-當中的緣故啊！如果要移除的話：" class="headerlink" title="/lib/modules/uname -r/modules.dep 當中的緣故啊！如果要移除的話："></a>/lib/modules/<code>uname -r</code>/modules.dep 當中的緣故啊！如果要移除的話：</h1><p>[root@linux ~]# modprobe -r smbfs<br>使用 modprobe 真的是要比 insmod 方便很多！因為他是直接去搜尋 modules.dep 的紀錄，所以囉，當然可以克服模組的相依性問題，而且還不需要知道該模組的詳細路徑呢！好方便！ ^_^</p><p>小標題的圖示核心模組的額外參數設定：/etc/modprobe.conf<br>這個檔案我們之前已經談過了，這裡只是再強調一下而已，如果您想要修改某些模組的額外參數設定，就在這個檔案內設定吧！我們假設一個案例好了，假設我的網路卡 eth0 是使用 ne ，但是 eth1 同樣也使用 ne ，為了避免同一個模組會導致網路卡的錯亂，因此，我可以先找到 eth0 與 eth1 的 I/O 與 IRQ ，假設：<br>eth0 ： I/O (0x300) 且 IRQ=5<br>eth1 ： I/O (0x320) 且 IRQ=7<br>則：<br>[root@linux ~]# vi /etc/modprobe.conf<br>alias eth0 ne<br>alias eth1 ne<br>options eth0 io=0x300 irq=5<br>options eth1 io=0x320 irq=7<br>嘿嘿！如此一來，我的 Linux 就不會捉錯網路卡的對應囉！因為被我強制指定某個 I/O 咯嘛！ ^_^<br>再来一个例子：<br>vi /etc/modprobe.conf<br>alias eth0 8139too<br>alias snd-card-0 snd-via82xx<br>options snd-card-0 index=0<br>options snd-via82xx index=0<br>alias usb-controller uhci-hcd<br>意思是說：『我的 eth0 這個玩意兒，代表的是使用 8139too 這個核心模組， 至於 sndcard-<br>0 則使用 snd-via82xx 那個模組。此外， snd-card-0 這個模組在使用時， 還使用<br>index=0 這個參數。』這玩意真的是挺常用的～不過，這個檔案通常在安裝的時候， 安裝<br>程式就會主動的建立這個檔案囉～除非您對系統提供的驅動程式模組不滿意～～ 才會主動<br>的修改這個模組載入的相關檔案啦～(早期 2.4.xx 核心版本時，使用的是<br>/etc/modules.conf 喔！) 更多的相關說明，請 man modprobe.conf 喔！</p><p>我們現在知道核心所支援的功能當中，有直接編譯到核心內部的，也有使用外掛模組的，<br>外掛模組可以簡單的想成 就是驅動程式 啦！那麼也知道這些核心模組依據不同的版本， 被<br>分別放置到 /lib/modules/<code>uname -r</code>/ 目錄中，各個硬體的驅動程式則是放置到<br>/lib/modules/<code>uname -r</code>/kernel/drivers/ 當中！而這些模組與裝置代號的對應， 就必須<br>要被寫入 /etc/modprobe.conf 檔案當中了。<br>事實上，我們的 Linux 核心真的是越來越聰明了， 一般來說，當我們的軟體有使用到核心<br>的某項功能時，其實核心是會『主動的』去載入該功能的！ 根本不需要使用什麼<br>modprobe 還是 insmod 之類的指令去載入呢！不過，有時候某些程式寫的不好時， 確實<br>可能需要我們手動來載入模組就是了。<br>那麼在 Linux kernel 2.6 版裡面的模組檔名是怎樣呢？這個得要特別說明一下囉。在<br>kernel 2.4 版以前，模組的檔名都是 <em>.o 的，例如 vfat.o 這個檔案系統模組就放在：<br>· /lib/modules/<code>uname -r</code>/kernel/fs/vfat/vfat.o<br>但是在 kernel 2.6 版以後，所有的核心模組都被改名字成為 *.ko 了！所以，如果你有<br>vfat 的模組， 他就會被放置到：<br>· /lib/modules/<code>uname -r</code>/kernel/fs/vfat/vfat.ko<br>請特別留意這個差異喔！ ^<em>^。此外，由於我們的核心原本就有提供很多的核心工具給硬<br>體開發商來使用， 而硬體開發商也需要針對核心所提供的功能來設計他們的驅動程式模組，<br>因此， 我們如果想要自行使用硬體開發商所提供的模組來進行編譯時，就需要使用到核心<br>所提供的原始檔當中， 所謂的標頭檔案 (header include file) 來取得驅動模組所需要的一<br>些函式庫或標頭的定義啦！ 也因此我們常常會發現到，如果想要自行編譯核心模組時，就<br>得要擁有核心原始碼嘛！<br>那核心原始碼我們知道他是可能放置在 /usr/src/ 底下，早期的核心原始碼被要求一定要放<br>置到 /usr/src/linux/ 目錄下，不過，如果您有多個核心在一個 Linux 系統當中，而且使用<br>的原始碼並不相同時， 呵呵～問題可就大了！所以，在 2.6 版以後，核心使用比較有趣的<br>方法來設計他的原始碼放置目錄， 那就是以 /lib/modules/<code>uname -r</code>/build 及<br>/lib/modules/<code>uname -r</code>/source 這兩個連結檔來指向正確的核心原始碼放置目錄。如果<br>以我們剛剛由 kernel 2.6.14.2 建立的核心模組來說， 那麼他的核心模組目錄底下有什麼<br>咚咚？<br>其中比較有趣的除了那兩個連結檔之外，還有那個 modules.dep 檔案也挺有趣的， 那個<br>檔案是記錄了核心模組的相依屬性的地方，依據該檔案，我們可以簡單的使用 modprobe<br>這個指令來載入模組呢！至於核心原始碼提供的標頭檔，在上面的案例當中， 則是放置到<br>/usr/src/linux-2.6.14.2/include/ 目錄中，當然就是藉由 build/source 這兩個連結檔案來<br>取得目錄所在的啦！^</em>^5.單一模組編譯<br>想像兩個情況：<br>· 如果我的預設核心忘記加入某個功能，而且該功能可以編譯成為模組，不過， 預設<br>核心卻也沒有將該項功能編譯成為模組，害我不能使用時，該如何是好？<br>· 如果 Linux 核心原始碼並沒有某個硬體的驅動程式 (module) ，但是開發該硬體的<br>廠商有提供給 Linux 使用的驅動程式原始碼，那麼我又該如何將該項功能編進核心<br>模組呢？<br>很有趣對吧！不過，在這樣的情況下其實沒有什麼好說的，反正就是 『去取得原始碼後，<br>重新編譯成為系統可以載入的模組』啊！很簡單，對吧！^_^ 但是，上面那兩種情況的模<br>組編譯行為是不太一樣的，不過，都是需要 make, gcc 以及核心所提供的 include 標頭檔<br>與函式庫等等。<br>· 硬體開發商提供的額外模組：<br>很多時候，可能由於核心預設的核心驅動模組所提供的功能您不滿意， 或者是硬體開發商<br>所提供的核心模組具有更強大的功能， 又或者該硬體是新的，所以預設的核心並沒有該硬<br>體的驅動模組時，那您只好自行由硬體開發商處取得驅動模組， 然後自行編譯囉！<br>如果您的硬體開發商有提供驅動程式的話，那麼真的很好解決，直接下載該原始碼，重新編<br>譯， 將他放置到核心模組該放置的地方後，呵呵！就能夠使用了！舉例來說，如果您不想<br>使用核心原本提供的 Intel 網路卡模組，而想使用 Intel 官方釋出的最新模組，例如下面這<br>個例子：<br>· 模組說明與下載：<a href="http://downloadfinder.intel.com/scripts-dfexternal/" target="_blank" rel="noopener">http://downloadfinder.intel.com/scripts-dfexternal/</a><br>Detail_Desc.aspx?agr=Y&amp;Inst=Yes&amp;ProductID=993&amp;DwnldID=2896&amp;strOSs=39&amp;OSFullName<br>=Linux</em>〈=eng<br>您可以利用各種方法將他下載後，假設這個檔案放置到 /root ，那麼直接將他解壓縮吧！<br>之後就可以讀一讀 INSTALL/README ，然後找一下 Makefile ，就能夠編譯了。整體流程<br>有點像這樣：</p><ol><li>將檔案解壓縮：<br>[root@linux ~]# cd /usr/local/src<br>[root@linux src]# tar -zxvf /root/e100-3.4.14.tar.gz<br>[root@linux src]# cd e100-3.4.14</li><li>開始進行編譯與安裝：<br>[root@linux e100-3.4.14]# vi README &lt;==注意查一下該檔案內容<br>[root@linux e100-3.4.14]# cd src<br>[root@linux src]# make<h1 id="此時您會看到出現如下這一行："><a href="#此時您會看到出現如下這一行：" class="headerlink" title="此時您會看到出現如下這一行："></a>此時您會看到出現如下這一行：</h1><h1 id="make-1-Entering-directory-usr-src-kernels-2-6-13-1-1532-FC4-i686’"><a href="#make-1-Entering-directory-usr-src-kernels-2-6-13-1-1532-FC4-i686’" class="headerlink" title="make[1]: Entering directory `/usr/src/kernels/2.6.13-1.1532_FC4-i686’"></a>make[1]: Entering directory `/usr/src/kernels/2.6.13-1.1532_FC4-i686’</h1><h1 id="這代表這個驅動程式在編譯時，會去讀取的核心原始碼-include-file"><a href="#這代表這個驅動程式在編譯時，會去讀取的核心原始碼-include-file" class="headerlink" title="這代表這個驅動程式在編譯時，會去讀取的核心原始碼 include file"></a>這代表這個驅動程式在編譯時，會去讀取的核心原始碼 include file</h1><h1 id="的目錄所在！有興趣的朋友，務必查閱一下-Makefile-啦！"><a href="#的目錄所在！有興趣的朋友，務必查閱一下-Makefile-啦！" class="headerlink" title="的目錄所在！有興趣的朋友，務必查閱一下 Makefile 啦！"></a>的目錄所在！有興趣的朋友，務必查閱一下 Makefile 啦！</h1>[root@linux src]# ls -l</li></ol><p>-rw-r–r– 1 root root 77908 Jul 2 08:24 e100.c<br>-rw-r–r– 1 root root 351351 Dec 5 00:48 e100.ko<br>-rw-r–r– 1 root root 4775 Dec 5 00:48 e100.mod.c<br>-rw-r–r– 1 root root 39684 Dec 5 00:48 e100.mod.o<br>-rw-r–r– 1 root root 312564 Dec 5 00:48 e100.o<br>-rw-r–r– 1 root root 21092 Jul 2 08:24 ethtool.c<br>-rw-r–r– 1 root root 43258 Jul 2 08:24 kcompat.h<br>-rw-r–r– 1 root root 9610 Jul 2 08:24 Makefile</p><ol start="3"><li>開始將該模組移動到核心目錄，並且更新模組相依屬性！<br>[root@linux src]# cp e100.ko \<blockquote><p>/lib/modules/<code>uname -r</code>/kernel/drivers/net<br>[root@linux src]# cd /lib/modules/<code>uname -r</code><br>[root@linux 2.6.13-1.1532_FC4]# depmod -a<br>有趣吧！透過這樣的動作，我們就可以輕易的將模組編譯起來，並且還可以將他直接<br>放置到核心模組目錄中， 同時以 depmod 將模組建立相關性，未來就能夠利用<br>modprobe 來直接取用啦！^<em>^ 但是需要提醒您的是，當自行編譯模組時， 若您的<br>核心有更新 (例如利用自動更新機制進行線上更新) 時，則您必須要重新編譯該模組<br>一次， 重複上面的步驟！才行！因為這個模組僅針對目前的核心來編譯的啊！對吧！<br>利用舊有的核心原始碼進行編譯：<br>舉個例子來說，鳥哥目前 FC4 的核心就是 2.6 版，而且也有 NTFS 的原始碼，只不過，<br>FC4 就是沒有將這個模組給他編譯起來！那我能否使用目前的核心原始碼進行 NTFS 檔案<br>系統的模組編譯呢？當然可以啊！不過，我是否需要整個核心編譯的過程從頭來一次呢？<br>呵呵！當然不需要啊！否則～多麻煩～那該怎麼作？<br>很簡單啦～我們首先到目前的核心原始碼所在目錄下達 make menuconfig ， 然後將<br>NTFS 的選項設定成為模組，之後直接下達：<br>make fs/ntfs/<br>那麼 ntfs 的模組就會自動的被編譯出來了！可惜的是，預設的 FC4 核心原始碼並沒有附上<br>所有的程式碼， 僅有提供相關的 Makefile 檔案而已，傷腦筋～ 因此，您僅能以我們剛剛<br>才建立的 /usr/src/linux-2.6.14.2 這個目錄， 直接下達 make fs/ntfs 來建立起 ntfs.ko<br>這個模組～ 然後將該模組複製到 /lib/modules/2.6.14.2/kernel/fs/ntsf/ 目錄下， 再去到<br>/lib/modules/2.6.14.2 底下執行 depmod -a ，呵呵～ 就可以在原來的核心底下新增某個<br>想要加入的模組功能囉～ ^</em>^核心模組管理： lsmod, modinfo, modprobe, insmod, rmmod…<br>核心與核心模組是分不開的，至於驅動程式模組在編譯的時候，更與核心的原始碼功能分不<br>開～ 因此，您必須要先瞭解到：核心、核心模組、驅動程式模組、核心原始碼與標頭檔案<br>的相關性， 然後才有辦法瞭解到為何編譯驅動程式的時候老是需要找到核心的原始碼才能<br>夠順利編譯！ 然後也才會知道，為何當核心更新之後，自己之前所編譯的核心模組會失效～</p></blockquote></li></ol><p>转载完</p><p>这里要说明的是在debian中modprobe.conf已经被modprobe.d目录替代了(debian的一贯做法^_^)<br>再探讨一下核心模块的问题，如果我们自己编译了内核，却又忘记编译某个模块的时候，怎么办呢，总不会<br>再重新编译一遍kernel吧,鸟哥已经提过这个事了，这里我们再转载一篇，可以比较看看，再验证一下我们<br>学到的一些知识。</p><p>传统编译内核模块的方法繁琐而费时，本文将告诉我们一种快速编译所需要内核模块的<br>新方法。<br>当你安装完linux系统，并且已经启动，恭喜你！如果你的硬盘上还安装了WinNT/2000<br>系统，你试图去访问另一个NTFS分区时却遇到了麻烦。因为你所用的linux系统没有已编译<br>的支持NTFS文件系统的模块。怎么办？也许你会运行make menuconfig，重新定制你需<br>要的所有模块，接着运行make modeules;make modeules_install来安装。这样不仅繁琐、<br>费时，还可能会出现问题。或者因为编译内核对你有些棘手，太多的选择让你手足无措<br>，你根本没有太好的方法。本文给你提供一个简单的方法，你可以轻松地去编译你所需<br>要的支持NTFS系统的模块（ntfs.o）。以此为例，但愿对你编译其他模块有所帮助。<br>写此文时我用的系统是Red Hat linux release 7.0 (Guinness) Kernel 2.2.16-22 on<br>an i686。从一个新安装的系统开始，我们一起去编译一个自己想要的支持NTFS文件系<br>统模块。<br>一、找到编译内核所需要的.config文件。<br>在/usr/src/linux/configs目录下有若干编译内核所用的配置。选择我们想要的配置，<br>将它复制到/usr/src/linux目录下，改名为.config。<br>cp /usr/src/linux/configs/kernel-2.2.16-i686.config /usr/src/linux/.config<br>二、修改.config文件，去掉不用的模块，加上自己想要的模块。<br>打开.config，有许多XXXX=m的项，这些都是要被编译为模块的项，因为我们不希望编<br>译这些模块，所以要把XXXX=m的项统统去掉。然后再加上我们想要的模块，将#<br>CONFIG_N<br>TFS_FS is not set 改为CONFIG_NTFS_FS=m 当然，可以用你熟悉各种工具来做这件事。<br>三、编译NTFS模块。<br>在/usr/src/linux目录下运行命令make modules来编译我们想要的NTFS模块。<br>四、安装NTFS模块。<br>编译后得到的ntfs.o在/usr/src/linux/fs/ntfs目录下，手动将它复制到正确的目录下。<br>cp /usr/src/linux/fs/ntfs/ntfs.o /lib/modules/2.2.16-22/fs/<br>注意：千万不能运行命令make modules_install，否则将带来严重的后果，它会删除你<br>系统中的所有模块，只安装刚刚编译的模块（ntfs.o）。<br>五、载入NTFS模块.<br>运行命令depmod;modprobe ntfs 试着访问你的NTFS文件系统吧，祝你成功！<br>有些模块依赖于你的系统内核，所以不适用本文所提供的方法。还有些模块和其他模块<br>有依赖关系。如果你不熟悉这些依赖关系的话，建议你在第二步去掉不用的模块选项后<br>，通过make menuconfig来加上自己想要的模块。<br>我用此方法用了三分钟编译了支持NTFS文件系统的模块，你呢？</p><p>作者简介<br>刘军民，海辰天泽公司的工程师（<a href="http://www.hisen.com),源码开放运动的追随者，业余时间喜" target="_blank" rel="noopener">www.hisen.com),源码开放运动的追随者，业余时间喜</a><br>欢用写程序打发时光。您可以通过电子邮件 <a href="mailto:fancao0515@0451.com" target="_blank" rel="noopener">fancao0515@0451.com</a>与他联系。<br>转载完</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>crontab</title>
      <link href="/Linux/linux-crontab/"/>
      <url>/Linux/linux-crontab/</url>
      
        <content type="html"><![CDATA[<p>在Linux下用 crontab 来实现定期的执行脚本的功能。</p><h3 id="一-crontab-使用说明"><a href="#一-crontab-使用说明" class="headerlink" title="一. crontab 使用说明"></a>一. crontab 使用说明</h3><p><strong>1. <span class="redBold">crond</span> 是 Linux 下定期执行程序的命令。</strong></p><p>（通常，当安装完成操作系统之后，默认便会启动此任务调度命令。）<br>crond命令每分钟会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</p><p>而linux任务调度的工作主要分为以下两类：</p><ul><li>a. 系统执行的工作，比如垃圾清理，备份</li><li>b. 用户自定义的工作，比如每5分钟执行一次脚本</li></ul><p><strong>2. <span class="redBold">crontab</span> 是 UNIX 系统下定期执行任务的触发器。(Ubuntu 是叫 crontab 而不是 crond)</strong></p><p>用户把要定期执行的任务记录在这个文件下面，然后crond定期的去检查这个定期执行列表，有要执行的工作时便自动执行。<br>通过man crontab可以查看到下面的信息<br>a. /etc/crond.allow 表示的是允许使用crontab的用户列表<br>b. /etc/crond.deny 表示的是不允许使用crontab的用户列表</p><p><strong>3. crontab 常用的几个命令格式</strong></p><p>crontab -l //显示用户的crontab文件的内容<br>crontab -e //编辑用户的crontab文件的内容<br>crontab -r //删除用户的crontab文件</p><p><strong>4，crontab 文件的基本格式如下所示</strong></p><pre><code>* * * * * command分 时 天 月 周 命令每列表示意义a. 第一个*表示的是分钟1～59分钟，默认*表示的是每分钟都执行，x-y表示的是x～y这段每分钟都执行，*/n表示每n分钟执行一次，x，y，z表示的是x，y，z分钟都执行。b. 第二个*表示的是小时1~23小时，默认*表示的是每小时都执行，x-y表示的是x～y这段每小时都执行，*/n表示每n小时执行一次，x，y，z表示的是x，y，z小时都执行。c. 第三个*表示的是天1~31，默认*表示的是每天都执行，x-y表示的是x～y这段每天都执行，*/n表示每n天执行一次，x，y，z表示的是x，y，z天都执行。d. 第四个*表示的是月1～12，默认*表示的是每个月都执行，x-y表示的是x～y这个段每月都执行，*/n表示每n分钟执行一次，x，y，z表示的是x，y，z天都执行。e. 第五个*表示的是周0～6(0表示周天)，默认周一～周天都执行，x-y表示周x～周y每天都执行。</code></pre><p><strong>5，crontab文件的一些例子</strong></p><pre><code>a. 30 21 * * * /usr/local/etc/rc.d/lighttpd restart //表示每天21：30重启apacheb. 45 4 1，10，22 * * /usr/local/etc/rc.d/lighttpd restart //表示每月1，10，22号4：45重启apachec. 0，30 18-23 * * * /usr/local/etc/rc.d/lighttpd restart //表示每天18 : 00至23 : 00之间每隔30分钟重启apached. * */1 * * * /usr/local/etc/rc.d/lighttpd restart //表示每一小时重启apachee. */5 * * * * /usr/local/etc/rc.d/lighttpd restart //表示每5分钟重启apache</code></pre><h3 id="二-crontab-使用实例"><a href="#二-crontab-使用实例" class="headerlink" title="二. crontab 使用实例"></a>二. crontab 使用实例</h3><p>首先，在 <code>/home/juniway/tmp/</code> 创建一个shell脚本名为 <code>s.sh</code>。注意，脚本内部的路径使用绝对路径。<br>此脚本用于把当前的日期输出重定向到当前目录下的out文件。</p><p>然后，设置每2分钟执行一次这个脚本，&gt;/dev/null 2&gt;&amp;1。<br>原因：系统会在每次执行完任务之后就发一个邮件告诉用户，通过这个操作可以把信息全部重定向到/dev/null中，/dev/null这个文件类似回收站过一段时间系统自动清理。</p><pre><code>*/2 * * * * sh /home/juniway/tmp/s.sh &gt;/dev/null 2&gt;&amp;1</code></pre><p>然后，发现过了n个2分钟，out文件根本就没有输出。<br>因为 crontab 可能有时无法执行用户家目录下面的两个文件，分别是.bashrc和.bash_profile。</p><p>这二个文件的作用：</p><ul><li>.bashrc作用是用于bash shell的bash信息，当登录时及每次打开新的shell时，该文件被读取;</li><li>.bash_profile作用是每个用户都可使用该文件输入专用于自己使用的shell信息，当用户登录时，该文件仅仅执行一次!</li></ul><p>默认情况下，设置一些环境变量，执行用户的.bashrc文件。<br>因此，要手动在crontab文件中添加这条命令 <code>source /home/juniway/.bashrc &amp;&amp; source /home/juniway/.bash_profile</code>。</p><p>source的作用是当前bash环境下执行命令，而scripts是启动一个子shell来执行命令。<br>这样如果把设置环境变量(或alias等等)的命令写进scripts中，就只会影响子shell，无法改变当前的BASH，所以通过文件(命令列)设置环境变量时，要用source 命令。<br>因此crontab文件中变成：</p><pre><code>*/2 * * * * source &amp;&amp; /home/juniway/.bashrc &amp;&amp; source /home/juniway/.bash_profile &amp;&amp; sh /home/juniway/tmp/s.sh &gt;/dev/null 2&gt;&amp;1</code></pre><p>发现可以定时的执行脚本。<br>如果还不行，那只能通过查找log来查错。<br>非ubuntu的Linux crond的日志文件保存在/var/log下。</p><h3 id="三-ubuntu下使用crontab定时执行脚本"><a href="#三-ubuntu下使用crontab定时执行脚本" class="headerlink" title="三. ubuntu下使用crontab定时执行脚本"></a>三. ubuntu下使用crontab定时执行脚本</h3><p><strong>注意问题：</strong></p><p>（1）ubuntu下crontab的服务程序是cron，并且默认cron服务的log是没有的，必须手动开启</p><ul><li>a. sudo vim /etc/rsyslog.d/50-default.conf</li><li>b. 找到cron.*那一行把注释去掉</li><li>c. 然后，重启cron服务 sudo service cron restart</li><li>d. 这样就可以在/var/log里面发现有cron的日志文件了，可以通过查看日志文件找到问题所在。</li></ul><p>（2）ubuntu下，用户家目录下是没有.bash_profile文件的，并且会自动去执行.bashrc文件。可以这样操作：</p><pre><code>*/2 * * * * sh /home/juniway/tmp/s.sh &gt;/dev/null 2&gt;&amp;1</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Use rapidjson</title>
      <link href="/Programming/cpp-rapidjson/"/>
      <url>/Programming/cpp-rapidjson/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Parse-json"><a href="#1-Parse-json" class="headerlink" title="1. Parse json"></a>1. Parse json</h3><p>use <code>doc.Parse()</code> to parse a json string, also, rapidjson provides a <code>ParseInsitu()</code> which can be use to parse json in place.<br>After getting parsed value into <code>rapidjson::Document</code>, we can extract the field out.</p><p>use <code>doc.HasMember(&quot;key_name&quot;)</code> to test member existence, use <code>doc[&quot;key_name&quot;].IsString()</code> to get test value type, and use <code>d[&quot;key_name&quot;].GetString()</code> to extract the value.</p><p>Besides, we can iterate over the object members as <code>&lt;key, value&gt;</code>, the value is actually an index, we can use const array to store the type names, then use the returned index to get it.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* typenames[] = &#123; <span class="string">"Null"</span>, <span class="string">"False"</span>, <span class="string">"True"</span>, <span class="string">"Object"</span>, <span class="string">"Array"</span>, <span class="string">"String"</span>, <span class="string">"Number"</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (Value::ConstMemberIterator it = doc.MemberBegin(); it != doc.MemberEnd(); ++it)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Type of member %s is %s\n"</span>, it-&gt;name.GetString(), typenames[it-&gt;value.GetType()]);</span><br></pre></td></tr></table></figure><p>example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readjson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">ifstream <span class="title">file</span><span class="params">(injson)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">        ss &lt;&lt; file.rdbuf();</span><br><span class="line">        file.close();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"!! Unable to open json file"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Document doc;</span><br><span class="line">    <span class="keyword">if</span> (doc.Parse&lt;<span class="number">0</span>&gt;(ss.str().c_str()).HasParseError())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::invalid_argument(<span class="string">"json parse error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start parsing json string</span></span><br><span class="line">    assert(d.HasMember(<span class="string">"id"</span>));</span><br><span class="line">    assert(d[<span class="string">"date"</span>].IsInt());</span><br><span class="line">    <span class="keyword">int</span> id = doc[<span class="string">"id"</span>].GetInt();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> version = doc[<span class="string">"version"</span>].GetString();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> date = doc[<span class="string">"data"</span>].GetString();</span><br><span class="line">    <span class="keyword">const</span> Value&amp; <span class="built_in">array</span> = doc[<span class="string">"file"</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; files;</span><br><span class="line">    <span class="keyword">for</span> (rapidjson::SizeType i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.Size(); i++) &#123;</span><br><span class="line">        files.emplace_back(<span class="built_in">array</span>[i].GetString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id: "</span> &lt;&lt; id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"version: "</span> &lt;&lt; version &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"date: "</span> &lt;&lt; date &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"files"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;f : files) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Serialize-to-json"><a href="#2-Serialize-to-json" class="headerlink" title="2. Serialize to json"></a>2. Serialize to json</h3><p>RapidJson provides <code>Writer&lt;StringBuffer&gt;</code> and <code>PrettyWriter&lt;StringBuffer&gt;</code> both of which can be used to write key values into json string.</p><p>the type of <code>doc[&quot;key_name&quot;]</code> is <code>rapidjson::Value</code>, we can use <code>doc[&quot;key_name&quot;].SetString()</code> to set value, or we can even specify an allocator and string length, like this:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value author;</span><br><span class="line">author.SetString(buffer2, <span class="keyword">static_cast</span>&lt;SizeType&gt;(len), doc.GetAllocator());</span><br></pre></td></tr></table></figure><p>How to add values to an array?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Value&amp; a = document[<span class="string">"a"</span>];   <span class="comment">// This time we uses non-const reference.</span></span><br><span class="line">Document::AllocatorType&amp; allocator = document.GetAllocator();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    a.PushBack(i, allocator);   <span class="comment">// May look a bit strange, allocator is needed for potentially realloc. We normally uses the document's.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fluent API</span></span><br><span class="line">a.PushBack(<span class="string">"Lua"</span>, allocator).PushBack(<span class="string">"Mio"</span>, allocator);</span><br></pre></td></tr></table></figure><p>Add members to json</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Variable 'buffer' is unusable now but 'author' has already made a copy.</span></span><br><span class="line">document.AddMember(<span class="string">"author"</span>, author, document.GetAllocator());</span><br></pre></td></tr></table></figure><p>after the writer is constructed</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.Accept(writer);    <span class="comment">// Accept() traverses the DOM and generates Handler events.</span></span><br></pre></td></tr></table></figure><br>##### (1) Array<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vals&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i: vals) &#123;</span><br><span class="line">    writer.Int(i);</span><br><span class="line">&#125;</span><br><span class="line">writer.EndArray();</span><br></pre></td></tr></table></figure><p><strong>Result:</strong></p><pre><code>[    0,    1,    2]</code></pre><br>##### (2) Key : ArrayWe can use `writer` to write key and value recursively.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vals&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">StringBuffer sbuf;</span><br><span class="line">PrettyWriter&lt;StringBuffer&gt; writer(sbuf);</span><br><span class="line">writer.StartObject();</span><br><span class="line">  writer.String(<span class="string">"key"</span>);      <span class="comment">// key</span></span><br><span class="line">  writer.StartArray();       <span class="comment">// value</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i: vals) &#123;</span><br><span class="line">      writer.Int(i);</span><br><span class="line">  &#125;</span><br><span class="line">  writer.EndArray();</span><br><span class="line">writer.EndObject();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sbuf.GetString() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>Result:</strong></p><blockquote><p>{    “key”: [<br>        0,<br>        1,<br>        2<br>    ]<br>}</p></blockquote><p>We can also construct the <code>rapidjson::Value</code> first and then write it to writer.<br>Firstly, we create a empty object for the whole json document using <code>d.SetObject()</code>, then we create a rapidjson::Value which stores an array using <code>Value key_array(rapidjson::kArrayType)</code>, after we setting all elements of the array, we add this array object to the document object using <code>d.AddMembeer(&quot;key&quot;, key_array, allocator)</code>, finally we create a writer to accept the document.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vals&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">rapidjson::Document d;</span><br><span class="line">d.SetObject();</span><br><span class="line"></span><br><span class="line"><span class="function">Value <span class="title">key</span><span class="params">(kArrayType)</span></span>;</span><br><span class="line">Document::AllocatorType&amp; allocator = d.GetAllocator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// key.PushBack(0, allocator).PushBack(512, allocator);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i: keys) &#123;</span><br><span class="line">    key.PushBack(i, allocator);</span><br><span class="line">&#125;</span><br><span class="line">d.AddMember(<span class="string">"key"</span>, key, allocator);</span><br><span class="line">StringBuffer sb;</span><br><span class="line">PrettyWriter&lt;StringBuffer&gt; writer(sb);</span><br><span class="line">d.Accept(writer);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sb.GetString() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>Result:</strong></p><blockquote><p>{    “key”: [<br>        0,<br>        1,<br>        2<br>    ]<br>}</p></blockquote><br>##### More examples<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writejson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss_date;</span><br><span class="line">    <span class="keyword">time_t</span> t = time(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> * <span class="title">now</span> = <span class="title">localtime</span>(&amp;<span class="title">t</span>);</span></span><br><span class="line">    ss_date &lt;&lt; (now-&gt;tm_year + <span class="number">1900</span>) &lt;&lt; <span class="string">'-'</span> &lt;&lt; (now-&gt;tm_mon + <span class="number">1</span>) &lt;&lt; <span class="string">'-'</span> &lt;&lt; now-&gt;tm_mday;</span><br><span class="line">    StringBuffer s;</span><br><span class="line">    PrettyWriter&lt;StringBuffer&gt; writer(s);</span><br><span class="line"></span><br><span class="line">    writer.StartObject();</span><br><span class="line">    writer.Key(<span class="string">"version"</span>);</span><br><span class="line">    writer.String(<span class="string">"1.0"</span>);</span><br><span class="line">    writer.Key(<span class="string">"id"</span>);</span><br><span class="line">    writer.Int(<span class="number">123</span>);</span><br><span class="line">    writer.Key(<span class="string">"date"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> RAPIDJSON_HAS_STDSTRING</span></span><br><span class="line">    writer.String(ss_date.str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    writer.String(ss_date.str().c_str(), <span class="keyword">static_cast</span>&lt;SizeType&gt;(ss_date.str().length())); <span class="comment">// Supplying length of string is faster.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    writer.Key(<span class="string">"file"</span>);</span><br><span class="line">    writer.StartArray();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; paths&#123;<span class="string">"0.mp3"</span>, <span class="string">"1.mp3"</span>, <span class="string">"2.mp3"</span>, <span class="string">"3.mp3"</span>&#125;;</span><br><span class="line">    <span class="comment">// m_vWriteFilePath is a vector&lt;std::string&gt; which contains 0.mp3 1.mp3 ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; path : paths) &#123;</span><br><span class="line">        writer.String(path.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    writer.EndArray();</span><br><span class="line">    writer.EndObject();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">ofstream <span class="title">of</span><span class="params">(<span class="string">"out.json"</span>)</span></span>;</span><br><span class="line">    of &lt;&lt; s.GetString();</span><br><span class="line">    <span class="keyword">if</span> (!of.good())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"Can't write the JSON string to the file!"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>###### Referencehttps://github.com/miloyip/rapidjson/blob/master/example/serialize/serialize.cpp]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置 Shadowsocks 服务开机启动</title>
      <link href="/Network-Technology/vps-shadowsocks-auto/"/>
      <url>/Network-Technology/vps-shadowsocks-auto/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇文章介绍如何设置 Shadowsocks server 开机启动</p><p>如果自己在服务器上手动搭建了 shadowsocks server，如果没有开机脚本的话，每次重启都需要手动启动 ss-server，非常不方便。因此，编写一个开机自启动脚本就显得非常必要。</p><p>（1） 创建脚本 /etc/init.d/shadowsocks</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/init.d/shadowsocks</span><br></pre></td></tr></table></figure><p>进入文件后添加以下内容,方法与前面创建 <code>ss-conf.json</code> 这个文件一样，使用 insert 键、shif+：、wq回车保存等等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> shadowsocks start/restart/stop shadowsocks</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides: shadowsocks</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Required-Start: <span class="variable">$all</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Start: 2 3 4 5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Stop:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chkconfig: 2345 85 15</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> description: start shadowsocks/ssserver at boot time</span></span><br><span class="line">​</span><br><span class="line">start()&#123;</span><br><span class="line">        ssserver -c /etc/shadowsocks.json -d start</span><br><span class="line">&#125;</span><br><span class="line">stop()&#123;</span><br><span class="line">        ssserver -c /etc/shadowsocks.json -d stop</span><br><span class="line">&#125;</span><br><span class="line">restart()&#123;</span><br><span class="line">        ssserver -c /etc/shadowsocks.json -d restart</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">case "$1" in</span><br><span class="line">start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">restart)</span><br><span class="line">        restart</span><br><span class="line">        ;;</span><br><span class="line">*)</span><br><span class="line">        echo "Usage: $0 &#123;start|restart|stop&#125;"</span><br><span class="line">        exit 1</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>注：<br>前面的几行，看起来像注释，特别是 chkconfig 那一行，不可删除，否则无法设置开机启动，会提示错误：service shadowsocks does not support chkconfig<br>chkconfig: 2345 85 15 中，2345 代表在设置在那个 level 中是 on 的。如果一个都不想 on，那就写一个横线”-“，比如：chkconfig: - 85 15。后面两个数字代表 S 和 K 的默认排序号。</p><p>脚本编写好之后，我们需要给它添加可执行权限，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod +x /etc/init.d/shadowsocks</span><br></pre></td></tr></table></figure><p>这样就可以在 shell 中直接运行下面的命令开启程序了（重启和停止同理）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service shadowsocks start</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.d/shadowsocks start</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>上述命令是以 root 权限运行的，如果不想以 root 权限运行可以用 sudo -u {user} {command}。<br>如果不给脚本文件加上其他用户的可执行权限，不带参数运行 service shadowsocks 会提示 unrecognized service。</p><p><strong>设置开机启动</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chkconfig shadowsocks on</span><br></pre></td></tr></table></figure><p>这样程序就会自动启动了。</p><p>另外，我们也可以试试直接把启动命令写到 <code>/etc/rc.local</code> 文件，也可以开机启动的。</p><p>或者<br>创建软链到系统启动级别下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ln -sf /etc/init.d/ssserverd /etc/rc3.d/S20ssserverd</span><br><span class="line">$ ln -sf /etc/init.d/ssserverd /etc/rc3.d/K20ssserverd</span><br></pre></td></tr></table></figure><p>以下使用 Systemd 来实现 shadowsocks 开机自启。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/shadowsocks.service</span><br></pre></td></tr></table></figure><p>在里面填写如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks Client Service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">ExecStart=/usr/bin/sslocal -c /home/xx/Software/ShadowsocksConfig/shadowsocks.json</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>注：把上述的 <code>/home/xx/Software/ShadowsocksConfig/shadowsocks.json</code> 修改为你自己的 shadowsocks.json 路径，如：<code>/etc/shadowsocks.json</code>。</p><p>执行下列命令来使配置生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> /etc/systemd/system/shadowsocks.service</span><br></pre></td></tr></table></figure><br>全文完！<br><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Network Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Proxying </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 中使用 Shadowsocks</title>
      <link href="/Network-Technology/vps-linux-shadowsocks/"/>
      <url>/Network-Technology/vps-linux-shadowsocks/</url>
      
        <content type="html"><![CDATA[<h2 id="Shadowsocks-简介"><a href="#Shadowsocks-简介" class="headerlink" title="Shadowsocks 简介"></a>Shadowsocks 简介</h2><p>经常有翻墙需求的人应该对 Shadowsocks 这个工具不陌生，简单来说，它是一款通过 sock5 协议进行代理的工具，Windows 下使用比较简单，只需要下载好 ss 客户端，配置好服务器地址及 pac 列表，然后在浏览器中使用代理插件（比如 Chrome 中使用 SwitchyOmega），配置好代理规则即可正常翻墙了。 这种使用浏览器配置代理规则的方式有一个局限就是，只能在浏览器中翻墙，如果需要在命令行中，或者在程序中调用需要访问外网的服务，那么就变得不太可行。</p><p>本文就是介绍如何在命令行中也可以使用 shadowsocks 进行代理。</p><h3 id="一、安装-Shadowsocks"><a href="#一、安装-Shadowsocks" class="headerlink" title="一、安装 Shadowsocks"></a>一、安装 Shadowsocks</h3><p>命令行中的 shadowsocks 客户端是一个 python 脚本，可以直接通过下列命令来安装</p><pre><code>$ pip install shadowsocks</code></pre><p>或者，在 Ubuntu/Arch Linux 也可以使用如下命令安装</p><pre><code>$ apt-get install shadowsocks -y$ pacman -Sy shadowsocks</code></pre><p>安装完成之后，会得到一个 /usr/bin/sslocal 的可执行文件，实际上是一个 python 脚本（python 2）。</p><p>安装完成后编辑配置文件，填写对应服务器地址</p><pre><code>vim ~/.etc/shadowsocks.json</code></pre><p>下面是一个服务器配置样例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "server":"1.1.1.1",</span><br><span class="line">    "server_port":8383,</span><br><span class="line">    "local_address": "127.0.0.1",</span><br><span class="line">    "local_port":1080,</span><br><span class="line">    "password":"passwd",</span><br><span class="line">    "timeout":300,</span><br><span class="line">    "method":"aes-256-cfb",</span><br><span class="line">    "fast_open": true,</span><br><span class="line">    "workers": 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后启动代理</p><pre><code>$ nohup sslocal -c /etc/shadowsocks.json &amp;</code></pre><h3 id="二、将-Socks5-代理转化为-http-代理"><a href="#二、将-Socks5-代理转化为-http-代理" class="headerlink" title="二、将 Socks5 代理转化为 http 代理"></a>二、将 Socks5 代理转化为 http 代理</h3><p>由于 shadowsocks 使用的是 socks5 协议代理，因此我们还需要把其转换成 http 代理以便访问外网的 http 服务。在 Linux 下我们需要借助第三方软件完成，这里我们使用 privoxy 这个工具。</p><p>Ubuntu 下使用如下命令安装 privoxy</p><pre><code>apt-get install privoxy -y</code></pre><p>编辑配置文件</p><h4 id="先备份原配置文件"><a href="#先备份原配置文件" class="headerlink" title="先备份原配置文件"></a>先备份原配置文件</h4><pre><code>$ mv /etc/privoxy/config /etc/privoxy/config.bak</code></pre><h5 id="在新建一个配置文件"><a href="#在新建一个配置文件" class="headerlink" title="在新建一个配置文件"></a>在新建一个配置文件</h5><pre><code>$ vim /etc/privoxy/config</code></pre><p>privoxy 配置样例如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 转发地址</span><br><span class="line">forward-socks5   /          127.0.0.1:1080 .</span><br><span class="line"><span class="meta">#</span> 监听地址</span><br><span class="line">listen-address  localhost:8118</span><br><span class="line"><span class="meta">#</span> local network do not use proxy</span><br><span class="line">forward         192.168.*.*/     .</span><br><span class="line">forward            10.*.*.*/     .</span><br><span class="line">forward           127.*.*.*/     .</span><br></pre></td></tr></table></figure><p>最后启动 privoxy 并查看状态：</p><pre><code>$ systemctl start privoxy$ systemctl status privoxy</code></pre><h3 id="三、创建快捷代理命令"><a href="#三、创建快捷代理命令" class="headerlink" title="三、创建快捷代理命令"></a>三、创建快捷代理命令</h3><p>完成上两步配置后，即可将需要代理的请求指向 127.0.0.1:8118 端口即可。<br>建议，不要设置全局的访问都使用这个代理，可以写一个代理脚本，只为需要代理的请求触发代理。<br>如下:</p><pre><code>$ vim /usr/local/bin/proxy</code></pre><p>脚本内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">http_proxy=http://127.0.0.1:8118 https_proxy=http://127.0.0.1:8118 $*</span><br></pre></td></tr></table></figure><p>赋予可执行权限</p><pre><code>$ chmod +x /usr/local/bin/proxy</code></pre><p>最后，对任何想要走代理的命令，只需要在前面加上 proxy 即可，样例如下</p><pre><code>$ proxy gvm install go1.8.3$ proxy go get -t -u -v ./...</code></pre><h3 id="简化流程"><a href="#简化流程" class="headerlink" title="简化流程"></a>简化流程</h3><p>熟悉了上述过程之后，可以把流程简化如下：</p><h5 id="1、先启动-sslocal"><a href="#1、先启动-sslocal" class="headerlink" title="1、先启动 sslocal"></a>1、先启动 sslocal</h5><pre><code>$ nohup ssolcao -c /etc/shadowsocks.json 2&amp;&gt;1 &amp;</code></pre><h5 id="2、启动-http-proxy-转换器-privoxy"><a href="#2、启动-http-proxy-转换器-privoxy" class="headerlink" title="2、启动 http proxy 转换器 privoxy"></a>2、启动 http proxy 转换器 privoxy</h5><pre><code>$ systemctl start privoxy</code></pre><h5 id="3、设置环境变量http-proxy-和-https-proxy"><a href="#3、设置环境变量http-proxy-和-https-proxy" class="headerlink" title="3、设置环境变量http_proxy 和 https_proxy"></a>3、设置环境变量http_proxy 和 https_proxy</h5><pre><code>$ source ~/.etc/proxy1  // 设置$ source ~/.etc/proxy2  // 还原</code></pre><br><p style="text-align:center;">如果你对我的文章感兴趣，欢迎留言或者关注我的专栏。</p><p style="text-align:center;">微信公众号：“知辉”</p><p style="text-align:center;">搜索“deliverit”或</p><p style="text-align:center;">扫描二维码</p><!-- <p style="text-align:center;">a</p> ![](/image/qrcode_258.jpg) --><div align="center"><img width="258" height="258" src="/image/qrcode_258.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> Network Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Proxying </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Certbot usages</title>
      <link href="/Network-Technology/vps-certbot/"/>
      <url>/Network-Technology/vps-certbot/</url>
      
        <content type="html"><![CDATA[<h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><p>(1) CentOS</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.eff.org/certbot-auto</span><br><span class="line">sudo mv certbot-auto /usr/local/bin/certbot-auto</span><br><span class="line">sudo chown root /usr/local/bin/certbot-auto</span><br><span class="line">sudo chmod 0755 /usr/local/bin/certbot-auto</span><br><span class="line">/usr/local/bin/certbot-auto --help</span><br></pre></td></tr></table></figure><p>(2) Ubuntu</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo add-apt-repository ppa:certbot/certbot</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install certbot</span><br><span class="line">certbot --version</span><br></pre></td></tr></table></figure><p>There are mainly three ways to generate a certificate for you web site using certbot.<br>Below are examples to show how to generate the certificates non-interactively.</p><h4 id="1-standalone"><a href="#1-standalone" class="headerlink" title="1. standalone"></a>1. standalone</h4><p>Generating a standalone certificate.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot certonly --standalone -n --agree-tos --email you@gmail.com --preferred-challenges http -d you.domain.com</span><br></pre></td></tr></table></figure><h4 id="2-nginx-apache…"><a href="#2-nginx-apache…" class="headerlink" title="2. nginx/apache…"></a>2. nginx/apache…</h4><p>Generating the certificate for the specific web server.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot certonly --nginx -n --agree-tos --email you@gmail.com --preferred-challenges http -d you.domain.com</span><br></pre></td></tr></table></figure><h4 id="3-webroot"><a href="#3-webroot" class="headerlink" title="3. webroot"></a>3. webroot</h4><p>Generating the certificate by specifying the root directory of the website with <code>--webroot</code> option.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```shell</span><br><span class="line">certbot certonly --webroot --agree-tos --no-eff-email --email xxxgmail.com --preferred-challenges http -w /var/www/html -d you.domain.net</span><br></pre></td></tr></table></figure><h4 id="4-manual"><a href="#4-manual" class="headerlink" title="4. manual"></a>4. manual</h4><p>This is a manual way, which means interactively, to generate the certificate.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot certonly --manual -d you.domain.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Network Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Proxying </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake Advanced</title>
      <link href="/Tools-and-Build/tool-and-build-cmake-advanced/"/>
      <url>/Tools-and-Build/tool-and-build-cmake-advanced/</url>
      
        <content type="html"><![CDATA[<p>本文介绍 CMake 的一些高级配置方式</p><p>执行 <code>cmake --help-variable VARIABLE_NAME</code> 可以查看某个 CMake 变量的含义。</p><h4 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h4><hr><p>主要有隐式定义和显式定义两种。<br>隐式定义的一个例子是 <code>PROJECT 指令</code>，它会隐式的定义 <code>&lt;projectname&gt;_BINARY_DIR</code> 和 <code>&lt;projectname&gt;_SOURCE_DIR</code> 两个变量；显式定义使用SET指令构建自定义变量，比如: <code>SET(HELLO_SRCmain.c)</code>就可以通过 <code>${HELLO_SRC}</code> 来引用这个自定义变量了。</p><h4 id="变量引用方式"><a href="#变量引用方式" class="headerlink" title="变量引用方式"></a>变量引用方式</h4><hr><p>使用 <code>${}</code> 进行变量的引用；在 <code>IF</code> 等语句中，是直接使用变量名而不通过 <code>${}</code> 取值。</p><h4 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h4><pre><code>CMAKE_BINARY_DIR PROJECT_BINARY_DIR &lt; projectname &gt;_BINARY_DIR </code></pre><p>这三个变量指代的内容是一致的，如果是in-source编译，指得就是工程顶层目录；如果是out-of-source编译，指的是工程编译发生的目录。<code>PROJECT_BINARY_DIR</code> 跟其它指令稍有区别，目前可以认为它们是一致的。</p><pre><code>CMAKE_SOURCE_DIR PROJECT_SOURCE_DIR &lt; projectname &gt;_SOURCE_DIR </code></pre><p>这三个变量指代的内容是一致的，不论采用何种编译方式，都是工程顶层目录。也就是在 in-source 编译时，他跟 <code>CMAKE_BINARY_DIR</code> 等变量一致。`PROJECT_SOURCE_DIR 跟其它指令稍有区别,目前可以认为它们是一致的。<br>（out-of-source build与in-source build相对，指是否在CMakeLists.txt所在目录进行编译。）</p><p>CMAKE_CURRENT_SOURCE_DIR<br>当前处理的CMakeLists.txt所在的路径，比如上面我们提到的src子目录。</p><p>CMAKE_CURRRENT_BINARY_DIR<br>如果是in-source编译，它跟CMAKE_CURRENT_SOURCE_DIR一致；如果是out-of-source编译，指的是target编译目录。使用ADD_SUBDIRECTORY(src bin)可以更改这个变量的值。使用SET(EXECUTABLE_OUTPUT_PATH &lt;新路径&gt;)并不会对这个变量造成影响,它仅仅修改了最终目标文件存放的路径。</p><p>CMAKE_CURRENT_LIST_FILE<br>输出调用这个变量的CMakeLists.txt的完整路径</p><p>CMAKE_CURRENT_LIST_LINE<br>输出这个变量所在的行</p><p>CMAKE_MODULE_PATH<br>这个变量用来定义自己的cmake模块所在的路径。如果工程比较复杂，有可能会自己编写一些cmake模块，这些cmake模块是随工程发布的，为了让cmake在处理CMakeLists.txt时找到这些模块，你需要通过SET指令将cmake模块路径设置一下。比如SET(CMAKE_MODULE_PATH,${PROJECT_SOURCE_DIR}/cmake)<br>这时候就可以通过INCLUDE指令来调用自己的模块了。</p><p>EXECUTABLE_OUTPUT_PATH<br>新定义最终结果的存放目录</p><p>LIBRARY_OUTPUT_PATH<br>新定义最终结果的存放目录</p><p>PROJECT_NAME<br>返回通过PROJECT指令定义的项目名称。</p><h4 id="cmake调用环境变量的方式"><a href="#cmake调用环境变量的方式" class="headerlink" title="cmake调用环境变量的方式"></a>cmake调用环境变量的方式</h4><hr><p>使用 $ENV{NAME} 指令就可以调用系统的环境变量了。比如 MESSAGE(STATUS “HOME dir: $ENV{HOME}”)设置环境变量的方式是SET(ENV{变量名} 值)。</p><p>CMAKE_INCLUDE_CURRENT_DIR<br>自动添加CMAKE_CURRENT_BINARY_DIR和CMAKE_CURRENT_SOURCE_DIR到当前处理的CMakeLists.txt，相当于在每个CMakeLists.txt加入：INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_SOURCE_DIR})</p><p>CMAKE_INCLUDE_DIRECTORIES_PROJECT_BEFORE<br>将工程提供的头文件目录始终置于系统头文件目录的前面,当定义的头文件确实跟系统发生冲突时可以提供一些帮助。</p><p>CMAKE_INCLUDE_PATH和CMAKE_LIBRARY_PATH</p><p><strong>查看系统信息</strong></p><p>CMAKE_MAJOR_VERSION，CMAKE主版本号，比如2.4.6中的2<br>CMAKE_MINOR_VERSION，CMAKE次版本号，比如2.4.6中的4<br>CMAKE_PATCH_VERSION，CMAKE补丁等级，比如2.4.6中的6<br>CMAKE_SYSTEM，系统名称，比如Linux-2.6.22<br>CMAKE_SYSTEM_NAME，不包含版本的系统名，比如Linux<br>CMAKE_SYSTEM_VERSION，系统版本，比如2.6.22<br>CMAKE_SYSTEM_PROCESSOR，处理器名称，比如i686<br>UNIX，在所有的类Unix平台为TRUE，包括OSX和cygwin<br>WIN32，在所有的Win32平台为TRUE，包括cygwin</p><p><strong>主要的开关选项</strong></p><p>CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS<br>用来控制IF ELSE语句的书写方式。</p><p>BUILD_SHARED_LIBS<br>这个开关用来控制默认的库编译方式。如果不进行设置，使用ADD_LIBRARY并没有指定库类型的情况下，默认编译生成的库都是静态库；如果SET(BUILD_SHARED_LIBSON)后,默认生成的为动态库。</p><p>CMAKE_C_FLAGS<br>设置C编译选项，也可以通过指令ADD_DEFINITIONS()添加。</p><p>MAKE_CXX_FLAGS<br>设置C++编译选项，也可以通过指令ADD_DEFINITIONS()添加。</p><h4 id="CMake常用指令"><a href="#CMake常用指令" class="headerlink" title="CMake常用指令"></a>CMake常用指令</h4><hr><p>这里引入更多的cmake指令,为了编写的方便,将按照cmakeman page 的顺序介绍各种指令，不再推荐使用的指令将不再介绍。</p><p><strong>基本指令</strong></p><p>PROJECT(HELLO)<br>指定项目名称，生成的VC项目的名称，使用${HELLO_SOURCE_DIR}表示项目根目录。</p><p>INCLUDE_DIRECTORIES<br>指定头文件的搜索路径，相当于指定gcc的-I参数<br>INCLUDE_DIRECTORIES(${HELLO_SOURCE_DIR}/Hello) #增加Hello为include目录</p><p>TARGET_LINK_LIBRARIES<br>添加链接库，相同于指定-l参数<br>TARGET_LINK_LIBRARIES(demoHello) #将可执行文件与Hello连接成最终文件demo</p><p>LINK_DIRECTORIES<br>动态链接库或静态链接库的搜索路径，相当于gcc的-L参数<br>LINK_DIRECTORIES(${HELLO_BINARY_DIR}/Hello)#增加Hello为link目录</p><p>ADD_DEFINITIONS<br>向C/C++编译器添加-D定义，比如：<br>ADD_DEFINITIONS(-DENABLE_DEBUG-DABC)<br>参数之间用空格分割。如果代码中定义了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_DEBUG</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这个代码块就会生效。如果要添加其他的编译器开关,可以通过CMAKE_C_FLAGS变量和CMAKE_CXX_FLAGS变量设置。</p><p>ADD_DEPENDENCIES<br>定义target依赖的其它target，确保在编译本target之前，其它的target已经被构建。ADD_DEPENDENCIES(target-name depend-target1 depend-target2 …)</p><p>ADD_EXECUTABLE<br>ADD_EXECUTABLE(helloDemo demo.cxx demo_b.cxx)<br>指定编译，好像也可以添加.o文件，将cxx编译成可执行文件</p><p>ADD_LIBRARY<br>ADD_LIBRARY(Hellohello.cxx) #将hello.cxx编译成静态库如libHello.a</p><p>ADD_SUBDIRECTORY<br>ADD_SUBDIRECTORY(Hello) #包含子目录</p><p>ADD_TEST<br>ENABLE_TESTING<br>ENABLE_TESTING指令用来控制Makefile是否构建test目标，涉及工程所有目录。语法很简单，没有任何参数，ENABLE_TESTING()一般放在工程的主CMakeLists.txt中。<br>ADD_TEST指令的语法是:ADD_TEST(testnameExename arg1 arg2 …)<br>testname是自定义的test名称，Exename可以是构建的目标文件也可以是外部脚本等等，后面连接传递给可执行文件的参数。</p><p>如果没有在同一个CMakeLists.txt中打开ENABLE_TESTING()指令，任何ADD_TEST都是无效的。比如前面的Helloworld例子,可以在工程主CMakeLists.txt中添加</p><p>ADD_TEST(mytest ${PROJECT_BINARY_DIR}/bin/main)<br>ENABLE_TESTING</p><p>生成Makefile后，就可以运行make test来执行测试了。</p><p>AUX_SOURCE_DIRECTORY<br>基本语法是:AUX_SOURCE_DIRECTORY(dir VARIABLE)，作用是发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表，因为目前cmake还不能自动发现新添加的源文件。比如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span>(. SRC_LIST)</span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(main <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><p>我们可以通过后面提到的FOR EACH指令来处理这个LIST。</p><p>CMAKE_MINIMUM_REQUIRED<br>语法为CMAKE_MINIMUM_REQUIRED(VERSION versionNumber [FATAL_ERROR])，<br>比如:CMAKE_MINIMUM_REQUIRED(VERSION 2.5 FATAL_ERROR)<br>如果cmake版本小与2.5，则出现严重错误，整个过程中止。</p><p>EXEC_PROGRAM<br>在CMakeLists.txt处理过程中执行命令，并不会在生成的Makefile中执行。具体语法为:</p><pre><code>EXEC_PROGRAM(Executable [directory in which to run] [ARGS &lt;arguments to executable&gt;] [OUTPUT_VARIABLE &lt;var&gt;] [RETURN_VALUE &lt;var&gt;])</code></pre><p>用于在指定的目录运行某个程序，通过ARGS添加参数，如果要获取输出和返回值，可通过OUTPUT_VARIABLE和RETURN_VALUE分别定义两个变量。<br>这个指令可以帮助在CMakeLists.txt处理过程中支持任何命令，比如根据系统情况去修改代码文件等等。举个简单的例子，我们要在src目录执行ls命令，并把结果和返回值存下来，可以直接在src/CMakeLists.txt中添加：</p><pre><code>EXEC_PROGRAM(ls ARGS &quot;*.c&quot; OUTPUT_VARIABLE LS_OUTPUT RETURN_VALUE LS_RVALUE)IF(not LS_RVALUE)    MESSAGE(STATUS &quot;ls result: &quot; ${LS_OUTPUT})ENDIF(not LS_RVALUE)</code></pre><p>在 cmake 生成Makefile过程中，就会执行ls命令，如果返回0，则说明成功执行，那么就输出ls *.c的结果。关于IF语句，后面的控制指令会提到。</p><p>FILE指令<br>文件操作指令，基本语法为:</p><pre><code>FILE(WRITEfilename &quot;message to write&quot;... )FILE(APPENDfilename &quot;message to write&quot;... )FILE(READfilename variable)FILE(GLOBvariable [RELATIVE path] [globbing expression_r_rs]...)FILE(GLOB_RECURSEvariable [RELATIVE path] [globbing expression_r_rs]...)FILE(REMOVE[directory]...)FILE(REMOVE_RECURSE[directory]...)FILE(MAKE_DIRECTORY[directory]...)FILE(RELATIVE_PATHvariable directory file)FILE(TO_CMAKE_PATHpath result)FILE(TO_NATIVE_PATHpath result)</code></pre><p>INCLUDE指令<br>用来载入CMakeLists.txt文件，也用于载入预定义的cmake模块。</p><pre><code>INCLUDE(file1[OPTIONAL])INCLUDE(module[OPTIONAL])</code></pre><p>OPTIONAL参数的作用是文件不存在也不会产生错误，可以指定载入一个文件，如果定义的是一个模块，那么将在CMAKE_MODULE_PATH中搜索这个模块并载入，载入的内容将在处理到INCLUDE语句是直接执行。</p><p>INSTALL指令</p><p>FIND_指令<br>FIND_系列指令主要包含一下指令:</p><pre><code>FIND_FILE(&lt;VAR&gt;name1 path1 path2 …)    VAR变量代表找到的文件全路径,包含文件名FIND_LIBRARY(&lt;VAR&gt;name1 path1 path2 …)    VAR变量表示找到的库全路径,包含库文件名FIND_PATH(&lt;VAR&gt;name1 path1 path2 …)   VAR变量代表包含这个文件的路径FIND_PROGRAM(&lt;VAR&gt;name1 path1 path2 …)   VAR变量代表包含这个程序的全路径FIND_PACKAGE(&lt;name&gt;[major.minor] [QUIET] [NO_MODULE] [[REQUIRED|COMPONENTS][componets...]])   用来调用预定义在CMAKE_MODULE_PATH下的Find&lt;name&gt;.cmake模块，也可以自己定义Find&lt;name&gt;模块，通过SET(CMAKE_MODULE_PATH dir)将其放入工程的某个目录中供工程使用，后面会详细介绍FIND_PACKAGE的使用方法和Find模块的编写。</code></pre><p>FIND_LIBRARY示例:</p><pre><code>FIND_LIBRARY(libXX11 /usr/lib)IF(NOT libX)    MESSAGE(FATAL_ERROR &quot;libX not found&quot;)ENDIF(NOT libX)</code></pre><p>控制指令</p><p>IF指令，基本语法为:</p><pre><code>IF(expression_r_r)    #THEN section.    COMMAND1(ARGS…)    COMMAND2(ARGS…)    …ELSE(expression_r_r)    #ELSE section.    COMMAND1(ARGS…)    COMMAND2(ARGS…)    …ENDIF(expression_r_r)</code></pre><p>另外一个指令是ELSEIF，总体把握一个原则，凡是出现IF的地方一定要有对应的ENDIF，出现ELSEIF的地方，ENDIF是可选的。表达式的使用方法如下:</p><pre><code>IF(var)  如果变量不是：空, 0, N, NO, OFF, FALSE, NOTFOUND 或 &lt;var&gt;_NOTFOUND时，表达式为真。IF(NOT var)， 与上述条件相反。IF(var1AND var2)， 当两个变量都为真是为真。IF(var1OR var2)， 当两个变量其中一个为真时为真。IF(COMMANDcmd)， 当给定的cmd确实是命令并可以调用是为真。IF(EXISTS dir) or IF(EXISTS file)， 当目录名或者文件名存在时为真。IF(file1IS_NEWER_THAN file2)， 当file1比file2新，或者file1/file2其中有一个不存在时为真文件名请使用完整路径。IF(IS_DIRECTORY dirname),  当dirname是目录时为真。IF(variableMATCHES regex)</code></pre><p>IF(string MATCHES regex) 当给定的变量或者字符串能够匹配正则表达式regex时为真。比如:</p><pre><code>IF(&quot;hello&quot; MATCHES &quot;hello&quot;)    MESSAGE(&quot;true&quot;)ENDIF(&quot;hello&quot; MATCHES &quot;hello&quot;)IF(variable LESS number)IF(string LESS number)IF(variable GREATER number)IF(string GREATER number)IF(variable EQUAL number)IF(string EQUAL number)</code></pre><p>数字比较表达式</p><pre><code>IF(variable STRLESS string)IF(string STRLESS string)IF(variable STRGREATER string)IF(string STRGREATER string)IF(variable STREQUAL string)IF(string STREQUAL string)</code></pre><p>按照字母序的排列进行比较。</p><p>IF(DEFINED variable)，如果变量被定义，为真。<br>一个小例子,用来判断平台差异:</p><pre><code>IF(WIN32)    MESSAGE(STATUS“This is windows.”) #作一些Windows相关的操作ELSE(WIN32)    MESSAGE(STATUS“This is not windows”) #作一些非Windows相关的操作ENDIF(WIN32)</code></pre><p>上述代码用来控制在不同的平台进行不同的控制,但是阅读起来却并不是那么舒服, ELSE(WIN32)之类的语句很容易引起歧义。<br>这就用到了我们在 常用变量 一节提到的CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS开关。可以SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTSON)，这时候就可以写成:</p><pre><code>IF(WIN32)ELSE()ENDIF()</code></pre><p>如果配合ELSEIF使用,可能的写法是这样:</p><pre><code>IF(WIN32)    #dosomething related to WIN32ELSEIF(UNIX)    #dosomething related to UNIXELSEIF(APPLE)    #dosomething related to APPLEENDIF(WIN32)</code></pre><p>WHILE指令</p><p>WHILE指令的语法是:</p><pre><code>WHILE(condition)    COMMAND1(ARGS…)    COMMAND2(ARGS…)    …ENDWHILE(condition)</code></pre><p>其真假判断条件可以参考IF指令。</p><p>FOREACH指令</p><p>FOREACH指令的使用方法有三种形式:<br>(1)列表</p><pre><code>FOREACH(loop_vararg1 arg2 …)    COMMAND1(ARGS…)    COMMAND2(ARGS…)    …ENDFOREACH(loop_var)</code></pre><p>像我们前面使用的AUX_SOURCE_DIRECTORY的例子</p><pre><code>AUX_SOURCE_DIRECTORY(.SRC_LIST)FOREACH(F ${SRC_LIST})    MESSAGE(${F})ENDFOREACH(F)</code></pre><p>(2)范围</p><pre><code>FOREACH(loop_var RANGE total)ENDFOREACH(loop_var)</code></pre><p>从0到total以1为步进，举例如下:</p><pre><code>FOREACH(VARRANGE 10)    MESSAGE(${VAR})ENDFOREACH(VAR)</code></pre><p>最终得到的输出是:</p><blockquote><p>01<br>23<br>45<br>67<br>89<br>10</p></blockquote><p>(3)范围和步进</p><pre><code>FOREACH(loop_var RANGE start stop [step])ENDFOREACH(loop_var)</code></pre><p>从start开始到stop结束，以step为步进。举例如下:</p><pre><code>FOREACH(A RANGE 5 15 3)    MESSAGE(${A})ENDFOREACH(A)</code></pre><p>最终得到的结果是:</p><blockquote><p>58<br>11<br>14</p></blockquote><p>这个指令需要注意的是，直到遇到ENDFOREACH指令，整个语句块才会得到真正的执行。</p><h6 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h6><p><a href="http://blog.csdn.net/z_h_s/article/details/50699905" target="_blank" rel="noopener">http://blog.csdn.net/z_h_s/article/details/50699905</a><br><a href="http://blog.csdn.net/wzzfeitian/article/details/40963457" target="_blank" rel="noopener">http://blog.csdn.net/wzzfeitian/article/details/40963457</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Write custom CMake modules</title>
      <link href="/Tools-and-Build/tool-and-build-cmake-module/"/>
      <url>/Tools-and-Build/tool-and-build-cmake-module/</url>
      
        <content type="html"><![CDATA[<p>注：本文中的大部分内容均参考至 <em>CMake Practice</em> 一书。</p><br><p>CMake 中默认的模块文件通常会位于 <code>/usr/share/cmake-3.7.1/Module</code> 目录下，如果我们需要为工程项目自定义 CMake 的模块文件，通常在工程根目录下新建一个名称为 cmake 的目录来存放，然后在 <code>CMakeLists.txt</code> 中通过 <code>set(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake)</code> 的方式引入该目录。</p><h4 id="模块的使用和自定义模块"><a href="#模块的使用和自定义模块" class="headerlink" title="模块的使用和自定义模块"></a>模块的使用和自定义模块</h4><hr><p>纯粹依靠 CMake 本身提供的基本指令来管理工程是一件非常复杂的事情，所以 CMake 设计成了可扩展的架构，使得我们可以通过编写一些自定义的模块来扩展 CMake。</p><p>这里将着重介绍系统预定义的 <strong>Find 模块</strong>的使用以及如何编写用户自定义的 Find 模块，系统中提供了其他各种模块，一般情况需要使用 <code>INCLUDE</code> 指令显式的调用，<code>FIND_PACKAGE</code> 指令是一个特例，可以直接调用预定义的模块。</p><p>下面，我就通过一个具体的例子来介绍如何编写用户自定义的 Find 模块。</p><br>####（一）使用 CMake 默认提供的 FindCURL 模块<p>我们在 /proj/cmake/test/src 编写 <code>main.c</code>，这段代码通过 curl 命令获取 <a href="http://www.linux-ren.org" target="_blank" rel="noopener">www.linux-ren.org</a> 的首页并写入 /tmp/curl-test 文件中，其内容如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE*fp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_data</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, <span class="keyword">void</span> *stream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> written = fwrite(ptr, size, nmemb, (FILE *)fp);</span><br><span class="line">    <span class="keyword">return</span> written;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *path = “/tmp/curl-test”;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mode = “w”;</span><br><span class="line">    fp = fopen(path,mode);</span><br><span class="line">    curl_global_init(CURL_GLOBAL_ALL);</span><br><span class="line">    CURL coderes;</span><br><span class="line">    CURL *curl = curl_easy_init();</span><br><span class="line"></span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, “http:<span class="comment">//www.linux-ren.org”);</span></span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_VERBOSE, <span class="number">1</span>);</span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码由于使用了 curl 库的函数，在执行 <code>gcc</code> 编译链接时，不仅需要能找到对应的头文件信息，还需要添加动态库选项 <code>-lcurl</code>。因此，编写 CMakeLiksts.txt 时也需要能实现这一点，下面就讲述如何实现：</p><p>建立主工程文件 CmakeLists.txt，内容如下：</p><pre><code>PROJECT(CURLTEST)ADD_SUBDIRECTORY(src)</code></pre><p>新建 src/CmakeLists.txt，内容如下</p><pre><code>ADD_EXECUTABLE(curltest main.c)</code></pre><p>现在自然是没办法编译的，我们需要添加 curl 的头文件路径和库文件。</p><p><strong>方法1:</strong><br>直接通过 <code>INCLUDE_DIRECTORIES</code> 和 <code>TARGET_LINK_LIBRARIES</code> 指令添加:</p><p>我们可以直接在 <code>src/CMakeLists.txt</code> 中添加:</p><pre><code>INCLUDE_DIRECTORIES(/usr/include)TARGET_LINK_LIBRARIES(curltestcurl)</code></pre><p>然后建立 build 目录进行外部构建即可。<br>现在要探讨的是使用 CMake 提供的 <code>FindCURL 模块</code>。</p><p><strong>方法2:</strong><br>使用 FindCURL 模块。向 <code>src/CMakeLists.txt</code> 中添加下列内容:</p><pre><code>FIND_PACKAGE(CURL)IF(CURL_FOUND)    INCLUDE_DIRECTORIES(${CURL_INCLUDE_DIR})    TARGET_LINK_LIBRARIES(curltest${CURL_LIBRARY})ELSE(CURL_FOUND)    MESSAGE(FATAL_ERROR”CURL library not found”)ENDIF(CURL_FOUND)</code></pre><p>对于系统预定义的 <code>Find&lt;name&gt;.cmake</code> 模块，使用方法一般如上例所示，每一个模块都会定义以下几个变量:</p><pre><code>&lt;name&gt;_FOUND&lt;name&gt;_INCLUDE_DIR or &lt;name&gt;_INCLUDES&lt;name&gt;_LIBRARY or &lt;name&gt;_LIBRARIES</code></pre><p>可以通过 <code>&lt;name&gt;_FOUND</code> 来判断模块是否被找到，如果没有找到，按照工程的需要关闭某些特性、给出提醒或者中止编译，上面的例子就是报出致命错误并终止构建。<br>如果 <code>&lt;name&gt;_FOUND</code>为真，则将 <code>&lt;name&gt;_INCLUDE_DIR</code> 加入 <code>INCLUDE_DIRECTORIES</code>，将 <code>&lt;name&gt;_LIBRARY加入TARGET_LINK_LIBRARIES</code> 中。</p><p>我们再来看一个复杂的例子，通过 <name>_FOUND 来控制工程特性:</name></p><pre><code>SET(mySourcesviewer.c)SET(optionalSources)SET(optionalLibs)FIND_PACKAGE(JPEG)IF(JPEG_FOUND)    SET(optionalSources${optionalSources} jpegview.c)    INCLUDE_DIRECTORIES(${JPEG_INCLUDE_DIR} )    SET(optionalLibs${optionalLibs} ${JPEG_LIBRARIES} )    ADD_DEFINITIONS(-DENABLE_JPEG_SUPPORT)ENDIF(JPEG_FOUND)IF(PNG_FOUND)    SET(optionalSources${optionalSources} pngview.c)    INCLUDE_DIRECTORIES(${PNG_INCLUDE_DIR} )    SET(optionalLibs${optionalLibs} ${PNG_LIBRARIES} )    ADD_DEFINITIONS(-DENABLE_PNG_SUPPORT)ENDIF(PNG_FOUND)ADD_EXECUTABLE(viewer${mySources} ${optionalSources}TARGET_LINK_LIBRARIES(viewer${optionalLibs}</code></pre><p>通过判断系统是否提供了 JPEG 库来决定程序是否支持 JPEG 功能。</p><br>#####（二）编写属于自己的 FindHello 模块 <p>接下来在 t6 示例中演示如何自定义 FindHELLO 模块并使用这个模块构建工程。在 /backup/cmake/ 中建立 t6 目录，并在其中建立 cmake 目录用于存放我们自己定义的 FindHELLO.cmake 模块，同时建立 src 目录，用于存放我们的源文件。</p><p><strong>1. 定义 <code>cmake/FindHELLO.cmake</code> 模块</strong></p><pre><code>FIND_PATH(HELLO_INCLUDE_DIR hello.h /usr/include/hello /usr/local/include/hello)FIND_LIBRARY(HELLO_LIBRARY NAMES hello PATH /usr/lib /usr/local/lib)IF(HELLO_INCLUDE_DIR AND HELLO_LIBRARY)    SET(HELLO_FOUNDTRUE)ENDIF(HELLO_INCLUDE_DIR AND HELLO_LIBRARY)IF(HELLO_FOUND)    IF(NOT HELLO_FIND_QUIETLY)        MESSAGE(STATUS&quot;Found Hello: ${HELLO_LIBRARY}&quot;)    ENDIF(NOT HELLO_FIND_QUIETLY)ELSE(HELLO_FOUND)    IF(HELLO_FIND_REQUIRED)        MESSAGE(FATAL_ERROR&quot;Could not find hello library&quot;)    ENDIF(HELLO_FIND_REQUIRED)ENDIF(HELLO_FOUND)</code></pre><p>针对上面的模块让我们再来回顾一下 FIND_PACKAGE 指令:</p><pre><code>FIND_PACKAGE(&lt;name&gt;[major.minor] [QUIET] [NO_MODULE] [[REQUIRED|COMPONENTS][componets...]])</code></pre><p>前面的CURL例子中我们使用了最简单的FIND_PACKAGE指令，其实它可以使用多种参数：</p><p>QUIET参数，对应与我们编写的FindHELLO中的 <code>HELLO_FIND_QUIETLY</code>，如果不指定这个参数，就会执行:</p><pre><code>MESSAGE(STATUS&quot;Found Hello: ${HELLO_LIBRARY}&quot;)</code></pre><p>REQUIRED参数，其含义是指这个共享库是否是工程必须的，如果使用了这个参数，说明这个链接库是必备库,如果找不到这个链接库,则工程不能编译。对应于FindHELLO.cmake模块中的HELLO_FIND_REQUIRED变量。<br>同样,我们在上面的模块中定义了HELLO_FOUND,HELLO_INCLUDE_DIR, HELLO_LIBRARY变量供开发者在FIND_PACKAGE指令中使用。</p><p>下面建立 <code>src/main.c</code>，内容为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hello.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HelloFunc();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立 <code>src/CMakeLists.txt</code> 文件,内容如下:</p><pre><code>FIND_PACKAGE(HELLO)IF(HELLO_FOUND)    ADD_EXECUTABLE(hellomain.c)    INCLUDE_DIRECTORIES(${HELLO_INCLUDE_DIR})    TARGET_LINK_LIBRARIES(hello${HELLO_LIBRARY})ENDIF(HELLO_FOUND)</code></pre><p>为了能够让工程找到 FindHELLO.cmake 模块(存放在工程中的cmake目录)我们在主工程文件 CMakeLists.txt 中加入:</p><pre><code>SET(CMAKE_MODULE_PATH${PROJECT_SOURCE_DIR}/cmake)</code></pre><br>##### （三）使用自定义的 FindHELLO 模块构建工程 <p>仍然采用外部编译的方式,建立build目录,进入目录运行:</p><pre><code>$ cmake ..</code></pre><p>我们可以从输出中看到:</p><p>FoundHello: /usr/lib/libhello.so</p><p>如果我们把上面的FIND_PACKAGE(HELLO)修改为FIND_PACKAGE(HELLO QUIET),</p><p>不会看到上面的输出。接下来就可以使用make命令构建工程,运行:</p><pre><code># ./src/hello</code></pre><p>可以得到输出：</p><blockquote><p>HelloWorld</p></blockquote><p>说明工程成功构建。</p><br>#####（四）如果没有找到hellolibrary呢? 我们可以尝试将/usr/lib/libhello.x移动到/tmp目录,这样按照FindHELLO模块的定义,找不到hellolibrary了,我们再来看一下构建结果:<pre><code>$ cmake ..</code></pre><p>仍然可以成功进行构建,但是这时候是没有办法编译的。</p><p>修改FIND_PACKAGE(HELLO)为FIND_PACKAGE(HELLO REQUIRED)，将hellolibrary定义为工程必须的共享库。<br>这时候再次运行</p><pre><code>$ cmake ..</code></pre><p>我们得到如下输出:</p><p>CMakeError: Could not find hello library.</p><p>因为找不到libhello.x，所以,整个Makefile生成过程被出错中止。</p><p>一些问题</p><p>1.怎样区分debug、release版本<br>建立debug/release两目录，分别在其中执行cmake -D CMAKE_BUILD_TYPE=Debug（或Release），需要编译不同版本时进入不同目录执行make即可：</p><p>Debug版会使用参数-g；<br>Release版使用-O3–DNDEBUG</p><p>另一种设置方法——例如DEBUG版设置编译参数DDEBUG</p><pre><code>IF(DEBUG_mode)    add_definitions(-DDEBUG)ENDIF()</code></pre><p>在执行cmake时增加参数即可，例如cmake -D DEBUG_mode=ON</p><p>2.怎样设置条件编译<br>例如debug版设置编译选项DEBUG，并且更改不应改变CMakelist.txt<br>使用option command，eg：</p><p>option(DEBUG_mode”ON for debug or OFF for release” ON)<br>IF(DEBUG_mode)<br>    add_definitions(-DDEBUG)<br>ENDIF()</p><p>使其生效的方法：首先cmake生成makefile，然后make edit_cache编辑编译选项；Linux下会打开一个文本框，可以更改，改完后再make生成目标文件——emacs不支持make edit_cache；</p><p>局限：这种方法不能直接设置生成的makefile，而是必须使用命令在make前设置参数；对于debug、release版本，相当于需要两个目录，分别先cmake一次，然后分别makeedit_cache一次；</p><p>期望的效果：在执行cmake时直接通过参数指定一个开关项，生成相应的makefile。</p><h6 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h6><p><a href="https://www.kancloud.cn/itfanr/cmake-practice/82982" target="_blank" rel="noopener">https://www.kancloud.cn/itfanr/cmake-practice/82982</a><br><a href="http://stackoverflow.com/questions/10765885/how-to-install-your-custom-cmake-find-module" target="_blank" rel="noopener">http://stackoverflow.com/questions/10765885/how-to-install-your-custom-cmake-find-module</a><br><a href="http://blog.csdn.net/z_h_s/article/details/50699905" target="_blank" rel="noopener">http://blog.csdn.net/z_h_s/article/details/50699905</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Use CMake to generate Makefile</title>
      <link href="/Tools-and-Build/tool-and-build-cmake-makefile/"/>
      <url>/Tools-and-Build/tool-and-build-cmake-makefile/</url>
      
        <content type="html"><![CDATA[<p>CMake 通过用户编写的 CMakeLists.txt 来生成 Makefile，可以减轻为复杂工程编写 Makefile 的工作量。<br>CMakeLists.txt 的编写遵循 Cmake 定义的一些规则，本文介绍该文件的编写以及如何使用它生成 Makefile。</p><p>我们需要在源码所在的顶层目录来编写 CMakeLists.txt 文件，编写完成之后就可以通过 <code>cmake</code> 命令来生成 Makefile 等规则文件了。为了防止编译后生成的文件与已有的源文件在同一个目录下导致混乱，我们通常会在项目源码之外的其他位置新建一个 build 子目录来存放编译后生成的文件。新建 build 目录之后，进入该目录，在其中执行 <code>cmake src_dir</code> 生成 Makefile，生成的 Makefile 会在当前的 build 目录中，如果生成过程顺利没有出错，那么直接执行 <code>make</code> 命令就可以自动编译整个项目了。</p><p><strong>上述流程大致如下：</strong></p><pre><code>$ cd &lt;build_dir_different_from_source_dir&gt;$ cmake &lt;source_dir&gt;</code></pre><p><strong>CMakeLists.txt 的一般格式如下：</strong></p><pre><code># This is testCMAKE_MINIMUM_REQUIRED(VERSION 3.2)PROJECT(MAIN) AUX_SOURCE_DIRECTORY(. DIR_SRCS) ADD_EXECUTABLE(main ${DIR_SRCS})</code></pre><p>CMakeLists.txt 的语法比较简单，由命令、注释和空格组成。<br>符号 # 后面的内容是注释。<br>命令由命令名称、小括号和参数组成，命令<strong>不区分大小写</strong>，参数之间使用<strong>空格</strong>进行间隔。</p><p><strong>cmake_minimum_required</strong>：指定运行此配置文件所需的 CMake 的最低版本；<br>project：表示项目的名称是 MAIN 。<br><strong>aux_source_directory</strong>: 定义需要编译的所有源码文件，这里用 <code>.</code> 表示当前目录中的所有文件，保存在变量 DIR_SRCS 中。<br><strong>add_executable</strong>：将名为 <code>${DIR_SRCS}</code> 指定的所有源文件编译成一个目标名称为 main 的可执行文件。</p><p>CMake 中有许多环境变量，可以通过 <code>SET()</code> 命令去设置，然后通过 <code>${Var}</code> 的方式引用。</p><p>比如： </p><pre><code>SET(SRC_LIST test.cpp main.cpp)ADD_EXECUTABLE(hello ${SRC_LIST})</code></pre><br><h5 id="1-指定编译选项-Compile-args"><a href="#1-指定编译选项-Compile-args" class="headerlink" title="1. 指定编译选项 (Compile args)"></a>1. 指定编译选项 (Compile args)</h5><p>在使用 gcc 或者 g++ 编译源码文件时，我们通常会指定一些编译参数，比如常见的 <code>gcc -g -Wall -O2</code> 等等。</p><p>如何在 CMakeLists.txt 中指定这些选项呢？可以参考如下方式：</p><pre><code>SET(CMAKE_BUILD_TYPE DEBUG)SET(CMAKE_CXX_FLAGS &quot;-Wall&quot;)SET(CMAKE_CXX_FLAGS_RELWITHDEBINFO &quot;-O2 -g&quot;)SET(CMAKE_CXX_FLAGS_DEBUG  &quot;-O0 -g -DDEBUG_ -DUSE_BOOST&quot;)SET(CMAKE_CXX_FLAGS_RELEASE &quot;-O2&quot;)SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)INCLUDE_DIRECTORIES(../otherheaders)</code></pre><br><h5 id="2-添加头文件搜索路径"><a href="#2-添加头文件搜索路径" class="headerlink" title="2. 添加头文件搜索路径"></a>2. 添加头文件搜索路径</h5><p>如果我们有除 gcc 默认头文件搜索路径之外的头文件需要引入，通常我们会通过 <code>export C_INCLUDE_PATH=/path/to/our_include</code> 或者 <code>gcc -I /path/to/our_include</code> 的方式引入。</p><p>那么在 CMakeLists.txt 中如何指定呢？</p><p>使用 CMake 中的 <code>include_directories</code> 命令来添加：</p><pre><code>include_directories(    /usr/local/other_include    ../others    include)</code></pre><p>如果要为指定的目标文件（库文件或可执行文件，比如目标为 foobar）添加头文件路径，可以使用 <code>target_include_directories</code> 命令来添加：</p><pre><code>target_include_directories(    foobar PUBLIC    /usr/local/flac    include    src)</code></pre><br><h5 id="3-添加动态链接库"><a href="#3-添加动态链接库" class="headerlink" title="3. 添加动态链接库"></a>3. 添加动态链接库</h5><p>在目标文件的链接阶段，我们可能会需要链接外部库，比如 <code>-lpthread</code>, <code>-lcurl</code>, <code>-lcrypto</code> 等等。</p><p>如何在 CMakeLists.txt 来指定这些外部库呢？</p><p>CMake 提供了一个 <code>FIND_PACKAGE(LibName)</code> 命令帮助我们来查找指定的外部链接库，这个是通过 cmake 提供的 .cmake 后缀的文件来定位的。<br>然后通过 <code>TARGET_LINK_LIBRARIES</code> 来为目标文件添加指定的库链接。</p><p>CMake 提供的 <strong>.cmake 文件</strong>通常位于 <code>/usr/share/cmake/Modules</code> 或者 <code>/usr/local/share/cmake-3.6/Modules/</code> 目录中，<br>文件名是由 Find 加上库名字(即上述 <code>FIND_PACKAGE</code> 中的 LibName)拼接而成，比如 pthread 库，使用了 FindThreads.cmake 作为文件名，而 curl 库，使用了 FindCURL.cmake 作为文件名。<br>遇到默认没有提供的库的 .cmake 文件，用户还可以自定义 .cmake 文件。如果不知道如何编写 .cmake 文件，可以参考系统提供的 .cmake 来编写，语法非常简单。</p><p>下面简单列举下 <code>-lpthread</code>, <code>-lcurl</code>, <code>-lcrypto</code> 这几个库在 CMakeLists.txt 中的指定方式，其他的外部库指定方式是完全类似的。当然，需要先确保本地已经安装了这几个库。</p><br><h6 id="1-lpthread"><a href="#1-lpthread" class="headerlink" title="(1) -lpthread"></a>(1) -lpthread</h6><pre><code>FIND_PACKAGE(Threads REQUIRED)TARGET_LINK_LIBRARIES(testprog ${CMAKE_THREAD_LIBS_INIT})</code></pre><p>提示：添加 REQUIRED 的目的是强制要求链接该库，没找到的话会报错。如果不添加 REQUIRED 的话，就相当于是 OPTIONAL 可选的。</p><br><h6 id="2-lcurl"><a href="#2-lcurl" class="headerlink" title="(2) -lcurl"></a>(2) -lcurl</h6><pre><code>FIND_PACKAGE(CURL REQUIRED)IF(CURL_FOUND)    INCLUDE_DIRECTORIES(${CURL_INCLUDE_DIR})    SET(Libs ${Libs} ${CURL_LIBRARIES})ELSE()    MESSAGE(FATAL_ERROR &quot;Could not find the CURL library.&quot;)ENDIF()TARGET_LINK_LIBRARIES(testcurl ${Libs})</code></pre><br><h6 id="3-lcrypto"><a href="#3-lcrypto" class="headerlink" title="(3) -lcrypto"></a>(3) -lcrypto</h6><p>默认没有提供 .cmake 文件，只能自己手写。可以参考 FindCURL.cmake 来编写。</p><p><strong>下面介绍如何编写 .cmake 文件：</strong></p><p><strong>（i）首先定位 header 头文件</strong></p><pre><code>FIND_PATH(CRYPTO_INCLUDE_DIR openssl/crypto.h)    参考 find_path(CURL_INCLUDE_DIR NAMES curl/curl.h)</code></pre><p><strong>（ii）然后声明 library 名字，crypto 是由 openssl 提供的库的名字，链接时也是使用 -lcrypto，因此 库名字就叫 crypto。</strong><br>实际的库文件名是 <code>libcrypto.so</code>，位于 <code>/usr/lib64</code> 或者 <code>/usr/lib/x86_64-linux-gnu/</code> 目录下</p><pre><code>FIND_LIBRARY(CRYPTO_LIBRARIES NAMES crypto)</code></pre><p><strong>（iii）声明为高级</strong></p><pre><code>MARK_AS_ADVANCED(CRYPTO_INCLUDE_DIR CRYPTO_LIBRARIES)</code></pre><p><strong>（iv）如果找到了头文件和相应的库，就设置相关的标志，比如 CRYPTO_FOUND 设为 true</strong></p><pre><code>IF(CRYPTO_INCLUDE_DIR AND CRYPTO_LIBRARIES)   SET(CRYPTO_FOUND TRUE)ELSE()   SET(CRYPTO_FOUND FALSE)ENDIF ()</code></pre><p><strong>（v）然后根据 CRYPTO_FOUND 来设置一些变量。</strong></p><pre><code>if(CRYPTO_FOUND)    set(CRYPTO_LIBRARIES ${CRYPTO_LIBRARY})    set(CRYPTO_INCLUDE_DIRS ${CRYPTO_INCLUDE_DIR})endif()</code></pre><p><strong>（iv）和 （v） 还可以直接用统一的方式来处理</strong><br>引入 cmake 默认提供的 FindPackageHandleStandardArgs.cmake ，然后调用 <code>FIND_PACKAGE_HANDLE_STANDARD_ARGS()</code></p><pre><code>include(${CMAKE_CURRENT_LIST_DIR}/FindPackageHandleStandardArgs.cmake)FIND_PACKAGE_HANDLE_STANDARD_ARGS( CRYPTO                                   REQUIRED_VARS CRYPTO_LIBRARY CRYPTO_INCLUDE_DIR                                   VERSION_VAR CRYPTO_VERSION_STRING)</code></pre><br><h5 id="4-cmake-提示信息"><a href="#4-cmake-提示信息" class="headerlink" title="4 cmake 提示信息"></a>4 cmake 提示信息</h5><p>有时候我们需要在执行 cmake 命令时向终端输出一些信息，以便更清晰的了解编译过程。cmake 提供了 MESSAGE 命令来达到目的，</p><p>MESSAGE 指令的语法：</p><pre><code>MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] &quot;message to display&quot; ...)</code></pre><p>MESSAGE 指令包含三种类型：</p><ul><li>SEND_ERROR  产生错误，生成过程被跳过。</li><li>SATUS       输出前缀为 - 的信息。</li><li>FATAL_ERROR 立即终止所有cmake过程。</li></ul><p>例子：</p><pre><code>MESSAGE(STATUS &quot;Found xxx in ${XXX_LIBRARIES}&quot;)MESSAGE(FATAL_ERROR &quot;Could not find the xxx library.&quot;)MESSAGE(SEND_ERROR &quot;Couldn&apos;t find xxx include files and/or library&quot;)</code></pre><p>附：CMake 命令列表<br><a href="https://cmake.org/cmake/help/v3.2/manual/cmake-commands.7.html" target="_blank" rel="noopener">https://cmake.org/cmake/help/v3.2/manual/cmake-commands.7.html</a></p><br><br><br><p><strong>参考</strong><br><a href="https://www.johnlamp.net/cmake-tutorial.html" target="_blank" rel="noopener">https://www.johnlamp.net/cmake-tutorial.html</a><br><a href="https://cmake.org/cmake-tutorial/" target="_blank" rel="noopener">https://cmake.org/cmake-tutorial/</a><br><a href="https://wiki.openssl.org/index.php/Libcrypto_API" target="_blank" rel="noopener">https://wiki.openssl.org/index.php/Libcrypto_API</a><br><a href="https://cmake.org/cmake/help/v2.8.8/cmake.html#command%3afind_package" target="_blank" rel="noopener">https://cmake.org/cmake/help/v2.8.8/cmake.html#command%3afind_package</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Understand Linux Environment Variables</title>
      <link href="/Linux/linux-env-files/"/>
      <url>/Linux/linux-env-files/</url>
      
        <content type="html"><![CDATA[<p>There are several configuraiton files in linux that can have environment variables set, we need a better understanding of different config files and set environment variables properly in them.</p><p>Use <code>env</code> or <code>set</code> command to list all environment variables that are related to the current $SHELL.</p><p>Common environment variables that are in most Linux distributions:<br>PAHT, HOME, PWD, USER, UID, SHELL, BASH, BASH_VERSION</p><h3 id="Global-Settings"><a href="#Global-Settings" class="headerlink" title="Global Settings"></a>Global Settings</h3><p>Environment variables in below system files will have effects to all users</p><ul><li>/etc/bash.bashrc in CentOS this could be <code>/etc/bashrc</code>, will be executed everytime a shell is opened.</li><li>/etc/environment  variable set in this file will have system wide effect, will be loaded before /etc/profile. We can only set variables in this file, by which means we can not execute any command in this file. We can use <code>source /etc/environment</code> to make it take effect to current shell immediately, however, we have to restart system so that it will take effect to all shells.</li><li>/etc/profile     this file will <code>source /etc/bash.bashrc</code> and executes all the shell scripts in <code>/etc/profile.d</code>. This file will be loaded only one time when system starts up</li></ul><p>Contents in /etc/profile</p><pre><code>$ cat /etc/profileif [ &quot;$PS1&quot; ]; then  if [ &quot;$BASH&quot; ] &amp;&amp; [ &quot;$BASH&quot; != &quot;/bin/sh&quot; ]; then    if [ -f /etc/bash.bashrc ]; then      . /etc/bash.bashrc    fifiif [ -d /etc/profile.d ]; then  for i in /etc/profile.d/*.sh; do    if [ -r $i ]; then      . $i    fi  done  unset ifi</code></pre><p>If we want to set a system wide variable, don’t add it in <code>/etc/profile</code>, add a customed script *.sh in /etc/profile.d. Especially, never add or modify a system wide variabe in /etc/bash.bashrc because this file will be loaded before any other config files when the system starts up, if we add a variable like ‘export JAVA_HOME=…’ in it, this may cause the normal system variable is overriden and falsely read, in worst case, if the PATH is not read correctly, all commands will not be able to executed as it will prompt the message saying “command is not found”.</p><p>Note that /etc/profile is loaded later than /etc/environment, we should put user-defined variable in customed script in /etc/profile.d, to achieve the least effect to system startup.</p><pre><code>$ cat /etc/bash.bashrc# System-wide .bashrc file for interactive bash(1) shells.# To enable the settings / commands in this file for login shells as well,# this file has to be sourced in /etc/profile.</code></pre><p>We set environment variable according to our requirement. For example, if we want all users in this system to be able to access JAVA, we can set JAVA_HOME in /etc/enviroment.</p><h3 id="User-Settings"><a href="#User-Settings" class="headerlink" title="User Settings"></a>User Settings</h3><p>Variables in below user-scope files have effect only on current user.</p><ul><li>~/.bashrc</li><li>~/.bash_profile this file will automaticall <code>source ~/.bashrc</code></li><li><del>/.profile   this file is not read by bash if `</del>/.bash_profile<code>or</code>~/.bash_login` exists</li></ul><p>Contents in <code>~/.bash_profile</code></p><pre><code># .bash_profile# Get the aliases and functionsif [ -f ~/.bashrc ]; then. ~/.bashrcfi</code></pre><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p>export is only effective to the current shell, if we open another shell, variables exported in current shell will not be set.</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>利用多核多线程进行程序优化</title>
      <link href="/Operating-System/os-cpu-cache/"/>
      <url>/Operating-System/os-cpu-cache/</url>
      
        <content type="html"><![CDATA[<p>本文转载自：<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-optimization/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-optimization/index.html</a></p><p>大家也许还记得 2005 年 3 月 C++ 大师 Herb Sutter 在 Dr.Dobb’s Journal 上发表了一篇名为《免费的午餐已经结束》的文章。文章指出：现在的程序员对效率、伸缩性、吞吐量等一系列性能指标相当忽视，很多性能问题都仰仗越来越快的 CPU 来解决。但 CPU 的速度在不久的将来，即将偏离摩尔定律的轨迹，并达到一定的极限。所以，越来越多的应用程序将不得不直面性能问题，而解决这些问题的办法就是采用并发编程技术。</p><h3 id="样例程序"><a href="#样例程序" class="headerlink" title="样例程序"></a>样例程序</h3><hr><p>程序功能：求从1一直到 APPLE_MAX_VALUE (100000000) 相加累计的和，并赋值给 apple 的 a 和 b ；求 orange 数据结构中的 a[i]+b[i ] 的和，循环 ORANGE_MAX_VALUE(1000000) 次。<br>说明：<br>由于样例程序是从实际应用中抽象出来的模型，所以本文不会进行 test.a=test.b= test.b+sum 、中间变量(查找表)等类似的优化。<br>以下所有程序片断均为部分代码，完整代码请参看本文最下面的附件。</p><h5 id="清单-1-样例程序"><a href="#清单-1-样例程序" class="headerlink" title="清单 1. 样例程序"></a>清单 1. 样例程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ORANGE_MAX_VALUE      1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> APPLE_MAX_VALUE       100000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSECOND               1000000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">apple</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> a;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">orange</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[ORANGE_MAX_VALUE];</span><br><span class="line">    <span class="keyword">int</span> b[ORANGE_MAX_VALUE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">apple</span> <span class="title">test</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">orange</span> <span class="title">test1</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(sum=<span class="number">0</span>;sum&lt;APPLE_MAX_VALUE;sum++) &#123;</span><br><span class="line">        test.a += sum;</span><br><span class="line">        test.b += sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(index=<span class="number">0</span>;index&lt;ORANGE_MAX_VALUE;index++) &#123;</span><br><span class="line">        sum += test1.a[index]+test1.b[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="K-Best-测量方法"><a href="#K-Best-测量方法" class="headerlink" title="K-Best 测量方法"></a>K-Best 测量方法</h3><hr><p>在检测程序运行时间这个复杂问题上，将采用 Randal E.Bryant 和 David R. O’Hallaron 提出的 K 次最优测量方法。假设重复的执行一个程序，并纪录 K 次最快的时间，如果发现测量的误差 ε 很小，那么用测量的最快值表示过程的真正执行时间， 称这种方法为“ K 次最优（K-Best）方法”，要求设置三个参数：<br>K: 要求在某个接近最快值范围内的测量值数量。<br>ε 测量值必须多大程度的接近，即测量值按照升序标号 V1, V2, V3, … , Vi, … ，同时必须满足（1+ ε）Vi &gt;= Vk<br>M: 在结束测试之前，测量值的最大数量。<br>按照升序的方式维护一个 K 个最快时间的数组，对于每一个新的测量值，如果比当前 K 处的值更快，则用最新的值替换数组中的元素 K ，然后再进行升序排序，持续不断的进行该过程，并满足误差标准，此时就称测量值已经收敛。如果 M 次后，不能满足误差标准，则称为不能收敛。<br>在接下来的所有试验中，采用 K=10，ε=2%，M=200 来获取程序运行时间，同时也对 K 次最优测量方法进行了改进，不是采用最小值来表示程序执行的时间，而是采用 K 次测量值的平均值来表示程序的真正运行时间。由于采用的误差 ε 比较大，在所有试验程序的时间收集过程中，均能收敛，但也能说明问题。<br>为了可移植性，采用 gettimeofday() 来获取系统时钟（system clock）时间，可以精确到微秒。</p><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><hr><p>硬件：联想 Dual-core 双核机器，主频 2.4G，内存 2G<br>软件：Suse Linunx Enterprise 10，内核版本：linux-2.6.16</p><h3 id="软件优化的三个层次"><a href="#软件优化的三个层次" class="headerlink" title="软件优化的三个层次"></a>软件优化的三个层次</h3><hr><p>医生治病首先要望闻问切，然后才确定病因，最后再对症下药，如果胡乱医治一通，不死也残废。说起来大家都懂的道理，但在软件优化过程中，往往都喜欢犯这样的错误。不分青红皂白，一上来这里改改，那里改改，其结果往往不如人意。<br>一般将软件优化可分为三个层次：系统层面，应用层面及微架构层面。首先从宏观进行考虑，进行望闻问切，即系统层面的优化，把所有与程序相关的信息收集上来，确定病因。确定病因后，开始从微观上进行优化，即进行应用层面和微架构方面的优化。<br>系统层面的优化：内存不够，CPU 速度过慢，系统中进程过多等<br>应用层面的优化：算法优化、并行设计等<br>微架构层面的优化：分支预测、数据结构优化、指令优化等<br>软件优化可以在应用开发的任一阶段进行，当然越早越好，这样以后的麻烦就会少很多。<br>在实际应用程序中，采用最多的是应用层面的优化，也会采用微架构层面的优化。将某些优化和维护成本进行对比，往往选择的都是后者。如分支预测优化和指令优化，在大型应用程序中，往往采用的比较少，因为维护成本过高。<br>本文将从应用层面和微架构层面，对样例程序进行优化。对于应用层面的优化，将采用多线程和 CPU 亲和力技术；在微架构层面，采用 Cache 优化。</p><h3 id="并行设计"><a href="#并行设计" class="headerlink" title="并行设计"></a>并行设计</h3><hr><p>利用并行程序设计模型来设计应用程序，就必须把自己的思维从线性模型中拉出来，重新审视整个处理流程，从头到尾梳理一遍，将能够并行执行的部分识别出来。<br>可以将应用程序看成是众多相互依赖的任务的集合。将应用程序划分成多个独立的任务，并确定这些任务之间的相互依赖关系，这个过程被称为分解（Decomosition）。分解问题的方式主要有三种：任务分解、数据分解和数据流分解。关于这部分的详细资料，请参看参考资料一。<br>仔细分析样例程序，运用任务分解的方法 ，不难发现计算 apple 的值和计算 orange 的值，属于完全不相关的两个操作，因此可以并行。<br>改造后的两线程程序：</p><h5 id="清单-2-两线程程序"><a href="#清单-2-两线程程序" class="headerlink" title="清单 2. 两线程程序"></a>清单 2. 两线程程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">add</span><span class="params">(<span class="keyword">void</span>* x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(sum=<span class="number">0</span>;sum&lt;APPLE_MAX_VALUE;sum++) &#123;</span><br><span class="line">        ((struct apple *)x)-&gt;a += sum;</span><br><span class="line">        ((struct apple *)x)-&gt;b += sum;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">apple</span> <span class="title">test</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">orange</span> <span class="title">test1</span>=&#123;</span>&#123;<span class="number">0</span>&#125;,&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">pthread_t</span> ThreadA;</span><br><span class="line">        </span><br><span class="line">    pthread_create(&amp;ThreadA,<span class="literal">NULL</span>,add,&amp;test);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(index=<span class="number">0</span>;index&lt;ORANGE_MAX_VALUE;index++) &#123;</span><br><span class="line">        sum += test1.a[index]+test1.b[index];</span><br><span class="line">    &#125;       </span><br><span class="line">    </span><br><span class="line">    pthread_join(ThreadA,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更甚一步，通过数据分解的方法，还可以发现，计算 apple 的值可以分解为两个线程，一个用于计算 apple a 的值，另外一个线程用于计算 apple b 的值(说明：本方案抽象于实际的应用程序)。但两个线程存在同时访问 apple 的可能性，所以需要加锁访问该数据结构。<br>改造后的三线程程序如下：</p><h5 id="清单-3-三线程程序"><a href="#清单-3-三线程程序" class="headerlink" title="清单 3. 三线程程序"></a>清单 3. 三线程程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">apple</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> a;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> b;</span><br><span class="line">    <span class="keyword">pthread_rwlock_t</span> rwLock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">addx</span><span class="params">(<span class="keyword">void</span>* x)</span> </span>&#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;((struct apple *)x)-&gt;rwLock);</span><br><span class="line">    <span class="keyword">for</span>(sum=<span class="number">0</span>; sum&lt;APPLE_MAX_VALUE; sum++) &#123;</span><br><span class="line">        ((struct apple *)x)-&gt;a += sum;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_rwlock_unlock(&amp;((struct apple *)x)-&gt;rwLock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">addy</span><span class="params">(<span class="keyword">void</span>* y)</span> </span>&#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;((struct apple *)y)-&gt;rwLock);</span><br><span class="line">    <span class="keyword">for</span>(sum=<span class="number">0</span>;sum&lt;APPLE_MAX_VALUE; sum++) &#123;</span><br><span class="line">        ((struct apple *)y)-&gt;b += sum;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_rwlock_unlock(&amp;((struct apple *)y)-&gt;rwLock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">apple</span> <span class="title">test</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">orange</span> <span class="title">test1</span> = &#123;</span>&#123;<span class="number">0</span>&#125;,&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">pthread_t</span> ThreadA, ThreadB;</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;ThreadA,<span class="literal">NULL</span>,addx,&amp;test);</span><br><span class="line">    pthread_create(&amp;ThreadB,<span class="literal">NULL</span>,addy,&amp;test);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(index=<span class="number">0</span>;index&lt;ORANGE_MAX_VALUE;index++) &#123;</span><br><span class="line">        sum+=test1.a[index]+test1.b[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pthread_join(ThreadA,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(ThreadB,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样改造后，真的能达到我们想要的效果吗？通过 K-Best 测量方法，其结果让我们大失所望，如下图：</p><h5 id="图-1-单线程与多线程耗时对比图"><a href="#图-1-单线程与多线程耗时对比图" class="headerlink" title="图 1. 单线程与多线程耗时对比图"></a>图 1. 单线程与多线程耗时对比图</h5><p><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-optimization/images/image001.jpg" alt=""><br>为什么多线程会比单线程更耗时呢？其原因就在于，线程启停以及线程上下文切换都会引起额外的开销，所以消耗的时间比单线程多。<br>为什么加锁后的三线程比两线程还慢呢？其原因也很简单，那把读写锁就是罪魁祸首。通过 Thread Viewer 也可以印证刚才的结果，实际情况并不是并行执行，反而成了串行执行，如图2：<br><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-optimization/images/image002.jpg" alt=""><br>其中最下面那个线程是主线程，一个是 addx 线程，另外一个是 addy 线程，从图中不难看出，其他两个线程为串行执行。<br>通过数据分解来划分多线程，还存在另外一种方式，一个线程计算从1到 APPLE_MAX_VALUE/2 的值，另外一个线程计算从 APPLE_MAX_VALUE/2+1 到 APPLE_MAX_VALUE 的值，但本文会弃用这种模型，有兴趣的读者可以试一试。<br>在采用多线程方法设计程序时，如果产生的额外开销大于线程的工作任务，就没有并行的必要。线程并不是越多越好，软件线程的数量尽量能与硬件线程的数量相匹配。最好根据实际的需要，通过不断的调优，来确定线程数量的最佳值。</p><h3 id="加锁与不加锁"><a href="#加锁与不加锁" class="headerlink" title="加锁与不加锁"></a>加锁与不加锁</h3><hr><p>针对加锁的三线程方案，由于两个线程访问的是 apple 的不同元素，根本没有加锁的必要，所以修改 apple 的数据结构（删除读写锁代码），通过不加锁来提高性能。<br>测试结果如下：</p><h5 id="图-3-加锁与不加锁耗时对比图"><a href="#图-3-加锁与不加锁耗时对比图" class="headerlink" title="图 3. 加锁与不加锁耗时对比图"></a>图 3. 加锁与不加锁耗时对比图</h5><p><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-optimization/images/image003.jpg" alt=""><br>其结果再一次大跌眼镜，可能有些人就会越来越糊涂了，怎么不加锁的效率反而更低呢？将在针对 Cache 的优化一节中细细分析其具体原因。<br>在实际测试过程中，不加锁的三线程方案非常不稳定，有时所花费的时间相差4倍多。<br>要提高并行程序的性能，在设计时就需要在较少同步和较多同步之间寻求折中。同步太少会导致错误的结果，同步太多又会导致效率过低。尽量使用私有锁，降低锁的粒度。无锁设计既有优点也有缺点，无锁方案能充分提高效率，但使得设计更加复杂，维护操作困难，不得不借助其他机制来保证程序的正确性。</p><h3 id="针对-Cache-的优化"><a href="#针对-Cache-的优化" class="headerlink" title="针对 Cache 的优化"></a>针对 Cache 的优化</h3><p>在串行程序设计过程中，为了节约带宽或者存储空间，比较直接的方法，就是对数据结构做一些针对性的设计，将数据压缩 (pack) 的更紧凑，减少数据的移动，以此来提高程序的性能。但在多核多线程程序中，这种方法往往有时会适得其反。<br>数据不仅在执行核和存储器之间移动，还会在执行核之间传输。根据数据相关性，其中有两种读写模式会涉及到数据的移动：写后读和写后写 ，因为这两种模式会引发数据的竞争，表面上是并行执行，但实际只能串行执行，进而影响到性能。<br>处理器交换的最小单元是 cache 行，或称 cache 块。在多核体系中，对于不共享 cache 的架构来说，两个独立的 cache 在需要读取同一 cache 行时，会共享该 cache 行，如果在其中一个 cache 中，该 cache 行被写入，而在另一个 cache 中该 cache 行被读取，那么即使读写的地址不相交，也需要在这两个 cache 之间移动数据，这就被称为 cache 伪共享，导致执行核必须在存储总线上来回传递这个 cache 行，这种现象被称为“乒乓效应”。<br>同样地，当两个线程写入同一个 cache 的不同部分时，也会互相竞争该 cache 行，也就是写后写的问题。上文曾提到，不加锁的方案反而比加锁的方案更慢，就是互相竞争 cache 的原因。<br>在 X86 机器上，某些处理器的一个 cache 行是64字节，具体可以参看 Intel 的参考手册。<br>既然不加锁三线程方案的瓶颈在于 cache，那么让 apple 的两个成员 a 和 b 位于不同的 cache 行中，效率会有所提高吗？<br>修改后的代码片断如下：</p><h5 id="清单-4-针对Cache的优化"><a href="#清单-4-针对Cache的优化" class="headerlink" title="清单 4. 针对Cache的优化"></a>清单 4. 针对Cache的优化</h5><p>struct apple {<br>    unsigned long long a;<br>    char c[128];  /<em>32,64,128</em>/    unsigned long long b;<br>};</p><p>测量结果如下图所示：</p><h5 id="图-4-增加-Cache-时间耗时对比图"><a href="#图-4-增加-Cache-时间耗时对比图" class="headerlink" title="图 4. 增加 Cache 时间耗时对比图"></a>图 4. 增加 Cache 时间耗时对比图</h5><p><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-optimization/images/image004.jpg" alt=""><br>小小的一行代码，尽然带来了如此高的收益，不难看出，我们是用空间来换时间。当然读者也可以采用更简便的方法： <strong>attribute</strong>((<strong>aligned</strong>(L1_CACHE_BYTES))) 来确定 cache 的大小。<br>如果对加锁三线程方案中的 apple 数据结构也增加一行类似功能的代码，效率也是否会提升呢？性能不会有所提升，其原因是加锁的三线程方案效率低下的原因不是 Cache 失效造成的，而是那把锁。<br>在多核和多线程程序设计过程中，要全盘考虑多个线程的访存需求，不要单独考虑一个线程的需求。在选择并行任务分解方法时，要综合考虑访存带宽和竞争问题，将不同处理器和不同线程使用的数据放在不同的 Cache 行中，将只读数据和可写数据分离开。</p><h3 id="CPU-亲和力"><a href="#CPU-亲和力" class="headerlink" title="CPU 亲和力"></a>CPU 亲和力</h3><p>CPU 亲和力可分为两大类：软亲和力和硬亲和力。<br>Linux 内核进程调度器天生就具有被称为 CPU 软亲和力（affinity） 的特性，这意味着进程通常不会在处理器之间频繁迁移。这种状态正是我们希望的，因为进程迁移的频率小就意味着产生的负载小。但不代表不会进行小范围的迁移。<br>CPU 硬亲和力是指进程固定在某个处理器上运行，而不是在不同的处理器之间进行频繁的迁移。这样不仅改善了程序的性能，还提高了程序的可靠性。<br>从以上不难看出，在某种程度上硬亲和力比软亲和力具有一定的优势。但在内核开发者不断的努力下，2.6内核软亲和力的缺陷已经比2.4的内核有了很大的改善。<br>在双核机器上，针对两线程的方案，如果将计算 apple 的线程绑定到一个 CPU 上，将计算 orange 的线程绑定到另外一个 CPU 上，效率是否会有所提高呢？<br>程序如下：</p><h5 id="清单-5-CPU-亲和力"><a href="#清单-5-CPU-亲和力" class="headerlink" title="清单 5. CPU 亲和力"></a>清单 5. CPU 亲和力</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">apple</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> a;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">orange</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[ORANGE_MAX_VALUE];</span><br><span class="line">    <span class="keyword">int</span> b[ORANGE_MAX_VALUE];        </span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">set_cpu</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    CPU_ZERO(&amp;mask);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> &lt;= cpu_nums) &#123;</span><br><span class="line">        CPU_SET(i, &amp;mask);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == sched_setaffinity(gettid(), <span class="keyword">sizeof</span>(&amp;mask), &amp;mask)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">add</span><span class="params">(<span class="keyword">void</span>* x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(set_cpu(<span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(sum=<span class="number">0</span>;sum&lt;APPLE_MAX_VALUE;sum++) &#123;</span><br><span class="line">        ((struct apple *)x)-&gt;a += sum;</span><br><span class="line">        ((struct apple *)x)-&gt;b += sum;</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">apple</span> <span class="title">test</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">orange</span> <span class="title">test1</span>;</span></span><br><span class="line">    </span><br><span class="line">    cpu_nums = sysconf(_SC_NPROCESSORS_CONF);</span><br><span class="line">    <span class="keyword">if</span>(set_cpu(<span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">        </span><br><span class="line">    pthread_create(&amp;ThreadA,<span class="literal">NULL</span>,add,&amp;test);</span><br><span class="line">    <span class="keyword">for</span>(index=<span class="number">0</span>;index&lt;ORANGE_MAX_VALUE;index++) &#123;</span><br><span class="line">        sum+=test1.a[index]+test1.b[index];</span><br><span class="line">    &#125;       </span><br><span class="line"></span><br><span class="line">    pthread_join(ThreadA,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测量结果为：</p><h5 id="图-5-采用硬亲和力时间对比图-两线程"><a href="#图-5-采用硬亲和力时间对比图-两线程" class="headerlink" title="图 5. 采用硬亲和力时间对比图(两线程)"></a>图 5. 采用硬亲和力时间对比图(两线程)</h5><p><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-optimization/images/image005.jpg" alt=""></p><p>其测量结果正是我们所希望的，但花费的时间还是比单线程的多，其原因与上面分析的类似。<br>进一步分析不难发现，样例程序大部分时间都消耗在计算 apple 上，如果将计算 a 和 b 的值，分布到不同的 CPU 上进行计算，同时考虑 Cache 的影响，效率是否也会有所提升呢？</p><h5 id="图-6-采用硬亲和力时间对比图-三线程"><a href="#图-6-采用硬亲和力时间对比图-三线程" class="headerlink" title="图 6. 采用硬亲和力时间对比图(三线程)"></a>图 6. 采用硬亲和力时间对比图(三线程)</h5><p><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-optimization/images/image006.jpg" alt=""></p><p>从时间上观察，设置亲和力的程序所花费的时间略高于采用 Cache 的三线程方案。由于考虑了 Cache 的影响，排除了一级缓存造成的瓶颈，多出的时间主要消耗在系统调用及内核上，可以通过 time 命令来验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#time ./unlockcachemultiprocess</span><br><span class="line">    real   0m0.834s      user  0m1.644s       sys    0m0.004s</span><br><span class="line">#time ./affinityunlockcacheprocess</span><br><span class="line">    real   0m0.875s      user  0m1.716s       sys    0m0.008s</span><br></pre></td></tr></table></figure><p>通过设置 CPU 亲和力来利用多核特性，为提高应用程序性能提供了捷径。同时也是一把双刃剑，如果忽略负载均衡、数据竞争等因素，效率将大打折扣，甚至带来事倍功半的结果。<br>在进行具体的设计过程中，需要设计良好的数据结构和算法，使其适合于应用的数据移动和处理器的性能特性。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>根据以上分析及实验，对所有改进方案的测试时间做一个综合对比，如下图所示：<br>图 7. 各方案时间对比图<br><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-optimization/images/image007.jpg" alt=""></p><p>单线程原始程序平均耗时：1.049046s，最慢的不加锁三线程方案平均耗时：2.217413s，最快的三线程( Cache 为128)平均耗时：0.826674s，效率提升约26%。当然，还可以进一步优化，让效率得到更高的提升。<br>从上图不难得出结论：采用多核多线程并行设计方案，能有效提高性能，但如果考虑不全面，如忽略带宽、数据竞争及数据同步不当等因素，效率反而降低，程序执行越来越慢。<br>如果抛开本文开篇时的限制，采用上文曾提到的另外一种数据分解模型，同时结合硬亲和力对样例程序进行优化，测试时间为0.54s，效率提升了92%。<br>软件优化是一个贯穿整个软件开发周期，从开始设计到最终完成一直进行的连续过程。在优化前，需要找出瓶颈和热点所在。正如最伟大的 C 语言大师 Rob Pike 所说：<br>如果你无法断定程序会在什么地方耗费运行时间，瓶颈经常出现在意想不到的地方，所以别急于胡乱找个地方改代码，除非你已经证实那儿就是瓶颈所在。<br>将这句话送给所有的优化人员，和大家共勉。</p>]]></content>
      
      
      <categories>
          
          <category> Operating System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>缓存一致性（Cache Coherency）</title>
      <link href="/Operating-System/os-cpu-cache-consistency-1/"/>
      <url>/Operating-System/os-cpu-cache-consistency-1/</url>
      
        <content type="html"><![CDATA[<p>本文是 RAD Game Tools 程序员 Fabian “ryg” Giesen 在其<a href="https://fgiesen.wordpress.com/2014/07/07/cache-coherency/" target="_blank" rel="noopener">博客</a>上发表的《Cache coherency primer》一文的翻译。该系列共有两篇，本文系第一篇。</p><p>我计划写一些关于多核场景下数据组织的文章。写了第一篇，但我很快意识到有大量的基础知识我首先需要讲一下。在本文中，我就尝试阐述这些知识。</p><br><h4 id="缓存（Cache）"><a href="#缓存（Cache）" class="headerlink" title="缓存（Cache）"></a>缓存（Cache）</h4><p>本文是关于CPU缓存的快速入门。我假设你已经有了基本概念，但你可能不熟悉其中的一些细节。（如果你已经熟悉了，你可以忽略这部分。）</p><p>在现代的CPU（大多数）上，所有的内存访问都需要通过层层的缓存来进行。也有些例外，比如，对映射成内存地址的I/O口、写合并（Write-combined）内存，这些访问至少会绕开这个流程的一部分。但这两者都是罕见的场景（意味着绝大多数的用户态代码都不会遇到这两种情况），所以在本文中，我将忽略这两者。</p><p>CPU的读/写（以及取指令）单元正常情况下甚至都不能直接访问内存——这是物理结构决定的；CPU都没有管脚直接连到内存。相反，CPU和一级缓存（L1 Cache）通讯，而一级缓存才能和内存通讯。大约二十年前，一级缓存可以直接和内存传输数据。如今，更多级别的缓存加入到设计中，一级缓存已经不能直接和内存通讯了，它和二级缓存通讯——而二级缓存才能和内存通讯。或者还可能有三级缓存。你明白这个意思就行。</p><p>缓存是分“段”（line）的，一个段对应一块存储空间，大小是32（较早的ARM、90年代/2000年代早期的x86和PowerPC）、64（较新的ARM和x86）或128（较新的Power ISA机器）字节。每个缓存段 (cache line) 知道自己对应什么范围的物理内存地址，并且在本文中，我不打算区分物理上的缓存段和它所代表的内存，这听起来有点草率，但是为了方便起见，还是请熟悉这种提法。具体地说，当我提到“缓存段”的时候，我就是指一段和缓存大小对齐的内存，不关心里面的内容是否真正被缓存进去（就是说保存在任何级别的缓存中）了。</p><p>当CPU看到一条读内存的指令时，它会把内存地址传递给一级数据缓存（或可戏称为L1D$，因为英语中“缓存（cache）”和“现金（cash）”的发音相同）。一级数据缓存会检查它是否有这个内存地址对应的缓存段。如果没有，它会把整个缓存段从内存（或者从更高一级的缓存，如果有的话）中加载进来。是的，一次加载整个缓存段，这是基于这样一个假设：内存访问倾向于本地化（localized），如果我们当前需要某个地址的数据，那么很可能我们马上要访问它的邻近地址。一旦缓存段被加载到缓存中，读指令就可以正常进行读取。</p><p>如果我们只处理读操作，那么事情会很简单，因为所有级别的缓存都遵守以下规律，我称之为：</p><blockquote><p>基本定律：在任意时刻，任意级别缓存中的缓存段的内容，等同于它对应的内存中的内容。</p></blockquote><p>一旦我们允许写操作，事情就变得复杂一点了。这里有两种基本的写模式：直写（write-through）和回写（write-back）。直写更简单一点：我们透过本级缓存，直接把数据写到下一级缓存（或直接到内存）中，如果对应的段被缓存了，我们同时更新缓存中的内容（甚至直接丢弃），就这么简单。这也遵守前面的定律：缓存中的段永远和它对应的内存内容匹配。</p><p>回写模式就有点复杂了。缓存不会立即把写操作传递到下一级，而是仅修改本级缓存中的数据，并且把对应的缓存段标记为“脏”段。脏段会触发回写，也就是把里面的内容写到对应的内存或下一级缓存中。回写后，脏段又变“干净”了。当一个脏段被丢弃的时候，总是先要进行一次回写。回写所遵循的规律有点不同。</p><blockquote><p>回写定律：当所有的脏段被回写后，任意级别缓存中的缓存段的内容，等同于它对应的内存中的内容。</p></blockquote><p>换句话说，回写模式的定律中，我们去掉了“在任意时刻”这个修饰语，代之以弱化一点的条件：要么缓存段的内容和内存一致（如果缓存段是干净的话），要么缓存段中的内容最终要回写到内存中（对于脏缓存段来说）。</p><p>直接模式更简单，但是回写模式有它的优势：它能过滤掉对同一地址的反复写操作，并且，如果大多数缓存段都在回写模式下工作，那么系统经常可以一下子写一大片内存，而不是分成小块来写，前者的效率更高。</p><p>有些（大多数是比较老的）CPU只使用直写模式，有些只使用回写模式，还有一些，一级缓存使用直写而二级缓存使用回写。这样做虽然在一级和二级缓存之间产生了不必要的数据流量，但二级缓存和更低级缓存或内存之间依然保留了回写的优势。我想说的是，这里涉及到一系列的取舍问题，且不同的设计有不同的解决方案。没有人规定各级缓存的大小必须一致。举个例子，我们会看到有CPU的一级缓存是32字节，而二级缓存却有128字节。</p><p>为了简化问题，我省略了一些内容：缓存关联性（cache associativity），缓存组（cache sets），使用分配写（write-allocate）还是非分配写（上面我描述的直写是和分配写相结合的，而回写是和非分配写相结合的），非对齐的访问（unaligned access），基于虚拟地址的缓存。如果你感兴趣，所有这些内容都可以去查查资料，但我不准备在这里讲了。</p><br><h4 id="一致性协议（Coherency-protocols）"><a href="#一致性协议（Coherency-protocols）" class="headerlink" title="一致性协议（Coherency protocols）"></a>一致性协议（Coherency protocols）</h4><p>只要系统只有一个CPU核在工作，一切都没问题。如果有多个核，每个核又都有自己的缓存，那么我们就遇到问题了：如果某个CPU缓存段中对应的内存内容被另外一个CPU偷偷改了，会发生什么？</p><p>好吧，答案很简单：什么也不会发生。这很糟糕。因为如果一个CPU缓存了某块内存，那么在其他CPU修改这块内存的时候，我们希望得到通知。我们拥有多组缓存的时候，真的需要它们保持同步。或者说，系统的内存在各个CPU之间无法做到与生俱来的同步，我们实际上是需要一个大家都能遵守的方法来达到同步的目的。</p><p>注意，这个问题的根源是我们拥有多组缓存，而不是多个CPU核。我们也可以这样解决问题，让多个CPU核共用一组缓存：也就是说只有一块一级缓存，所有处理器都必须共用它。在每一个指令周期，只有一个幸运的CPU能通过一级缓存做内存操作，运行它的指令。</p><p>这本身没问题。唯一的问题就是太慢了，因为这下处理器的时间都花在排队等待使用一级缓存了（并且处理器会做大量的这种操作，至少每个读写指令都要做一次）。我指出这一点是因为它表明了问题不是由多核引起的，而是由多缓存引起的。我们知道了只有一组缓存也能工作，只是太慢了，接下来最好就是能做到：使用多组缓存，但使它们的行为看起来就像只有一组缓存那样。缓存一致性协议就是为了做到这一点而设计的。就像名称所暗示的那样，这类协议就是要使多组缓存的内容保持一致。</p><p>缓存一致性协议有多种，但是你日常处理的大多数计算机设备使用的都属于“窥探（snooping）”协议，这也是我这里要讲的。（还有一种叫“基于目录的（directory-based）”协议，这种协议的延迟性较大，但是在拥有很多个处理器的系统中，它有更好的可扩展性。）</p><p>“窥探”背后的基本思想是，所有内存传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线：缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁（arbitrate）：同一个指令周期中，只有一个缓存可以读写内存。窥探协议的思想是，缓存不仅仅在做内存传输的时候才和总线打交道，而是不停地在窥探总线上发生的数据交换，跟踪其他缓存在做什么。所以当一个缓存代表它所属的处理器去读写内存时，其他处理器都会得到通知，它们以此来使自己的缓存保持同步。只要某个处理器一写内存，其他处理器马上就知道这块内存在它们自己的缓存中对应的段已经失效。</p><p>在直写模式下，这是很直接的，因为写操作一旦发生，它的效果马上会被“公布”出去。但是如果混着回写模式，就有问题了。因为有可能在写指令执行过后很久，数据才会被真正回写到物理内存中——在这段时间内，其他处理器的缓存也可能会傻乎乎地去写同一块内存地址，导致冲突。在回写模型中，简单把内存写操作的信息广播给其他处理器是不够的，我们需要做的是，在修改本地缓存之前，就要告知其他处理器。搞懂了细节，就找到了处理回写模式这个问题的最简单方案，我们通常叫做MESI协议（译者注：MESI是Modified、Exclusive、Shared、Invalid的首字母缩写，代表四种缓存状态，下面的译文中可能会以单个字母指代相应的状态）。</p><br><h4 id="MESI以及衍生协议"><a href="#MESI以及衍生协议" class="headerlink" title="MESI以及衍生协议"></a>MESI以及衍生协议</h4><p>本节叫做“MESI以及衍生协议”，是因为MESI衍生了一系列紧密相关的一致性协议。我们先从原生的MESI协议开始：MESI是四种缓存段状态的首字母缩写，任何多核系统中的缓存段都处于这四种状态之一。我将以相反的顺序逐个讲解，因为这个顺序更合理：</p><ul><li>失效（Invalid）缓存段，要么已经不在缓存中，要么它的内容已经过时。为了达到缓存的目的，这种状态的段将会被忽略。一旦缓存段被标记为失效，那效果就等同于它从来没被加载到缓存中。</li><li>共享（Shared）缓存段，它是和主内存内容保持一致的一份拷贝，在这种状态下的缓存段只能被读取，不能被写入。多组缓存可以同时拥有针对同一内存地址的共享缓存段，这就是名称的由来。</li><li>独占（Exclusive）缓存段，和S状态一样，也是和主内存内容保持一致的一份拷贝。区别在于，如果一个处理器持有了某个E状态的缓存段，那其他处理器就不能同时持有它，所以叫“独占”。这意味着，如果其他处理器原本也持有同一缓存段，那么它会马上变成“失效”状态。</li><li>已修改（Modified）缓存段，属于脏段，它们已经被所属的处理器修改了。如果一个段处于已修改状态，那么它在其他处理器缓存中的拷贝马上会变成失效状态，这个规律和E状态一样。此外，已修改缓存段如果被丢弃或标记为失效，那么先要把它的内容回写到内存中——这和回写模式下常规的脏段处理方式一样。</li></ul><p>如果把以上这些状态和单核系统中回写模式的缓存做对比，你会发现I、S和M状态已经有对应的概念：失效/未载入、干净以及脏的缓存段。所以这里的新知识只有E状态，代表独占式访问。这个状态解决了“在我们开始修改某块内存之前，我们需要告诉其他处理器”这一问题：只有当缓存段处于E或M状态时，处理器才能去写它，也就是说只有这两种状态下，处理器是独占这个缓存段的。当处理器想写某个缓存段时，如果它没有独占权，它必须先发送一条“我要独占权”的请求给总线，这会通知其他处理器，把它们拥有的同一缓存段的拷贝失效（如果它们有的话）。只有在获得独占权后，处理器才能开始修改数据——并且此时，这个处理器知道，这个缓存段只有一份拷贝，在我自己的缓存里，所以不会有任何冲突。</p><p>反之，如果有其他处理器想读取这个缓存段（我们马上能知道，因为我们一直在窥探总线），独占或已修改的缓存段必须先回到“共享”状态。如果是已修改的缓存段，那么还要先把内容回写到内存中。</p><p>MESI协议是一个合适的状态机，既能处理来自本地处理器的请求，也能把信息广播到总线上。我不打算讲更多关于状态图的细节以及不同的状态转换类型。如果你感兴趣的话，可以在关于硬件架构的书中找到更多的深度内容，但对于本文来说，讲这些东西有点过了。作为一个软件开发者，你只要理解以下两点，就大有可为：</p><p>第一，在多核系统中，读取某个缓存段，实际上会牵涉到和其他处理器的通讯，并且可能导致它们发生内存传输。写某个缓存段需要多个步骤：在你写任何东西之前，你首先要获得独占权，以及所请求的缓存段的当前内容的拷贝（所谓的“带权限获取的读（Read For Ownership）”请求）。</p><p>第二，尽管我们为了一致性问题做了额外的工作，但是最终结果还是非常有保证的。即它遵守以下定理，我称之为：</p><blockquote><p>MESI定律：在所有的脏缓存段（M状态）被回写后，任意缓存级别的所有缓存段中的内容，和它们对应的内存中的内容一致。此外，在任意时刻，当某个位置的内存被一个处理器加载入独占缓存段时（E状态），那它就不会再出现在其他任何处理器的缓存中。</p></blockquote><p>注意，这其实就是我们已经讲过的回写定律加上独占规则而已。我认为MESI协议或多核系统的存在根本没有弱化我们现有的内存模型。</p><p>好了，至此我们（粗略）讲了原生MESI协议（以及使用它的CPU，比如ARM）。其他处理器使用MESI扩展后的变种。常见的扩展包括“O”（Owned）状态，它和E状态类似，也是保证缓存间一致性的手段，但它直接共享脏段的内容，而不需要先把它们回写到内存中（“脏段共享”），由此产生了MOSEI协议。还有MERSI和MESIF，这两个名字代表同一种思想，即指定某个处理器专门处理针对某个缓存段的读操作。当多个处理器同时拥有某个S状态的缓存段的时候，只有被指定的那个处理器（对应的缓存段为R或F状态）才能对读操作做出回应，而不是每个处理器都能这么做。这种设计可以降低总线的数据流量。当然你可以同时加入R/F状态和O状态，或者更多的状态。这些都属于优化，没有一种会改变基本定律，也没有一种会改变MESI协议所确保的结果。</p><p>我不是这方面的专家，很有可能有系统在使用其他协议，这些协议并不能完全保证一致性，不过如果有，我没有注意到它们，或者没有看到有什么流行的处理器在使用它们。所以为了达到我们的目的，我们真的就可以假设一致性协议能保证缓存的一致性。不是基本一致，不是“写入一会儿后才能保持一致”——而是完全的一致。从这个层面上说，除非硬件有问题，内存的状态总是一致的。用技术术语来说，MESI以及它的衍生协议，至少在原理上，提供了完整的<a href="http://en.wikipedia.org/wiki/Sequential_consistency" target="_blank" rel="noopener">顺序一致性</a>（sequential consistency），在C++ 11的内存模型中，这是最强的一种确保内存顺序的模型。这也引出了问题，为什么我们需要弱一点的内存模型，以及“什么时候会用到它们”？</p><br><h5 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h5><p>不同的体系结构提供不同的内存模型。到本文写作的时候为止，ARM和POWER体系结构的机器拥有相对较弱的内存模型：这类CPU在读写指令重排序（reordering）方面有相当大的自由度，这种重排序有可能会改变程序在多核环境下的语义。通过“内存屏障（memory barrier）”，程序可以对此加以限制：“重排序操作不允许越过这条边界”。相反，x86则拥有较强的内存模型。</p><p>我不打算在这里深入到内存模型的细节中，这很容易陷入堆砌技术术语中，而且也超出了本文的范围。但是我想说一点关于“他们如何发生”的内容——也就是，弱内存模型如何保证正确性（相比较于MESI协议给缓存带来的顺序一致性），以及为什么。当然，一切都归结于性能。</p><p>规则是这样的：如果满足下面的条件，你就可以得到完全的顺序一致性：第一，缓存一收到总线事件，就可以在当前指令周期中迅速做出响应。第二，处理器如实地按程序的顺序，把内存操作指令送到缓存，并且等前一条执行完后才能发送下一条。当然，实际上现代处理器一般都无法满足以上条件：</p><ul><li>缓存不会及时响应总线事件。如果总线上发来一条消息，要使某个缓存段失效，但是如果此时缓存正在处理其他事情（比如和CPU传输数据），那这个消息可能无法在当前的指令周期中得到处理，而会进入所谓的“失效队列（invalidation queue）”，这个消息等在队列中直到缓存有空为止。</li><li>处理器一般不会严格按照程序的顺序向缓存发送内存操作指令。当然，有乱序执行（Out-of-Order execution）功能的处理器肯定是这样的。顺序执行（in-order execution）的处理器有时候也无法完全保证内存操作的顺序（比如想要的内存不在缓存中时，CPU就不能为了载入缓存而停止工作）。</li><li>写操作尤其特殊，因为它分为两阶段操作：在写之前我们先要得到缓存段的独占权。如果我们当前没有独占权，我们先要和其他处理器协商，这也需要一些时间。同理，在这种场景下让处理器闲着无所事事是一种资源浪费。实际上，写操作首先发起获得独占权的请求，然后就进入所谓的由“写缓冲（store buffer）”组成的队列（有些地方使用“写缓冲”指代整个队列，我这里使用它指代队列的一条入口）。写操作在队列中等待，直到缓存准备好处理它，此时写缓冲就被“清空（drained）”了，缓冲区被回收用于处理新的写操作。</li></ul><p>这些特性意味着，默认情况下，读操作有可能会读到过时的数据（如果对应失效请求还等在队列中没执行），写操作真正完成的时间有可能比它们在代码中的位置晚，一旦牵涉到乱序执行，一切都变得模棱两可。回到内存模型，本质上只有两大阵营：</p><p>在弱内存模型的体系结构中，处理器为了开发者能写出正确的代码而做的工作是最小化的，指令重排序和各种缓冲的步骤都是被正式允许的，也就是说没有任何保证。如果你需要确保某种结果，你需要自己插入合适的内存屏障——它能防止重排序，并且等待队列中的操作全部完成。</p><p>使用强一点的内存模型的体系结构则会在内部做很多记录工作。比如，x86会跟踪所有在等待中的内存操作，这些操作都还没有完全完成（称为“退休（retired）”）。它会把它们的信息保存在芯片内部的MOB（“memory ordering buffer”，内存排序缓冲）。x86作为部分支持乱序执行的体系结构，在出问题的时候能把尚未“退休”的指令撤销掉——比如发生页错误（page fault），或者分支预测失败（branch mispredict）的时候。我已经在我以前的文章“<a href="http://fgiesen.wordpress.com/2013/03/04/speculatively-speaking/" target="_blank" rel="noopener">好奇地说</a>”中提到过一些细节，以及和内存子系统的一些交互。主旨是x86处理器会主动地监控外部事件（比如缓存失效），有些已经执行完的操作会因为这些事件而被撤销，但不算“退休”。这就是说，x86知道自己的内存模型应该是什么样子的，当发生了一件和这个模型冲突的事，处理器会回退到上一个与内存模型兼容的状态。这就是我在以前<a href="http://fgiesen.wordpress.com/2013/01/31/cores-dont-like-to-share/" target="_blank" rel="noopener">另一篇文章</a>中提到的“清除内存排序机（memory ordering machine clear）”。最后的结果是，x86处理器为内存操作提供了很强的一致性保证——虽然没有达到完美的顺序一致性。</p><p>无论如何，一篇文章讲这么多已经够了。我把它放在我的博客上。我的想法是将来的文章只要引用它就行了。我们看效果吧。感谢阅读！</p><p>英文原文：<a href="http://fgiesen.wordpress.com/2014/07/07/cache-coherency/" target="_blank" rel="noopener">http://fgiesen.wordpress.com/2014/07/07/cache-coherency/</a></p><p><strong>文章来源</strong><br><a href="http://www.infoq.com/cn/articles/cache-coherency-primer" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/cache-coherency-primer</a></p>]]></content>
      
      
      <categories>
          
          <category> Operating System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Memory Allocation Contention</title>
      <link href="/Operating-System/os-memory-allocation-contention/"/>
      <url>/Operating-System/os-memory-allocation-contention/</url>
      
        <content type="html"><![CDATA[<p>How much of a bottleneck is memory allocation/deallocation in typical real-world programs? Answers from any type of program where performance typically matters are welcome. Are decent implementations of malloc/free/garbage collection fast enough that it’s only a bottleneck in a few corner cases, or would most performance-critical software benefit significantly from trying to keep the amount of memory allocations down or having a faster malloc/free/garbage collection implementation?</p><p>Note: I’m not talking about real-time stuff here. By performance-critical, I mean stuff where throughput matters, but latency doesn’t necessarily.</p><p>Edit: Although I mention malloc, this question is not intended to be C/C++ specific.</p><p>It’s significant, especially as fragmentation grows and the allocator has to hunt harder across larger heaps for the contiguous regions you request. Most performance-sensitive applications typically write their own fixed-size block allocators (eg, they ask the OS for memory 16MB at a time and then parcel it out in fixed blocks of 4kb, 16kb, etc) to avoid this issue.</p><p>In games I’ve seen calls to malloc()/free() consume as much as 15% of the CPU (in poorly written products), or with carefully written and optimized block allocators, as little as 5%. Given that a game has to have a consistent throughput of sixty hertz, having it stall for 500ms while a garbage collector runs occasionally isn’t practical.</p><p>for long running applications, fragmentation is the biggest allocaiton problem.</p><p>“Long running”, nor “Heap-y” aren’t great indicators of heap performance. Like using CPU caches well, technique is. My financial simulations ran for ~ 8hrs, but objects were allocated high up in the call tree, so used billions of times, but allocated once. 99% memory was from the heap. Microsoft used to support multiple heaps (maybe still does) for a single process, so a tree and a linked list could allocate their own sizes and avoid the fragmentation that would result otherwise. Likewise, keeping allocations per heap multiples of some basic unit size helps. These 2 cannons help a lot.</p><p>Stack usage is more about the lifetime of the object than performance. Performance is identical in a well-constructed program. Stack allocation does make for easy cleanup when you exit the scope. _alloca() is a nice cheat for dynamic memory allocation from the stack, but except for easy cleanup, and maybe preventing fragmentation, has no advantage over malloc().<br><a href="https://caligari.dartmouth.edu/doc/ibmcxx/en_US/doc/libref/concepts/cumemmng.htm" target="_blank" rel="noopener">https://caligari.dartmouth.edu/doc/ibmcxx/en_US/doc/libref/concepts/cumemmng.htm</a></p><p>Nearly every high performance application now has to use threads to exploit parallel computation. This is where the real memory allocation speed killer comes in when writing C/C++ applications.</p><p>In a C or C++ application, malloc/new must take a lock on the global heap for every operation. Even without contention locks are far from free and should be avoided as much as possible.</p><p>Java and C# are better at this because threading was designed in from the start and the memory allocators work from per-thread pools. This can be done in C/C++ as well, but it isn’t automatic.</p><p>First off, since you said malloc, I assume you’re talking about C or C++.</p><p>Memory allocation and deallocation tend to be a significant bottleneck for real-world programs. A lot goes on “under the hood” when you allocate or deallocate memory, and all of it is system-specific; memory may actually be moved or defragmented, pages may be reorganized–there’s no platform-independent way way to know what the impact will be. Some systems (like a lot of game consoles) also don’t do memory defragmentation, so on those systems, you’ll start to get out-of-memory errors as memory becomes fragmented.</p><p>A typical workaround is to allocate as much memory up front as possible, and hang on to it until your program exits. You can either use that memory to store big monolithic sets of data, or use a memory pool implementation to dole it out in chunks. Many C/C++ standard library implementations do a certain amount of memory pooling themselves for just this reason.</p><p>No two ways about it, though–if you have a time-sensitive C/C++ program, doing a lot of memory allocation/deallocation will kill performance.</p><p>In general the cost of memory allocation is probably dwarfed by lock contention, algorithmic complexity, or other performance issues in most applications. In general, I’d say this is probably not in the top-10 of performance issues I’d worry about.</p><p>Now, grabbing very large chunks of memory might be an issue. And grabbing but not properly getting rid of memory is something I’d worry about.</p><p>In Java and JVM-based languages, new’ing objects is now very, very, very fast.</p><p>Here’s one decent article by a guy who knows his stuff with some references at the bottom to more related links: <a href="http://www.ibm.com/developerworks/java/library/j-jtp09275.html" target="_blank" rel="noopener">http://www.ibm.com/developerworks/java/library/j-jtp09275.html</a></p><p>In Java (and potentially other languages with a decent GC implementation) allocating an object is very cheap. In the SUN JVM it only needs 10 CPU Cycles. A malloc in C/c++ is much more expensive, just because it has to do more work.</p><p>Still even allocation objects in Java is very cheap, doing so for a lot of users of a web application in parallel can still lead to performance problems, because more Garbage Collector runs will be triggered. Therefore there are those indirect costs of an allocation in Java caused by the deallocation done by the GC. These costs are difficult to quantify because they depend very much on your setup (how much memory do you have) and your application.</p><p>Regards, Markus (<a href="http://kohlerm.blogspot.com/" target="_blank" rel="noopener">http://kohlerm.blogspot.com/</a>)</p><p><a href="http://stackoverflow.com/questions/470683/memory-allocation-deallocation-bottleneck" target="_blank" rel="noopener">http://stackoverflow.com/questions/470683/memory-allocation-deallocation-bottleneck</a></p>]]></content>
      
      
      <categories>
          
          <category> Operating System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CRTP, Curiously Recurring Template Pattern</title>
      <link href="/Programming/cpp-crtp/"/>
      <url>/Programming/cpp-crtp/</url>
      
        <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><hr><p>什么是 CRTP？其英文全称是 Curiously Recurring Template Pattern，最早是由 James Coplien 在 1995 年提出的一个高级 C++ 编程技术，后来在 Stanley B. Lippman 写的 Cpp Gems 一书中也介绍了它的实践。中文翻译过来是“奇特的模板递归模式”，很拗口，如果是第一次接触 C++ 的这个高级特性，肯定会被这个名称弄得云里雾里，这篇文章我就来详细讲述下 CRTP 的原理和应用。</p><p>从表现形式上来说，在 CRTP 中，派生类继承基类的时候把自身作为基类的模板参数，派生类继承这个模板基类之后，就可以用基类类型的指针指向派生类，并且能够正确调用到派生类的函数。<strong>这里注意：基类必须是一个模板类，而派生类可以是，也可以不是。</strong><br>例如：</p><p>（1）基类是模板类，模板参数是普通类型；派生类是非模板类。继承时，派生类 D 作为基类的模板参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base&lt;D&lt;T&gt;&gt; &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（2）基类是模板类，模板参数是普通类型；派生类是非模板类。继承时，带模板参数的派生类 D<t> 作为基类的模板参数</t></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base&lt;D&lt;T&gt;&gt; &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（3）基类是模板类，模板参数是模板的模板，派生类是非模板类。继承时，派生类 D 作为基类的模板参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Base</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base&lt;D&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><p>当然，上述两段代码片段只是简单展示了 CRTP 模式的一些声明方式，远远没有展示 CRTP 的精髓所在，这部分在后文将继续阐述。</p><h3 id="二、CRTP-有什么优势？"><a href="#二、CRTP-有什么优势？" class="headerlink" title="二、CRTP 有什么优势？"></a>二、CRTP 有什么优势？</h3><p>要理解为什么 CRTP 有用以及能用在什么地方，我们需要从 C++ 的本质说起。我们知道，要对原有的一个类进行功能上的扩展，在不进行修改的情况下，主要有两种方式，它们都是通过继承机制来实现。一是通过虚函数来实现多态；二是通过 模板继承（ mixin 技术），实现自身扩展。</p><p>先讲虚函数实现的多态机制，多态是 C++ 实现类功能扩展的一个重大特性，大部分编译器都是通过虚函数表（vtbl）和虚函数表指针（vptr）来实现晚绑定 late binding。这样，虚函数在被调用的时候，具体执行的代码能够找到对应的对象的动态类型，从而调用正确的函数。在这里，虚表和虚表指针的使用都必然增加一部分开销，首先，内存占用上，虚表通常需要占用不超过 128 字节的内存，而一个虚指针通常也要占用 8 字节的内存，而虚指针的间接函数调用在高频率的调用中由于多增加的 cpu 指令和内存访问，也会对性能有影响。</p><p>再来看看 minix，mixin 是通过一种在调用时组合不同模板参数的方式来达到扩展的技术，比如：<code>A&lt;B&lt;C&lt;T&gt;&gt;&gt; obj;</code><br>其主要是通过先定义几个非模板的基类，然后定义派生类继承一个模板参数（如：template<class base=""> class Derived1 : public Base {}），这样，派生类在实例化的时候把基类类型作为模板参数进行实例化即可。mixin 通过模板参数的方式把基类和派生类联系在了一起，我们可以通过定义多个不同的派生类，然后按照上面提到的层层嵌套模板参数的方式调用，可以达到在同一个基类上组合多个派生类的效果，就想层叠蛋糕一样。mixin 的缺陷也很明显，就是需要大量多层次扩展的时候，一旦嵌套过深，可读性非常不好。而且也只适合单一的堆叠增加功能，不适合动态改变功能。</class></p><p>mixin 和虚函数一样，对类的扩展，都是从派生类为入口的，通过派生类来实现不同的功能从而进行扩展。具体方式就是从基类开始一层一层的派生，一直到最终的派生类，层层的继承和扩展。从派生类中调用基类的函数，是很显然的，因为派生类就包含了基类的信息。</p><p>回到 CRTP，由于 CRTP 不使用虚函数，那么让基类调用派生类函数的唯一方法，就是让基类知道派生类的信息。这样，在实例化一个基类类型的对象时，就可以通过给基类不同的的模板参数的方式进行扩展基类的功能了。调用时，把基类 down cast 强制转换成派生类，就可以调用派生类的函数了。这种通过把基类定义成一个类模板，并且把派生类作为模板参数传递给基类，然后通过指针静态转换的方式来达到扩展类功能的技巧，就是 CRTP 的精妙之处所在！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;bar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&lt;B&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>T 就是派生类，在定义时只是一个模板参数，而当定义 class B 时，继承了 A ，并把 B 作为模板参数传递到了 A。<br>在调用 foo() 时，自然就调到了 B 的 bar() 函数。<br>这里，由于 A 是 B 的基类，所以 A 的指针静态转换（Down Cast）成 B 会成功。这就保证的安全性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A&lt;C&gt; &#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，在 main 函数中我们实例化 C，并且如下方式调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    c.foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这段代码看上去有些奇怪，这里的 <code>c.foo()</code>，它会成功吗？如果成功那么它会调用哪个 bar？<br>我们知道，由于 A 是 C 的基类，在派生类 C 中，没有定义 foo 函数，那么默认就会调用基类 A 中的 foo 函数，这就有点虚函数的感觉了。当然，如果基类也没有定义该函数，那么编译会报错。简单来说，派生类定义了该函数，其就被调用，不定义，就使用基类的该函数。<br>在这里，基类的 foo 函数中有一个静态转换，foo() 函数中调用了派生类的 bar 函数。有两种情况：</p><ul><li>如果派生类没有定义 bar 函数，那么基类的 bar 函数会被调用</li><li>如果派生类定义了 bar 函数，那么派生类的 bar 函数会被调用</li></ul><p>看到了吗？ 这几乎完完全全达到了虚函数所实现的同样的效果！最重要的是，还没有虚函数的开销！这得益于它的静态编译。<br>那么，现在来看看 CRTP 具体的应用场景，有了 CRTP，我们可以把一个功能分成很细的粒度，每步都做成 down cast 调用，并且每步都有默认处理（inline的），用户想在哪步修改逻辑，就把哪步抓出来覆盖。这个是虚函数不可能做到的。就像一个链条，每步都可以修改。</p><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;major();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">major</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;minor1();</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;minor2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">minor1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;step1();</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;step2();</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;step3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">minor2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;step4();</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;step5();</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;step6();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step1</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step3</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step4</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step5</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step6</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>function() 是整个功能的入口，里面调用了 major，major 的默认处理调用了 minor1, minor2。minor1, minor2 分别调用了各个 step，<br>这就是整个骨架，你可以抓出某个 step 改写，也可以抓出 minor 改写，甚至抓出 major 改写。控制粒度可以从“整个”到“极细”。<br>而整个类 A 只是提供一套 CRTP 给你改写“皮肤”，“肌肉”，“骨架”的规则。这就是 CRTP 的神奇所在。</p><h3 id="三、CRTP-的应用"><a href="#三、CRTP-的应用" class="headerlink" title="三、CRTP 的应用"></a>三、CRTP 的应用</h3><hr><p>下面再列举一个 CRTP 一个具体的应用，这个例子展示了如何记录某个类对象构造的总个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CountedType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectCounter</span>&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> count;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ObjectCounter()&#123; ++ObjectCounter&lt;CountedType&gt;::count; &#125; <span class="comment">// 声明为 protected，防止生成对象，限定只能被继承</span></span><br><span class="line">    ObjectCounter(<span class="keyword">const</span> ObjectCounter&lt;CountedType&gt;&amp;)&#123; ++ObjectCounter&lt;CountedType&gt;::count; &#125;</span><br><span class="line">    ~ObjectCounter()&#123; --count; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">getCount</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> ObjectCounter&lt;CountedType&gt;::count; &#125; <span class="comment">// 作为静态函数，类方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> CountedType&gt;</span><br><span class="line"><span class="keyword">size_t</span> ObjectCounter&lt;CountedType&gt;::count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> :</span> <span class="keyword">public</span> ObjectCounter&lt;MyString&lt;T&gt; &gt;&#123;&#125;; <span class="comment">// CRTP</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyString&lt;<span class="keyword">char</span>&gt; s1, s2;</span><br><span class="line">    MyString&lt;<span class="keyword">wchar_t</span>&gt; ws;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"MyString&lt;char&gt;:"</span>&lt;&lt; MyString&lt;<span class="keyword">char</span>&gt;::getCount()&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//输出2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"MyString&lt;wchar_t&gt;:"</span>&lt;&lt; MyString&lt;<span class="keyword">wchar_t</span>&gt;::getCount() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//输出1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CRTP-与-虚函数的总结比较"><a href="#CRTP-与-虚函数的总结比较" class="headerlink" title="CRTP 与 虚函数的总结比较"></a>CRTP 与 虚函数的总结比较</h3><hr><ul><li><p>虚函数是实现动态绑定（运行时绑定），CRTP 则是实现静态绑定（编译时绑定）</p></li><li><p>虚函数的优点是基类不需要知道派生类的信息，只管调用虚函数就是，这个得益于虚函数的“晚捆绑”实现机制。</p></li><li><p>虚函数的“晚捆绑”特性由于是运行时才进行，因此有一定的空间开销和运行开销。</p></li><li><p>而 CRTP 正好相反，它不使用“晚捆绑”机制，因此没有这些开销，但缺点是基类需要知道派生类的信息，才能调用派生类的函数，但是派生类是不可预料的。因此它使用的场景相对来说受限。</p></li><li><p>在实现多态时，需要重写虚函数，因而这是运行时绑定的操作。</p></li><li><p>然而如果想在编译期确定通过基类来得到派生类的行为，CRTP 便是最佳选择，它是通过派生类覆盖基类成员函数来实现静态绑定的。</p></li></ul><br>##### 参考---[C++ Gems][]]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Difference between select, poll and epoll</title>
      <link href="/Programming/network-programming-diff-select-poll-epoll/"/>
      <url>/Programming/network-programming-diff-select-poll-epoll/</url>
      
        <content type="html"><![CDATA[<p>本文总结 select, poll, epoll 之间的区别</p><p>select，poll，epoll 都是 IO 多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。关于这三种IO多路复用的用法，前面三篇总结写的很清楚，并用服务器回射echo程序进行了测试。</p><p>本文对这三种 IO多路复用进行对比：</p><br><h4 id="select-实现"><a href="#select-实现" class="headerlink" title="select 实现"></a>select 实现</h4><p><span class="blueBold">select的调用过程如下所示：</span><br><img src="http://images.cnitblog.com/blog/305504/201308/17201205-8ac47f1f1fcd4773bd4edd947c0bb1f4.png" alt=""></p><p>（1）使用 copy_from_user 从用户空间拷贝 fd_set 到内核空间<br>（2）注册回调函数<strong>pollwait<br>（3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）<br>（4）以 tcp_poll 为例，其核心实现就是</strong>pollwait，也就是上面注册的回调函数。<br>（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。<br>（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。<br>（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。<br>（8）把fd_set从内核空间拷贝到用户空间。</p><p><strong>总结：</strong></p><p>select 的几大缺点：</p><p>（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大<br>（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大<br>（3）select支持的文件描述符数量太小了，默认是1024</p><br><h4 id="poll-实现"><a href="#poll-实现" class="headerlink" title="poll 实现"></a>poll 实现</h4><p>　　poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，其他的都差不多。</p><p>关于 select 和 poll 更详细的实现分析，可以参考下面几篇博文：</p><p><a href="http://blog.csdn.net/lizhiguo0532/article/details/6568964#comments" target="_blank" rel="noopener">http://blog.csdn.net/lizhiguo0532/article/details/6568964#comments</a><br><a href="http://blog.csdn.net/lizhiguo0532/article/details/6568968" target="_blank" rel="noopener">http://blog.csdn.net/lizhiguo0532/article/details/6568968</a><br><a href="http://blog.csdn.net/lizhiguo0532/article/details/6568969" target="_blank" rel="noopener">http://blog.csdn.net/lizhiguo0532/article/details/6568969</a><br><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-edntwk/index.html?ca=drs-" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/linux/l-cn-edntwk/index.html?ca=drs-</a><br><a href="http://linux.chinaunix.net/techdoc/net/2009/05/03/1109887.shtml" target="_blank" rel="noopener">http://linux.chinaunix.net/techdoc/net/2009/05/03/1109887.shtml</a></p><br><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。</p><p>对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</p><p>对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。</p><p>对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</p><p><strong>总结：</strong></p><p>（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p><p>（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p><p>相关文章：<br>select：<a href="http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html" target="_blank" rel="noopener">http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html</a><br>poll：<a href="http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html" target="_blank" rel="noopener">http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html</a><br>epoll：<a href="http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html" target="_blank" rel="noopener">http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html</a></p><br><br><br><p>参考<br><a href="http://www.cnblogs.com/apprentice89/archive/2013/05/09/3070051.html" target="_blank" rel="noopener">http://www.cnblogs.com/apprentice89/archive/2013/05/09/3070051.html</a><br><a href="http://www.linuxidc.com/Linux/2012-05/59873p3.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2012-05/59873p3.htm</a><br><a href="http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/" target="_blank" rel="noopener">http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/</a><br><a href="http://blog.csdn.net/kkxgx/article/details/7717125" target="_blank" rel="noopener">http://blog.csdn.net/kkxgx/article/details/7717125</a><br><a href="https://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/epoll-example.c" target="_blank" rel="noopener">https://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/epoll-example.c</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Use epoll to multiplexing network connections</title>
      <link href="/Programming/network-programming-epoll/"/>
      <url>/Programming/network-programming-epoll/</url>
      
        <content type="html"><![CDATA[<br><h4 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h4><p>epoll 是在 2.6内核中提出的，是之前的 select 和 poll 的增强版本。相对于 select 和 poll 来说，epoll 更加灵活，没有描述符限制。<br>epoll 使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。</p><h4 id="epoll接口"><a href="#epoll接口" class="headerlink" title="epoll接口"></a>epoll接口</h4><p>epoll操作过程需要三个接口，分别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>（1） int epoll_create(int size);</strong><br>创建一个 epoll 的句柄，size 用来告诉内核这个监听的数目一共有多大。这个参数不同于 select() 中的第一个参数，给出最大监听的 fd + 1 的值。需要注意的是，当创建好 epoll 句柄后，它就是会占用一个 fd 值，在 Linux 下如果查看 /proc/ 进程 id/fd/，是能够看到这个 fd 的，所以在使用完 epoll 后，必须调用 close() 关闭，否则可能导致 fd 被耗尽。</p><p><strong>（2）int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</strong></p><p>epoll 的事件注册函数，它不同与 select() 是在监听事件时告诉内核要监听什么类型的事件 epoll 的事件注册函数，它不同与 select() 是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。第一个参数是 epoll_create() 的返回值，第二个参数表示动作，用三个宏来表示：</p><pre><code>EPOLL_CTL_ADD：注册新的 fd 到 epfd 中；EPOLL_CTL_MOD：修改已经注册的 fd 的监听事件；EPOLL_CTL_DEL：从 epfd 中删除一个 fd；</code></pre><p>第三个参数是需要监听的 fd，第四个参数是告诉内核需要监听什么事，struct epoll_event 结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">__uint32_t</span> events;  <span class="comment">// Epoll events</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;  <span class="comment">// User data variable</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>events 可以是以下几个宏的集合：</p><pre><code>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；EPOLLOUT：表示对应的文件描述符可以写；EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；EPOLLERR：表示对应的文件描述符发生错误；EPOLLHUP：表示对应的文件描述符被挂断；EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</code></pre><p><strong>（3） int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong><br>等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p><p>3、工作模式<br>epoll 对文件描述符的操作有两种模式：LT（level trigger）和 ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：</p><pre><code>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</code></pre><br>#### 测试程序<p>以下程序展示 epoll 的使用。</p><p>服务端代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPADDRESS   <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT        8787</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE     1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ     5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FDSIZE      1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLEVENTS 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="comment">//创建套接字并进行绑定</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">socket_bind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ip,<span class="keyword">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IO多路复用epoll</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_epoll</span><span class="params">(<span class="keyword">int</span> listenfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件处理函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">handle_events(<span class="keyword">int</span> epollfd,struct epoll_event *events,<span class="keyword">int</span> num,<span class="keyword">int</span> listenfd,<span class="keyword">char</span> *buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理接收到的连接</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_accpet</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> listenfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  listenfd;</span><br><span class="line">    listenfd = socket_bind(IPADDRESS,PORT);</span><br><span class="line">    listen(listenfd,LISTENQ);</span><br><span class="line">    do_epoll(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">socket_bind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ip,<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  listenfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    listenfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd == <span class="number">-1</span>)    &#123;</span><br><span class="line">        perror(<span class="string">"socket error:"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bzero(&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET,ip,&amp;servaddr.sin_addr);</span><br><span class="line">    servaddr.sin_port = htons(port);</span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd,(struct sockaddr*)&amp;servaddr,<span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"bind error: "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_epoll</span><span class="params">(<span class="keyword">int</span> listenfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> epollfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EPOLLEVENTS</span>];</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,MAXSIZE);</span><br><span class="line">    <span class="comment">//创建一个描述符</span></span><br><span class="line">    epollfd = epoll_create(FDSIZE);</span><br><span class="line">    <span class="comment">//添加监听描述符事件</span></span><br><span class="line">    add_event(epollfd,listenfd,EPOLLIN);</span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">        <span class="comment">//获取已经准备好的描述符事件</span></span><br><span class="line">        ret = epoll_wait(epollfd,events,EPOLLEVENTS,<span class="number">-1</span>);</span><br><span class="line">        handle_events(epollfd,events,ret,listenfd,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    close(epollfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_events</span><span class="params">(<span class="keyword">int</span> epollfd,struct epoll_event *events,<span class="keyword">int</span> num,<span class="keyword">int</span> listenfd,<span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">//进行选好遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">        fd = events[i].data.fd;</span><br><span class="line">        <span class="comment">//根据描述符的类型和事件类型进行处理</span></span><br><span class="line">        <span class="keyword">if</span> ((fd == listenfd) &amp;&amp;(events[i].events &amp; EPOLLIN))</span><br><span class="line">            handle_accpet(epollfd,listenfd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">            do_read(epollfd,fd,buf);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">            do_write(epollfd,fd,buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_accpet</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> listenfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clifd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span>  cliaddrlen;</span><br><span class="line">    clifd = accept(listenfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen);</span><br><span class="line">    <span class="keyword">if</span> (clifd == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">"accpet error:"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"accept a new client: %s:%d\n"</span>,inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port);</span><br><span class="line">        <span class="comment">//添加一个客户描述符和事件</span></span><br><span class="line">        add_event(epollfd,clifd,EPOLLIN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nread;</span><br><span class="line">    nread = read(fd,buf,MAXSIZE);</span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"read error:"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        delete_event(epollfd,fd,EPOLLIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"client close.\n"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        delete_event(epollfd,fd,EPOLLIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read message is : %s"</span>,buf);</span><br><span class="line">        <span class="comment">//修改描述符对应的事件，由读改为写</span></span><br><span class="line">        modify_event(epollfd,fd,EPOLLOUT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nwrite;</span><br><span class="line">    nwrite = write(fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="keyword">if</span> (nwrite == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"write error:"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        delete_event(epollfd,fd,EPOLLOUT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        modify_event(epollfd,fd,EPOLLIN);</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,MAXSIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端也用使用 epoll 来实现，控制 <code>STDIN_FILENO</code>、<code>STDOUT_FILENO</code>、和 <code>sockfd</code> 三个描述符，程序如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE     1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPADDRESS   <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT   8787</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FDSIZE      1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLEVENTS 20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_connection</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">handle_events(<span class="keyword">int</span> epollfd,struct epoll_event *events,<span class="keyword">int</span> num,<span class="keyword">int</span> sockfd,<span class="keyword">char</span> *buf);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> sockfd,<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> sockfd,<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> sockfd,<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>                 sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>  <span class="title">servaddr</span>;</span></span><br><span class="line">    sockfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    bzero(&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    inet_pton(AF_INET,IPADDRESS,&amp;servaddr.sin_addr);</span><br><span class="line">    connect(sockfd,(struct sockaddr*)&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    <span class="comment">//处理连接</span></span><br><span class="line">    handle_connection(sockfd);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_connection</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> epollfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EPOLLEVENTS</span>];</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    epollfd = epoll_create(FDSIZE);</span><br><span class="line">    add_event(epollfd,STDIN_FILENO,EPOLLIN);</span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">        ret = epoll_wait(epollfd,events,EPOLLEVENTS,<span class="number">-1</span>);</span><br><span class="line">        handle_events(epollfd,events,ret,sockfd,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    close(epollfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_events</span><span class="params">(<span class="keyword">int</span> epollfd,struct epoll_event *events,<span class="keyword">int</span> num,<span class="keyword">int</span> sockfd,<span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; num;i++) &#123;</span><br><span class="line">        fd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">            do_read(epollfd,fd,sockfd,buf);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">            do_write(epollfd,fd,sockfd,buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> sockfd,<span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nread;</span><br><span class="line">    nread = read(fd,buf,MAXSIZE);</span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"read error:"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"server close.\n"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fd == STDIN_FILENO)</span><br><span class="line">            add_event(epollfd,sockfd,EPOLLOUT);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            delete_event(epollfd,sockfd,EPOLLIN);</span><br><span class="line">            add_event(epollfd,STDOUT_FILENO,EPOLLOUT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> sockfd,<span class="keyword">char</span> *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nwrite;</span><br><span class="line">    nwrite = write(fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="keyword">if</span> (nwrite == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"write error:"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fd == STDOUT_FILENO)</span><br><span class="line">            delete_event(epollfd,fd,EPOLLOUT);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            modify_event(epollfd,fd,EPOLLIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,MAXSIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、测试结果</p><p><img src="http://images.cnitblog.com/blog/305504/201308/17013658-d6aa0df188b24c6da6759c4c611570b3.png" alt=""><br><img src="http://images.cnitblog.com/blog/305504/201308/17013713-0bd444572e064c8e80d58d6221277eb4.png" alt=""><br><img src="http://images.cnitblog.com/blog/305504/201308/17013723-571312abdc2945a68016a080690fc3fb.png" alt=""></p><br><br><br><p><strong>本文来源</strong><br><a href="http://www.cnblogs.com/Anker/p/3263780.html" target="_blank" rel="noopener">http://www.cnblogs.com/Anker/p/3263780.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Use poll to multiplexing network connections</title>
      <link href="/Programming/network-programming-poll/"/>
      <url>/Programming/network-programming-poll/</url>
      
        <content type="html"><![CDATA[<br>#### 基本知识<p>poll 的机制与 select 类似，与 select 在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。<br>poll 和 select 同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p><br>#### poll 函数<p>函数格式如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">( struct pollfd * fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>pollfd 结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd;         <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">short</span> events;   <span class="comment">// 等待的事件</span></span><br><span class="line">    <span class="keyword">short</span> revents;  <span class="comment">// 实际发生了的事件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每一个pollfd结构体指定了一个被监视的文件描述符，可以传递多个结构体，指示poll()监视多个文件描述符。<br>每个结构体的events域是监视该文件描述符的事件掩码，由用户来设置这个域。revents 域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域。<br>events 域中请求的任何事件都可能在revents域中返回。合法的事件如下：</p><pre><code>POLLIN 　　　　　　　有数据可读。POLLRDNORM 　　　　  有普通数据可读。POLLRDBAND　　　　　 有优先数据可读。POLLPRI　　　　　　　有紧迫数据可读。POLLOUT　　　　　　  写数据不会导致阻塞。POLLWRNORM　　　　　 写普通数据不会导致阻塞。POLLWRBAND　　　　　 写优先数据不会导致阻塞。POLLMSGSIGPOLL 　　  消息可用。此外，revents 域中还可能返回下列事件：POLLER　　  指定的文件描述符发生错误。POLLHUP　　 指定的文件描述符挂起事件。POLLNVAL　　指定的文件描述符非法。</code></pre><p>这些事件在events域中无意义，因为它们在合适的时候总是会从revents中返回。</p><p>使用 poll() 和 select() 不一样，不需要显式地请求异常情况报告。<br>POLLIN | POLLPRI等价于select()的读事件，POLLOUT |POLLWRBAND等价于select()的写事件。POLLIN等价于POLLRDNORM |POLLRDBAND，而POLLOUT则等价于POLLWRNORM。<br>例如，要同时监视一个文件描述符是否可读和可写，我们可以设置 events为POLLIN |POLLOUT。在poll返回时，我们可以检查revents中的标志，对应于文件描述符请求的events结构体。如果POLLIN事件被设置，则文件描述符可以被读取而不阻塞。如果POLLOUT被设置，则文件描述符可以写入而不导致阻塞。这些标志并不是互斥的：它们可能被同时设置，表示这个文件描述符的读取和写入操作都会正常返回而不阻塞。</p><p>timeout 参数指定等待的毫秒数，无论I/O是否准备好，poll都会返回。timeout指定为负数值表示无限超时，使poll()一直挂起直到一个指定事件发生；timeout为0指示poll调用立即返回并列出准备好I/O的文件描述符，但并不等待其它的事件。这种情况下，poll()就像它的名字那样，一旦选举出来，立即返回。</p><p><strong>返回值和错误代码</strong><br>成功时，poll()返回结构体中revents域不为0的文件描述符个数；如果在超时前没有任何事件发生，poll()返回0；失败时，poll()返回-1，并设置errno为下列值之一：</p><pre><code>EBADF　　     一个或多个结构体中指定的文件描述符无效。EFAULTfds　　 指针指向的地址超出进程的地址空间。EINTR　　　　 请求的事件之前产生一个信号，调用可以重新发起。EINVALnfds　　参数超出PLIMIT_NOFILE值。ENOMEM　　    可用内存不足，无法完成请求。</code></pre><br><h4 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h4><p>编写一个echo server程序，功能是客户端向服务器发送信息，服务器接收输出并原样发送回给客户端，客户端接收到输出到终端。</p><p>服务器端程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPADDRESS   <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT        8787</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE     1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ     5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX    1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFTIM      -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="comment">//创建套接字并进行绑定</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">socket_bind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ip,<span class="keyword">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IO多路复用poll</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_poll</span><span class="params">(<span class="keyword">int</span> listenfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理多个连接</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_connection</span><span class="params">(struct pollfd *connfds,<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  listenfd,connfd,sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> cliaddrlen;</span><br><span class="line">    listenfd = socket_bind(IPADDRESS,PORT);</span><br><span class="line">    listen(listenfd,LISTENQ);</span><br><span class="line">    do_poll(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">socket_bind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ip,<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  listenfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    listenfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket error:"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bzero(&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET,ip,&amp;servaddr.sin_addr);</span><br><span class="line">    servaddr.sin_port = htons(port);</span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd,(struct sockaddr*)&amp;servaddr,<span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind error: "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listenfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_poll</span><span class="params">(<span class="keyword">int</span> listenfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  connfd,sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> cliaddrlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">clientfds</span>[<span class="title">OPEN_MAX</span>];</span></span><br><span class="line">    <span class="keyword">int</span> maxi;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> nready;</span><br><span class="line">    <span class="comment">//添加监听描述符</span></span><br><span class="line">    clientfds[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">    clientfds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">    <span class="comment">//初始化客户连接描述符</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>;i &lt; OPEN_MAX;i++)</span><br><span class="line">        clientfds[i].fd = <span class="number">-1</span>;</span><br><span class="line">    maxi = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环处理</span></span><br><span class="line">    <span class="keyword">for</span> ( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取可用描述符的个数</span></span><br><span class="line">        nready = poll(clientfds,maxi+<span class="number">1</span>,INFTIM);</span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"poll error:"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//测试监听描述符是否准备好</span></span><br><span class="line">        <span class="keyword">if</span> (clientfds[<span class="number">0</span>].revents &amp; POLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            cliaddrlen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">            <span class="comment">//接受新的连接</span></span><br><span class="line">            <span class="keyword">if</span> ((connfd = accept(listenfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen)) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                   perror(<span class="string">"accept error:"</span>);</span><br><span class="line">                   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"accept a new client: %s:%d\n"</span>, inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port);</span><br><span class="line">            <span class="comment">//将新的连接描述符添加到数组中</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>;i &lt; OPEN_MAX;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (clientfds[i].fd &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    clientfds[i].fd = connfd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == OPEN_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"too many clients.\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将新的描述符添加到读描述符集合中</span></span><br><span class="line">            clientfds[i].events = POLLIN;</span><br><span class="line">            <span class="comment">//记录客户连接套接字的个数</span></span><br><span class="line">            maxi = (i &gt; maxi ? i : maxi);</span><br><span class="line">            <span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理客户连接</span></span><br><span class="line">        handle_connection(clientfds,maxi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_connection</span><span class="params">(struct pollfd *connfds,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,MAXLINE);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>;i &lt;= num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (connfds[i].fd &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//测试客户描述符是否准备好</span></span><br><span class="line">        <span class="keyword">if</span> (connfds[i].revents &amp; POLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//接收客户端发送的信息</span></span><br><span class="line">            n = read(connfds[i].fd,buf,MAXLINE);</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                close(connfds[i].fd);</span><br><span class="line">                connfds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// printf("read msg is: ");</span></span><br><span class="line">            write(STDOUT_FILENO,buf,n);</span><br><span class="line">            <span class="comment">//向客户端发送buf</span></span><br><span class="line">            write(connfds[i].fd,buf,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE     1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPADDRESS   <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT   8787</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a &gt; b) ? a : b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_connection</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>                 sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>  <span class="title">servaddr</span>;</span></span><br><span class="line">    sockfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    bzero(&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    inet_pton(AF_INET,IPADDRESS,&amp;servaddr.sin_addr);</span><br><span class="line">    connect(sockfd,(struct sockaddr*)&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    <span class="comment">//处理连接描述符</span></span><br><span class="line">    handle_connection(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_connection</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>    sendline[MAXLINE],recvline[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span>     maxfdp,stdineof;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfds</span>[2];</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">//添加连接描述符</span></span><br><span class="line">    pfds[<span class="number">0</span>].fd = sockfd;</span><br><span class="line">    pfds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">    <span class="comment">//添加标准输入描述符</span></span><br><span class="line">    pfds[<span class="number">1</span>].fd = STDIN_FILENO;</span><br><span class="line">    pfds[<span class="number">1</span>].events = POLLIN;</span><br><span class="line">    <span class="keyword">for</span> (; ;)</span><br><span class="line">    &#123;</span><br><span class="line">        poll(pfds,<span class="number">2</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pfds[<span class="number">0</span>].revents &amp; POLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            n = read(sockfd,recvline,MAXLINE);</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"client: server is closed.\n"</span>);</span><br><span class="line">                    close(sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">            write(STDOUT_FILENO,recvline,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//测试标准输入是否准备好</span></span><br><span class="line">        <span class="keyword">if</span> (pfds[<span class="number">1</span>].revents &amp; POLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            n = read(STDIN_FILENO,sendline,MAXLINE);</span><br><span class="line">            <span class="keyword">if</span> (n  == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                shutdown(sockfd,SHUT_WR);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            write(sockfd,sendline,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>程序测试结果</strong></p><p><img src="http://images.cnitblog.com/blog/305504/201308/15221309-20c52e41db7a467eb3ad035e79f3cfaf.png" alt=""><br><img src="http://images.cnitblog.com/blog/305504/201308/15221335-bd0b92bf12a24744857ffdfde4276b71.png" alt=""><br><img src="http://images.cnitblog.com/blog/305504/201308/15221501-f9c689d65bdd43c980838f37a3d1eb00.png" alt=""></p><p><strong>本文来源</strong><br><a href="http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html" target="_blank" rel="noopener">http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Use select to multiplexing network connections</title>
      <link href="/Programming/network-programming-select/"/>
      <url>/Programming/network-programming-select/</url>
      
        <content type="html"><![CDATA[<br><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：</p><p>（1）当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。<br>（2）当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。<br>（3）如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。<br>（4）如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。<br>（5）如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</p><p>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</p><br><h4 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h4><p>该函数准许进程指示内核等待多个事件中的任何一个发送，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,<span class="keyword">const</span> struct timeval *timeout)</span></span></span><br></pre></td></tr></table></figure><p>返回值：就绪描述符的数目，超时返回0，出错返回-1</p><p>函数参数介绍如下：</p><p>（1）第一个参数maxfdp1指定待测试的描述字个数，它的值是待测试的最大描述字加 1（因此把该参数命名为maxfdp1），描述字0、1、2…maxfdp1-1均将被测试。因为文件描述符是从0开始的。<br>（2）中间的三个参数 <code>readset</code>、<code>writeset</code> 和 <code>exceptset</code> 指定我们要让内核测试读、写和异常条件的描述字。如果对某一个的条件不感兴趣，就可以把它设为空指针。<br><code>struct fd_set</code> 可以理解为一个集合，这个集合中存放的是文件描述符，可通过以下四个宏进行设置：</p><pre><code>void FD_ZERO(fd_set *fdset);           // 清空集合void FD_SET(int fd, fd_set *fdset);    // 将一个给定的文件描述符加入集合之中void FD_CLR(int fd, fd_set *fdset);    // 将一个给定的文件描述符从集合中删除int FD_ISSET(int fd, fd_set *fdset);   // 检查集合中指定的文件描述符是否可以读写 </code></pre><p>（3）timeout告知内核等待所指定描述字中的任何一个就绪可花多少时间。其timeval结构用于指定这段时间的秒数和微秒数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;   <span class="comment">//seconds</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;  <span class="comment">//microseconds</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个参数有三种可能：</p><p>（1）永远等待下去：仅在有一个描述字准备好I/O时才返回。为此，把该参数设置为空指针NULL。<br>（2）等待一段固定时间：在有一个描述字准备好I/O时返回，但是不超过由该参数所指向的timeval结构中指定的秒数和微秒数。<br>（3）根本不等待：检查描述字后立即返回，这称为轮询。为此，该参数必须指向一个timeval结构，而且其中的定时器值必须为0。</p><p>原理图：<br><img src="http://images2015.cnblogs.com/blog/305504/201509/305504-20150918012828961-1176245587.png" alt=""></p><br><h4 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h4><p>写一个 TCP 回射程序，程序的功能是：客户端向服务器发送信息，服务器接收并原样发送给客户端，客户端显示出接收到的信息。</p><p>服务端程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPADDR      <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT        8787</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE     1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ     5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE        10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">server_context_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cli_cnt;        <span class="comment">// 客户端个数</span></span><br><span class="line">    <span class="keyword">int</span> clifds[SIZE];   <span class="comment">// 客户端的个数</span></span><br><span class="line">    fd_set allfds;      <span class="comment">// 句柄集合</span></span><br><span class="line">    <span class="keyword">int</span> maxfd;          <span class="comment">// 句柄最大值</span></span><br><span class="line">&#125; server_context_st;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> server_context_st *s_srv_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">create_server_proc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ip,<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    fd = socket(AF_INET, SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"create socket fail,erron:%d,reason:%s\n"</span>,</span><br><span class="line">                errno, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。</span></span><br><span class="line">    <span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(reuse)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET,ip,&amp;servaddr.sin_addr);</span><br><span class="line">    servaddr.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(fd,(struct sockaddr*)&amp;servaddr,<span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"bind error: "</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listen(fd,LISTENQ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">accept_client_proc</span><span class="params">(<span class="keyword">int</span> srvfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> cliaddrlen;</span><br><span class="line">    cliaddrlen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="keyword">int</span> clifd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"accpet clint proc is called.\n"</span>);</span><br><span class="line"></span><br><span class="line">ACCEPT:</span><br><span class="line">    clifd = accept(srvfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clifd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">            <span class="keyword">goto</span> ACCEPT;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"accept fail,error:%s\n"</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"accept a new client: %s:%d\n"</span>,</span><br><span class="line">            inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将新的连接描述符添加到数组中</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s_srv_ctx-&gt;clifds[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            s_srv_ctx-&gt;clifds[i] = clifd;</span><br><span class="line">            s_srv_ctx-&gt;cli_cnt++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == SIZE) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"too many clients.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handle_client_msg</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"recv buf is :%s\n"</span>, buf);</span><br><span class="line">    write(fd, buf, <span class="built_in">strlen</span>(buf) +<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recv_client_msg</span><span class="params">(fd_set *readfds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> clifd;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt;= s_srv_ctx-&gt;cli_cnt;i++) &#123;</span><br><span class="line">        clifd = s_srv_ctx-&gt;clifds[i];</span><br><span class="line">        <span class="keyword">if</span> (clifd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断客户端套接字是否有数据</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(clifd, readfds)) &#123;</span><br><span class="line">            <span class="comment">// 接收客户端发送的信息</span></span><br><span class="line">            n = read(clifd, buf, MAXLINE);</span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// n==0表示读取完成，客户都关闭套接字</span></span><br><span class="line">                FD_CLR(clifd, &amp;s_srv_ctx-&gt;allfds);</span><br><span class="line">                close(clifd);</span><br><span class="line">                s_srv_ctx-&gt;clifds[i] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            handle_client_msg(clifd, buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_client_proc</span><span class="params">(<span class="keyword">int</span> srvfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  clifd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span>  retval = <span class="number">0</span>;</span><br><span class="line">    fd_set *readfds = &amp;s_srv_ctx-&gt;allfds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 每次调用select前都要重新设置文件描述符和时间，因为事件发生后，文件描述符和时间都被内核修改啦</span></span><br><span class="line">        FD_ZERO(readfds);</span><br><span class="line">        <span class="comment">// 添加监听套接字</span></span><br><span class="line">        FD_SET(srvfd, readfds);</span><br><span class="line">        s_srv_ctx-&gt;maxfd = srvfd;</span><br><span class="line"></span><br><span class="line">        tv.tv_sec = <span class="number">30</span>;</span><br><span class="line">        tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 添加客户端套接字</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s_srv_ctx-&gt;cli_cnt; i++) &#123;</span><br><span class="line">            clifd = s_srv_ctx-&gt;clifds[i];</span><br><span class="line">            <span class="comment">/*去除无效的客户端句柄*/</span></span><br><span class="line">            <span class="keyword">if</span> (clifd != <span class="number">-1</span>) &#123;</span><br><span class="line">                FD_SET(clifd, readfds);</span><br><span class="line">            &#125;</span><br><span class="line">            s_srv_ctx-&gt;maxfd = (clifd &gt; s_srv_ctx-&gt;maxfd ? clifd : s_srv_ctx-&gt;maxfd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始轮询接收处理服务端和客户端套接字</span></span><br><span class="line">        retval = select(s_srv_ctx-&gt;maxfd + <span class="number">1</span>, readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"select error:%s.\n"</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"select is timeout.\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(srvfd, readfds)) &#123;</span><br><span class="line">            <span class="comment">// 监听客户端请求</span></span><br><span class="line">            accept_client_proc(srvfd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 接受处理客户端消息</span></span><br><span class="line">            recv_client_msg(readfds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server_uninit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s_srv_ctx) &#123;</span><br><span class="line">        <span class="built_in">free</span>(s_srv_ctx);</span><br><span class="line">        s_srv_ctx = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">server_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_srv_ctx = (server_context_st *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(server_context_st));</span><br><span class="line">    <span class="keyword">if</span> (s_srv_ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(s_srv_ctx, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_context_st));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;i &lt; SIZE; i++) &#123;</span><br><span class="line">        s_srv_ctx-&gt;clifds[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  srvfd;</span><br><span class="line">    <span class="comment">// 初始化服务端 context</span></span><br><span class="line">    <span class="keyword">if</span> (server_init() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建服务,开始监听客户端请求</span></span><br><span class="line">    srvfd = create_server_proc(IPADDR, PORT);</span><br><span class="line">    <span class="keyword">if</span> (srvfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"socket create or bind fail.\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始接收并处理客户端请求</span></span><br><span class="line">    handle_client_proc(srvfd);</span><br><span class="line">    server_uninit();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    server_uninit();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPADDRESS <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8787</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a &gt; b) ? a : b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_recv_msg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">char</span> *buf)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client recv msg is:%s\n"</span>, buf);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    write(sockfd, buf, <span class="built_in">strlen</span>(buf) +<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_connection</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> sendline[MAXLINE],recvline[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> maxfdp,stdineof;</span><br><span class="line">    fd_set readfds;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        FD_ZERO(&amp;readfds);</span><br><span class="line">        FD_SET(sockfd,&amp;readfds);</span><br><span class="line">        maxfdp = sockfd;</span><br><span class="line"></span><br><span class="line">        tv.tv_sec = <span class="number">5</span>;</span><br><span class="line">        tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        retval = select(maxfdp+<span class="number">1</span>,&amp;readfds,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;tv);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"client timeout.\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;readfds)) &#123;</span><br><span class="line">            n = read(sockfd,recvline,MAXLINE);</span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"client: server is closed.\n"</span>);</span><br><span class="line">                close(sockfd);</span><br><span class="line">                FD_CLR(sockfd,&amp;readfds);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            handle_recv_msg(sockfd, recvline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    inet_pton(AF_INET,IPADDRESS,&amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line">    retval = connect(sockfd,(struct sockaddr*)&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"connect fail,error:%s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client send to server .\n"</span>);</span><br><span class="line">    write(sockfd, <span class="string">"hello server"</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    handle_connection(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>**测试结果**<p>启动服务程序，执行三个个客户程序进行测试，结果如下图所示：</p><p><img src="http://images2015.cnblogs.com/blog/305504/201509/305504-20150918013817539-541219182.png" alt=""></p><br><br><br><p><strong>本文来源</strong><br><a href="http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html" target="_blank" rel="noopener">http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Encryption terminology</title>
      <link href="/Programming/network-programming-encryption-basics/"/>
      <url>/Programming/network-programming-encryption-basics/</url>
      
        <content type="html"><![CDATA[<p>在进行网络开发时，经常会需要处理加密连接等跟证书加密等相关的概念，本文总结了证书加密等常见的名词术语及文件格式。</p><br><h5 id="术语及常见概念"><a href="#术语及常见概念" class="headerlink" title="术语及常见概念"></a>术语及常见概念</h5><p><strong>SSL - Secure Sockets Layer</strong></p><p>现在应该叫”TLS”,但由于习惯问题,还有很多场景下会称为”SSL”，涵义跟 TLS 完全相同。我们知道，HTTP 协议默认情况下是不加密内容的，在内容传播的时候由于是明文的容易被人截获。对于安全性要求较高的场合，需要对传输加密才能保证内容不被泄露，HTTPS 就是带加密的 HTTP 协议，它的加密是基于 SSL 加密协议的，这个加密对用户和开发者来说都是透明的，详见<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="noopener">维基百科</a>。</p><p><strong>OpenSSL</strong></p><p>简单地说，OpenSSL 是 SSL 的一个实现，SSL只是一种规范。理论上来说，SSL 这种规范是安全的，目前的技术水平很难破解。但SSL的实现就可能有些漏洞，如著名的”<a href="https://en.wikipedia.org/wiki/Heartbleed" target="_blank" rel="noopener">心脏出血(Heartbleed bug)</a>“。OpenSSL 提供了一大堆强大的工具软件，强大到 90% 我们都用不到。</p><p><strong>ASN.1</strong></p><p>Abstract Syntax Notation One，抽象语法标记，一种 ISO/ITU-T 标准，该标准描述了一种对数据进行表示、编码、传输和解码的数据格式。<br>我们可以把其类比成为开发语言提供的各种基础类型，X.509使用了这些基础类型来定义了数字证书的数据结构。（参考链接：<a href="http://baike.baidu.com/link?url=MWBtdL-WJS4sIBuxg4FY5gtFeVV6FARF_EaXDBCmBRhreSAQ1BAlSvyy2yCh0JHtgQMbUVqk0Zq6nt5c5jEwmq" target="_blank" rel="noopener">ASN.1</a>）</p><p><strong>X.509</strong></p><p>X.509 是最常见的一种数字证书标准，由国际电信联盟（ITU-T）依据 ASN.1 规范制定，它规定了证书应包含哪些信息和使用什么样的编码格式（默认DER二进制编码）。<br>其详情可以参考 RFC5280，SSL使用的就是这种证书标准。简单来说，X.509 是使用ASN.1 提供的抽象语法定义了证书的数据结构和编码规范。<br>同样的 X.509 数字证书，可能有不同的编码格式，目前有以下两种编码格式：</p><p><strong>（1）PEM - Privacy Enhanced Mail</strong><br>最初是为了增强邮件安全，将 X.509 证书用 base64 进行重新编码随着邮件一起传输，现在基本就用来生成公钥/私钥文件供用户下载了，原本的功能反而不再重要。</p><p>Openssl 使用 PEM 格式来存放各种信息，是 openssl 默认采用的信息存放方式。<br>Openssl 中的 PEM 文件一般包含如下信息:</p><ul><li>内容类型: 表明本文件存放的是什么信息内容，它的形式为 “——-BEGIN XXXX ——”，与结尾的 “——END XXXX——” 对应。</li><li>头信息: 表明数据是如果被处理后存放，openssl 中用的最多的是加密信息，比如加密算法以及初始化向量 iv。</li><li>信息体: 为 BASE64 编码的数据。可以包括所有私钥（RSA 和 DSA）、公钥（RSA 和 DSA）和 (x509) 证书。它存储用 Base64 编码后的 DER 格式数据，用 ascii 报头包围，因此适合系统之间的文本模式传输。</li></ul><p><strong>(i) 使用PEM格式存储的证书：</strong></p><pre><code>—–BEGIN CERTIFICATE—–MIICJjCCAdCgAwIBAgIBITANBgkqhkiG9w0BAQQFADCBqTELMAkGA1UEBhMCVVMx...1p8h5vkHVbMu1frD1UgGnPlOO/K7Ig/KrsU=—–END CERTIFICATE—–</code></pre><p><strong>(ii) 使用PEM格式存储的私钥：</strong></p><pre><code>—–BEGIN RSA PRIVATE KEY—–MIICJjCCAdCgAwIBAgIBITANBgkqhkiG9w0BAQQFADCBqTELMAkGA1UEBhMCVVMx...1p8h5vkHVbMu1frD1UgGnPlOO/K7Ig/KrsU=—–END RSA PRIVATE KEY—–</code></pre><p><strong>(iii) 使用PEM格式存储的证书请求文件：</strong></p><pre><code>—–BEGIN CERTIFICATE REQUEST—–MIICJjCCAdCgAwIBAgIBITANBgkqhkiG9w0BAQQFADCBqTELMAkGA1UEBhMCVVMx...1p8h5vkHVbMu1frD1UgGnPlOO/K7Ig/KrsU=—–END CERTIFICATE REQUEST—–</code></pre><p>根据上述例子展示的是证书的文本内容，我们可以看到，如果起始行是 <strong>–BEGIN CERTIFICATE–</strong>，说明这是一个证书<br>如果是 <strong>—–BEGIN RSA PRIVATE KEY—–</strong>，就说明这是一个私钥。<br>文本格式怎么变成二进制？从程序角度来说，去掉前后的—-行，剩下的去掉回车，然后用 base64 解码，就得到二进制了格式的证书了。</p><p>我们通过 openssl 来完成这个工作，</p><p>(i) 用openssl创建 CA 证书的 RSA 密钥（PEM格式）：</p><pre><code>$ openssl genrsa -des3 -out ca.key 1024</code></pre><p>(ii) 用openssl创建CA证书(PEM格式,假如有效期为一年)：</p><pre><code>$ openssl req -new -x509 -days 365 -key ca.key -out ca.crt -config openssl.cnf</code></pre><p>openssl 是可以生成DER格式的CA证书的，在 Windows 下最好将 PEM 格式的 CA 证书转换成 DER 格式的 CA 证书。</p><p>查看PEM格式证书的信息: <code>openssl x509 -in certificate.pem -text -noout</code></p><p><strong>（2）DER - Distinguished Encoding Rules</strong></p><p>可包含所有私钥、公钥和证书。它是大多数浏览器的缺省格式，并按 ASN1 DER 格式存储。注意它是无报头的，而 PEM 则是用文本报头包围的 DER。</p><p>其他</p><p><strong>PKCS</strong></p><p>The Public-Key Cryptography Standards，公钥密码学标准。RSA 公司制定的一系列规范，#7/#12对基础X.509证书和证书对应的私钥进行扩充、加密、重新编码后用于交换，#8定义了一种私钥格式标准。<br>PKCS#7 常用的后缀是：<code>.P7B</code>, <code>.P7C</code>, <code>.SPC</code>，PKCS#12 常用的后缀有：<code>.P12</code>, <code>.PFX</code>。</p><br><h5 id="文件扩展名"><a href="#文件扩展名" class="headerlink" title="文件扩展名"></a>文件扩展名</h5><p>一般来说上述的两种加密格式分别使用 <code>.pem</code> 和 <code>.der</code> 作为文件名后缀来进行标示。</p><p>还有以下常见后缀:</p><p><strong>CRT</strong><br>Certificate的简写，*NIX 系统下常见的证书文件后缀。<code>.crt</code> 后缀的证书文件有可能是 PEM 编码，也有可能是DER编码，大多数是 PEM 编码。</p><p><strong>CER</strong><br>同样是 Certificate 的简写，Windows系统下常见的证书文件类型后缀。<code>.cer</code> 后缀的证书可能是PEM编码，也可能是DER编码，大多数是 DER 编码。</p><p>注意：<code>.cer</code> 或 <code>.crt</code> 文件是二进制形式存放的，只放证书，不含私钥。</p><p><strong>KEY</strong><br>通常用来存放一个公钥或者私钥，并非X.509证书，编码类型可能是 PEM 或 DER。<br>查看 KEY 的办法: <code>openssl rsa -in mykey.key -text -noout</code><br>如果是 DER 格式：<code>openssl rsa -in mykey.key -text -noout -inform der</code></p><p><strong>CSR</strong><br>Certificate Signing Request，证书签名请求。<br>生成 X509 数字证书前，需要用户向权威证书颁发机构提交证书申请文件，然后由 CA 来签发签名后的证书。<br>X509 证书申请的格式标准为 pkcs#10 和 rfc2314，大致过程如下：</p><pre><code>1. 用户生成自己的公私钥对;2. 构造自己的证书申请文件,符合 PKCS#10 标准。该文件主要包括了用户信息、公钥以及一些可选的属性信息,并用自己的私钥给该内容签名;3. 用户将证书申请文件提交给 CA;4. CA 验证签名,提取用户信息,并加上其他信息(比如颁发者等信息),用 CA 的私钥签发数字证书;说明:数字证书(如x.509)是将用户(或其他实体)身份与公钥绑定的信息载体。一个合法的数字证书不仅要符合 X509 格式规范，还必须有 CA 的签名。用户不仅有自己的数字证书，还必须有对应的私钥。X509v3 数字证书主要包含的内容有:证书版本、证书序列号、签名算法、颁发者信息、有效时间、持有者信息、公钥信息、颁发者 ID、持有者 ID 和扩展项。</code></pre><p>其核心内容是一个公钥(还附带了一些别的信息)，在生成这个申请的时候，同时也会生成一个私钥，私钥要自己保管好。<br>查看 CSR 的办法: <code>openssl req -noout -text -in my.csr</code> (如果是DER格式的话照旧加上 <code>-inform der</code>)</p><p><strong>PFX/P12</strong><br>Personal Information Exchange 个人信息交换协议。Predecessor of PKCS#12, 对 *nix 服务器来说，一般 CRT 和 KEY 是分开存放在不同文件中的，但 Windows 下的 IIS 则将它们存在一个 PFX 文件中（因此这个文件同时包含了证书及私钥）。那么这样会不会造成不安全？答案是不会，PFX 通常会有一个”提取密码”，你想把里面的东西读取出来的话，它就要求你提供提取密码，PFX使用的是 DER 编码，那么如何把 PFX 转换为 PEM 编码？</p><p>A <code>.pfx</code> file is a <a href="https://en.wikipedia.org/wiki/PKCS_12" target="_blank" rel="noopener">PKCS#12</a> archive, usually containing a certificate and the corresponding private key.<br>On the other hand, a <code>.cer</code> or <code>.crt</code> file usually contains a single certificate, alone and without any wrapping (no private key, no password protection, just the certificate).</p><pre><code>$ openssl pkcs12 -in for-iis.pfx -out for-iis.pem -nodes</code></pre><p>这个时候会提示你输入提取代码。提取成功后 for-iis.pem 就是可读的文本.<br>生成 pfx 的命令类似这样: <code>openssl pkcs12 -export -in certificate.crt -inkey privateKey.key -out certificate.pfx -certfile CACert.crt</code><br>其中 <code>CACert.crt</code> 是CA（权威证书颁发机构）的根证书，有的话也通过 <code>-certfile</code> 参数一起带进去。</p><p>从 PFX 格式文件中提取私钥格式文件 (.key)</p><pre><code>$ openssl pkcs12 -in mycert.pfx -nocerts -nodes -out mycert.key</code></pre><p>简单来说，pfx/p12 用于存放个人证书/私钥，其通常包含保护密码，2进制方式存储。</p><p><strong>JKS</strong><br>Java Key Storage，这是 Java 的专利，跟OpenSSL关系不大。利用Java的一个叫”keytool”的工具可以将PFX转为JKS，当然 keytool 也能直接生成JKS。</p><br><h5 id="证书编码的转换"><a href="#证书编码的转换" class="headerlink" title="证书编码的转换"></a>证书编码的转换</h5><p><strong>(1) PEM转为DER</strong></p><pre><code>$ openssl x509 -in cert.crt -outform der -out cert.der</code></pre><p><strong>(2) DER转为PEM</strong></p><pre><code>$ openssl x509 -in cert.crt -inform der -outform pem -out cert.pem</code></pre><p>(提示:要转换KEY文件也类似，只不过把 x509 换成 rsa，要转CSR的话,把x509换成req…)</p><br><h5 id="获得证书"><a href="#获得证书" class="headerlink" title="获得证书"></a>获得证书</h5><p>有两种方式获得证书</p><p><strong>(1) 向权威证书颁发机构申请证书</strong></p><p>先生成一个 csr 证书请求</p><pre><code>$ openssl req -newkey rsa:2048 -new -nodes -keyout my.key -out my.csr</code></pre><p>生成 .csr 文件之后，把其交给权威证书颁发机构，权威证书颁发机构将会对改 .csr 文件进行签名。签名返回给用户，当权威证书颁发机构颁发的证书过期的时候，你还可以用同样的csr来申请新的证书，key 可以保持不变。</p><p><strong>(2) 生成自签名的证书</strong></p><pre><code>$ openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem</code></pre><p>在生成证书的过程中会要你填一堆的东西，其实真正要填的只有 Common Name，通常填写你服务器的域名（如”yourcompany.com”），或者你服务器的IP地址，其它项可以默认留空。<br>生产环境中还是不要使用自签的证书，否则浏览器会不认。或者如果你是企业应用的话能够强制让用户的浏览器接受你的自签证书也行。向权威机构要证书通常是要钱的，但也有一些是免费的，仅仅需要一个简单的域名验证即可。</p><br><br><br><p><strong>Reference</strong><br><a href="http://blog.csdn.net/anxuegang/article/details/6157927" target="_blank" rel="noopener">http://blog.csdn.net/anxuegang/article/details/6157927</a><br><a href="https://www.sslshopper.com/ssl-converter.html" target="_blank" rel="noopener">https://www.sslshopper.com/ssl-converter.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Call C functions in C++</title>
      <link href="/Programming/cpp-extern-c/"/>
      <url>/Programming/cpp-extern-c/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要介绍下 C 和 C++ 程序之间互相调用需要知道基本知识，作为一个 C++ 程序员，虽然不爱写 C 风格的代码，但是由于项目中难免需要使用到 C 语言的库，了解这部分原理也是有助于加深对 C++ 语言机制的理解的。</p><h3 id="如何调用"><a href="#如何调用" class="headerlink" title="如何调用"></a>如何调用</h3><p>C++ 和 C 的编译链接处理方式完全不同，编译器生成函数名所用的规则不同。如果直接在 C++ 里面直接调用 C 函数，会找不到函数体，报链接错误。本文介绍如何在 C++ 中调用 C 函数。</p><p>简单来说，只需要在 C++ 程序中把要调用的 C 函数添加一个 <code>extern &quot;C&quot;</code> 声明。如下，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> “C” <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">extern</span> “C”&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要调用 header 文件中定义的全部函数，可以把相应的 C 头文件添加 <code>extern &quot;C&quot;</code> 声明，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> “myheader.h”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内在原理"><a href="#内在原理" class="headerlink" title="内在原理"></a>内在原理</h3><p>C++ 语言支持函数重载，而 C 语言不支持函数重载。函数经过 C++ 编译器编译之后所生成的名字与 C 编译器所生成的不同。<br>添加 <code>extern &quot;C&quot;</code> 的目的就是告诉 C++ 编译器哪些函数是 C 写的，要用 C 的方式来处理。</p><p>假设某个 C 函数的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数被 C 编译器编译后在库中的名字为 <span class="red">_foo</span>，而 C++ 编译器则会产生像 <span class="red">_foo_int_int</span> 之类的名字用（为了支持函数重载和类型安全连接）。由于编译时生成函数名字的规则不同，C++ 程序在链接时按照其名字规则去寻找函数实现时就会找不到对应的函数。<br>因此，C++ 中不能直接调用 C 函数。C++ 提供了一个 C 连接交换指定符号 extern “C” 来解决这个问题。</p><p>在 C++ 程序中给要调用的 C 函数添加 Extern “C” 就是告诉 C++ 编译译器，函数 foo 是个 C 连接，链接目标文件时应该按照 C 函数的函数名规则到库中去找名字 <span class="red">_foo</span> ，而不是找 <span class="red">_foo_int_int</span> 。</p><p>C++ 编译器开发商已经对 C 标准库的头文件作了 extern “C” 处理，所以可以用 #include 直接引用这些头文件之后就可以直接调用了。</p><p>在 C++ 程序通添加 extern “C” 这种方式有一定的缺陷，比如会导致 C++ 代码比较繁冗复杂，无法保持代码的整洁，同时还需要程序员维护调用来源上下文，对 C++ 程序有一定的侵入。</p><p>通常，C++ 中需要调用 C 函数的场景是，已经有一个编译好的 C 动态库（如 .so 文件），需要直接使用它提供的功能而避免重复开发。</p><p>如果可以修改 C 源码的头文件，那么可以用如下方式来处理，</p><p>在 C 的头文件的开头加上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>同时，在头文件的末尾加上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样的作用就是把头文件中所声明的所有函数都声明为在 C++ 调用时使用 C 的方式去链接函数，就不用在 C++ 代码中添加 extern “C” 了，<br>C++ 程序中可以直接用 <code>#include&lt;*.h&gt;</code> 来引入用户自己定义的 C 函数所在的头文件，从而，C++ 的代码就简洁了很多！</p><br><p><strong>Reference</strong><br><a href="https://isocpp.org/wiki/faq/mixing-c-and-cpp" target="_blank" rel="noopener">How to mix C and C++</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to write a service script</title>
      <link href="/Linux/linux-service-script/"/>
      <url>/Linux/linux-service-script/</url>
      
        <content type="html"><![CDATA[<p>In Linux, service scripts are usually located in <code>/etc/init.d/</code> directory (In CentOS 7, it is <code>/usr/lib/systemd/system/my.service</code>), if we don’t know how to write such script we can always go to that directory and find a ‘template’ for study.</p><p>Below is a simple start up service script, it controls the start, restart and stop of Python Flask service:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">host=http://localhost:4000</span><br><span class="line"></span><br><span class="line">cur_dir=`<span class="built_in">pwd</span>`</span><br><span class="line">cur_pid=$$</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">start_hexo</span></span>() &#123;</span><br><span class="line">    <span class="built_in">test</span> $(<span class="built_in">pwd</span>) = <span class="string">"/e/god/juniway"</span> || (<span class="built_in">echo</span> <span class="string">"not in directory /e/god/juniway"</span>; <span class="built_in">exit</span> 1)</span><br><span class="line">    (hexo g &gt;/dev/null 2&gt;&amp;1 &amp;&amp; nohup hexo s &amp;&gt; out 2&gt;&amp;1) &amp; (sleep 6; chrome http://localhost:4000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">stop_hexo</span></span>() &#123;</span><br><span class="line">    <span class="built_in">test</span> $(<span class="built_in">pwd</span>) = <span class="string">"/e/god/juniway"</span> || (<span class="built_in">echo</span> <span class="string">"not in directory /e/god/juniway"</span>; <span class="built_in">exit</span> 1)</span><br><span class="line">    ps ux | grep -E <span class="string">'/usr/bin/sh|node'</span> | awk -v var=<span class="string">"<span class="variable">$cur_pid</span>"</span> <span class="string">'$1!=var&#123;print $1&#125;'</span> | xargs <span class="built_in">kill</span> &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">    <span class="comment"># don't kill current shell, otherwise restart will fail after executing stop_hexo()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">restart_hexo</span></span>() &#123;</span><br><span class="line">    stop_hexo</span><br><span class="line">    start_hexo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">status_hexo</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"cur_pid:"</span><span class="variable">$cur_pid</span><span class="string">"\n"</span></span><br><span class="line">    ps ux | grep -E <span class="string">'/usr/bin/sh|node'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    action=<span class="variable">$1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$action</span> <span class="keyword">in</span></span><br><span class="line">        <span class="string">'start'</span>)</span><br><span class="line">            start_hexo</span><br><span class="line">            ;;</span><br><span class="line">        <span class="string">'stop'</span>)</span><br><span class="line">            stop_hexo</span><br><span class="line">            ;;</span><br><span class="line">        <span class="string">'restart'</span>)</span><br><span class="line">            restart_hexo</span><br><span class="line">            ;;</span><br><span class="line">        <span class="string">'status'</span>)</span><br><span class="line">            status_hexo</span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"Bad argument!"</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">"Usage: <span class="variable">$0</span> &#123;start|stop|restart|status&#125;"</span></span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main $*</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shell String Manipulations</title>
      <link href="/Linux/linux-shellstring/"/>
      <url>/Linux/linux-shellstring/</url>
      
        <content type="html"><![CDATA[<h2 id="Test-command"><a href="#Test-command" class="headerlink" title="Test command"></a>Test command</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test condition</span><br><span class="line">test condition &amp;&amp; true-command</span><br><span class="line">test condition || false-command</span><br><span class="line"></span><br><span class="line">test 5 -gt 2 &amp;&amp; echo &quot;Yes&quot;</span><br><span class="line">test 1 -lt 2 &amp;&amp; echo &quot;Yes&quot;</span><br><span class="line"></span><br><span class="line">result:</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test -f /etc/resolv.conf &amp;&amp; echo &quot;File /etc/resolv.conf found.&quot; || echo &quot;File /etc/resolv.conf not found.&quot;</span><br><span class="line">test -f /etc/resolv1.conf &amp;&amp; echo &quot;File /etc/resolv1.conf found.&quot; || echo &quot;File /etc/resolv1.conf not found.&quot;</span><br></pre></td></tr></table></figure><h2 id="String-Operators"><a href="#String-Operators" class="headerlink" title="String Operators"></a>String Operators</h2><p>There are following string operators supported by Bourne Shell.</p><p>Assume variable a holds “abc” and variable b holds “efg” then −</p><p><strong>Operator</strong> | <strong>Description</strong> | <strong>Example</strong><br>-|-|<br>=   | Checks if two strings are equal.              | [ $a = $b ] is true.<br>!=  | Checks if two strings are not.                | [ $a != $b ] is true.<br>-z  | Checks if the given string is zero length.    | [ -z $a ] is not true.<br>-n  | Checks if the given string is not empty.      | [ -n $a ] is not false.<br>str | Check if str is not the empty string.         | [ $a ]</p><h2 id="Default-value"><a href="#Default-value" class="headerlink" title="Default value"></a>Default value</h2><p><span class="navy">${parameter-default}, ${parameter:-default}</span></p><p>return parameter’s value if it was set, otherwise return the default value.</p><p>e.g. echo ${username-`whoami`}</p><p>Echoes the result of `whoami`, if variable $username is still unset.</p><p><span class="navy">${parameter=default}, ${parameter:=default}</span></p><p>If parameter not set, set it to default.</p><p>e.g.</p><pre><code>site=$1site=${site:-www.google.com}delay=`curl -o /dev/null -s -w %{time_namelookup} $site&apos;</code></pre><p><span class="navy">${parameter+alt_value}, ${parameter:+alt_value}</span></p><p>If parameter set, use alt_value, else use null string.</p><p>Both forms nearly equivalent. The : makes a difference only when parameter has been declared and is null.</p><p><span class="navy">${parameter?err_msg}, ${parameter:?err_msg}</span></p><p>If parameter set, use it, else print err_msg and abort the script with an exit status of 1.</p><table><thead><tr><th align="left">Expression</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><span class="olive">${#string}</span></td><td align="left">Length of $string</td></tr><tr><td align="left"><span class="olive">${string:position}</span></td><td align="left">Extract substring of $string from $position to the end</td></tr><tr><td align="left"><span class="olive">${string:position:length}</span></td><td align="left">Extract substring of $string from $position with $length</td></tr><tr><td align="left"><span class="olive">${string#substring}</span></td><td align="left">Deletes shortest match of $substring from begining of $string</td></tr><tr><td align="left"><span class="olive">${string##substring}</span></td><td align="left">Deletes longest match of $substring from begining of $string</td></tr><tr><td align="left"><span class="olive">${string%substring}</span></td><td align="left">Deletes shortest match of $substring from end of $string</td></tr><tr><td align="left"><span class="olive">${string%%substring}</span></td><td align="left">Deletes shortest match of $substring from end of $string</td></tr><tr><td align="left"><span class="olive">${string/substring/replacement}</span></td><td align="left">Replace first match of $substring with $replacement.</td></tr><tr><td align="left"><span class="olive">${string//substring/replacement}</span></td><td align="left">Replace all matches of $substring with $replacement.</td></tr><tr><td align="left"><span class="olive">${string/#substring/replacement}</span></td><td align="left">If $substring matches front end of $string, substitute $replacement for $substring.</td></tr><tr><td align="left"><span class="olive">${string/%substring/replacement}</span></td><td align="left">If $substring matches back end of $string, substitute $replacement for $substring.</td></tr></tbody></table><h3 id="String-Length"><a href="#String-Length" class="headerlink" title="String Length"></a>String Length</h3><p><span class="navy">${#string}</span></p><h3 id="Length-of-Matching-Substring-at-Beginning-of-String"><a href="#Length-of-Matching-Substring-at-Beginning-of-String" class="headerlink" title="Length of Matching Substring at Beginning of String"></a>Length of Matching Substring at Beginning of String</h3><p><span class="navy">expr match “$string” ‘$substring’</span></p><h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p><span class="navy">expr index $string $substring</span></p><h3 id="Substring-Extraction"><a href="#Substring-Extraction" class="headerlink" title="Substring Extraction"></a>Substring Extraction</h3><p><span class="navy">${string:position}</span></p><p>Extracts substring from $string at $position.</p><p>position can be negative, but must add a prefix space or enbraced with Parentheses otherwise will match the whole string.</p><p><span class="navy">${string:position:length}</span></p><p>Extracts $length characters of substring from $string at $position.</p><p><span class="navy">expr substr $string $position $length</span></p><p><span class="navy">expr match “$string” ‘($substring)‘</span><br><span class="navy">expr “$string” : ‘($substring)‘</span></p><p>Extracts $substring at beginning of $string, where $substring is a regular expression.</p><p><span class="navy">expr match “$string” ‘.<em>($substring)‘</em></span><br><span class="navy">expr “$string” : ‘.($substring)‘</span></p><p>Extracts $substring at end of $string, where $substring is a regular expression.</p><h3 id="Substring-Removal"><a href="#Substring-Removal" class="headerlink" title="Substring Removal"></a>Substring Removal</h3><p><span class="navy">${string#substring}</span></p><p>Deletes shortest match of $substring from front of $string.</p><p><span class="navy">${string##substring}</span></p><p>Deletes longest match of $substring from front of $string.</p><p><span class="navy">${string%substring}</span></p><p>Deletes shortest match of $substring from back of $string.</p><p>Useful in stripping the file extention from a filename, e.g. filename=”test.tmp”, ${filename%.*} will get “test” out.</p><p><span class="navy">${string%%substring}</span></p><p>Deletes longest match of $substring from back of $string.</p><h3 id="Substring-Replacement"><a href="#Substring-Replacement" class="headerlink" title="Substring Replacement"></a>Substring Replacement</h3><p><span class="navy">${string/substring/replacement}</span></p><p>Replace first match of $substring with $replacement.</p><p><span class="navy">${string//substring/replacement}</span></p><p>Replace all matches of $substring with $replacement.</p><p><span class="navy">${string/#substring/replacement}</span></p><p>If $substring matches front end of $string, substitute $replacement for $substring.</p><p><span class="navy">${string/%substring/replacement}</span></p><p>If $substring matches back end of $string, substitute $replacement for $substring.</p><h3 id="Manipulating-strings-using-awk"><a href="#Manipulating-strings-using-awk" class="headerlink" title="Manipulating strings using awk"></a>Manipulating strings using awk</h3><p>Bash numbers first character of string as 0.<br>Awk  numbers first character of string as 1.</p><p>The awk equivalent of ${string:pos:length} is substr(string,pos,length).</p><pre><code>$ echo | awk &apos;{ print substr(&quot;12good9day&quot;,3,4)}good</code></pre><p>PS: Piping an empty “echo” to awk gives it dummy input, and thus makes it unnecessary to supply a filename.</p><p><strong>Reference</strong><br><a href="http://justcoding.iteye.com/blog/1963463" target="_blank" rel="noopener">http://justcoding.iteye.com/blog/1963463</a><br><a href="http://www.tldp.org/LDP/abs/html/string-manipulation.html" target="_blank" rel="noopener">http://www.tldp.org/LDP/abs/html/string-manipulation.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Troubleshoot networking in Virtualbox</title>
      <link href="/VirtualBox/vbox-vbox-network-dialog/"/>
      <url>/VirtualBox/vbox-vbox-network-dialog/</url>
      
        <content type="html"><![CDATA[<p>Virtuabox 中的 Guest OS 有时会遇到无法上网的情况，这篇文章记录和总结我解决网络故障的过程。</p><br>#### 1. 依次排查故障可能的原因---<p><strong>1. 首先确保网线是连通的， 即物理设备上是连通的。</strong><br><strong>2. 确保自己有（正确的） IP 地址</strong><br>也即网卡能正常获得 IP 地址。这个 IP 地址可能是通过 dhcp 服务器分配的，也可能是用户设置的静态 IP。<br>我们可以通过 <code>ifconfig -a</code> 或者 <code>ip link show</code> 来查看本机上的网卡是否已经获得 IP 地址：</p><p><img src="/image/ifconfig1.png" alt=""></p><p><img src="/image/ifconfig2.png" alt=""></p><br>#### 2. 查看网卡是否正常工作**---<p>这里，网卡正常工作的含义是指满足下面 3 种情况：</p><p><strong>(1) 网关可以访问，也即可以  ping 通网关</strong><br>查看网关信息:</p><pre><code>$ route -n</code></pre><p>或者 </p><pre><code>$ route show</code></pre><p>查得网关地址之后，比如是 192.168.0.1，我们可以 <code>ping 192.168.0.1</code> 来查看是否连通。</p><p><strong>(2) DNS 服务器可以访问，可以 ping 通 DNS 服务器</strong><br>执行下列命令来查看 DNS 服务器地址：</p><pre><code>$ less /etc/resolv.conf</code></pre><p><strong>(3) localhost 可以访问，并且主机名正确</strong></p><pre><code>$ ping 127.0.0.1$ cat /etc/hostname</code></pre><p>Windows 下查看 DNS 服务器，网关 Gateway，DHCP 服务器 的方法：<br><img src="/image/ipconfig.png" alt=""></p><br>#### 在 Ubuntu 中配置网卡信息：---<p>在 Ubuntu 中，网络配置文件是 <code>/etc/network/interfaces</code>，我们需要修改这个文件：</p><pre><code>$ sudo vim /etc/network/interfaces</code></pre><p>对于网络的设置进行修改之后，需要重启网络服务才能生效：</p><pre><code>$ sudo /etc/init.d/networking restart</code></pre><br>#### 4. 查看 VirtualBox 启动日志---<p>通常，VirtualBox 启动日志里面记录了登录及网络交互的过程。如果网卡正常工作，还是不能上网的话，我们可以查看这个这个日志来查找出错原因。</p><p><img src="/image/vm_settings.png" alt=""><br><img src="/image/log_viewer.png" alt=""><br><img src="/image/log_viewer1.png" alt=""></p><p>果然，从日志中可以看出是网络连接失败的原因了。这个 <span class="red">xunyount64.dll</span> 是迅游加速器的动态加载库，NAT 的转发请求被这个程序拦截并拒绝了，导致虚拟机中的 Guest OS 无法上网（例如：<code>ping www.github.com</code> 会失败），返回错误提示： <span class="red">Unknow Host</span>。</p><p>找到原因之后，解决它就很简单了，直接卸载迅游加速器，问题就得到解决。</p>]]></content>
      
      
      <categories>
          
          <category> VirtualBox </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VirtualBox Port Forwarding</title>
      <link href="/VirtualBox/vbox-vbox-portforwarding/"/>
      <url>/VirtualBox/vbox-vbox-portforwarding/</url>
      
        <content type="html"><![CDATA[<p>Virtualbox 中提供的端口转发（Port Forwarding）主要是 NAT 网络模式下用来实现 Host 主机访问虚拟机中 Guest 主机的。</p><p>在 VirtualBox 的 NAT 网络模式下，虚拟机 Guest OS 对 Host 主机来说是不可见的，因为对于 Host 主机来说，Guest OS 处在一个内网中，他的 IP 地址是一个内网 IP 地址：比如 10.0.2.15 这种。而主机的地址一般可能是 192.168.1. 111 这种，也可能直接是一个公网 ip 地址。总之，NAT 模式下两个主机肯定不在一个网段内，那么主机要访问 Guest OS 的话就必须穿墙打洞了，VirtualBox 提供的是 Port Forwarding，把对 Host 主机上某个端口的访问转发给 Guest OS 上的某个端口。比如，在 Host 主机中想要 SSH 登录到 Guest 主机，那么就可以在 VirtualBox 中设置端口转发，通过 Virtualbox 来登录信息转发给 Guest 主机上的 22 端口从而实现远程登录。</p><p>在 VirtualBox 中设置端口转发的方法，如下所示：</p><p class="blue">Settings > Network > Port Forwarding</p>![](/image/port_fwd.png)<p>图中的 Host ip 可以随意填，Host Port 填一个未被 Host 主机应用程序占用的即可，Guest IP 可以填对应的 Geust OS 的 IP 地址，也可以不填（不填就代表所有的都行），Port 填 SSH Server 侦听的端口号， 也即 22。<br>填好之后， 启动 VirtualBox。<br>在 Windows 命令行中执行 <code>netstat</code> 命令就会看到有对应的 Host Port 处于侦听状态，如果该端口没有在侦听，那么就说明启动设备失败了，可以 通过查看 VirtualBox 启动日志来定位出错原因。</p><p>通过 Windows 任务管理器，找到 Headless 进程（一般启动一个 Guest OS 的话，会有 3 个 Headless 进程），找到那个内存占用最多的Headless进程对应的 pid：<br><img src="/image/headless_pid.png" alt=""></p><p>在 Windows 下的 Git Bash 中执行；</p><pre><code>$ netstat -nao | grep 5036</code></pre><p><img src="/image/listening_port.png" alt=""></p><p>可以看到，所有设置了端口转发的端口都在侦听了！</p>]]></content>
      
      
      <categories>
          
          <category> VirtualBox </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Enable DHCP server in VirtualBox</title>
      <link href="/VirtualBox/vbox-vbox-dhcp/"/>
      <url>/VirtualBox/vbox-vbox-dhcp/</url>
      
        <content type="html"><![CDATA[<p>VirtualBox provides a built in default dhcp server, which will dynamically assign IP address for the guest OS (when guest OS uses NAT mode).<br>the default NAT engine uses 10.0.2.0 as the gateway/DNS, so Guest OS will usually get 10.0.2.15 as the IP address.</p><p>Beside that, VirtualBox also provides a way for use to manually config the dhcp server for <strong>Nat Network</strong> and <strong>Host-Only</strong> mode.<br>We can use below command in Windows command line to list the dhcpservers that has already been set: </p><pre><code>$ vboxmanage list dhcpserversNetworkName:    HostInterfaceNetworking-VirtualBox Host-Only Ethernet AdapterIP:             192.168.56.100NetworkMask:    255.255.255.0lowerIPAddress: 192.168.56.101upperIPAddress: 192.168.56.254Enabled:        Yes</code></pre><p>We can do this using GUI interfaces as well:</p><p>File -&gt; Preferences -&gt; Network<br><img src="/image/vbox_preference.png" alt=""></p><p>Now select the VirtualBox Host-only Ethernet adapter and edit it as shown below, then in the DHCP server tab un-check Enable server.<br><img src="/image/natnetwork_dhcp.jpg" alt=""></p><p>Now press OK twice and we should theoretically be done, but due to a bug in VBox the DHCP is not truly disabled till the time you restart the host machine (The machine on which VBox is running).</p><p><strong>Note:</strong><br>In Bridge Mode, guest OS usually get its IP addresses from the router of the Host.<br>If the router is configured to use predefined addresses for known mac addresses, it probably always returned the ip address which is already used by wireless adapter on host computer.</p>]]></content>
      
      
      <categories>
          
          <category> VirtualBox </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Write Makefile in simple</title>
      <link href="/Tools-and-Build/tool-and-build-makefile-notes/"/>
      <url>/Tools-and-Build/tool-and-build-makefile-notes/</url>
      
        <content type="html"><![CDATA[<p><img src="/image/1ed55b17-1095-4b2b-a786-030c22aa06e3.png" alt=""></p><br>### Makefile 语法格式----在 Makefile 中定义目标规则的通用语法是：<pre><code>[target] : [dependents ....][tab][ command ...]</code></pre><p>注意：command 前面需要用 tab 而不是空格来隔开。由于执行 make 时每条命令本身都会显示出来，我们还可以在命令前加@符号，来使得只显示命令的执行结果。</p><p>下面这个简单的例子定义了一个规则（rule）来生成目标为 hello，这个目标依赖 3 个文件而生成：</p><pre><code>hello: main.o factorial.o hello.o    $(CC) main.o factorial.o hello.o -o hello</code></pre><p>上例中要真正生成目标 hello，我们还需要为每个依赖项都定义生成规则（rule）。<br>隐式规则：对于没有依赖项的目标，make 会直接执行其所定义的命令（commands）</p><br>### Makefile 中变量的赋值----Makefile 中给变量赋值的方式有："="，":="、"?="，"+="<table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>“=”</td><td>定义一个递归展开的变量。</td></tr><tr><td>“:=”</td><td>定义一个简单展开的变量。</td></tr><tr><td>“?=”</td><td>如果该变量为空（也即未被赋值过），则为其赋值。</td></tr><tr><td>“+=”</td><td>给该变量追加值。</td></tr></tbody></table><p>“?=”” 和 “+=” 很好理解，下面介绍一下 “=” 和 “:=” 的区别：</p><p><span class="redBold">=</span> 使用递归展开来定义变量的意思是，如果变量的值包含了一个对其他变量的引用，那么会递归展开之后再赋给其。</p><p>比如：</p><pre><code>foo = $(bar)bar = $(zee)zee = hello</code></pre><p>那么最终, foo 的值就是 hello。</p><p>递归展开的方式有两个缺陷：<br>一是赋给该变量的值不能包含自己，否则会造成无限循环。比如 <code>foo = $(foo) abc</code>，make 命令会检测到这种无限循环的递归展开定义并报错。<br>二是由于每次引用该变量时都会进行一次递归展开，导致性能很差。</p><p><span class="redBold">:=</span> 可以克服上述使用 <strong>=</strong> 来递归展开定义变量所造成的缺陷。</p><p><strong>:=</strong> 是简单展开，意思是，只会在变量被定义的时候展开一次，而且整个 Makefile 文件中，也只会展开一次。这也就意味着，如果引用的变量的值在之后改变了，那么就不会再被原变量展开了。</p><p>比如：</p><pre><code>x := fooy := $(x) barx := later</code></pre><p>上面的籽粒中 y 最后的值是 foo bar，虽然 x 在 y 定义之后又改变了，但是 y 的值不会再改变，因为它只会在定义的时候对其所引用的 x 展开一次。</p><br>### 内置变量（Implicit Variables）Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见手册。<pre><code>output:    $(CC) -o output input.c</code></pre><br>### 自动变量（Automatic Variables）Make 命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。<p>####（1）$@</p><p>$@ 指代当前目标，就是 Make 命令当前构建的那个目标。比如，make foo 的 $@ 就指代 foo。</p><pre><code>a.txt b.txt:    touch $@</code></pre><p>等同于下面的写法。</p><pre><code>a.txt:    touch a.txtb.txt:    touch b.txt</code></pre><p>####（2）$&lt;</p><p>$&lt; 指代第一个依赖项。比如，规则为 t: p1 p2，那么 $&lt; 就指代 p1。</p><pre><code>a.txt: b.txt c.txt    cp $&lt; $@</code></pre><p>等同于下面的写法。</p><pre><code>a.txt: b.txt c.txt    cp b.txt a.txt</code></pre><p>####（3）$?</p><p>$? 指代比目标更新的所有依赖项，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$? 就指代 p2。</p><p>####（4）$^</p><p>$^ 指代所有依赖项，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。</p><p>####（5）$*</p><p>$* 指代匹配符 % 匹配的部分， 比如 % 匹配 f1.txt 中的 f1 ，$* 就表示 f1。</p><p>####（6）$(@D) 和 $(@F)</p><p>$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@ 是 src/input.c，那么 $(@D) 的值为 src ，$(@F) 的值为 input.c。</p><p>####（7）$(&lt;D) 和 $(&lt;F)</p><p>$(&lt;D) 和 $(&lt;F) 分别指向 $&lt; 的目录名和文件名。</p><p>所有的自动变量清单，请看手册。下面是自动变量的一个例子。</p><pre><code>dest/%.txt: src/%.txt    @[ -d dest ] || mkdir dest    cp $&lt; $@</code></pre><p>上面代码将 src 目录下的 txt 文件，拷贝到 dest 目录下。首先判断 dest 目录是否存在，如果不存在就新建，然后，$&lt; 指代前置文件（src/%.txt）， $@ 指代目标文件（dest/%.txt）。</p><h5 id="使用-define-endef-来定义一系列命令（Canned-Command-Sequences）"><a href="#使用-define-endef-来定义一系列命令（Canned-Command-Sequences）" class="headerlink" title="使用 define ... endef 来定义一系列命令（Canned Command Sequences）"></a>使用 <code>define ... endef</code> 来定义一系列命令（Canned Command Sequences）</h5><hr><p>当一组命令可以用来作用于多个 targets 来使用时，我们可以使用 <code>define</code> 指令来把他们定义到一个变量中，然后通过这个变量来引用和执行这些命令。</p><pre><code>define cc =@file Makefile@date -u +%Y/%m/%dendefinfo:    $(cc)</code></pre><br>##### 使用空命令----虽然给一个 target 定义一个空命令会什么也不做，但有时候这么定义也是有用的。定义的方式就是在目标冒号后面直接添加一个 ; 就可以了<pre><code>target: ;</code></pre><br>##### 条件控制----Makefile 中可以使用的条件指令有：<ul><li>ifeq</li><li>ifneq</li><li>ifdef</li><li>ifndef</li><li>else</li><li>endif</li></ul><p>条件语句的语法：</p><pre><code>conditional-directive   text-if-trueelse   text-if-falseendif</code></pre><p><code>ifeq (arg1, arg2)</code> 与 <code>ifeq &#39;arg1&#39;, &#39;arg2&#39;</code> 效果相同。</p><p>注意：条件比较语句之前不能有 Tab，必须是在每行的第一个字符开始。</p><p>例子</p><pre><code>ifeq ($(CC),gcc)  libs=$(libs_for_gcc)else  libs=$(normal_libs)endif</code></pre><p>上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。</p><pre><code>LIST = one two threeall:    for i in $(LIST); do \        echo $$i; \    done</code></pre><p>等同于</p><pre><code>all:    for i in one two three; do \        echo $i; \    done</code></pre><p>上面代码的运行结果。</p><pre><code>onetwothree</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Makefile 还可以使用函数，格式如下。</p><pre><code>$(function arguments)</code></pre><h1 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h1><pre><code>${function arguments}</code></pre><p>Makefile 提供了许多内置函数，可供调用。下面是几个常用的内置函数。</p><p>####（1）shell 函数</p><p>shell 函数用来执行 shell 命令</p><pre><code>srcfiles := $(shell echo src/{00..99}.txt)</code></pre><p>或者</p><pre><code>PWD:=$(shell pwd)BUILD:=$(shell date +&quot;%Y%m%d%H%M%S&quot;)SOURCE:=$(shell ls *.go)all:    @echo $(PWD)    @echo $(BUILD)    @echo $(SOURCE)    @echo &quot;done&quot;</code></pre><p>####（2）wildcard 函数</p><p>wildcard 函数用来在 Makefile 中，替换 Bash 的通配符。</p><pre><code>srcfiles := $(wildcard src/*.txt)</code></pre><p>####（3）subst 函数</p><p>subst 函数用来文本替换，格式如下：</p><pre><code>$(subst from,to,text)</code></pre><p>下面的例子将字符串 “feet on the street” 替换成 “fEEt on the strEEt”。</p><pre><code>$(subst ee,EE,feet on the street)</code></pre><p>下面是一个稍微复杂的例子。</p><pre><code>comma:= ,empty:=# space变量用两个空变量作为标识符，当中是一个空格space:= $(empty) $(empty)foo:= a b cbar:= $(subst $(space),$(comma),$(foo))# bar is now `a,b,c&apos;.</code></pre><p>####（4）patsubst函数</p><p>patsubst 函数用于模式匹配的替换，格式如下。</p><pre><code>$(patsubst pattern,replacement,text)</code></pre><p>下面的例子将文件名 “x.c.c bar.c”，替换成 “x.c.o bar.o”。</p><pre><code>$(patsubst %.c,%.o,x.c.c bar.c)</code></pre><p>####（5）替换后缀名</p><p>替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上 patsubst 函数的一种简写形式。</p><pre><code>min: $(OUTPUT:.js=.min.js)</code></pre><p>上面代码的意思是，将变量OUTPUT中的后缀名 .js 全部替换成 .min.js 。</p><br>##### make 命令的默认执行顺序----<p>执行 make 命令时默认会执行第一个不以 <strong>.</strong> 开头的目标。<br>比如第一行定义的目标为 haha，那么如果直接执行 make 的话，就会执行 haha 。<br>By default, it begins by processing the first target that does not begin with a <strong>‘.’</strong> aka the default goal; to do that, it may have to process other targets - specifically, ones the first target depends on. The GNU make manual covers all this stuff, and is a surprisingly easy and informative read.</p><p>also note, calling the first target all is just a convention, there is no mandatory requirement we declare the first target as all.</p><p>Makefile 中通常会支持 make all, make install, make clean，这只是一种惯例，而不是强制要求，我们可以完全使用其他的目标名字来代替 all, install, clean 等。</p><br>##### 在 Makefile 中调用 make 命令----当我们工作在一个大型工程中，每个子系统都有自己的 Makefile 文件，那么我们可能需要在最外层的 Makefile 文件中去执行 make 命令从而递归调用处于子目录中的 Makefile 文件。比如，我们有个子目录叫做 `subdir`，这个子目录有自己的 Makefile，如果想在当前目录中的 Makefile 中调用 make 命令去执行 `subdir` 中的 Makefile，可以这样做：<pre><code>subsystem:    cd subdir &amp;&amp; make</code></pre><p>或者</p><pre><code>subsystem:    make -C subdir</code></pre><p>上述两者等效。</p><p>提示：在执行 make 时，屏幕会打印 make[1]: Entering directory ‘…/subdir’ 和 Leaving directory ‘../subdir’ 这样的信息，如果不希望打印这些信息，可以在 make 命令后添加 <code>-s</code> 选项来屏蔽这些输出。<br>比如执行 <code>make -s</code> 或者在 Makefile 中改成 <code>@make -s -C subdir</code>。更多信息可参考<a href="https://www.gnu.org/software/automake/manual/html_node/Tricks-For-Silencing-Make.html" target="_blank" rel="noopener">这个</a></p><p>如果不想显示除了出错和警告之外的任何信息。如果 Makefile 指定的目标中执行了 shell 命令打印结果到屏幕，那么那些命令的结果也不会显示。那么可以在 make 命令后添加 <code>&gt; /dev/null</code> 来屏蔽标准输出。</p><p>例如：</p><pre><code>subsystem:    @make -C subdir &gt; /dev/null</code></pre><br>##### 在 Makefile 中使用系统环境变量----Makefile 中可以直接引用系统环境变量，但是如果在 Makefile 中定义了与系统环境变量同名的变量，那么会覆盖系统环境变量。如果定义的变量不在系统环境变量中，那么这些变量只会在当前 Makefile 中起作用。可以把一些常用的变量定义在一个单独的文件中，然后在 Makefile 中使用 include 关键字把他们引进来。<pre><code>include envfileexport $(shell sed &apos;s/=.*//&apos; envfile)test:    env</code></pre><br>##### 在递归调用 sub-make 时传递变量----在最外层的 Makefile 文件中定义的变量可能需要传递给子目录中的 Makefile 使用，要达到此效果，我们需要在 Makefile 中使用 export 关键字显示的导出变量到环境变量中，这样子 make 就能访问到这些变量了。同理，如果不想变量传递，可以使用 unexport。<p>例子：</p><pre><code>variable := valueexport variable</code></pre><p>或者</p><pre><code>export variable := value</code></pre><br>##### .PHONY 的作用----<p>由于执行 make clean 的时候， clean 目标没有任何依赖， make 则认为已经到根上了，如果正好当前目录中有一个文件其名称正好是叫 clean，那么会导致 make clean 什么也不做。<br>加 .PHONY 之后，就告诉 make 这个 clean 目标是假的，这时候 make clean 就会无视当前目录是否有 clean 文件存在，而为这个目标强制执行 clean 目标所指定的命令。</p><p>简单来说，.PHONY 修饰的目标是只有规则而没有依赖的，主要为了防止当前目录中有跟目标同名的文件。</p><p><strong>其他</strong><br>执行 make 时可能会报错：”make: warning:  Clock skew detected.  Your build may be incomplete.”<br>这可能是由于你在挂载的目录或者文件系统中新建文件（比如在 Linux 系统中挂载了一个 Windows 系统下的目录）导致的时间不一致的情况，<br>一般，这种情况下，只需要执行 <code>touch Makefile</code> 命令就可以解决。</p><br><br><br><p><strong>Reference</strong><br><a href="https://ftp.gnu.org/old-gnu/Manuals/make-3.80/html_mono/make.html" target="_blank" rel="noopener">https://ftp.gnu.org/old-gnu/Manuals/make-3.80/html_mono/make.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools and Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ High Performance Programming</title>
      <link href="/Programming/cpp-cpp-high-performance/"/>
      <url>/Programming/cpp-cpp-high-performance/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>C++ 高性能编程主要是需要理解对 CPU，内存，以及 IO 等方面的理解，这方面的知识极具挑战也令人兴奋，本人由于经验所限，暂时只从大的几个方面来剖析如何编写高性能的 C++ 网络程序。</p><p>TODO …</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bigtable distributed storage system</title>
      <link href="/Distributed-System/distributed-system-bigtable/"/>
      <url>/Distributed-System/distributed-system-bigtable/</url>
      
        <content type="html"><![CDATA[<p><a href="https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf" target="_blank" rel="noopener">论文原文</a></p><p>Bigtable presents a multi-dimensional sorted map to users.<br>● Keys are (row, column, time stamp).<br>● Handles petabytes of data and runs reliably on large numbers of (possibly unreliable) machines.<br>● Provides lookup and update operations on each row, and<br>● Provides atomic read-modify-write operations on individual rows (but not multiple rows).<br>● A running Bigtable consists of a collection of tablet servers, each of which is responsible for serving several tablets<br>● (tablet = contiguous region of key space).<br>● The operation of the tablet servers is coordinated by a master, i.e., the master might direct a server to load/unload a tablet.<br>● A tablet is stored as a collection of readonly files in the Google SSTable (Sorted String Table) format.<br>● The SSTables are stored in GFS, and Bigtable relies on GFS to preserve data in the event of disk loss</p><figure class="highlight plain"><figcaption><span>.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="noopener">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /home/alex/dir</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Distributed System Theory:Two Generals&#39; Problem</title>
      <link href="/Distributed-System/distributed-system-1-dist-two-general/"/>
      <url>/Distributed-System/distributed-system-1-dist-two-general/</url>
      
        <content type="html"><![CDATA[<p>两军问题是计算机领域的一个思想实验，用来阐述在一个不可靠的通信链路上试图通过通信以达成一致是存在缺陷的和困难的。这个问题和更有名的“拜占庭将军问题”有关（译者注：拜占庭将军问题很早就被提出，但是没有普及，后来为了普及，采用故事的方式来说明问题，并命名为拜占庭将军问题），并且经常出现在计算机网络课程的开头（特别是由于解释传输控制协议中的 TCP 协议并不能保证通信两端状态的一致性）。不过两军问题适用于任何有可能通信失败情况下的两点通信。在认知逻辑上一个重要概念是，两军问题强调了常识的重要性。也有些学者称之为“两军悖论”、“两军难题”、“协同攻击问题“等。两军问题是在计算机通信领域首个被证明无解的问题（译者注：据说量子通信可能会解决此问题），由此也可推论出，随机通信失败条件下的“拜占庭将军问题”也同样无解。</p><p>[定义]<br>两支军队，分别由两个将军领导，正在准备攻击一个坚固的城市。两支军队都驻扎在城市旁边的两个不同的山谷里。两军之间隔着第三个山谷，两个将军想要通讯的唯一方法就是穿过第三个山谷传送信件。问题是，第三个山谷被城市的守卫军占据，并且经此传送的信件可能会被守卫军截获（也就意味着信件无法到达对方）。<br>虽然两个将军商量好要同时对城市发起攻击，但是他们没有约定特定的攻击时间。为了保证取胜，他们必须同时发起攻击，否则任何单独发起攻击的军队都有可能全军覆没。他们必须互相通信来决定一个同时攻击时间，并且同意在那个时间发起攻击。两个将军彼此之间要知道另一个将军知道自己同意了作战计划。（译者注：A同意了作战计划，A将同意作战计划的信发给B，A将军要知道：B知道了A同意了作战计划。）因为返回来的信件和送出去的信件一样容易丢失，未来大量的消息必须保持一致性。<br>这个思想实验致力于考虑两军怎么做才能达成一致。在最简单的情况下，其中一个将军作为领导人，决定着发起攻击的时间，他必须将这个时间准确无误地通知另外一个将军。现在的问题是提出一种两个将军可以使用的算法。这个算法包含发送和接收处理消息，并正确地做出决定和推断：</p><p>没问题，我们会在约定的时间同时发起攻击</p><p>考虑到两个将军达成同时攻击的约定非常简单（例如，每一个成功发出去的信件，必须有一个成功的返回）。两军问题的微妙之处在于，对于上面的情形，不可能设计出一种能安全使用的算法。</p><p><img src="http://www.liuzhaocn.com/wp-content/uploads/2016/10/220px-2-generals.svg_.png" alt=""></p><p>军队位置图。A1和A2军队需要通信，但是他们的信息有可能被B军队拦截。</p><p>[问题描述]</p><p>A将军可以先发送一个消息：八月4日9点发起攻击。但是，一旦消息发送出去，A将军并不知道B是否收到了这个消息。这种不确定性使得A将军攻击之前非常犹豫，因为有独自发起攻击的危险。</p><p>为了让A将军放心，B将军可能要发送一个确认的返回信息给A将军：“我收到了你消息，我会在八月4日9点发起攻击”。可是，这个给A将军的确认消息也面临着被守卫军截获的可能，B将军也犹豫了，如果A将军没有收到确认信息，那么A将军很有可能停止此次攻击。</p><p>[证明]</p><p>带有特定消息数量的确定性协议。<br><a href="http://coolshell.cn//wp-content/uploads/2012/03/0915533324-2.png" target="_blank" rel="noopener">http://coolshell.cn//wp-content/uploads/2012/03/0915533324-2.png</a><br>因为协议是确定性的的，假设有一个固定数量消息的队列，一些消息成功发送了，另一些失败了。假设两个将军有一个明确的攻击目标。</p><p>考虑最后一条消息成功送达。如果最后一条消息没有成功送达，至少有一个将军（很有可能是接收这条消息的将军）估计会不进行攻击。从最后一条消息发送者的角度出发，已发送的和已送达的消息队列顺序和预想的一致，并且包含所有已发送的消息。</p><p>因为协议是确定性的，最后一个发送消息的将军依然决定发起攻击。这样会形成如下情形：这个协议让一个将军发起攻击，另一个将军不发起攻击。这个情形与这个协议能解决两军问题的假设相矛盾。</p><p>不确定性和变长协议</p><p>一个带有变长消息的不确定性协议就像一个有限的森林，每个叶子或者分支（节点）代表一个被发现的相当于特定点的实例。</p><p>森林的根节点标记着第一条合适的消息。由根节点衍生出来的分支节点标记着合适的下一条消息。叶子节点代表发送了最后一条消息的实例。在发送任何消息之前，这个协议就是一棵空树。</p><p>假设有一个不确定性协议可以解决两军问题。那么，根据之前确定性协议的场景和分析，可以从一棵树去掉所有叶子节点，得到另外一棵树。也就是说，确定性协议一定也可以解决两军问题。</p><p>因为不确定性协议是有限的，由此可推断一棵代表空树的协议，也可以解决两军问题。很显然这是扯淡。所以不存在一个不确定性协议可以解决两军问题。</p><p>[工程方法]</p><p>一个解决两军问题实际可行的办法就是接受而非试图去消除通信信道的不可靠性，但是要将这种不可靠性降低到可以接受的程度。例如，A将军可以送出100个信使，并预期所有信使被抓的可能性是极低的。用了这种方法，A将军无论如何都会发起攻击，B将军只要收到一个信使的信，也会发起攻击。</p><p>一个类似的方法是，A将军发起一连串消息，B将军对每一个消息都返回一个应答消息。两个将军对每个返回的消息都感觉是充分的。</p><p>但是正如证明里看到的那样，无法确定攻击是协调一致的。没有一种可用的算法（比如收到4个消息）一定能防止只有一个将军发起攻击。</p><p>同样的，A将军可以给每一个发送的信息编号，从1到n。这种方法可以让B将军了解信道的可靠性，并且发送适当数量的返回信息来保证至少有一条信息会被收到。如果这个信道是可靠的，一条消息足够了，其他的消息都没什么用了。最后一条消息和第一条消息一样容易丢失。</p><p>假设每发送一个消息并被拦截时，将军将会牺牲一批士兵，那么我们可以设计这样一种算法，使得用最少的消息通信换取协同攻击的最大化确认。为了达到这个目的，发送方使用停止发送信息的方式表示已收到至少一次确认信息并承诺发起攻击。假设每个消息通过危险区需要1分钟，发送方收到确认信息后沉默200分钟，这样可以既不用牺牲更多的士兵又能达到高可靠的协同可信度。也就是说，只有当接收方没有收到攻击时间时发送方才会继续发送消息。发送方沉默200分钟后，接收方将得出以下结论：一种可能是连续200个消息都被敌方截获（显然概率极低）；另一种可能是对方已收到我的确认信息也相信我将发起攻击，对方也将发动攻击。</p><p>[历史]</p><p>两军问题及其无解性证明1975年被E. A. Akkoyunlu、K. Ekanadham和R. V. Huber首次提出。发表在《网络通信设计的约束与权衡》一文中。它在73页的开头用来描述两个匪徒团伙之间的通信。</p><p>1978年，Jim Gray在《数据库操作系统笔记》的465页，将这个问题命名为“两军问题”。这个引用被普遍地认为是最早的两军问题的定义和无解证明，但是正如上一段说的，其实他们早就被发表了。</p><p>参考<br><a href="https://en.wikipedia.org/wiki/Two_Generals%27_Problem" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Two_Generals%27_Problem</a></p>]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Distributed System Theory:Byzantine Generals&#39; problem</title>
      <link href="/Distributed-System/distributed-system-2-dist-byzantine-problem/"/>
      <url>/Distributed-System/distributed-system-2-dist-byzantine-problem/</url>
      
        <content type="html"><![CDATA[<h4 id="Byzantine-failures"><a href="#Byzantine-failures" class="headerlink" title="Byzantine failures"></a>Byzantine failures</h4><p>拜占庭将军问题又称为“拜占庭失败”，是由 Leslie Lamport 提出的点对点通信中的基本问题，<a href="http://www.andrew.cmu.edu/course/15-749/READINGS/required/resilience/lamport82.pdf" target="_blank" rel="noopener">论文原文</a></p><p>拜占庭问题的最初描述是：N 个将军被分隔在不同的地方，忠诚的将军希望通过某种协议达成某个命令的一致（比如一起进攻或者一起后退）。但其中一些背叛的将军会通过发送错误的消息阻挠忠诚的将军达成命令上的一致。Lamport 证明了在将军总数大于 3m，背叛者为 m 或者更少时，忠诚的将军可以达成命令上的一致。</p><p>拜占庭将军问题本质是一个协议问题，问题的起源是拜占庭帝国军队的将军们准备攻击某一支敌军，但是他们必须达到全体一致的是否攻击的决定。由于这些将军在地理上是分隔开来的，因而他们必须通过信使来传递彼此的决定，而将军中存在叛徒，叛徒采取行动来欺骗某些将军采取进攻行动或者促成一个不是所有将军都同意的决定，从而导致最终行动失败，因为只有只有完全达成一致的行动才能获得胜利。</p><p>拜占庭失败对应于通信中的表现就是：消息可能丢失、重复，甚至内容损坏或者篡改（非拜占庭模型允许消息的丢失或者重复，但是不会出现内容损坏篡改的情况）。<br>因此，拜占庭模型的含义是在存在消息丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。</p><p>拜占庭假设是对现实世界的模型化，由于硬件错误、网络拥塞或断开以及遭到恶意攻击，计算机和网络可能出现不可预料的行为。拜占庭容错协议必须处理这些失效，并且这些协议还要满足所要解决的问题要求的规范。这些算法通常以其弹性 t 作为特征，t 表示算法可以应付的错误进程数。</p><h4 id="算法演绎"><a href="#算法演绎" class="headerlink" title="算法演绎"></a>算法演绎</h4><p>假设多股军队计划同时攻打某城池，这些军队的 commander 被一个将军领导，但其中一个或几个可能是叛徒，所以如果想获得胜利，就一定要让忠诚的 commander 同时发动进攻，但叛徒会用错误的信息扰乱进攻时间，避免的方式就是所有的 commander 共同交换信息，以判定叛徒；</p><p>该算法的目标是：<br>1。忠诚的 commander 遵守同样的命令<br>2。如果将军也是忠诚的，所有忠诚的commander遵守该将军发布的命令</p><p>算法的需求：<br>1。如果存在 3m＋1 个 unit，则可容错1个 unit 的 byzantine failure<br>2。至少 m＋1 轮的消息传递<br>3。所有 unit 同步</p><p>算法的假设：<br>1。不会丢失消息<br>2。消息接收者知道谁是发送者<br>3。消息丢失可被探测</p><p>算法开始：<br>1。将军的命令被送到每个 commander<br>2。每个接收者使用该命令或使用 retreat 状态</p><p>算法进行；<br>1。将军的命令被发布到每个节点<br>2。每个接收者使用该命令或使用retreat状态（如未收到任何命令），每个接受者如将军般向其他n－2个commander继续转发命令（不发给自己和消息来源）<br>3。重复以上过程；最后得到命令集合｛vi…..vj｝</p><p>如为了容一个错，使用4个节点：<br><img src="/image/5c4b6875gaecb662df4d4&690.png" alt=""><br>unit2  将向节点3，4继续转发命令，同时也收到节点3，4转发的命令，节点2在{v1 v31 v41}使用少数服从多数的方式获取最终命令；<br>对于获得一个共识的消息数量：3＋2<em>3＝9条<br>则对于4个节点或许4个共识而言，消息数量是 4</em>9＝36条；<br><img src="/image/5c4b6875gaecb73f38209&690.png" alt=""></p><p>对于一个能容2个错的7节点系统来说<br>获取一个共识的消息数量：6＋6＊（5＋5*4）＝156条<br>消息总数：7 * 156</p><br>##### 参考：http://baike.baidu.com/item/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98http://www.2cto.com/os/201312/268181.html]]></content>
      
      
      <categories>
          
          <category> Distributed System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gateway and DNS</title>
      <link href="/VirtualBox/vbox-gateway-dns/"/>
      <url>/VirtualBox/vbox-gateway-dns/</url>
      
        <content type="html"><![CDATA[<h2 id="网关和-DNS-的区别"><a href="#网关和-DNS-的区别" class="headerlink" title="网关和 DNS 的区别"></a>网关和 DNS 的区别</h2><h4 id="什么是网关"><a href="#什么是网关" class="headerlink" title="什么是网关"></a>什么是网关</h4><p>通俗的来说，网关（Gateway）就是一个网络连接到另一个网络的“关口”。<br>按照不同的分类标准，网关也有很多种。TCP/IP 协议里的网关是最常用的，在这里我要讲的“网关”均指 TCP/IP 协议下的网关。</p><p><strong>那么网关到底是什么呢？</strong>网关实质上是一个网络通向其他网络的 IP 地址。比如有网络 A 和网络 B，网络 A的 IP 地址范围为 “192.168.1.1<del>192. 168.1.254”，子网掩码为 255.255.255.0；网络B的IP地址范围为 “192.168.2.1</del>192.168.2.254”，子网掩码为 255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行TCP/IP 通信的，即使是两个网络连接在同一台交换机（或集线器）上，TCP/IP 协议也会根据子网掩码（255.255.255.0）判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。</p><p>如果网络 A 中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络 B 的网关，网络 B 的网关再转发给网络 B 的某个主机。网络 B 向网络 A 转发数据包的过程也是如此。</p><p>所以，只有设置好网关的 IP 地址，TCP/IP 协议才能实现不同网络之间的相互通信。那么这个 IP 地址是哪台机器的 IP 地址呢？网关的 IP 地址是具有路由功能的设备的 IP 地址，具有路由功能的设备有路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。</p><br>#### 什么是 DNS ?---DNS 全名叫 Domain Name Server，中文俗称“域名服务器”，在说明 DNS Server 之前，可能要先说明什么叫 Domain Name(域名)。正如上面所讲，在网上辨别一台电脑的方法是利用 IP 地址，但是 IP用数字表示，没有特殊的意义，非常不便于记忆。因此，我们一般会为一个 IP 地址取一个有某种含义又容易记忆的名字，这个名字我们就叫它 “Domain Name"。 <p>发出一个网络请求时，比如 ping <a href="http://www.google.com，它会经过" target="_blank" rel="noopener">www.google.com，它会经过</a> DNS 解析域名得到目标 IP 进行发送请求。</p><h5 id="主机发送一个网络请求的请求过程"><a href="#主机发送一个网络请求的请求过程" class="headerlink" title="主机发送一个网络请求的请求过程"></a>主机发送一个网络请求的请求过程</h5><p>具体来说就是，主机先把 DNS 请求发送到网关，网关充当路由功能，把该 DNS 请求发送到 DNS 服务器，DNS 服务器接收到请求后，解析 DNS （域名解析）并获得 ip 地址，返回给主机，<br>主机获得域名所对应的 ip 地址后，再继续把该目的 ip 地址发向网关进行请求。</p><p>下面是详细的请求过程：<br>1.首先，主机 A 会广播发送 ARP 请求，请求报文的目的 MAC地址 为 FFFFFF-FFFFFF（这个地址用于广播，也即每个主机都会收到该 ARP 请求），目的IP为网关的IP，要求获得网关的MAC地址；<br>2.路由器（即主机A的默认网关）响应该 ARP 请求，发送目的 MAC 地址为 A，目的IP为A的IP的 ARP 应答报文，以告知A网关的 MAC 地址；<br>3.A 获得网关的 MAC 地址后，就向网关发送一个 DNS 查询报文，其目的 MAC 地址为网关的 MAC 地址，目的 IP 为 DNS 服务器的IP地址；<br>4.网关收到 DNS 查询报文后，拆包检查发现是 DNS 查询于是将相应（查询）信息封装，向 DNS 服务器发送该报文，其目的 IP 地址为 DNS 服务器的 IP，目的mac为下一跳的mac，解析域名IP地址此时就交给了 DNS 服务器；<br>5.经过 DNS 解析，主机 A 知道了所要 ping 的域名的 ip 地址；<br>6.剩下的 ping 过程就和ping一个特定的 ip 地址相同了，首先判断 ping 命令的目的 B 的 IP 地址是否和 A 在同一网段，若在同一网段则相当于同网段内 ping，若不在同一网段，就是不同网段的 ping 只不过此时主机不需要再解析网关的 MAC 地址了。</p><p>IP 地址 192.168.1.1 指向的就是你的路由器。<br>其实我们的路由器，不光只有路由功能，还有两个重要的功能，一个叫网关，一个叫 DNS 中继。DNS 和默认网关本来是不一样的，只是我们在挂上路由器后，为了避免用户麻烦的设置自己的电脑，便将这些路由能转发的协议都指向到路由去，结果，我们这边看到的就是，默认网关，DNS 服务器，甚至是 DHCP 服务器、WHOIS 服务器都是路由器了。<br>如果要改，到路由器配置页面去看路由 WAN 口的设置，然后把电脑上除网关外的参数设置成和路由器 WAN 口一样，也还是可以正常上网的。</p><p><span class="blueBold">单向 ping 通的原因</span><br>从 Ping 的工作过程，我们可以知道，主机 A 收到了主机 B 的一个应答包，说明两台主机之间的去、回通路均正常。也就是说，无论从主机 A 到主机 B，还是从主机 B 到主机 A，都是正常的。那么，是什么原因引起只能单方向 Ping 通的呢?</p><p><strong>一、安装了个人防火墙</strong><br>在共享上网的机器中，出于安全考虑，大部分作为服务器的主机都安装了个人防火墙软件，而其他作为客户机的机器则一般不安装。几乎所有的个人防火墙软件，默认情况下是不允许其他机器Ping本机的。一般的做法是将来自外部的 ICMP 请求报文滤掉，但它却对本机出去的 ICMP 请求报文，以及来自外部的 ICMP 应答报文不加任何限制。这样，从本机 Ping 其他机器时，如果网络正常，就没有问题。但如果从其他机器 Ping 这台机器，即使网络一切正常，也会出现“超时无应答”的错误。<br>大部分的单方向 Ping 通现象源于此。解决的办法也很简单，根据你自己所用的不同类型的防火墙，调整相应的设置即可。</p><p><strong>二、双网卡 IP 地址冲突</strong><br>正常情况下，一台主机应该有一个网卡，一个 IP 地址，或多个网卡，多个 IP 地址(这些地址一定要处于不同的 IP 子网)。但对于在公共场所使用的电脑，特别是网吧，人多手杂，其中不泛有“探索者”。曾有一次两台电脑也出现了这种单方向 Ping 通的情况，经过仔细检查，发现其中一台电脑的“拨号网络适配器”(相当于一块软网卡)的 TCP/IP 设置中，设置了一个与网卡 IP 地址处于同一子网的 IP 地址，这样，在 IP 层协议看来，这台主机就有两个不同的接口处于同一网段内。当从这台主机 Ping 其他的机器时，会存在这样的问题:<br>(1)主机不知道将数据包发到哪个网络接口，因为有两个网络接口都连接在同一网段;<br>(2)主机不知道用哪个地址作为数据包的源地址。因此，从这台主机去 Ping 其他机器，IP 层协议会无法处理，超时后，Ping 就会给出一个“超时无应答”的错误信息提示。但从其他主机 Ping 这台主机时，请求包从特定的网卡来，ICMP 只须简单地将目的、源地址互换，并更改一些标志即可，ICMP 应答包能顺利发出，其他主机也就能成功 Ping 通这台机器了</p><h4 id="查看主机的-网关-和-DNS"><a href="#查看主机的-网关-和-DNS" class="headerlink" title="查看主机的 网关 和 DNS"></a>查看主机的 网关 和 DNS</h4><p>&lt;1&gt; 查看网关</p><pre><code>$ netstat -rnKernel IP routing tableDestination     Gateway         Genmask         Flags   MSS Window irtt Iface0.0.0.0         10.0.2.2        0.0.0.0         UG        0 0          0 enp0s1710.0.2.0        0.0.0.0         255.255.255.0   U         0 0          0 enp0s17192.168.56.0    0.0.0.0         255.255.255.0   U         0 0          0 enp0s8</code></pre><p>注：(以 0.0.0.0 开始的行的 gateway 是默认网关)</p><p>&lt;2&gt; 查看 DNS</p><pre><code>$ less /etc/resolv.confnameserver 10.16.0.222nameserver 192.168.0.222nameserver 10.18.126.10nameserver 8.8.8.8search www.abc.net</code></pre><p>注：nameserver 就是 DNS 服务器地址，一般不超过 5 个，查询时按顺序进行，第一个查不到才会去查第二个。8.8.8.8 是 google 的 DNS 服务器。</p><p>其他参数解释：<br><strong>domain</strong> 声明主机的域名。很多程序用到它，比如邮件系统，当为没有域名的主机进行 dns 查询时，也要用到。<br>如果没有域名，主机名将被使用。</p><p><strong>search</strong> 它的多个参数指明域名查询顺序。当要查询没有域名的主机，主机将在由 search 声明的域中分别查找。<br>需要注意的是，domain 和 search 不能共存; 如果同时存在，后面出现的将会被使用。 </p><p><strong>参考</strong><br><a href="http://blog.csdn.net/kunlong0909/article/details/6765564" target="_blank" rel="noopener">http://blog.csdn.net/kunlong0909/article/details/6765564</a><br><a href="http://blog.csdn.net/bat603/article/details/652126" target="_blank" rel="noopener">http://blog.csdn.net/bat603/article/details/652126</a><br><a href="http://duanple.blog.163.com/blog/static/70971767200981101340930/" target="_blank" rel="noopener">一个http请求的详细过程</a><br><a href="http://blog.163.com/yangji008@126/blog/static/7003693520117206102/" target="_blank" rel="noopener">http://blog.163.com/yangji008@126/blog/static/7003693520117206102/</a></p>]]></content>
      
      
      <categories>
          
          <category> VirtualBox </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VM Definition File in VirtualBox</title>
      <link href="/VirtualBox/vbox-vbox-config-files/"/>
      <url>/VirtualBox/vbox-vbox-config-files/</url>
      
        <content type="html"><![CDATA[<p>VM Definition file is a file of XML format, it descibes the properties of a VM, each time we create a VM in VirtualBox, a VM definition file is generated automatically.</p><p>VirtualBox stores the Machine Definition File for each VM in <code>C:\Users\user_name\VirtualBox VMs</code> directory, each VM have a separate sub directory.<br>For example, for a VM with name “Centos7”, its definition file should be <code>C:\Users\user_name\VirtualBox VMs\Centos7\Centos7.vbox</code>.</p><p>The machine definition file is recognized by VirtualBox, this means we can double click it and VirtualBox will load the cooresponding VM (guest OS). The config file is<br>essentially a xml formatted file which is generated automatically by the VirtualBox when we create the VM.</p><p>When we create a VM, VirtualBox will need to create a virtual disk (an image file, e.g. <code>VDI</code>, <code>vmdk</code>, <code>vhd</code>, <code>hdd</code>) with a specified capacity residing on the physical disk of the host machine. The disk image file can be fixed-size or dynamically-allocated on creation, and a machine definition file will be generated to describe the configurations of this image file. </p><p>We can duplicate hard disk image files on the same host to quickly produce a second virtual machine with the same operating system setup. However, you should only make copies of virtual disk images using the utility supplied with VirtualBox (see VirtualBox User Manual chapter 8.24, VBoxManage clonemedium, page 158 for more details. This is because VirtualBox assigns a unique identity number (UUID) to each disk image, which is also stored inside the image, and VirtualBox will refuse to work with two images that use the same number.</p><p>Take the <code>Centos7.vbox</code> as an example.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">** DO NOT EDIT THIS FILE.</span></span><br><span class="line"><span class="comment">** If you make changes to this file while any VirtualBox related application</span></span><br><span class="line"><span class="comment">** is running, your changes will be overwritten later, without taking effect.</span></span><br><span class="line"><span class="comment">** Use VBoxManage or the VirtualBox Manager GUI to make changes.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">VirtualBox</span> <span class="attr">xmlns</span>=<span class="string">"http://www.virtualbox.org/"</span> <span class="attr">version</span>=<span class="string">"1.15-windows"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Machine</span> <span class="attr">uuid</span>=<span class="string">"&#123;7d0da8b6-a004-4adf-aecc-0870e4451b73&#125;"</span> <span class="attr">name</span>=<span class="string">"Centos7"</span> <span class="attr">OSType</span>=<span class="string">"RedHat_64"</span> <span class="attr">snapshotFolder</span>=<span class="string">"Snapshots"</span> <span class="attr">lastStateChange</span>=<span class="string">"2016-07-24T07:43:31Z"</span> <span class="attr">aborted</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MediaRegistry</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">HardDisks</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">HardDisk</span> <span class="attr">uuid</span>=<span class="string">"&#123;b778f3b3-e717-4a52-a030-9e361b2c8bfc&#125;"</span> <span class="attr">location</span>=<span class="string">"D:/Program Files/VDIs/Centos7.vdi"</span> <span class="attr">format</span>=<span class="string">"VDI"</span> <span class="attr">type</span>=<span class="string">"Normal"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">HardDisks</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">DVDImages</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Image</span> <span class="attr">uuid</span>=<span class="string">"&#123;15367d43-758d-454e-923f-817e85c9d554&#125;"</span> <span class="attr">location</span>=<span class="string">"D:/Program Files/CentOS-7-x86_64-Minimal.iso"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">DVDImages</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">MediaRegistry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ExtraData</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ExtraDataItem</span> <span class="attr">name</span>=<span class="string">"GUI/LastCloseAction"</span> <span class="attr">value</span>=<span class="string">"Detach"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ExtraDataItem</span> <span class="attr">name</span>=<span class="string">"GUI/LastNormalWindowPosition"</span> <span class="attr">value</span>=<span class="string">"8,30,720,445"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ExtraDataItem</span> <span class="attr">name</span>=<span class="string">"GUI/RestrictedRuntimeDevicesMenuActions"</span> <span class="attr">value</span>=<span class="string">"HardDrives"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ExtraDataItem</span> <span class="attr">name</span>=<span class="string">"GUI/RestrictedRuntimeMachineMenuActions"</span> <span class="attr">value</span>=<span class="string">"SaveState,PowerOff"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ExtraDataItem</span> <span class="attr">name</span>=<span class="string">"GUI/StatusBar/IndicatorOrder"</span> <span class="attr">value</span>=<span class="string">"HardDisks,OpticalDisks,FloppyDisks,Network,USB,SharedFolders,Display,VideoCapture,Features,Mouse,Keyboard"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ExtraData</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Hardware</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">CPU</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">PAE</span> <span class="attr">enabled</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">LongMode</span> <span class="attr">enabled</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">HardwareVirtExLargePages</span> <span class="attr">enabled</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">CPU</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Memory</span> <span class="attr">RAMSize</span>=<span class="string">"1694"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Paravirt</span> <span class="attr">provider</span>=<span class="string">"Default"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Display</span> <span class="attr">VRAMSize</span>=<span class="string">"12"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RemoteDisplay</span> <span class="attr">enabled</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">BIOS</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">IOAPIC</span> <span class="attr">enabled</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">BIOS</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">USB</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Controllers</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">Controller</span> <span class="attr">name</span>=<span class="string">"OHCI"</span> <span class="attr">type</span>=<span class="string">"OHCI"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Controllers</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">USB</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Network</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Adapter</span> <span class="attr">slot</span>=<span class="string">"0"</span> <span class="attr">enabled</span>=<span class="string">"true"</span> <span class="attr">MACAddress</span>=<span class="string">"0800274DAC52"</span> <span class="attr">cable</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"82540EM"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">DisabledModes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">InternalNetwork</span> <span class="attr">name</span>=<span class="string">"intnet"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">NATNetwork</span> <span class="attr">name</span>=<span class="string">"NatNetwork"</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">DisabledModes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">NAT</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Forwarding</span> <span class="attr">name</span>=<span class="string">"Rule 1"</span> <span class="attr">proto</span>=<span class="string">"1"</span> <span class="attr">hostip</span>=<span class="string">"192.168.56.1"</span> <span class="attr">hostport</span>=<span class="string">"3088"</span> <span class="attr">guestip</span>=<span class="string">"10.0.2.15"</span> <span class="attr">guestport</span>=<span class="string">"22"</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">NAT</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Adapter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Adapter</span> <span class="attr">slot</span>=<span class="string">"1"</span> <span class="attr">enabled</span>=<span class="string">"true"</span> <span class="attr">MACAddress</span>=<span class="string">"080027827973"</span> <span class="attr">cable</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"82545EM"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">DisabledModes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">InternalNetwork</span> <span class="attr">name</span>=<span class="string">"intnet"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">NATNetwork</span> <span class="attr">name</span>=<span class="string">"NatNetwork"</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">DisabledModes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">HostOnlyInterface</span> <span class="attr">name</span>=<span class="string">"VirtualBox Host-Only Ethernet Adapter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Adapter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Adapter</span> <span class="attr">slot</span>=<span class="string">"2"</span> <span class="attr">MACAddress</span>=<span class="string">"080027B6752A"</span> <span class="attr">cable</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"82545EM"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">DisabledModes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">NATNetwork</span> <span class="attr">name</span>=<span class="string">"NatNetwork"</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">DisabledModes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">InternalNetwork</span> <span class="attr">name</span>=<span class="string">"intnet"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Adapter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Adapter</span> <span class="attr">slot</span>=<span class="string">"3"</span> <span class="attr">MACAddress</span>=<span class="string">"0800272C7EC8"</span> <span class="attr">cable</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"82540EM"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Adapter</span> <span class="attr">slot</span>=<span class="string">"4"</span> <span class="attr">MACAddress</span>=<span class="string">"080027A6C18A"</span> <span class="attr">cable</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"82540EM"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Adapter</span> <span class="attr">slot</span>=<span class="string">"5"</span> <span class="attr">MACAddress</span>=<span class="string">"0800276B631C"</span> <span class="attr">cable</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"82540EM"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Adapter</span> <span class="attr">slot</span>=<span class="string">"6"</span> <span class="attr">MACAddress</span>=<span class="string">"0800276CB44B"</span> <span class="attr">cable</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"82540EM"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Adapter</span> <span class="attr">slot</span>=<span class="string">"7"</span> <span class="attr">MACAddress</span>=<span class="string">"080027404653"</span> <span class="attr">cable</span>=<span class="string">"true"</span> <span class="attr">type</span>=<span class="string">"82540EM"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Network</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">LPT</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Port</span> <span class="attr">slot</span>=<span class="string">"1"</span> <span class="attr">enabled</span>=<span class="string">"false"</span> <span class="attr">IOBase</span>=<span class="string">"0x378"</span> <span class="attr">IRQ</span>=<span class="string">"7"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">LPT</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AudioAdapter</span> <span class="attr">codec</span>=<span class="string">"AD1980"</span> <span class="attr">driver</span>=<span class="string">"DirectSound"</span> <span class="attr">enabled</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">RTC</span> <span class="attr">localOrUTC</span>=<span class="string">"UTC"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">SharedFolders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SharedFolder</span> <span class="attr">name</span>=<span class="string">"god"</span> <span class="attr">hostPath</span>=<span class="string">"E:\god"</span> <span class="attr">writable</span>=<span class="string">"true"</span> <span class="attr">autoMount</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">SharedFolders</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">GuestProperties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">GuestProperty</span> <span class="attr">name</span>=<span class="string">"/VirtualBox/HostInfo/GUI/LanguageID"</span> <span class="attr">value</span>=<span class="string">"C"</span> <span class="attr">timestamp</span>=<span class="string">"1459514481653377400"</span> <span class="attr">flags</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">GuestProperties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Hardware</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">StorageControllers</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">StorageController</span> <span class="attr">name</span>=<span class="string">"IDE"</span> <span class="attr">type</span>=<span class="string">"PIIX4"</span> <span class="attr">PortCount</span>=<span class="string">"2"</span> <span class="attr">useHostIOCache</span>=<span class="string">"true"</span> <span class="attr">Bootable</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">AttachedDevice</span> <span class="attr">passthrough</span>=<span class="string">"false"</span> <span class="attr">type</span>=<span class="string">"DVD"</span> <span class="attr">hotpluggable</span>=<span class="string">"false"</span> <span class="attr">port</span>=<span class="string">"1"</span> <span class="attr">device</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">Image</span> <span class="attr">uuid</span>=<span class="string">"&#123;02250ae0-f7a2-4435-a404-caf89a1583f2&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">AttachedDevice</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">StorageController</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">StorageController</span> <span class="attr">name</span>=<span class="string">"SATA"</span> <span class="attr">type</span>=<span class="string">"AHCI"</span> <span class="attr">PortCount</span>=<span class="string">"1"</span> <span class="attr">useHostIOCache</span>=<span class="string">"false"</span> <span class="attr">Bootable</span>=<span class="string">"true"</span> <span class="attr">IDE0MasterEmulationPort</span>=<span class="string">"0"</span> <span class="attr">IDE0SlaveEmulationPort</span>=<span class="string">"1"</span> <span class="attr">IDE1MasterEmulationPort</span>=<span class="string">"2"</span> <span class="attr">IDE1SlaveEmulationPort</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">AttachedDevice</span> <span class="attr">type</span>=<span class="string">"HardDisk"</span> <span class="attr">hotpluggable</span>=<span class="string">"false"</span> <span class="attr">port</span>=<span class="string">"0"</span> <span class="attr">device</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">Image</span> <span class="attr">uuid</span>=<span class="string">"&#123;b778f3b3-e717-4a52-a030-9e361b2c8bfc&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">AttachedDevice</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">StorageController</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">StorageControllers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Machine</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">VirtualBox</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> VirtualBox </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>How does NAT engine works in ViartualBox?</title>
      <link href="/VirtualBox/vbox-vbox-nat-engine/"/>
      <url>/VirtualBox/vbox-vbox-nat-engine/</url>
      
        <content type="html"><![CDATA[<p>VirtualBox provides several ways for the Guest OS to access the internet, they are </p><ul><li><strong>NAT</strong> - Your host will act as a router (firewall) and your hosts will be on a private subnet. Use this if you are not running servers on the guests.</li><li><strong>Bridged</strong> - Your guests will get a ip address on the same subnet as your host. Use this if you are running servers on the guest and wish to connect from other computers on the LAN.</li><li><strong>Host Only</strong> - Sort of a hybrid. As the name implies, with this option you can connect to the guest servers from the host only. Use this for “private” (host only) servers. I use this if I am running a test web server. The guest machine cannot communicate with the outside world too, since they are not connected via a physical interface.</li></ul><p><strong>Note:</strong><br>Actually, VirtualBox provides NAT and NAT network, we should notice the differences between them:<br>The major difference is that in NAT mode, Guest are in completely separated network, they can’t see each other. However, in NAT Network mode, all Guests are in the same network, they still use the NAT to access the outer world internet, and they can see each other.</p><p>Exerpt from <a href="https://www.virtualbox.org/manual/" target="_blank" rel="noopener">VirtualBox User Manual</a></p><p><strong>Ch 9. Fine-tuning the VirtualBox NAT engine</strong><br>In NAT mode, the guest network interface is assigned to the IPv4 range 10.0.x.0/24 by default where x corresponds to the instance of the NAT interface +2. So x is 2 when there is only one NAT instance active. In that case the guest is assigned to the address 10.0.2.15, the gateway is set to 10.0.2.2 and the name server can be found at 10.0.2.3.<br>If, for any reason, the NAT network needs to be changed, this can be achieved with the following command:</p><pre><code>$ VBoxManage modifyvm &quot;VM name&quot; --natnet1 &quot;192.168/16&quot;</code></pre><p>This command would reserve the network addresses from 192.168.0.0 to 192.168.254.254 for the first NAT network instance of “VM name”. The guest IP would be assigned to 192.168.0.15 and the default gateway could be found at 192.168.0.2.</p><p><strong>Reference</strong>：<a href="https://jekewa.com/blogs/index.php/weBlog/2014/01/09/virtualbox-4-3-adds-nat" target="_blank" rel="noopener">https://jekewa.com/blogs/index.php/weBlog/2014/01/09/virtualbox-4-3-adds-nat</a><br><a href="https://www.virtualbox.org/manual/ch09.html#changenat" target="_blank" rel="noopener">https://www.virtualbox.org/manual/ch09.html#changenat</a><br><a href="https://www.thomas-krenn.com/en/wiki/Network_Configuration_in_VirtualBox" target="_blank" rel="noopener">https://www.thomas-krenn.com/en/wiki/Network_Configuration_in_VirtualBox</a><br><a href="https://blogs.oracle.com/fatbloke/entry/networking_in_virtualbox1" target="_blank" rel="noopener">https://blogs.oracle.com/fatbloke/entry/networking_in_virtualbox1</a><br><a href="http://www.makeuseof.com/tag/what-is-network-address-translation-nat-and-how-does-it-work/" target="_blank" rel="noopener">http://www.makeuseof.com/tag/what-is-network-address-translation-nat-and-how-does-it-work/</a></p>]]></content>
      
      
      <categories>
          
          <category> VirtualBox </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Installing GuestAdditions and Setup SharedFolder in VirtualBox</title>
      <link href="/VirtualBox/vbox-vbox-guestaddition-shared-folder/"/>
      <url>/VirtualBox/vbox-vbox-guestaddition-shared-folder/</url>
      
        <content type="html"><![CDATA[<h2 id="Part-I-Install-VirtualBox-Guest-Additions"><a href="#Part-I-Install-VirtualBox-Guest-Additions" class="headerlink" title="Part I. Install VirtualBox Guest Additions"></a>Part I. Install VirtualBox Guest Additions</h2><p>Before we can mount the shared folder in Guest OS, we have to install Guest Additions in it, Virtualbox Guest Additions is a software and is distributed in its own CD image (.iso) file named VBoxGuestAdditions.iso, we need to get this image file from<br><a href="http://download.virtualbox.org/virtualbox/" target="_blank" rel="noopener">http://download.virtualbox.org/virtualbox/</a>, while we open this link and enter the subdirectory for the latest version of VirtualBox. The corresponding VBoxGuestAdditions_X.Y.Z.iso file should be there.</p><p>Once we have got <code>VBoxGuestAdditions_X.Y.Z.iso</code> image file, we should mount it on Guest OS so that it can be seen and be installed thereafter. There are multiple ways that we can mount the <code>VBoxGuestAdditions_X.Y.Z.iso</code> in Guest OS, For example, in the VirtualBox window, choose the Storage section under Details, and so forth.</p><p><img src="/image/vbox_image.png" alt=""></p><p>or we can right click the cd icon in bottom status bar of Virtualbox Window, like below:</p><p><img src="/image/39100897-25aa-4306-8196-75351934d4f9.png" alt=""></p><p>Before the <code>VBoxGuestAdditions_X.Y.Z.iso</code> can be installed successfully, we have to install the requiredd dependencies:</p><pre><code>$ sudo apt-get install build-essential linux-headers-$(uname -r)$ sudo apt-get install virtualbox-guest-dkms</code></pre><p>Now reboot the system, the Virtualbox guest additions should be installed successfully.</p><h2 id="Part-II-Setting-up-the-Shared-Folders"><a href="#Part-II-Setting-up-the-Shared-Folders" class="headerlink" title="Part II. Setting up the Shared Folders"></a>Part II. Setting up the Shared Folders</h2><h4 id="1-Setup-Shared-Folders"><a href="#1-Setup-Shared-Folders" class="headerlink" title="1. Setup Shared Folders"></a>1. Setup Shared Folders</h4><p>We need to choose a folder from the host system that we want to share,  and add it to a shared folder list in VirtualBox like this:<br><img src="/image/shared_folder.png" alt=""></p><p><img src="/image/shared_folder1.png" alt=""></p><p>Once the system is rebooted, we should be able to see that the shared folder is mounted under <code>/media</code> directory (it is automatically mounted when the system starts up). the shared folder is auto named  with a prefix <strong>sf_</strong> (e.g. <code>/media/sf_xxx</code>).</p><p>If there <code>/media/sf_SharedFolder</code> does not exist after we reboot the system, it is probably because it is not mounted successfuly, we can try to manually mount it: </p><pre><code>$ sudo mount -t vboxsf SharedFolder sf_SharedFolder</code></pre><h4 id="2-Shared-folder-access-permission"><a href="#2-Shared-folder-access-permission" class="headerlink" title="2. Shared folder access permission"></a>2. Shared folder access permission</h4><p>Add our current user account into <code>vboxsf</code> group so that we can access to <code>sf_xxx</code> folder.</p><pre><code>$ sudo adduser juniway vboxsf</code></pre><p>or</p><pre><code>$ sudo usermod -aG vboxsf juniway</code></pre><p><code>juniway</code> is the username</p><p><strong>Note:</strong> <span class="red">we need to re-login so that this takes effect!</span></p><p>Since shared folders are always in <code>/media</code> directory, which is not a convenient location that in daily work, it is suggested to create a symbolic link in our <code>$HOME</code> directory so that we can access to it more quickly:</p><pre><code>$ ln -s /media/sf_xxx ~/shared_dir</code></pre><p>Also, we can even set it as the starting directory when we login to the system, add the below line into <code>~/.bashrc</code> will achieve this:</p><pre><code>$ cd ~/shared_dir</code></pre><p>Done!</p><br><br><br><br>###### Reference---http://juniway.blogspot.com/2013/09/virtualbox-shared-folders-on-ubuntu.html]]></content>
      
      
      <categories>
          
          <category> VirtualBox </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
